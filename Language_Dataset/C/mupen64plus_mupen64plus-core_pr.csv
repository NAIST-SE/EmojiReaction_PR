mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,150,2016-02-04T02:08:30Z,2016-03-06T18:56:14Z,2016-03-06T20:29:36Z,MERGED,True,41,19,1,https://github.com/fzurita,Improve speed limiter accuracy,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/150,https://github.com/fzurita,1,https://github.com/mupen64plus/mupen64plus-core/pull/150,"If the speed limiter sleeps for too long, we will sleep for less time the next time around.
This is useful if the sleep period is so short that the application cannot sleep for that short a time which unnecessarily slows down the frame rate.","If the speed limiter sleeps for too long, we will sleep for less time the next time around.
This is useful if the sleep period is so short that the application cannot sleep for that short a time which unnecessarily slows down the frame rate.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,150,2016-02-04T02:08:30Z,2016-03-06T18:56:14Z,2016-03-06T20:29:36Z,MERGED,True,41,19,1,https://github.com/fzurita,Improve speed limiter accuracy,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/150,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/150#issuecomment-181387603,"If the speed limiter sleeps for too long, we will sleep for less time the next time around.
This is useful if the sleep period is so short that the application cannot sleep for that short a time which unnecessarily slows down the frame rate.","@richard42 I'm not sure if you are receiving notifications for pull requests. Could you please take a look at this? It's a fairly simple change, and I think it's correct. Thanks.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,150,2016-02-04T02:08:30Z,2016-03-06T18:56:14Z,2016-03-06T20:29:36Z,MERGED,True,41,19,1,https://github.com/fzurita,Improve speed limiter accuracy,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/150,https://github.com/richard42,3,https://github.com/mupen64plus/mupen64plus-core/pull/150#issuecomment-181686505,"If the speed limiter sleeps for too long, we will sleep for less time the next time around.
This is useful if the sleep period is so short that the application cannot sleep for that short a time which unnecessarily slows down the frame rate.","Yeah, it's in my inbox.  Sorry, I'm just quite a bit behind in this work at the moment.  I will get to it; I think there was another speed limiter change as well.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,150,2016-02-04T02:08:30Z,2016-03-06T18:56:14Z,2016-03-06T20:29:36Z,MERGED,True,41,19,1,https://github.com/fzurita,Improve speed limiter accuracy,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/150,https://github.com/fzurita,4,https://github.com/mupen64plus/mupen64plus-core/pull/150#issuecomment-189372810,"If the speed limiter sleeps for too long, we will sleep for less time the next time around.
This is useful if the sleep period is so short that the application cannot sleep for that short a time which unnecessarily slows down the frame rate.","I did some more testing and this is not entirely accurate either. I think I see a better way of making this almost entirely correct. I'll update my pull request if it works.
Here is some background: I'm testing an audio plugin that does audio processing in a separate thread. The issue I'm seeing is that the game is drifting away from audio over time when 100% speed limit is selected. At 100%, there should be no drift.
I have a fix that doesn't drift over time, or if it does, it seems to be much less significant. My next pull request will include this.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,150,2016-02-04T02:08:30Z,2016-03-06T18:56:14Z,2016-03-06T20:29:36Z,MERGED,True,41,19,1,https://github.com/fzurita,Improve speed limiter accuracy,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/150,https://github.com/fzurita,5,https://github.com/mupen64plus/mupen64plus-core/pull/150#issuecomment-189535022,"If the speed limiter sleeps for too long, we will sleep for less time the next time around.
This is useful if the sleep period is so short that the application cannot sleep for that short a time which unnecessarily slows down the frame rate.","Ok, fix has been comitted.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,150,2016-02-04T02:08:30Z,2016-03-06T18:56:14Z,2016-03-06T20:29:36Z,MERGED,True,41,19,1,https://github.com/fzurita,Improve speed limiter accuracy,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/150,https://github.com/richard42,6,https://github.com/mupen64plus/mupen64plus-core/pull/150#issuecomment-192962767,"If the speed limiter sleeps for too long, we will sleep for less time the next time around.
This is useful if the sleep period is so short that the application cannot sleep for that short a time which unnecessarily slows down the frame rate.","Ok I'll merge it, the code looks solid.  But unfortunately I think this area still needs more work.  There is a fundamental conflict between the speed limiters in the audio plugin and the core vi callback.  We need to implement a method for getting feedback from the audio plugin, and choose delay times here which help keep the audio buffer at its target fullness level.  When sound is not being played, or the dummy audio plugin is connected, we can use any speed control mechanism (such as the current one) in the core and it should be good.  It would also be nice to take into account the frame sync delay time (if the opengl swapbuffer is waiting to sync at 60hz intervals) from the video plugin, but that could get very complicated...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,150,2016-02-04T02:08:30Z,2016-03-06T18:56:14Z,2016-03-06T20:29:36Z,MERGED,True,41,19,1,https://github.com/fzurita,Improve speed limiter accuracy,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/150,https://github.com/fzurita,7,https://github.com/mupen64plus/mupen64plus-core/pull/150#issuecomment-192982589,"If the speed limiter sleeps for too long, we will sleep for less time the next time around.
This is useful if the sleep period is so short that the application cannot sleep for that short a time which unnecessarily slows down the frame rate.","This is the audio plugin I'm working on right now:
mupen64plus-ae/mupen64plus-ae#546
My goal is to keep the audio buffers at a certain fullness while the core is running on a separate thread. The way I'm achieving this currently is by using the SoundTouch library and speeding up or slowing down audio if buffers get too big or too small. The SoundTouch library allows audio to speed up or slow down without any pitch changes, so it's not very noticeable unless you have a well trained ear to the specific game.
My initial approach which didn't work too well was by slowing down or speeding up the core to maintain specific buffer size. This led to noticeable changes in the frame rate while playing which was very distracting.
Also back to the SoundTouch library. If emulation can't keep up with the sound, I can detect how much emulation has slowed down by when the buffers can't be kept full and actually slow down the audio to that rate before buffers run dry. This makes it so that there is much less crackling of sound when emulation can't keep up.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,155,2016-04-09T05:38:27Z,2016-04-11T03:18:28Z,2016-04-11T03:18:28Z,MERGED,True,4,2,1,https://github.com/fzurita,Fix speed limiter issue,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/155,https://github.com/fzurita,1,https://github.com/mupen64plus/mupen64plus-core/pull/155,"Fixed issue that would cause it to constantly reset if the speed was set
too low.
When this would happen, the game would appear to run way too fast.","Fixed issue that would cause it to constantly reset if the speed was set
too low.
When this would happen, the game would appear to run way too fast.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,165,2016-07-04T18:23:01Z,2016-07-08T22:36:04Z,2016-07-08T22:36:04Z,CLOSED,False,1,1,1,https://github.com/loganmc10,Fix link directory for Raspberry Pi,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/165,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/165,"The newest Raspberry Pi firmware moves some libraries into a ""GL"" folder.","The newest Raspberry Pi firmware moves some libraries into a ""GL"" folder.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,168,2016-07-18T15:57:33Z,2016-07-21T06:06:51Z,2016-07-21T06:06:51Z,MERGED,True,237,4,2,https://github.com/TheFlagCourier,Documentation Update and Formatting,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/168,https://github.com/TheFlagCourier,1,https://github.com/mupen64plus/mupen64plus-core/pull/168,"Goal was to provide a Markdown version of the README for those viewing from GitHub. Also added ""custom installation paths"" from the original wiki to Section 3 of both of the README files, as well as links to ""mupen64plus.org/docs"" for documentation.","Goal was to provide a Markdown version of the README for those viewing from GitHub. Also added ""custom installation paths"" from the original wiki to Section 3 of both of the README files, as well as links to ""mupen64plus.org/docs"" for documentation.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,175,2016-08-09T10:44:41Z,,2019-11-13T16:12:07Z,OPEN,False,61,16,3,https://github.com/ricrpi,word-wise dma copy,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/175,https://github.com/ricrpi,1,https://github.com/mupen64plus/mupen64plus-core/pull/175,If DMA transfers are word aligned then a more efficient copy can be done. I have not seen a dma transfer that is not word aligned however I have not extensively checked all roms so have left the safer byte-wise implementation in.,If DMA transfers are word aligned then a more efficient copy can be done. I have not seen a dma transfer that is not word aligned however I have not extensively checked all roms so have left the safer byte-wise implementation in.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,175,2016-08-09T10:44:41Z,,2019-11-13T16:12:07Z,OPEN,False,61,16,3,https://github.com/ricrpi,word-wise dma copy,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/175,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/175#issuecomment-238579729,If DMA transfers are word aligned then a more efficient copy can be done. I have not seen a dma transfer that is not word aligned however I have not extensively checked all roms so have left the safer byte-wise implementation in.,"I have not extensively checked all roms so have left the safer byte-wise implementation in.

From the manual:

All DMA transactions in the Nintendo 64 must use 64 bit aligned for data in RDRAM. DMA transactions for data in ROM must use 16 bit aligned addresses. )

So, to keep code clean, I suggest to remove old code and assume DMA are always 16 bits aligned.
What do you think?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,175,2016-08-09T10:44:41Z,,2019-11-13T16:12:07Z,OPEN,False,61,16,3,https://github.com/ricrpi,word-wise dma copy,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/175,https://github.com/wareya,3,https://github.com/mupen64plus/mupen64plus-core/pull/175#issuecomment-238581551,If DMA transfers are word aligned then a more efficient copy can be done. I have not seen a dma transfer that is not word aligned however I have not extensively checked all roms so have left the safer byte-wise implementation in.,"Depends on what the console actually does. Manuals are known to be ""best practice for stability/speed"" instead of ""the hardware requires this"".
I would keep the former behavior until someone pops in with a hardware test.",True,{'THUMBS_UP': ['https://github.com/Narann']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,175,2016-08-09T10:44:41Z,,2019-11-13T16:12:07Z,OPEN,False,61,16,3,https://github.com/ricrpi,word-wise dma copy,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/175,https://github.com/Narann,4,https://github.com/mupen64plus/mupen64plus-core/pull/175#issuecomment-238587091,If DMA transfers are word aligned then a more efficient copy can be done. I have not seen a dma transfer that is not word aligned however I have not extensively checked all roms so have left the safer byte-wise implementation in.,"Thinking about it, you're surely right, if it's technically possible we can't assume it will not happen...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,175,2016-08-09T10:44:41Z,,2019-11-13T16:12:07Z,OPEN,False,61,16,3,https://github.com/ricrpi,word-wise dma copy,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/175,https://github.com/richard42,5,https://github.com/mupen64plus/mupen64plus-core/pull/175#issuecomment-240004747,If DMA transfers are word aligned then a more efficient copy can be done. I have not seen a dma transfer that is not word aligned however I have not extensively checked all roms so have left the safer byte-wise implementation in.,"I'm a little hesitant to merge this because it increases the code complexity a fair amount, for a performance gain on the raspberry pi / arm architectures.  Do you have any quantitative data on the performance improvement from using this aligned memcpy in real world scenarios?  If it's just moving a few hundred or thousand bytes per VI then it's probably not worth it.  But if these loops are run for millions of iterations per VI then it would be.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,175,2016-08-09T10:44:41Z,,2019-11-13T16:12:07Z,OPEN,False,61,16,3,https://github.com/ricrpi,word-wise dma copy,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/175,https://github.com/ricrpi,6,https://github.com/mupen64plus/mupen64plus-core/pull/175#issuecomment-240015781,If DMA transfers are word aligned then a more efficient copy can be done. I have not seen a dma transfer that is not word aligned however I have not extensively checked all roms so have left the safer byte-wise implementation in.,"The performance increase is 1 to 2 % faster (timing to frame 501), depending on ROM on a Pi B.
It isn't much of an improvement but given Zelda OOT intro is only running at ~70% full speed it is significant.
It would be interesting to know if any ROMS require byte-wise copy as if none do then the word-wise only implementation would be simpler than the current byte-wise copy.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,175,2016-08-09T10:44:41Z,,2019-11-13T16:12:07Z,OPEN,False,61,16,3,https://github.com/ricrpi,word-wise dma copy,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/175,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/175#issuecomment-338359970,If DMA transfers are word aligned then a more efficient copy can be done. I have not seen a dma transfer that is not word aligned however I have not extensively checked all roms so have left the safer byte-wise implementation in.,"There is merit to this. RSP DMA transfers must be 8-byte aligned. The N64 ignores the lower 3 bits of the source and destination address. It also ignores the lower 3 bits of the length (or rather, it assumes the lower 3 bits are all 1's, then it adds 1).
As long as we properly mask the source and destination addresses, the transfers should always be 8-byte aligned.
@ricrpi I don't know if you're still around. I'm far less confident in the alignment of the PI DMA's, but I am very confident in the 8-byte alignment of the RSP DMA's. If you update this PR to just to 8-byte aligned RSP DMA's (with no fallback) I'd be willing to do a fair bit of testing on it",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,175,2016-08-09T10:44:41Z,,2019-11-13T16:12:07Z,OPEN,False,61,16,3,https://github.com/ricrpi,word-wise dma copy,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/175,https://github.com/ricrpi,8,https://github.com/mupen64plus/mupen64plus-core/pull/175#issuecomment-338373512,If DMA transfers are word aligned then a more efficient copy can be done. I have not seen a dma transfer that is not word aligned however I have not extensively checked all roms so have left the safer byte-wise implementation in.,"I am trying to keep up with all the commits/issues but have very limited time to do any coding at the moment :-(
I will try to take a look at this though as it shouldn't take too long to patch in.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,176,2016-08-15T23:15:39Z,2016-08-17T04:52:20Z,2016-08-17T04:52:20Z,CLOSED,False,17,8,1,https://github.com/dannbuckley,Specific fix for Banjo Tooie,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/176,https://github.com/dannbuckley,1,https://github.com/mupen64plus/mupen64plus-core/pull/176,"Emulator did not apply Banjo-Tooie player fix, so I added a specific patch for this game.","Emulator did not apply Banjo-Tooie player fix, so I added a specific patch for this game.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,176,2016-08-15T23:15:39Z,2016-08-17T04:52:20Z,2016-08-17T04:52:20Z,CLOSED,False,17,8,1,https://github.com/dannbuckley,Specific fix for Banjo Tooie,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/176,https://github.com/richard42,2,https://github.com/mupen64plus/mupen64plus-core/pull/176#issuecomment-240313032,"Emulator did not apply Banjo-Tooie player fix, so I added a specific patch for this game.","This is a hack.  If there is a bug preventing these settings from being applied, it would be better to fix the bug than to hack it like this.  I ran a test with my copy of banjo tooie, with this debugging code:
diff --git a/src/main/rom.c b/src/main/rom.c
index 1ec6587..a3f228a 100644
--- a/src/main/rom.c
+++ b/src/main/rom.c
@@ -195,6 +195,11 @@ m64p_error open_rom(const unsigned char* romimage, unsigned int size)
         ROM_SETTINGS.rumble = entry->rumble;
         ROM_PARAMS.countperop = entry->countperop;
         ROM_PARAMS.cheats = entry->cheats;
+        DebugMessage(M64MSG_INFO, ""INI settings override"");
+        DebugMessage(M64MSG_INFO, ""Savetype: %i"", ROM_SETTINGS.savetype);
+        DebugMessage(M64MSG_INFO, ""Players: %i"", ROM_SETTINGS.players);
+        DebugMessage(M64MSG_INFO, ""Status: %i"", ROM_SETTINGS.status);
+        DebugMessage(M64MSG_INFO, ""CountPerOp: %i"", ROM_PARAMS.countperop);
     }
     else
     {

and the game worked properly, generating this output:
UI-Console: attached to core library 'Mupen64Plus Core' version 2.5.0
UI-Console:             Includes support for Dynamic Recompiler.
Core: INI settings override
Core: Savetype: 1
Core: Players: 1
Core: Status: 0
Core: CountPerOp: 2
Core: Goodname: Banjo-Tooie (U) [!]
Core: Name: BANJO TOOIE         
Core: MD5: 40E98FAA24AC3EBE1D25CB5E5DDF49E4
Core: CRC: C2E9AA9A 475D70AA
Core: Imagetype: .z64 (native)
Core: Rom size: 33554432 bytes (or 32 Mb or 256 Megabits)
Core: Version: 144A
Core: Manufacturer: Nintendo
Core: Country: USA",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,177,2016-08-25T13:29:01Z,2016-08-30T16:08:28Z,2016-08-30T16:11:53Z,CLOSED,False,2,1,1,https://github.com/Gillou68310,new_dynarec: Fixed trap writes to compiled pages,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/177,https://github.com/Gillou68310,1,https://github.com/mupen64plus/mupen64plus-core/pull/177,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,177,2016-08-25T13:29:01Z,2016-08-30T16:08:28Z,2016-08-30T16:11:53Z,CLOSED,False,2,1,1,https://github.com/Gillou68310,new_dynarec: Fixed trap writes to compiled pages,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/177,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/177#issuecomment-243492733,,Why did you close 177 & 178?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,178,2016-08-25T15:03:42Z,2016-08-30T16:08:33Z,2016-09-10T20:55:21Z,CLOSED,False,1,7,1,https://github.com/Gillou68310,new_dynarec: Fixed invalidate_block,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/178,https://github.com/Gillou68310,1,https://github.com/mupen64plus/mupen64plus-core/pull/178,get_bounds returns physical address not virtual address,get_bounds returns physical address not virtual address,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,178,2016-08-25T15:03:42Z,2016-08-30T16:08:33Z,2016-09-10T20:55:21Z,CLOSED,False,1,7,1,https://github.com/Gillou68310,new_dynarec: Fixed invalidate_block,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/178,https://github.com/Gillou68310,2,https://github.com/mupen64plus/mupen64plus-core/pull/178#issuecomment-242671590,get_bounds returns physical address not virtual address,"@fzurita I remember retroben complaining about some of his cheat code not working with the new dynarec while working fine with interpreter, this commit might fix a few things for him.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,178,2016-08-25T15:03:42Z,2016-08-30T16:08:33Z,2016-09-10T20:55:21Z,CLOSED,False,1,7,1,https://github.com/Gillou68310,new_dynarec: Fixed invalidate_block,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/178,https://github.com/fzurita,3,https://github.com/mupen64plus/mupen64plus-core/pull/178#issuecomment-242703609,get_bounds returns physical address not virtual address,Ok,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,178,2016-08-25T15:03:42Z,2016-08-30T16:08:33Z,2016-09-10T20:55:21Z,CLOSED,False,1,7,1,https://github.com/Gillou68310,new_dynarec: Fixed invalidate_block,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/178,https://github.com/Gillou68310,4,https://github.com/mupen64plus/mupen64plus-core/pull/178#issuecomment-243492719,get_bounds returns physical address not virtual address,I will create a single PR for new dynarec fixes.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,178,2016-08-25T15:03:42Z,2016-08-30T16:08:33Z,2016-09-10T20:55:21Z,CLOSED,False,1,7,1,https://github.com/Gillou68310,new_dynarec: Fixed invalidate_block,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/178,https://github.com/fzurita,5,https://github.com/mupen64plus/mupen64plus-core/pull/178#issuecomment-243492856,get_bounds returns physical address not virtual address,Ok,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,178,2016-08-25T15:03:42Z,2016-08-30T16:08:33Z,2016-09-10T20:55:21Z,CLOSED,False,1,7,1,https://github.com/Gillou68310,new_dynarec: Fixed invalidate_block,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/178,https://github.com/Gillou68310,6,https://github.com/mupen64plus/mupen64plus-core/pull/178#issuecomment-243493594,get_bounds returns physical address not virtual address,"Here's the new branch https://github.com/Gillou68310/mupen64plus-core/tree/new_dynarec_fix
I'll wait @loganmc10's feedback on #158 before creating the new PR",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,178,2016-08-25T15:03:42Z,2016-08-30T16:08:33Z,2016-09-10T20:55:21Z,CLOSED,False,1,7,1,https://github.com/Gillou68310,new_dynarec: Fixed invalidate_block,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/178,https://github.com/Gillou68310,7,https://github.com/mupen64plus/mupen64plus-core/pull/178#issuecomment-243494365,get_bounds returns physical address not virtual address,"Here's what it fix so far:
#170
#171
#179",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,178,2016-08-25T15:03:42Z,2016-08-30T16:08:33Z,2016-09-10T20:55:21Z,CLOSED,False,1,7,1,https://github.com/Gillou68310,new_dynarec: Fixed invalidate_block,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/178,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/178#issuecomment-244093725,get_bounds returns physical address not virtual address,"Sorry I haven't forgotten about this, I don't have any savestate for Mario Party so I've just been playing it on the train to and from work, but I haven't come across Coin Block Bash yet.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,178,2016-08-25T15:03:42Z,2016-08-30T16:08:33Z,2016-09-10T20:55:21Z,CLOSED,False,1,7,1,https://github.com/Gillou68310,new_dynarec: Fixed invalidate_block,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/178,https://github.com/Gillou68310,9,https://github.com/mupen64plus/mupen64plus-core/pull/178#issuecomment-244167409,get_bounds returns physical address not virtual address,No problem ;-),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,178,2016-08-25T15:03:42Z,2016-08-30T16:08:33Z,2016-09-10T20:55:21Z,CLOSED,False,1,7,1,https://github.com/Gillou68310,new_dynarec: Fixed invalidate_block,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/178,https://github.com/loganmc10,10,https://github.com/mupen64plus/mupen64plus-core/pull/178#issuecomment-245919543,get_bounds returns physical address not virtual address,"Well I finally got there on my phone so now I have a savestate right before the game. It actually worked on Android, so I'll try it on my Raspberry Pi tonight and see if I can reproduce the crash, since that is where I experienced it initially.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,178,2016-08-25T15:03:42Z,2016-08-30T16:08:33Z,2016-09-10T20:55:21Z,CLOSED,False,1,7,1,https://github.com/Gillou68310,new_dynarec: Fixed invalidate_block,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/178,https://github.com/Gillou68310,11,https://github.com/mupen64plus/mupen64plus-core/pull/178#issuecomment-245985777,get_bounds returns physical address not virtual address,"Cool, don't hesitate to share the savestate so I can test this by my side too.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,178,2016-08-25T15:03:42Z,2016-08-30T16:08:33Z,2016-09-10T20:55:21Z,CLOSED,False,1,7,1,https://github.com/Gillou68310,new_dynarec: Fixed invalidate_block,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/178,https://github.com/loganmc10,12,https://github.com/mupen64plus/mupen64plus-core/pull/178#issuecomment-245986920,get_bounds returns physical address not virtual address,"I am testing this using RetroArch + GLupeN64, not mupen64plus...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,178,2016-08-25T15:03:42Z,2016-08-30T16:08:33Z,2016-09-10T20:55:21Z,CLOSED,False,1,7,1,https://github.com/Gillou68310,new_dynarec: Fixed invalidate_block,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/178,https://github.com/Gillou68310,13,https://github.com/mupen64plus/mupen64plus-core/pull/178#issuecomment-245987620,get_bounds returns physical address not virtual address,Oh yeah I forgot about that. Which version of the core is libretro based on?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,178,2016-08-25T15:03:42Z,2016-08-30T16:08:33Z,2016-09-10T20:55:21Z,CLOSED,False,1,7,1,https://github.com/Gillou68310,new_dynarec: Fixed invalidate_block,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/178,https://github.com/loganmc10,14,https://github.com/mupen64plus/mupen64plus-core/pull/178#issuecomment-245990346,get_bounds returns physical address not virtual address,"GLupeN64 uses the master branch of mupen64plus-core, the only modifications are to some of the plugin/audio/input code to make it work with libretro, but the dynarec code and all that is unmodified.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,178,2016-08-25T15:03:42Z,2016-08-30T16:08:33Z,2016-09-10T20:55:21Z,CLOSED,False,1,7,1,https://github.com/Gillou68310,new_dynarec: Fixed invalidate_block,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/178,https://github.com/Gillou68310,15,https://github.com/mupen64plus/mupen64plus-core/pull/178#issuecomment-245991055,get_bounds returns physical address not virtual address,Well the savestate is compatible then!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,178,2016-08-25T15:03:42Z,2016-08-30T16:08:33Z,2016-09-10T20:55:21Z,CLOSED,False,1,7,1,https://github.com/Gillou68310,new_dynarec: Fixed invalidate_block,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/178,https://github.com/loganmc10,16,https://github.com/mupen64plus/mupen64plus-core/pull/178#issuecomment-245993628,get_bounds returns physical address not virtual address,"Well I'm not sure about that, I don't know what kind of metadata or whatnot libretro adds to the savestate, I've attached it though
Mario Party (USA).zip
If you want to try it out in RetroArch you can get pre-compiled binaries of the GLupeN64 core from here: http://loganbuildbot.s3-website-us-east-1.amazonaws.com/",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,178,2016-08-25T15:03:42Z,2016-08-30T16:08:33Z,2016-09-10T20:55:21Z,CLOSED,False,1,7,1,https://github.com/Gillou68310,new_dynarec: Fixed invalidate_block,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/178,https://github.com/Gillou68310,17,https://github.com/mupen64plus/mupen64plus-core/pull/178#issuecomment-245997832,get_bounds returns physical address not virtual address,If they add datas at the end of the savestate it's not a problem. I'll test and report back.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,178,2016-08-25T15:03:42Z,2016-08-30T16:08:33Z,2016-09-10T20:55:21Z,CLOSED,False,1,7,1,https://github.com/Gillou68310,new_dynarec: Fixed invalidate_block,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/178,https://github.com/Gillou68310,18,https://github.com/mupen64plus/mupen64plus-core/pull/178#issuecomment-246000749,get_bounds returns physical address not virtual address,You're right it's not compatible :-(,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,178,2016-08-25T15:03:42Z,2016-08-30T16:08:33Z,2016-09-10T20:55:21Z,CLOSED,False,1,7,1,https://github.com/Gillou68310,new_dynarec: Fixed invalidate_block,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/178,https://github.com/loganmc10,19,https://github.com/mupen64plus/mupen64plus-core/pull/178#issuecomment-246053503,get_bounds returns physical address not virtual address,"Sorry I'm an idiot that last file wasn't the save state.... I've attached the actual savestate if you want to try that out :D
Mario Party (USA) Save State.zip",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,178,2016-08-25T15:03:42Z,2016-08-30T16:08:33Z,2016-09-10T20:55:21Z,CLOSED,False,1,7,1,https://github.com/Gillou68310,new_dynarec: Fixed invalidate_block,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/178,https://github.com/loganmc10,20,https://github.com/mupen64plus/mupen64plus-core/pull/178#issuecomment-246080133,get_bounds returns physical address not virtual address,"Well I just tried it on the Raspberry Pi and it didn't crash... so I don't know... somehow it works differently with GLupeN64?
I couldn't get the savestate to work with mupen64plus, I just tried to rename it to .st0 and open it, it didn't like it.
Anyway I don't really have the time to test this with mupen64plus so I'm afraid I can't be much more help.
I know I'm not the only one who has run into the Coin Block Bash crash, someone mentioned it on Reddit a while ago:
https://www.reddit.com/r/RetroPie/comments/3ufb7o/anyone_know_how_to_get_any_mario_party_working/",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,178,2016-08-25T15:03:42Z,2016-08-30T16:08:33Z,2016-09-10T20:55:21Z,CLOSED,False,1,7,1,https://github.com/Gillou68310,new_dynarec: Fixed invalidate_block,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/178,https://github.com/Gillou68310,21,https://github.com/mupen64plus/mupen64plus-core/pull/178#issuecomment-246134180,get_bounds returns physical address not virtual address,Ok I managed to make the savestate work with mp64+. I tried on both x86 and ARM with no crash using current core master.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,178,2016-08-25T15:03:42Z,2016-08-30T16:08:33Z,2016-09-10T20:55:21Z,CLOSED,False,1,7,1,https://github.com/Gillou68310,new_dynarec: Fixed invalidate_block,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/178,https://github.com/loganmc10,22,https://github.com/mupen64plus/mupen64plus-core/pull/178#issuecomment-246139726,get_bounds returns physical address not virtual address,Huh well I swear I'm not crazy lol maybe it depends on what map us being played? I don't remember what map it happened on but it happened twice to me a while ago,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,180,2016-09-01T18:05:56Z,2016-09-02T01:04:38Z,2016-09-02T01:04:38Z,MERGED,True,4,3,1,None,Use Ubuntu Trusty as base system for Travis CI,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/180,None,1,https://github.com/mupen64plus/mupen64plus-core/pull/180,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,182,2016-09-12T09:53:19Z,2016-09-14T04:55:57Z,2016-10-02T08:55:54Z,MERGED,True,122,49,6,https://github.com/Gillou68310,New dynarec fix,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/182,https://github.com/Gillou68310,1,https://github.com/mupen64plus/mupen64plus-core/pull/182,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,182,2016-09-12T09:53:19Z,2016-09-14T04:55:57Z,2016-10-02T08:55:54Z,MERGED,True,122,49,6,https://github.com/Gillou68310,New dynarec fix,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/182,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/182#issuecomment-250367403,,"@Gillou68310 After this pull request, Conker's bad fur day is crashing sometime after RomClose. Here is the back trace:
Build fingerprint: 'motorola/quark_verizon/quark:5.1/SU4TL-44/44:user/release-keys'
pid: 5500, tid: 7356, name: CoreThread  >>> org.mupen64plusae.v3.alpha <<<
signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x57940030
#00 pc 00052f6c  /data/app/org.mupen64plusae.v3.alpha-1/lib/arm/libmupen64plus-core.so: Routine ll_clear at mupen64plus-core/src/r4300/new_dynarec/new_dynarec.c:1158
#01 pc 0007ee44  /data/app/org.mupen64plusae.v3.alpha-1/lib/arm/libmupen64plus-core.so: Routine new_dynarec_cleanup at mupen64plus-core/src/r4300/new_dynarec/new_dynarec.c:7754 (discriminator 3)
#02 pc 0004217c  /data/app/org.mupen64plusae.v3.alpha-1/lib/arm/libmupen64plus-core.so: Routine r4300_execute at mupen64plus-core/src/r4300/r4300.c:274
#03 pc 00012288  /data/app/org.mupen64plusae.v3.alpha-1/lib/arm/libmupen64plus-core.so: Routine main_run at mupen64plus-core/src/main/main.c:1013
#04 pc 00003ef9  /data/app/org.mupen64plusae.v3.alpha-1/lib/arm/libmupen64plus-ui-console.so (SDL_main+3536): Routine SDL_main at mupen64plus-ui-console/src/main.c:782
#05 pc 007a3e55  /data/app/org.mupen64plusae.v3.alpha-1/oat/arm/base.odex (offset 0x4c3000) (int paulscode.android.mupen64plusae.jni.NativeExports.emuStart(java.lang.String, java.lang.String, java.lang.Object[])+144)
#06 pc 007948fb  /data/app/org.mupen64plusae.v3.alpha-1/oat/arm/base.odex (offset 0x4c3000) (void paulscode.android.mupen64plusae.jni.CoreInterface$4.run()+2470)
#07 pc 71cf78d1  /data/dalvik-cache/arm/system@framework@boot.oat (offset 0x1f68000)
PS C:\Users\Francisco\Documents\workspaces>",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,182,2016-09-12T09:53:19Z,2016-09-14T04:55:57Z,2016-10-02T08:55:54Z,MERGED,True,122,49,6,https://github.com/Gillou68310,New dynarec fix,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/182,https://github.com/Gillou68310,3,https://github.com/mupen64plus/mupen64plus-core/pull/182#issuecomment-250474102,,"Fixed by #192
This was a long standing issue, when do_dirty_stub_ds was called it was referencing the MIPS source code from the last recompiled block instead of the current one.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,182,2016-09-12T09:53:19Z,2016-09-14T04:55:57Z,2016-10-02T08:55:54Z,MERGED,True,122,49,6,https://github.com/Gillou68310,New dynarec fix,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/182,https://github.com/fzurita,4,https://github.com/mupen64plus/mupen64plus-core/pull/182#issuecomment-250486536,,"Gotcha, thanks.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,182,2016-09-12T09:53:19Z,2016-09-14T04:55:57Z,2016-10-02T08:55:54Z,MERGED,True,122,49,6,https://github.com/Gillou68310,New dynarec fix,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/182,https://github.com/fzurita,5,https://github.com/mupen64plus/mupen64plus-core/pull/182#issuecomment-250941501,,"I wonder why even though it was an issue before, it didn't crash before.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,182,2016-09-12T09:53:19Z,2016-09-14T04:55:57Z,2016-10-02T08:55:54Z,MERGED,True,122,49,6,https://github.com/Gillou68310,New dynarec fix,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/182,https://github.com/Gillou68310,6,https://github.com/mupen64plus/mupen64plus-core/pull/182#issuecomment-250961132,,"The old design was using a static circular buffer, so the problem was not noticeable. See bbf2d25 commit details for more info.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,192,2016-09-29T13:55:24Z,2016-10-09T21:12:34Z,2016-10-10T09:11:15Z,MERGED,True,7,6,1,https://github.com/Gillou68310,new_dynarec: Allocate memory for original MIPS source code of a recom…,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/192,https://github.com/Gillou68310,1,https://github.com/mupen64plus/mupen64plus-core/pull/192,…piled block before do_dirty_stub_ds is being called.,…piled block before do_dirty_stub_ds is being called.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,192,2016-09-29T13:55:24Z,2016-10-09T21:12:34Z,2016-10-10T09:11:15Z,MERGED,True,7,6,1,https://github.com/Gillou68310,new_dynarec: Allocate memory for original MIPS source code of a recom…,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/192,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/192#issuecomment-251277288,…piled block before do_dirty_stub_ds is being called.,I'm still experiencing some crashes on shutdown after this change. It seems very random though and the stack traces are useless.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,192,2016-09-29T13:55:24Z,2016-10-09T21:12:34Z,2016-10-10T09:11:15Z,MERGED,True,7,6,1,https://github.com/Gillou68310,new_dynarec: Allocate memory for original MIPS source code of a recom…,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/192,https://github.com/Gillou68310,3,https://github.com/mupen64plus/mupen64plus-core/pull/192#issuecomment-251302142,…piled block before do_dirty_stub_ds is being called.,With CBFD only? Or with other games too?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,192,2016-09-29T13:55:24Z,2016-10-09T21:12:34Z,2016-10-10T09:11:15Z,MERGED,True,7,6,1,https://github.com/Gillou68310,new_dynarec: Allocate memory for original MIPS source code of a recom…,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/192,https://github.com/Gillou68310,4,https://github.com/mupen64plus/mupen64plus-core/pull/192#issuecomment-251327284,…piled block before do_dirty_stub_ds is being called.,I made a few tests but I didn't experienced any crashes for now.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,192,2016-09-29T13:55:24Z,2016-10-09T21:12:34Z,2016-10-10T09:11:15Z,MERGED,True,7,6,1,https://github.com/Gillou68310,new_dynarec: Allocate memory for original MIPS source code of a recom…,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/192,https://github.com/fzurita,5,https://github.com/mupen64plus/mupen64plus-core/pull/192#issuecomment-251340816,…piled block before do_dirty_stub_ds is being called.,It seems to be any game. And it doesn't crash most of the time.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,192,2016-09-29T13:55:24Z,2016-10-09T21:12:34Z,2016-10-10T09:11:15Z,MERGED,True,7,6,1,https://github.com/Gillou68310,new_dynarec: Allocate memory for original MIPS source code of a recom…,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/192,https://github.com/Gillou68310,6,https://github.com/mupen64plus/mupen64plus-core/pull/192#issuecomment-251371536,…piled block before do_dirty_stub_ds is being called.,Any advice in order to reproduce it? What's your usual testing scenario?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,192,2016-09-29T13:55:24Z,2016-10-09T21:12:34Z,2016-10-10T09:11:15Z,MERGED,True,7,6,1,https://github.com/Gillou68310,new_dynarec: Allocate memory for original MIPS source code of a recom…,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/192,https://github.com/fzurita,7,https://github.com/mupen64plus/mupen64plus-core/pull/192#issuecomment-251372079,…piled block before do_dirty_stub_ds is being called.,I haven't found a reliable way to reproduce it. I have the feeling it had to do with which instruction the dynarec is in when it shuts down.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,192,2016-09-29T13:55:24Z,2016-10-09T21:12:34Z,2016-10-10T09:11:15Z,MERGED,True,7,6,1,https://github.com/Gillou68310,new_dynarec: Allocate memory for original MIPS source code of a recom…,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/192,https://github.com/Gillou68310,8,https://github.com/mupen64plus/mupen64plus-core/pull/192#issuecomment-251385307,…piled block before do_dirty_stub_ds is being called.,"Just to be sure it's not a cache issue, could you add __clear_cache((void *)base_addr,(void *)base_addr+(1<<TARGET_SIZE_2));
at the beginning of the new_dynarec_cleanup function?
Also try to put a DebugMessage instead of the assert(copy_size==0); to check if all dynamic allocations have been freed correctly.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,192,2016-09-29T13:55:24Z,2016-10-09T21:12:34Z,2016-10-10T09:11:15Z,MERGED,True,7,6,1,https://github.com/Gillou68310,new_dynarec: Allocate memory for original MIPS source code of a recom…,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/192,https://github.com/fzurita,9,https://github.com/mupen64plus/mupen64plus-core/pull/192#issuecomment-251426107,…piled block before do_dirty_stub_ds is being called.,"Ok, will do.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,192,2016-09-29T13:55:24Z,2016-10-09T21:12:34Z,2016-10-10T09:11:15Z,MERGED,True,7,6,1,https://github.com/Gillou68310,new_dynarec: Allocate memory for original MIPS source code of a recom…,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/192,https://github.com/Gillou68310,10,https://github.com/mupen64plus/mupen64plus-core/pull/192#issuecomment-251441167,…piled block before do_dirty_stub_ds is being called.,Thanks ;-),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,192,2016-09-29T13:55:24Z,2016-10-09T21:12:34Z,2016-10-10T09:11:15Z,MERGED,True,7,6,1,https://github.com/Gillou68310,new_dynarec: Allocate memory for original MIPS source code of a recom…,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/192,https://github.com/Gillou68310,11,https://github.com/mupen64plus/mupen64plus-core/pull/192#issuecomment-251898076,…piled block before do_dirty_stub_ds is being called.,I'm still unable to reproduce a crash. I tried almost every game of my library.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,192,2016-09-29T13:55:24Z,2016-10-09T21:12:34Z,2016-10-10T09:11:15Z,MERGED,True,7,6,1,https://github.com/Gillou68310,new_dynarec: Allocate memory for original MIPS source code of a recom…,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/192,https://github.com/fzurita,12,https://github.com/mupen64plus/mupen64plus-core/pull/192#issuecomment-251934569,…piled block before do_dirty_stub_ds is being called.,"Ok, maybe it's something we are doing wrong during shutdown with mupen64plus AE. Is that what you are using for testing?
Edit: Also, the core dumps I'm getting are somewhere in the Android frameworks, but I had been running under the assumption that they are happening because of the app because when they happen, they happen on shutdown of the game. Maybe the problem is with Android.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,192,2016-09-29T13:55:24Z,2016-10-09T21:12:34Z,2016-10-10T09:11:15Z,MERGED,True,7,6,1,https://github.com/Gillou68310,new_dynarec: Allocate memory for original MIPS source code of a recom…,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/192,https://github.com/Gillou68310,13,https://github.com/mupen64plus/mupen64plus-core/pull/192#issuecomment-251994729,…piled block before do_dirty_stub_ds is being called.,"Yep I'm using latest master + my patch (copy_fix branch)
Android frameworks is only used in gliden64 right? Maybe you can try another video plugin to see if you can reproduce the crash.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,192,2016-09-29T13:55:24Z,2016-10-09T21:12:34Z,2016-10-10T09:11:15Z,MERGED,True,7,6,1,https://github.com/Gillou68310,new_dynarec: Allocate memory for original MIPS source code of a recom…,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/192,https://github.com/fzurita,14,https://github.com/mupen64plus/mupen64plus-core/pull/192#issuecomment-251996240,…piled block before do_dirty_stub_ds is being called.,"The android frameworks stuff it's crashing on is not from GLideN64, it's like OS level stuff. It could be related to Android 6.0 which is what I have on the devices I'm testing on. Which Android version are you testing on?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,192,2016-09-29T13:55:24Z,2016-10-09T21:12:34Z,2016-10-10T09:11:15Z,MERGED,True,7,6,1,https://github.com/Gillou68310,new_dynarec: Allocate memory for original MIPS source code of a recom…,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/192,https://github.com/Gillou68310,15,https://github.com/mupen64plus/mupen64plus-core/pull/192#issuecomment-251996656,…piled block before do_dirty_stub_ds is being called.,4.4.2,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,192,2016-09-29T13:55:24Z,2016-10-09T21:12:34Z,2016-10-10T09:11:15Z,MERGED,True,7,6,1,https://github.com/Gillou68310,new_dynarec: Allocate memory for original MIPS source code of a recom…,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/192,https://github.com/fzurita,16,https://github.com/mupen64plus/mupen64plus-core/pull/192#issuecomment-252000833,…piled block before do_dirty_stub_ds is being called.,"Ok, that could be the reason.
Also, by the way, I just updated to the latest Android NDK and it seems like GCC is deprecated and now they are forcing the use of the clang compiler.
I got almost everything compiling fine again (I had to make a few minor changes). The only thing I'm having problems with the x86 FPIC version of the mupen64plus-core. This file specifically:
https://github.com/mupen64plus/mupen64plus-core/blob/master/src/r4300/x86/rjump.c
I'm getting undefined references to ""__i686.get_pc_thunk.bx"" I tried to define it myself using guides I found on the internet, but when it do that, the x86 version of the core crashes when exiting a game on line save_edi=0; line 160.
Any ideas? Assembly is really not my strong point.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,192,2016-09-29T13:55:24Z,2016-10-09T21:12:34Z,2016-10-10T09:11:15Z,MERGED,True,7,6,1,https://github.com/Gillou68310,new_dynarec: Allocate memory for original MIPS source code of a recom…,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/192,https://github.com/Gillou68310,17,https://github.com/mupen64plus/mupen64plus-core/pull/192#issuecomment-252008719,…piled block before do_dirty_stub_ds is being called.,I'll take a look,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,192,2016-09-29T13:55:24Z,2016-10-09T21:12:34Z,2016-10-10T09:11:15Z,MERGED,True,7,6,1,https://github.com/Gillou68310,new_dynarec: Allocate memory for original MIPS source code of a recom…,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/192,https://github.com/fzurita,18,https://github.com/mupen64plus/mupen64plus-core/pull/192#issuecomment-252154662,…piled block before do_dirty_stub_ds is being called.,"I was able to force GCC 4.9 again by setting this in Application.mk
NDK_TOOLCHAIN_VERSION := 4.9

Eventually, we are going to have to deal with the mupen64plus core PIC version. It would be nice to make the new dynarec eventually be compatible with Android 5.0+. This will probably happen once the NDK makes it harder to switch out of clang.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,192,2016-09-29T13:55:24Z,2016-10-09T21:12:34Z,2016-10-10T09:11:15Z,MERGED,True,7,6,1,https://github.com/Gillou68310,new_dynarec: Allocate memory for original MIPS source code of a recom…,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/192,https://github.com/fzurita,19,https://github.com/mupen64plus/mupen64plus-core/pull/192#issuecomment-252244142,…piled block before do_dirty_stub_ds is being called.,I'm starting to think the remaining crash in shut down must be an Android issue. I have another device here with Android 6.0 and I can't get it to crash on shut down. But I can't say for sure since it happens so rarely.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,196,2016-10-12T20:40:54Z,2016-10-14T11:51:02Z,2017-08-09T15:31:39Z,MERGED,True,20,1,4,https://github.com/loganmc10,Fix Pokemon Puzzle League,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/196,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/196,Taken from libretro/mupen64plus-libretro@9f071ad,Taken from libretro/mupen64plus-libretro@9f071ad,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,196,2016-10-12T20:40:54Z,2016-10-14T11:51:02Z,2017-08-09T15:31:39Z,MERGED,True,20,1,4,https://github.com/loganmc10,Fix Pokemon Puzzle League,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/196,https://github.com/richard42,2,https://github.com/mupen64plus/mupen64plus-core/pull/196#issuecomment-253953835,Taken from libretro/mupen64plus-libretro@9f071ad,"This fix is really suspicious.  How exactly is it supposed to fix anything, when it calculates some timing value, and rather than divide it by 1500 to get the result, it takes the number modulo 270?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,196,2016-10-12T20:40:54Z,2016-10-14T11:51:02Z,2017-08-09T15:31:39Z,MERGED,True,20,1,4,https://github.com/loganmc10,Fix Pokemon Puzzle League,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/196,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/196#issuecomment-253955472,Taken from libretro/mupen64plus-libretro@9f071ad,"@richard42 you can read the discussion here : https://github.com/libretro/mupen64plus-libretro/issues/128
I didn't write it, but it works, Pokemon Puzzle League didn't start before and now it does",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,196,2016-10-12T20:40:54Z,2016-10-14T11:51:02Z,2017-08-09T15:31:39Z,MERGED,True,20,1,4,https://github.com/loganmc10,Fix Pokemon Puzzle League,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/196,https://github.com/wareya,4,https://github.com/mupen64plus/mupen64plus-core/pull/196#issuecomment-253956365,Taken from libretro/mupen64plus-libretro@9f071ad,"It's a timing hack. m64p doesn't have very accurate timing in the first place, so having game-specific timing hacks when a game otherwise doesn't even boot doesn't seem like a bad idea.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,196,2016-10-12T20:40:54Z,2016-10-14T11:51:02Z,2017-08-09T15:31:39Z,MERGED,True,20,1,4,https://github.com/loganmc10,Fix Pokemon Puzzle League,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/196,https://github.com/orbea,5,https://github.com/mupen64plus/mupen64plus-core/pull/196#issuecomment-254007386,Taken from libretro/mupen64plus-libretro@9f071ad,"Well, given that the game doesn't work without the hack, it is probably a good temporary fix. It should be fixed properly eventually, but this is better than nothing.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,196,2016-10-12T20:40:54Z,2016-10-14T11:51:02Z,2017-08-09T15:31:39Z,MERGED,True,20,1,4,https://github.com/loganmc10,Fix Pokemon Puzzle League,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/196,https://github.com/Narann,6,https://github.com/mupen64plus/mupen64plus-core/pull/196#issuecomment-254330585,Taken from libretro/mupen64plus-libretro@9f071ad,"I got a warning on gcc:
../../src/vi/vi_controller.c:45:17: warning: type of ‘alternate_vi_timing’ does not match original declaration
 extern unsigned alternate_vi_timing;
                 ^
../../src/main/rom.c:59:15: note: previously declared here
 unsigned char alternate_vi_timing = 0;
               ^
Can anybody fix this?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,196,2016-10-12T20:40:54Z,2016-10-14T11:51:02Z,2017-08-09T15:31:39Z,MERGED,True,20,1,4,https://github.com/loganmc10,Fix Pokemon Puzzle League,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/196,https://github.com/richard42,7,https://github.com/mupen64plus/mupen64plus-core/pull/196#issuecomment-254377141,Taken from libretro/mupen64plus-libretro@9f071ad,"ok, I cleaned this up a bit.  I still don't like it though.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,196,2016-10-12T20:40:54Z,2016-10-14T11:51:02Z,2017-08-09T15:31:39Z,MERGED,True,20,1,4,https://github.com/loganmc10,Fix Pokemon Puzzle League,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/196,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/196#issuecomment-298761293,Taken from libretro/mupen64plus-libretro@9f071ad,"In case anyone is curious, it turns out this ""alternate timing"" is only really useful if the result is 0, for instance:
if (vi->alternate_timing)
    vi->regs[VI_CURRENT_REG] = (vi->delay - (vi->next_vi - cp0_regs[CP0_COUNT_REG])) % (NTSC_VERTICAL_RESOLUTION + 1);
if (vi->regs[VI_CURRENT_REG] != 0)
    vi->regs[VI_CURRENT_REG] = (vi->delay - (vi->next_vi - cp0_regs[CP0_COUNT_REG])) / vi->count_per_scanline;

Produces the same result.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,198,2016-10-20T09:22:37Z,2016-10-20T11:32:15Z,2016-10-24T08:47:08Z,MERGED,True,7,6,2,https://github.com/Gillou68310,Allow setting a loadstate job before emulator is running.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/198,https://github.com/Gillou68310,1,https://github.com/mupen64plus/mupen64plus-core/pull/198,If a loadstate job is set before emulator is running the loadstate will happen on the first safe state interrupt.,If a loadstate job is set before emulator is running the loadstate will happen on the first safe state interrupt.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,198,2016-10-20T09:22:37Z,2016-10-20T11:32:15Z,2016-10-24T08:47:08Z,MERGED,True,7,6,2,https://github.com/Gillou68310,Allow setting a loadstate job before emulator is running.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/198,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/198#issuecomment-255080660,If a loadstate job is set before emulator is running the loadstate will happen on the first safe state interrupt.,Related to mupen64plus/mupen64plus-ui-console#27,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,199,2016-10-26T10:41:17Z,2016-10-28T03:22:13Z,2016-10-31T08:16:33Z,MERGED,True,24,7,3,https://github.com/Gillou68310,Add using_tlb flag to savestates,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/199,https://github.com/Gillou68310,1,https://github.com/mupen64plus/mupen64plus-core/pull/199,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,199,2016-10-26T10:41:17Z,2016-10-28T03:22:13Z,2016-10-31T08:16:33Z,MERGED,True,24,7,3,https://github.com/Gillou68310,Add using_tlb flag to savestates,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/199,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/199#issuecomment-256330810,,"Should we still allow loading the old style save state? Specially since the new version only applies to the new dynarec, there won't be a difference with other dynarec versions.
Instead of cancelling there loading of the save state, we could only read the extra field if the save state file version >= the new save state file version.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,199,2016-10-26T10:41:17Z,2016-10-28T03:22:13Z,2016-10-31T08:16:33Z,MERGED,True,24,7,3,https://github.com/Gillou68310,Add using_tlb flag to savestates,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/199,https://github.com/Gillou68310,3,https://github.com/mupen64plus/mupen64plus-core/pull/199#issuecomment-256383269,,"Old savestate are still compatible, I'm not cancelling there loading since the upper 16bits of the version number are the same. Only the lower 16bits changed.

we could only read the extra field if the save state file version >= the new save state file version.

For now I'm only reading the extra field if the savestate file version == new savestate file version, but using the >= test might be a better idea if we bump the lower 16bits again.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,202,2016-11-05T15:34:53Z,2016-11-08T04:00:43Z,2016-11-08T04:00:43Z,MERGED,True,66,4,5,https://github.com/loganmc10,Make SDL usage optional in some files,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/202,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/202,"This is needed to make the savestate/cheat code work with GLupeN64 (RetroArch).
RetroArch doesn't use/need SDL, so this protects the SDL calls inside ""USE_SDL""
It also exposes savestates_save_m64p/savestates_load_m64p, since RetroArch has its own slot management system.
I'm not sure about Visual Studio, somewhere in there it will need to define USE_SDL for this to work.","This is needed to make the savestate/cheat code work with GLupeN64 (RetroArch).
RetroArch doesn't use/need SDL, so this protects the SDL calls inside ""USE_SDL""
It also exposes savestates_save_m64p/savestates_load_m64p, since RetroArch has its own slot management system.
I'm not sure about Visual Studio, somewhere in there it will need to define USE_SDL for this to work.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,202,2016-11-05T15:34:53Z,2016-11-08T04:00:43Z,2016-11-08T04:00:43Z,MERGED,True,66,4,5,https://github.com/loganmc10,Make SDL usage optional in some files,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/202,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/202#issuecomment-258916315,"This is needed to make the savestate/cheat code work with GLupeN64 (RetroArch).
RetroArch doesn't use/need SDL, so this protects the SDL calls inside ""USE_SDL""
It also exposes savestates_save_m64p/savestates_load_m64p, since RetroArch has its own slot management system.
I'm not sure about Visual Studio, somewhere in there it will need to define USE_SDL for this to work.",If it's preferred I can also make those #ifndef NO_SDLs instead and I can just define NO_SDL in my project,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,202,2016-11-05T15:34:53Z,2016-11-08T04:00:43Z,2016-11-08T04:00:43Z,MERGED,True,66,4,5,https://github.com/loganmc10,Make SDL usage optional in some files,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/202,https://github.com/richard42,3,https://github.com/mupen64plus/mupen64plus-core/pull/202#issuecomment-259038117,"This is needed to make the savestate/cheat code work with GLupeN64 (RetroArch).
RetroArch doesn't use/need SDL, so this protects the SDL calls inside ""USE_SDL""
It also exposes savestates_save_m64p/savestates_load_m64p, since RetroArch has its own slot management system.
I'm not sure about Visual Studio, somewhere in there it will need to define USE_SDL for this to work.","Can you please remove the extra macro definition from the makefile and do:
#ifdef SDL_MAJOR_VERSION
instead?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,202,2016-11-05T15:34:53Z,2016-11-08T04:00:43Z,2016-11-08T04:00:43Z,MERGED,True,66,4,5,https://github.com/loganmc10,Make SDL usage optional in some files,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/202,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/202#issuecomment-259038704,"This is needed to make the savestate/cheat code work with GLupeN64 (RetroArch).
RetroArch doesn't use/need SDL, so this protects the SDL calls inside ""USE_SDL""
It also exposes savestates_save_m64p/savestates_load_m64p, since RetroArch has its own slot management system.
I'm not sure about Visual Studio, somewhere in there it will need to define USE_SDL for this to work.","Sure makes sense, I wasn't sure if that SDL config script set any preprocessor macros like that",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,202,2016-11-05T15:34:53Z,2016-11-08T04:00:43Z,2016-11-08T04:00:43Z,MERGED,True,66,4,5,https://github.com/loganmc10,Make SDL usage optional in some files,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/202,https://github.com/wareya,5,https://github.com/mupen64plus/mupen64plus-core/pull/202#issuecomment-259038758,"This is needed to make the savestate/cheat code work with GLupeN64 (RetroArch).
RetroArch doesn't use/need SDL, so this protects the SDL calls inside ""USE_SDL""
It also exposes savestates_save_m64p/savestates_load_m64p, since RetroArch has its own slot management system.
I'm not sure about Visual Studio, somewhere in there it will need to define USE_SDL for this to work.",SDL_MAJOR_VERSION could be defined even if the downstream user doesn't want to use SDL. They would have to do macro magic or isolate different parts of the project in ways that they might not want to. An extra macro makes more sense to me because it doesn't make assumptions about the environment the downstream developer is compiling with.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,202,2016-11-05T15:34:53Z,2016-11-08T04:00:43Z,2016-11-08T04:00:43Z,MERGED,True,66,4,5,https://github.com/loganmc10,Make SDL usage optional in some files,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/202,https://github.com/richard42,6,https://github.com/mupen64plus/mupen64plus-core/pull/202#issuecomment-259039815,"This is needed to make the savestate/cheat code work with GLupeN64 (RetroArch).
RetroArch doesn't use/need SDL, so this protects the SDL calls inside ""USE_SDL""
It also exposes savestates_save_m64p/savestates_load_m64p, since RetroArch has its own slot management system.
I'm not sure about Visual Studio, somewhere in there it will need to define USE_SDL for this to work.",okay fair enough.  I'll merge it as-is,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,203,2016-11-07T03:17:20Z,2016-11-08T03:47:09Z,2016-11-08T03:47:09Z,MERGED,True,64,0,1,https://github.com/loganmc10,Fix mario kart multiplayer timings,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/203,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/203,"Mario Kart multiplayer has timing issues, this problem has been documented here:
http://tasvideos.org/GameResources/N64/MarioKart64/Patches.html
These cheat codes fix the timing/input lag.
This has been implemented in Project64 for a while now:
project64/project64#607
It has also been tested in mupen64plus:
https://github.com/loganmc10/GLupeN64/pull/93#issuecomment-258719007","Mario Kart multiplayer has timing issues, this problem has been documented here:
http://tasvideos.org/GameResources/N64/MarioKart64/Patches.html
These cheat codes fix the timing/input lag.
This has been implemented in Project64 for a while now:
project64/project64#607
It has also been tested in mupen64plus:
https://github.com/loganmc10/GLupeN64/pull/93#issuecomment-258719007",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,204,2016-11-08T22:35:47Z,2016-11-11T03:16:46Z,2016-11-11T03:16:46Z,MERGED,True,45,3,5,https://github.com/loganmc10,Use custom ViRefresh for some games,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/204,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/204,"This is meant to resolve #139
These values were taken from Project64's RDB file:
https://github.com/project64/project64/blob/master/Config/Project64.rdb
I assume they came to those values via some testing, but this should probably receive some testing as well before it is merged.
For games that had a ViRefresh value I also made sure the CountPerOp (Counter Factor for PJ64) matched. That includes Beetle Adventure Racing, Indiana Jones and the Infernal Machine, and Nightmare Creatures","This is meant to resolve #139
These values were taken from Project64's RDB file:
https://github.com/project64/project64/blob/master/Config/Project64.rdb
I assume they came to those values via some testing, but this should probably receive some testing as well before it is merged.
For games that had a ViRefresh value I also made sure the CountPerOp (Counter Factor for PJ64) matched. That includes Beetle Adventure Racing, Indiana Jones and the Infernal Machine, and Nightmare Creatures",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,204,2016-11-08T22:35:47Z,2016-11-11T03:16:46Z,2016-11-11T03:16:46Z,MERGED,True,45,3,5,https://github.com/loganmc10,Use custom ViRefresh for some games,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/204,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/204#issuecomment-259284625,"This is meant to resolve #139
These values were taken from Project64's RDB file:
https://github.com/project64/project64/blob/master/Config/Project64.rdb
I assume they came to those values via some testing, but this should probably receive some testing as well before it is merged.
For games that had a ViRefresh value I also made sure the CountPerOp (Counter Factor for PJ64) matched. That includes Beetle Adventure Racing, Indiana Jones and the Infernal Machine, and Nightmare Creatures","By the way, the GitHub diff doesn't do a great job of accurately showing the changes to the ini file, you might have to click the little ""Expand"" button where it shows the line numbers to get a more accurate picture.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,205,2016-11-10T15:01:06Z,2016-11-11T04:02:01Z,2016-11-23T14:30:55Z,MERGED,True,282,116,21,https://github.com/bsmiles32,Clean magic constants,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/205,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/205,This PR is mostly about avoiding magic constants. There should be no functional changes.,This PR is mostly about avoiding magic constants. There should be no functional changes.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,207,2016-11-16T17:27:44Z,2016-11-16T19:51:21Z,2016-11-16T19:51:21Z,CLOSED,False,1838,1675,84,https://github.com/bsmiles32,Various refactorings,14,[],https://github.com/mupen64plus/mupen64plus-core/pull/207,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/207,"Various refactorings (no functional changes). Main features of this PR are :

reduced usage of global variables throughout the various modules
introduction of a device struct which should eventually contain all n64 device state.
initialization of n64 components is done in 2 steps (init which configures static part of the component, and poweron which set component state like it would be at power on).
extraction of various backends for external resources (audio, controller, clock, rumble, storage)
unified management of save files (eep, fla, mpk, sra).","Various refactorings (no functional changes). Main features of this PR are :

reduced usage of global variables throughout the various modules
introduction of a device struct which should eventually contain all n64 device state.
initialization of n64 components is done in 2 steps (init which configures static part of the component, and poweron which set component state like it would be at power on).
extraction of various backends for external resources (audio, controller, clock, rumble, storage)
unified management of save files (eep, fla, mpk, sra).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,207,2016-11-16T17:27:44Z,2016-11-16T19:51:21Z,2016-11-16T19:51:21Z,CLOSED,False,1838,1675,84,https://github.com/bsmiles32,Various refactorings,14,[],https://github.com/mupen64plus/mupen64plus-core/pull/207,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/207#issuecomment-261052388,"Various refactorings (no functional changes). Main features of this PR are :

reduced usage of global variables throughout the various modules
introduction of a device struct which should eventually contain all n64 device state.
initialization of n64 components is done in 2 steps (init which configures static part of the component, and poweron which set component state like it would be at power on).
extraction of various backends for external resources (audio, controller, clock, rumble, storage)
unified management of save files (eep, fla, mpk, sra).",Not in mergeable state... I will need some time to fix it. Sorry,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,208,2016-11-17T05:23:06Z,2016-12-06T03:42:06Z,2016-12-06T15:03:09Z,MERGED,True,1835,1670,84,https://github.com/bsmiles32,Various refactorings,14,[],https://github.com/mupen64plus/mupen64plus-core/pull/208,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/208,"Various refactorings (no functional changes). Main features of this PR are :

reduced usage of global variables throughout the various modules
introduction of a device struct which should eventually contain all n64 device state.
initialization of n64 components is done in 2 steps (init which configures static part of the component, and poweron which set component state like it would be at power on).
extraction of various backends for external resources (audio, controller, clock, rumble, storage)
unified management of save files (eep, fla, mpk, sra).","Various refactorings (no functional changes). Main features of this PR are :

reduced usage of global variables throughout the various modules
introduction of a device struct which should eventually contain all n64 device state.
initialization of n64 components is done in 2 steps (init which configures static part of the component, and poweron which set component state like it would be at power on).
extraction of various backends for external resources (audio, controller, clock, rumble, storage)
unified management of save files (eep, fla, mpk, sra).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,208,2016-11-17T05:23:06Z,2016-12-06T03:42:06Z,2016-12-06T15:03:09Z,MERGED,True,1835,1670,84,https://github.com/bsmiles32,Various refactorings,14,[],https://github.com/mupen64plus/mupen64plus-core/pull/208,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/208#issuecomment-262904261,"Various refactorings (no functional changes). Main features of this PR are :

reduced usage of global variables throughout the various modules
introduction of a device struct which should eventually contain all n64 device state.
initialization of n64 components is done in 2 steps (init which configures static part of the component, and poweron which set component state like it would be at power on).
extraction of various backends for external resources (audio, controller, clock, rumble, storage)
unified management of save files (eep, fla, mpk, sra).","Looks nicer, good job. I wonder about how much new indirection (like g_dev.ri.regs) would cost.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,208,2016-11-17T05:23:06Z,2016-12-06T03:42:06Z,2016-12-06T15:03:09Z,MERGED,True,1835,1670,84,https://github.com/bsmiles32,Various refactorings,14,[],https://github.com/mupen64plus/mupen64plus-core/pull/208,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/208#issuecomment-262957576,"Various refactorings (no functional changes). Main features of this PR are :

reduced usage of global variables throughout the various modules
introduction of a device struct which should eventually contain all n64 device state.
initialization of n64 components is done in 2 steps (init which configures static part of the component, and poweron which set component state like it would be at power on).
extraction of various backends for external resources (audio, controller, clock, rumble, storage)
unified management of save files (eep, fla, mpk, sra).","I think there is no new indirection, because all structures are embedded inside the dev one, so offsets are easy to compute. On the other hand if I had stored pointers to structs that would have led to extra indirection.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,210,2016-11-25T04:01:46Z,2016-11-25T04:48:46Z,2016-11-25T04:48:50Z,CLOSED,False,11,0,2,https://github.com/raphnet,Avoid processing CIC response pif ram as commands,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/210,https://github.com/raphnet,1,https://github.com/mupen64plus/mupen64plus-core/pull/210,"When a CIC challenge took place in update_pif_write(), the pif ram
contains a bunch 0xFF followed by 0x00 at offsets 46 and 47. Offsets
48 onwards contains the challenge answer.
Then when update_pif_read() is called, the 0xFF bytes are skipped
up to the two 0x00 bytes that increase the channel to 2. Then the
challenge answer is (incorrectly) processed as if it were commands
for the third controller.
This cause issues with the raphnetraw plugin since it modifies pif ram
to store the result or command error flags. This corrupts the response
and leads to challenge failure.","When a CIC challenge took place in update_pif_write(), the pif ram
contains a bunch 0xFF followed by 0x00 at offsets 46 and 47. Offsets
48 onwards contains the challenge answer.
Then when update_pif_read() is called, the 0xFF bytes are skipped
up to the two 0x00 bytes that increase the channel to 2. Then the
challenge answer is (incorrectly) processed as if it were commands
for the third controller.
This cause issues with the raphnetraw plugin since it modifies pif ram
to store the result or command error flags. This corrupts the response
and leads to challenge failure.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,210,2016-11-25T04:01:46Z,2016-11-25T04:48:46Z,2016-11-25T04:48:50Z,CLOSED,False,11,0,2,https://github.com/raphnet,Avoid processing CIC response pif ram as commands,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/210,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/210#issuecomment-262878750,"When a CIC challenge took place in update_pif_write(), the pif ram
contains a bunch 0xFF followed by 0x00 at offsets 46 and 47. Offsets
48 onwards contains the challenge answer.
Then when update_pif_read() is called, the 0xFF bytes are skipped
up to the two 0x00 bytes that increase the channel to 2. Then the
challenge answer is (incorrectly) processed as if it were commands
for the third controller.
This cause issues with the raphnetraw plugin since it modifies pif ram
to store the result or command error flags. This corrupts the response
and leads to challenge failure.",You are using tabs instead of spaces like the rest of the code for indentation it looks like,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,210,2016-11-25T04:01:46Z,2016-11-25T04:48:46Z,2016-11-25T04:48:50Z,CLOSED,False,11,0,2,https://github.com/raphnet,Avoid processing CIC response pif ram as commands,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/210,https://github.com/raphnet,3,https://github.com/mupen64plus/mupen64plus-core/pull/210#issuecomment-262879904,"When a CIC challenge took place in update_pif_write(), the pif ram
contains a bunch 0xFF followed by 0x00 at offsets 46 and 47. Offsets
48 onwards contains the challenge answer.
Then when update_pif_read() is called, the 0xFF bytes are skipped
up to the two 0x00 bytes that increase the channel to 2. Then the
challenge answer is (incorrectly) processed as if it were commands
for the third controller.
This cause issues with the raphnetraw plugin since it modifies pif ram
to store the result or command error flags. This corrupts the response
and leads to challenge failure.","Oh, sorry. I'll correct this.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,211,2016-11-25T04:49:24Z,2016-11-28T03:24:23Z,2016-11-28T03:24:23Z,MERGED,True,11,0,2,https://github.com/raphnet,Avoid processing CIC response pif ram as commands,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/211,https://github.com/raphnet,1,https://github.com/mupen64plus/mupen64plus-core/pull/211,"When a CIC challenge took place in update_pif_write(), the pif ram
contains a bunch 0xFF followed by 0x00 at offsets 46 and 47. Offsets
48 onwards contains the challenge answer.
Then when update_pif_read() is called, the 0xFF bytes are skipped
up to the two 0x00 bytes that increase the channel to 2. Then the
challenge answer is (incorrectly) processed as if it were commands
for the third controller.
This cause issues with the raphnetraw plugin since it modifies pif ram
to store the result or command error flags. This corrupts the response
and leads to challenge failure.","When a CIC challenge took place in update_pif_write(), the pif ram
contains a bunch 0xFF followed by 0x00 at offsets 46 and 47. Offsets
48 onwards contains the challenge answer.
Then when update_pif_read() is called, the 0xFF bytes are skipped
up to the two 0x00 bytes that increase the channel to 2. Then the
challenge answer is (incorrectly) processed as if it were commands
for the third controller.
This cause issues with the raphnetraw plugin since it modifies pif ram
to store the result or command error flags. This corrupts the response
and leads to challenge failure.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,212,2016-11-28T06:39:02Z,2017-02-01T06:07:32Z,2017-02-01T06:07:32Z,MERGED,True,24,16,3,https://github.com/fzurita,Allow CountPerScan and ViTiming in ROM database to be overridden,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/212,https://github.com/fzurita,1,https://github.com/mupen64plus/mupen64plus-core/pull/212,"Allow ViRefresh and ViTiming in ROM database to be overridden in mupen64plus.cfg
This makes it easier to search for a correct value for a ROM because we don't have to find the correct ROM in the database.
This was done in the same style as CountPerOp.","Allow ViRefresh and ViTiming in ROM database to be overridden in mupen64plus.cfg
This makes it easier to search for a correct value for a ROM because we don't have to find the correct ROM in the database.
This was done in the same style as CountPerOp.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,212,2016-11-28T06:39:02Z,2017-02-01T06:07:32Z,2017-02-01T06:07:32Z,MERGED,True,24,16,3,https://github.com/fzurita,Allow CountPerScan and ViTiming in ROM database to be overridden,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/212,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/212#issuecomment-263634504,"Allow ViRefresh and ViTiming in ROM database to be overridden in mupen64plus.cfg
This makes it easier to search for a correct value for a ROM because we don't have to find the correct ROM in the database.
This was done in the same style as CountPerOp.","I just saw that this is probably going to conflict with pull request #208. Once #208 is merged, I can fix this pull request.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,212,2016-11-28T06:39:02Z,2017-02-01T06:07:32Z,2017-02-01T06:07:32Z,MERGED,True,24,16,3,https://github.com/fzurita,Allow CountPerScan and ViTiming in ROM database to be overridden,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/212,https://github.com/richard42,3,https://github.com/mupen64plus/mupen64plus-core/pull/212#issuecomment-265052578,"Allow ViRefresh and ViTiming in ROM database to be overridden in mupen64plus.cfg
This makes it easier to search for a correct value for a ROM because we don't have to find the correct ROM in the database.
This was done in the same style as CountPerOp.","Okay, I just merged #208.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,212,2016-11-28T06:39:02Z,2017-02-01T06:07:32Z,2017-02-01T06:07:32Z,MERGED,True,24,16,3,https://github.com/fzurita,Allow CountPerScan and ViTiming in ROM database to be overridden,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/212,https://github.com/fzurita,4,https://github.com/mupen64plus/mupen64plus-core/pull/212#issuecomment-265366791,"Allow ViRefresh and ViTiming in ROM database to be overridden in mupen64plus.cfg
This makes it easier to search for a correct value for a ROM because we don't have to find the correct ROM in the database.
This was done in the same style as CountPerOp.",I updated the pull request so that there is no longer a conflict.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,212,2016-11-28T06:39:02Z,2017-02-01T06:07:32Z,2017-02-01T06:07:32Z,MERGED,True,24,16,3,https://github.com/fzurita,Allow CountPerScan and ViTiming in ROM database to be overridden,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/212,https://github.com/fzurita,5,https://github.com/mupen64plus/mupen64plus-core/pull/212#issuecomment-265452543,"Allow ViRefresh and ViTiming in ROM database to be overridden in mupen64plus.cfg
This makes it easier to search for a correct value for a ROM because we don't have to find the correct ROM in the database.
This was done in the same style as CountPerOp.","Ok, I'll update and resubmit some time tonight.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,212,2016-11-28T06:39:02Z,2017-02-01T06:07:32Z,2017-02-01T06:07:32Z,MERGED,True,24,16,3,https://github.com/fzurita,Allow CountPerScan and ViTiming in ROM database to be overridden,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/212,https://github.com/fzurita,6,https://github.com/mupen64plus/mupen64plus-core/pull/212#issuecomment-265639714,"Allow ViRefresh and ViTiming in ROM database to be overridden in mupen64plus.cfg
This makes it easier to search for a correct value for a ROM because we don't have to find the correct ROM in the database.
This was done in the same style as CountPerOp.","Ok, I have updated the pull request to address the comments.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,212,2016-11-28T06:39:02Z,2017-02-01T06:07:32Z,2017-02-01T06:07:32Z,MERGED,True,24,16,3,https://github.com/fzurita,Allow CountPerScan and ViTiming in ROM database to be overridden,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/212,https://github.com/bsmiles32,7,https://github.com/mupen64plus/mupen64plus-core/pull/212#issuecomment-265645847,"Allow ViRefresh and ViTiming in ROM database to be overridden in mupen64plus.cfg
This makes it easier to search for a correct value for a ROM because we don't have to find the correct ROM in the database.
This was done in the same style as CountPerOp.",Thanks for the updated pr. Looks good to me.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,212,2016-11-28T06:39:02Z,2017-02-01T06:07:32Z,2017-02-01T06:07:32Z,MERGED,True,24,16,3,https://github.com/fzurita,Allow CountPerScan and ViTiming in ROM database to be overridden,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/212,https://github.com/fzurita,8,https://github.com/mupen64plus/mupen64plus-core/pull/212#issuecomment-266047215,"Allow ViRefresh and ViTiming in ROM database to be overridden in mupen64plus.cfg
This makes it easier to search for a correct value for a ROM because we don't have to find the correct ROM in the database.
This was done in the same style as CountPerOp.",@richard42 Anything preventing this from being merged?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/213,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/Gillou68310,2,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-264435342,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files.

@bsmiles32 you could apply the same method for the ARM architecture. Currently the ARM backend has it's own structure defined in linkage_arm.S. The address of the structure ( &dynarec_local) is loaded into the FP register in new_dyna_start so all load/store can use FP as the base address + the offset to the variable (ldr    r0, [fp, #stop-dynarec_local]). With your solution FP should be loaded with the address of g_dev (ldr    r0, [fp, #offsetof_struct_device_r4300 + offsetof_struct_r4300_core_stop].
However there are a few limitations to take into account:


The beginning of your structure should start with a 64 bytes (16 registers * 4 bytes) free space used as a stack for pushing/popping registers.


All new_dynarec specific variables should be added to your structure.
-int cycle_count;
-int last_count;
-int pending_exception;
-int pcaddr;
-char *invc_ptr;
-uint64_t readmem_dword;
-u_int rounding_modes[4];
-int branch_target;
-precomp_instr fake_pc;
-int ram_offset;
-u_int mini_ht[32][2];
-u_char restore_candidate[512];
-u_int memory_map[1048576];


The offset value has a limited range, so all variables accessed by the new_dynarec should be as close as possible to the address of g_dev.
-ldr/str 0-4095
-ldrb/strb 0-4095
-ldrh/strh 0-255 most contraining!!! (cpu_hword)


Be careful because the compiler will throw on error if an offset is out of range, but recompiled code won't. You can write a routine that load/store a value to all variables accessed by the new_dynarec to make sure all offsets are in a valid range.
Also on ARM64, 16bit variables should be 2 bytes aligned, 32bit variables should be 4 bytes aligned and 64bit variables should be 8 bytes aligned, on the other hand the offset range is usually bigger. Here's the structure definition for ARM64 https://github.com/Gillou68310/mupen64plus-core/blob/0fbadb4baf598850170a9da90e0b62be19d665f6/src/r4300/new_dynarec/arm64/linkage_arm64.S",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/Gillou68310,3,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-264437655,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Forgot to say memory_map is a special case and only the start address is accessed, no need to try accessing memory_map[1048575], it's not in valid offset range anyway ;-)
That's why it's at the end of the structure BTW.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,4,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-264441569,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Thanks for detailled answer.
As you outlined, the biggest issue is keeping variables used in linkage_arm close to fp. I can see 2 options here :

do as previously and let linkage_arm do it's manual allocation, and just code a bunch of accessors functions to hide this from other modules. This might clutter the code with conditional compilation directives.
or rework the r4300_core, cp0 cp1 and memory structs to ensure locality constrains are met. This would avoid the conditional compilation that we have now but we will loose the clear separation of the cp0, cp1 and memory modules. @Nebuleon already proposed a PR doing something like that 1 year ago.

To me both solutions are acceptables, so I'd like more opinions.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/Gillou68310,5,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-264721806,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.",Well it's just a design decision. I trust your judgment ;-),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,6,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-265460277,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Rebased against master.
Finally, I added accessor wrappers to take care of the difference in variables allocation between the core and the new_dynarec ARM. I renamed some variables along the way. I didn't touch other variables in new_dynarec. This might be done in a later PR as this one is already big enough.
@Gillou68310: can you test the ARM stuff ? I hope I didn't break anything, but I cannot compile and test myself.
Is there someone with VisualStudio that can update the VisualStudio file to generate the asm_defines.h file ?
Thanks.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,7,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-265665225,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.",Updated with some minor fixes.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/Gillou68310,8,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-265700397,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","@Gillou68310: can you test the ARM stuff ? I hope I didn't break anything, but I cannot compile and test myself.

@fzurita do you have time to do that? My android build setup is not really up to date.
I can take care of the visual studio update.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,9,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-265726532,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Yeah, sure, I'll test this some time today.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/Gillou68310,10,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-265732563,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.",Thanks ;-),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,11,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-265742897,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Well, it's not building any more.
[armeabi-v7a] Compile arm    : mupen64plus-core <= memory.c
./mupen64plus-core/src/memory/memory.c: In function 'memory_address':
./mupen64plus-core/src/memory/memory.c:57:13: error: 'g_dev_mem_address' undeclared (first use in this function)
     return &g_dev_mem_address;
             ^
./mupen64plus-core/src/memory/memory.c:57:13: note: each undeclared identifier is reported only once for each function it appears in
./mupen64plus-core/src/memory/memory.c: In function 'memory_wbyte':
./mupen64plus-core/src/memory/memory.c:67:13: error: 'g_dev_mem_wbyte' undeclared (first use in this function)
     return &g_dev_mem_wbyte;
             ^
./mupen64plus-core/src/memory/memory.c: In function 'memory_whword':
./mupen64plus-core/src/memory/memory.c:77:13: error: 'g_dev_mem_whword' undeclared (first use in this function)
     return &g_dev_mem_whword;
             ^
./mupen64plus-core/src/memory/memory.c: In function 'memory_wword':
./mupen64plus-core/src/memory/memory.c:87:13: error: 'g_dev_mem_wword' undeclared (first use in this function)
     return &g_dev_mem_wword;
             ^
./mupen64plus-core/src/memory/memory.c: In function 'memory_wdword':
./mupen64plus-core/src/memory/memory.c:97:13: error: 'g_dev_mem_wdword' undeclared (first use in this function)
     return &g_dev_mem_wdword;
             ^
make: *** [C:/Users/Francisco/Documents/workspaces/mupen64plus-ae/app/build/intermediates/ndkBuild/debug/obj/local/armeabi-v7a/objs/mupen64plus-core/./mupen64plus-core/src/memory/memory.o] Error 1
make: *** Waiting for unfinished jobs....


* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/Gillou68310,12,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-265780614,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","The extern declaration is probably missing for these variables.
Could you check again by adding the following lines:
extern uint32_t g_dev_mem_address;
extern uint8_t g_dev_mem_wbyte;
extern uint16_t g_dev_mem_whword;
extern uint32_t g_dev_mem_wword;
extern uint64_t g_dev_mem_wdword;",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,13,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-265822920,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Yep, I didn't see them defined anywhere. So I guess it's that macro that is defining them.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,14,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-265824618,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Ok, that was the problem in memory.c, unfortunately, the same type of problem repeats in multiple places.
I guess I can fix them all and submit to bsmiles32's branch.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,15,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-265941713,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Ok, I managed to fix all the similar errors, and I'm down to a few I'm not sure about.
In linkage_arm.S: tlb_LUT_r is undefined, what am I supposed to put there? I tried g_dev.r4300.cp0.tlb.LUT_r but it doesn't work.
In savestate_convert.c: There are still references to tlb_LUT_r and tlb_LUT_w. Should they be g_dev.r4300.cp0.tlb.LUT_r and g_dev.r4300.cp0.tlb.LUT_w?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,16,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-265944759,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Huge thanks for the help both of you 😀
For savestate_convert you guessed correctly.
For linkage_arm.S it's harder because it is an assembly file. You have to use the same approach as linkage_x86.S and generate a gas-compatible asm_defines.h from the main/asm_defines.c by filtering its compilation with awk. If I have time i can try to do that part.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,17,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-265947151,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Ok, I updated the Makefile to generate gas-compatible asm_defines.h and included that in linkage_arm.S.
@fzurita : Feel free to push your fixes here :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,18,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-265947394,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Ok, will do. Also, I just realized that savestate_convert.c is a separate tool not part of mupen64plus-core binary.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,19,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-265948720,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.",The pull request has been made to your branch.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,20,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-265950428,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Ok, one problem. main/asm_defines_gas.h doesn't exist in your branch.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,21,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-265951848,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","main\asm_defines_gas.h should be automatically generated. See Makefile.
If it isn't, try typing from unix directory : make ../../src/main/asm_defines_gas.h
If it is, maybe it is just an include directory problem, so instead of #include ""main/asm_defines_gas.h"" in linkage_arm.S, try ""../../src/main/asm_defines_gas.h""",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,22,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-265953373,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","@fzurita : My bad, the auto generation didn't work because I typed linkage_arm.asm instead of linkage_arm.S ...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,23,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-266005869,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","@bsmiles32 I'm building for Android, which has its own custom makefile, I'll see if I can incorporate the generation of that file.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,24,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-266179492,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","I'm having problems understanding what the Makefile is supposed to be doing to generate asm_defines_gas.h. What's the specific command to generate the file?
Edit: I'm assuming that this is what the makefile is trying to do:
http://stackoverflow.com/questions/4928238/include-header-with-c-declarations-in-an-assembly-file-without-errors
Edit: I'm unable to easily call the correct command in Android. Is there any way you can check in the generated file?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,25,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-266182338,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","The command is:
$(SRCDIR)/main/asm_defines_gas.h: $(SRCDIR)/main/asm_defines.c
$(GENS.c) -fno-lto $&lt; -o - | awk '($$1 == ""->"") { print ""#define "" $$2 ""_"" $$3 "" "" substr($$4,2) }' > $@
With
GENS.c = $(Q_CC)$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -S
What it does is that it generates assembler from asm_defines.c using the same compilation flags as the rest of the program (exception for lto). This output is filtered and reformatted to only retain offsets defines.
You can generate the asm_defines_gas.h individualy by typing in the unix directory:
make ../../src/main/asm_defines_gas.h
You can inspect the generated file in src/main/asm_defines_gas.h",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,26,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-266203155,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.",Fixed some regression which prevented pokemon stadium from booting.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,27,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-266425822,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","@fzurita, @Gillou68310: any progress ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,28,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-266426997,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","I have not gotten around to generating that file since I have to setup a Linux environment. It's the only thing that doesn't work for me. Unfortunately, it's been a busy couple of days for me there last few days. I'll try to get to it today.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/Gillou68310,29,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-266531007,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.",Sorry I've been busy with other things too. I'll try to work on this before the end of the week.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,30,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-267771928,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.",@Gillou68310: I've made a PR to add gawk in win32 deps repo as it will likely be needed to generate the asm_defines_*.h headers.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,31,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-267816909,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Updated msvc file to help generate the asm_defines_nasm.h file.
I can't test that myself (no win/msvc), but it should be a step in the right direction. Please test and report if it works.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,32,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-267835724,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Ok, I'm starting to get somewhere generating this file in windows...
First of all these are not defined for the NEW_DYNAREC_ARM
DEFINE(struct r4300_core, regs);
DEFINE(struct r4300_core, hi);
DEFINE(struct r4300_core, lo);
DEFINE(struct r4300_core, stop);
DEFINE(struct memory, wbyte);
DEFINE(struct memory, whword);
DEFINE(struct memory, wword);
DEFINE(struct memory, wdword);
DEFINE(struct memory, address);

Second, commenting those out temporarily still produces errors:
main/asm_defines.c: Assembler messages:
main/asm_defines.c:20: Error: junk at end of line, first unrecognized character is `-'
main/asm_defines.c:29: Error: junk at end of line, first unrecognized character is `-'
main/asm_defines.c:30: Error: junk at end of line, first unrecognized character is `-'
main/asm_defines.c:32: Error: junk at end of line, first unrecognized character is `-'
main/asm_defines.c:34: Error: junk at end of line, first unrecognized character is `-'
main/asm_defines.c:37: Error: junk at end of line, first unrecognized character is `-'
main/asm_defines.c:38: Error: junk at end of line, first unrecognized character is `-'
main/asm_defines.c:39: Error: junk at end of line, first unrecognized character is `-'
main/asm_defines.c:41: Error: junk at end of line, first unrecognized character is `-'
main/asm_defines.c:42: Error: junk at end of line, first unrecognized character is `-'
main/asm_defines.c:43: Error: junk at end of line, first unrecognized character is `-'
main/asm_defines.c:45: Error: junk at end of line, first unrecognized character is `-'
main/asm_defines.c:46: Error: junk at end of line, first unrecognized character is `-'
main/asm_defines.c:48: Error: junk at end of line, first unrecognized character is `-'
main/asm_defines.c:56: Error: junk at end of line, first unrecognized character is `-'
main/asm_defines.c:57: Error: junk at end of line, first unrecognized character is `-'
main/asm_defines.c:58: Error: junk at end of line, first unrecognized character is `-'

Not sure what those mean.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,33,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-267836875,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.",I don't think you can generate this file in Windows for the arm new dynarec. Just x86 and x64. And I guess I will also have to change the DEFINE macro to be compatible with msvc... Oups.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,34,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-267838957,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","I'm using the Android cross compiler. Either way, I get the same errors when building the Windows version. I'm probably missing something.
Here is the command I'm using:
BASE_DIR=`pwd`
echo ""Generating asm defines""
cd ""${BASE_DIR}""/app/src/main/jni/mupen64plus-core/src
x86_64-linux-android-g++ -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes \
 -IC:/Users/Francisco/Documents/workspaces/mupen64plus-ae/app/src/main/jni/./mupen64plus-core/src \
 -IC:/Users/Francisco/Documents/workspaces/mupen64plus-ae/app/src/main/jni/png/include/  \
 -IC:/Users/Francisco/Documents/workspaces/mupen64plus-ae/app/src/main/jni/SDL2/include/ \
 -IC:/Users/Francisco/android-sdks/ndk-bundle/build//../sources/cxx-stl/gnu-libstdc++/4.9/include \
 -IC:/Users/Francisco/android-sdks/ndk-bundle/platforms/android-15/arch-arm/usr/include \
 -IC:/Users/Francisco/android-sdks/ndk-bundle/build//../sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include \
 -IC:/Users/Francisco/android-sdks/ndk-bundle/build//../sources/cxx-stl/gnu-libstdc++/4.9/include/backward \
 -IC:/Users/Francisco/Documents/workspaces/mupen64plus-ae/app/src/main/jni/SDL2/include \
 -IC:/Users/Francisco/Documents/workspaces/mupen64plus-ae/app/src/main/jni \
 -DANDROID -O3 -ffast-math -fno-strict-aliasing -fomit-frame-pointer -frename-registers -fvisibility=hidden -DANDROID  \
 -DIOAPI_NO_64 -DNOCRYPT -DNOUNCRYPT -DUSE_GLES=1 -DDYNAREC -DNEW_DYNAREC=1 -Wa,--noexecstack -Wformat -Werror=format-security  \
 -fno-lto main/asm_defines.c > main/asm_defines_gas.h",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,35,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-267846402,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Add -S -o - to force generation of asm file on stdout and pipe it to awk to extract and generate defines.
g++ ... -S -o - | awk '($$1 == ""->"") { print ""%define "" $$2 ""_"" $$3 "" "" substr($$4,2) }' > main/asm_defines_nasm.h",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,36,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-267847738,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Also, I've just read that msvc doesn't support inline assembly for x64 and arm, so I will have to find an alternative way of generating the asm_defines .... :(",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,37,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-267849568,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.",That's a shame about the lack of support by visual studio.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,38,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-267852509,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","There is still the option of turning asm_defines.c into a separate executable that prints the desired asm_defines_nasm.h . If compiled with the very same options as m64p core, it should work and avoid the usage of inline assembly trick. It might also avoid the dependency on awk. In fact, I might try that option un the coming days :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,39,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-268230788,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","I've investigated the possibility of turning asm_defines into a separate executable, but that would be problematic for cross-compilation scenario. My other idea is to make asm_defines export global variables such as char offsetof_struct_xxx[] whose size is the value of the offset. That way I can retrieve these values easily with objdump/dumpbin and awk. And that would still work un cross-compile scenario.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,40,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269216690,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Updated with previously mentioned changes.
Please help refine the msvc project file so we can move on, I have some cool stuff to push after this PR :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,41,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269220676,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.",This looks interesting. I see you are using objdump now in the Makefile. I'll have to see if it exists in the Android environment.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/Gillou68310,42,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269221353,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","@fzurita sure, objdump is part of the ndk toolchain!",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/Gillou68310,43,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269367924,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","error C2466: cannot allocate an array of constant size 0
@bsmiles32 I get the above error in VS2013 with the following lines:
DEFINE(device, r4300);
DEFINE(r4300_core, regs);
DEFINE(cp0, regs);
DEFINE(tlb, entries);
DEFINE(cached_interp, invalid_code);

The offset from the beginning of the structure is 0 for the above defines and VS2013 doesn't allow allocating an array of size 0.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,44,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269417415,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.",My Bad ! GCC didn't complained 🙁. I've checked and it is indeed not valid c. A hacky workaround would be to add 1 to allow 0 sizes in asm_defines and subtract 1 in objdump/awk. Or maybe you have other ideas to defines symbols with given size ?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,45,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269480214,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Updated with the +1 -1 trick to avoid zero-sized arrays. I also cleaned a little the implementation (awk patterns, offsetof from stddef, don't hardcode programs in Makefile).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/Gillou68310,46,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269510899,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","I have another issue, the generated object file is not passed to dumpbin when using the following command cl /c /FoCON %(FullPath) | dumpbin.exe /SYMBOLS
What does the CON value means next to the /Fo option?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/Gillou68310,47,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269511364,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","However using the following command works:
cl /c %(FullPath) & dumpbin.exe /SYMBOLS asm_defines.obj",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/Gillou68310,48,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269519059,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","What does the CON value means next to the /Fo option?

Nevermind, printing to console.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/Gillou68310,49,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269531617,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Gillou68310@9890a39
Build fine but crashes at startup using 32bit new dynarec, I need time to investigate.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/Gillou68310,50,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269532054,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.",Is it working on linux?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,51,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269563565,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","64 bit works but I cannot test 32 bit due to missing libraries. Can you get a backtrace of the crash with debug symbols ? Does it crashes with all emumodes ( interpreter, cached , dyna) ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,52,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269563817,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Also, I think I gave you push access to this branch, do you can directly updated it 😎",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/Gillou68310,53,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269605222,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","It only crashes with new dynarec, the crash happens in the recompiled code so the backtrace is useless.
Don't worry I will cherry pick my commits to your branch when I'm finished ;-)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,54,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269606363,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.",Can you also check that the asm_defines_nasm.h has sensible values ?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,55,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269606471,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.",And that asm_defines.c is compiled with the same cflags as the rest of the project (except for GlobalOptimization which must be disabled).,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/Gillou68310,56,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269629690,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Here's the generated header file if you want to take a look:
asm_defines_nasm.txt
Here's the cflags used in the project for the New_Dynarec_Debug config:
/GS /analyze- /W3 /Zc:wchar_t /I""..\..\src"" /I""..\..\..\mupen64plus-win32-deps\SDL-1.2.15\include"" /I""..\..\..\mupen64plus-win32-deps\zlib-1.2.8\include"" /I""..\..\..\mupen64plus-win32-deps\libpng-1.6.18\include"" /I""..\..\..\mupen64plus-win32-deps\freetype-2.6\include"" /ZI /Gm /Od /Fd""Debug\vc120.pdb"" /fp:precise /D ""WIN32"" /D ""_DEBUG"" /D ""_WINDOWS"" /D ""_USRDLL"" /D ""_CRT_SECURE_NO_DEPRECATE"" /D ""DYNAREC"" /D ""M64P_OSD"" /D ""M64P_PARALLEL"" /D ""NEW_DYNAREC=1"" /D ""_WINDLL"" /D ""_MBCS"" /errorReport:prompt /WX- /Zc:forScope /RTC1 /Gd /Oy- /MDd /Fa""Debug\"" /EHsc /nologo /Fo""Debug\"" /Fp""Debug\mupen64plus.pch""
Since we are using a custom compile command none of these flags are inherited while compiling asm_defines.c and I don't know if there's a way to include them other than doing it manually.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,57,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269642227,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Your asm_defines_nasm is for 32bit new_dynarec (x86), right ?
Because when I generate it from my desktop (GCC, make BITS=32 NEW_DYNAREC=1 all) I have some different values (for instance for r4300_core_stop which is 0x128 instead of 0x12c for you). Can you try passing manually all the same CFLAGS to see if it helps ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/Gillou68310,58,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269649267,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Your asm_defines_nasm is for 32bit new_dynarec (x86), right ?

Yep.

Can you try passing manually all the same CFLAGS to see if it helps ?

I just tried and no difference in the generated header file.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/Gillou68310,59,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269654001,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Ok I found the cause:
The following line should be replaced:
emit_readword((int)r4300_cp1_regs_double()[(source[i]>>16)&0x1f],temp);
by:
emit_readword((int)&r4300_cp1_regs_double()[(source[i]>>16)&0x1f],temp);
in c1ls_assemble.
You'll have to change it for all reference to r4300_cp1_regs_double/simple within assem_x86/arm.c and new_dynarec.c.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,60,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269657894,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Well done !
Does it mean that with these changes everything works (msvc support, new dynarec x86 and arm) ?
/Me is very happy",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/Gillou68310,61,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269663506,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.",I didn't apply the fix right now so I don't know if everything else is working.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/Gillou68310,62,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269663570,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.",Will do tomorrow!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,63,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269737866,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","So I'm trying to generate asm_defines_nasm.h in the Android environment. But I'm running into issues. Here is my script so far. Ignore the local paths, I plan to replace those with environment variables:
generate-core-asm-defines.zip
Here is the generated objdump file:
asm_defines_obj_dump.zip
And here is the generated asm_defines_nasm.h:
asm_defines_nasm.zip
Is there something I'm missing in my script?
Edit: Here is a more up to date version of my script:
https://github.com/mupen64plus-ae/mupen64plus-ae/blob/bsmiles_noglobals/tools/generate-core-asm-defines.sh",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,64,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269740387,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Try adding -C to objdump (to demangle symbols as you compile in C++ not C),
and change in awk print the $$1 into $$5 as the symbols size seems to appear in fifth column not the first.
Also you might need to change the field separator to space (ie add -F "" "" to awk).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,65,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269740835,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.",Also for nasm it's %define not #define,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,66,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269741006,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Ok, it's looking better. But still not compiling. Here is the updated objdump for arm:
https://github.com/mupen64plus-ae/mupen64plus-ae/blob/bsmiles_noglobals/app/src/main/jni/mupen64plus-core/src/asm_defines_obj_dump_arm.txt
Here is the generated header file for arm:
https://github.com/mupen64plus-ae/mupen64plus-ae/blob/bsmiles_noglobals/app/src/main/jni/mupen64plus-core/src/main/asm_defines_gas.h
Edit: It looks like I'm ending up with 00000000 l     O .bss	00000001  after the #define which doesn't belong. I'm going to have to try to understand awk, I'm not familiar with it.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,67,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269741372,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","awk doesn't seem to correctly parse your columns, have you set the field separator -F "" "" as suggested ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,68,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269741435,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.",Yep. My columns seem to be separated by tabs. I'm looking up the man page on awk.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,69,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269741476,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Try -F ""\t"" ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,70,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269741700,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.",No luck. The cygwin version of awk seems to be acting weird.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,71,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269741880,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.",I think I figured it out. awk doesn't like the $$. It works correctly with just 1 $.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,72,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269742003,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.",ARM compiled fine... Now I have to figure out why x86 is not compiling...,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,73,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269742055,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Seems strange because inside shell scripts I would have expected doubling the $ mandatory, but if it works for you that's great !
So does it compile now and runs ? :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,74,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269742137,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.",Have you changed #define into %define as suggested ?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,75,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269742208,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Yes, I did change #define to %define. It doesn't like this: %include ""../../src/main/asm_defines_nasm.h"" inside the .asm files. I need to figure out proper relative path. Unfortunately, the way my environment is setup, I can't run the ARM version until I get the x86 version compiling.
Edit: %include ""../../../../src/main/asm_defines_nasm.h""  seems to work better for me in linkage_x86.asm.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,76,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269742565,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Ok, I tried to run it, it crashed.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,77,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269742745,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Here is the core dump:
********** Crash dump: **********
Build fingerprint: 'ZTE/P996A01/ailsa_ii:6.0.1/MMB29M/20161014.114339:user/release-keys'
pid: 24192, tid: 24961, name: CoreThread  >>> org.mupen64plusae.v3.alpha <<<
signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x0
#00 pc 000178f0  /system/lib/libc.so (memset+48)
#01 pc 00041c54  libmupen64plus-core.so: Routine poweron_r4300 at ./mupen64plus-core/src/r4300/r4300_core.c:50 (discriminator 1)
#02 pc 0000f35c  libmupen64plus-core.so: Routine poweron_device at ./mupen64plus-core/src/main/device.c:76
#03 pc 00012afc  libmupen64plus-core.so: Routine main_run at ./mupen64plus-core/src/main/main.c:1014
#04 pc 00003ee1  libmupen64plus-ui-console.so (SDL_main+3568): Routine SDL_main at ./mupen64plus-ui-console/src/main.c:782
#05 pc 007f6e2d  /data/app/org.mupen64plusae.v3.alpha-1/oat/arm/base.odex (offset 0x4f9000) (int paulscode.android.mupen64plusae.jni.NativeExports.emuStart(java.lang.String,java.lang.String, java.lang.Object[])+144)
#06 pc 007e6be7  /data/app/org.mupen64plusae.v3.alpha-1/oat/arm/base.odex (offset 0x4f9000) (void paulscode.android.mupen64plusae.jni.CoreInterface$4.run()+2930)
#07 pc 02108839  /system/framework/arm/boot.oat (offset 0x20eb000)

It seems to have crashed in this line in r4300_core.c
memset(r4300_regs(), 0, 32*sizeof(int64_t));

The array size seems to be 256 bytes, I'm not sure why it's crashing.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,78,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269743141,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","All I can think of is that #define offsetof_struct_device_r4300 (0x00000001-1) is not giving me the correct memory address.
Edit: I'm off to bed.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,79,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269743581,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","offsetof_struct_device_r4300 should be zero because it is the offset of r4300 member inside a struct device.
So here it is OK. I think there might be a problem when you compile both x86 and ARM within the same directory, some defines might not play well together, such as NEW_DYNAREC being sometimes  equal to and different from NEW_DYNAREC_ARM.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,80,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269744262,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","OK, can you double check this file? https://github.com/mupen64plus-ae/mupen64plus-ae/blob/bsmiles_noglobals/app/src/main/jni/mupen64plus-core/src/main/asm_defines_gas.h
I can compile and run this in Android with the regular mupen64plus-core. I'm not sure why only this branch would be an issue.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,81,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269744546,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.",The gas file looks good to me for the ARM.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,82,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269744683,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","OK, maybe @Gillou68310 will have an idea. I'll check again tomorrow.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,83,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269744732,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Ok ! Have some good sleep, we made great progress already :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/Gillou68310,84,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269749606,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","I confirm that the new_dynarec x86 is working on windows since your last commit. My android setup is at work so I won't be able to work on the ARM backend until monday, sorry for the delay :-(",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,85,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269755685,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","No worries ! Can you push your updated msvc project files here ?
If I understand correctly after we get confirmation that the ARM new dynarec works, this pr will be mergeable ? 😀
@richard42 Any suggestions on this ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,86,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269852824,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","I found the problem I was having with the ARM version. This problem is in numerous places, here is one example though, some of this may have been my doing. In r4300_core.c extern int64_t* g_dev_r4300_regs; should be extern int64_t g_dev_r4300_regs;
And
int64_t* r4300_regs(void)
{
    return g_dev_r4300_regs;
}

should change to this:
int64_t* r4300_regs(void)
{
    return &g_dev_r4300_regs;
}",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,87,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269854012,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Ok, I'm running now without core dumping in the ARM version. I'll update your branch.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,88,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269854200,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.",@Gillou68310 Can you check that the generate-core-asm-defines.sh script works correctly in a linux environment?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,89,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269867392,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","I took care of the ASFLAGS for upstream with this commit.
You can do the same for your fork now.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,90,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269870740,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.",It works correctly now without any modifications.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/Gillou68310,91,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-269998848,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","@Gillou68310 Can you check that the generate-core-asm-defines.sh script works correctly in a linux environment?

I'm working on windows too :-p.
@bsmiles32 I cleaned up the new dynarec code a bit, I didn't succeed pushing on your branch but you can cherry pick my work from my local branch https://github.com/Gillou68310/mupen64plus-core/commits/no_globals
The asm_defines_gas header for ARM is not necessary anymore but I left it in place just in case we need it in the future.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,92,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-270006072,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","@Gillou68310: I've sent you a collaboration invitation so you can push here. In your branch there are 2 commits, one for msvc file and one for new dynarec cleanings. Is the cleaning part of this PR ? Because if not, I would prefer it to be part of a separate pr as this one is already big enough.
To summarize the state of this PR:

Makefile and msvc files have been updated
Both 32/64 bits versions are working
New Dynarec x86/ARM is also working

Is that right ? Then it should be pretty soon ready for merge (eg After adding Gillou's commit(s))",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/Gillou68310,93,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-270011671,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Ok I pushed the updated msvc files.
I will open another PR for the new dynarec code cleanup part.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/loganmc10,94,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-272516460,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","I don't mean to sound rude, and I'm not sure who all has push access to this repo, but perhaps that list could be expanded? Many PR's seem to get submitted to mupen64plus that just sort of sit there for weeks or months without much action or discussion...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/bsmiles32,95,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-272600672,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","There are several devs with merge rights, myself included. Since I'm proposing the PR I'd prefer someone else to merge it, because last time I merged m'y own PR I got bitten by regressions 🙁 I'm not sure why @richard42 hasn't responded yet, but let's hope it's nothing too serious.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/fzurita,96,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-272601157,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.",It's around Christmas/new year's time. Maybe he went on vacation.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,213,2016-12-01T18:33:19Z,2017-02-01T06:27:09Z,2017-02-03T17:07:08Z,MERGED,True,6670,6159,97,https://github.com/bsmiles32,No globals,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/213,https://github.com/richard42,97,https://github.com/mupen64plus/mupen64plus-core/pull/213#issuecomment-272638038,"This PR depends upon what have been initiated in PR#208.
Main concern of this PR is to move all global variables related to the emulated system inside device (or one of its sub) structures. So that everything about the system state can be accessed from the g_dev global variable. Future work might go a little further and avoid the usage of the g_dev global with carefull passing of appropriate struct around. But for now, g_dev is heavily relied upon.
The main problem that was previously blocking such work is that assembly files can't use directly C struct fields. Assemblers only know about numerical offsets. To complicate the situation, C structure offsets are compiler/implementation dependent. So the only ""sane"" way to solve this is to make the compiler generate a file which will define these numerical offsets, and include it in assembly files. In practice, we make the compiler emit an assembly file from a crafted dummy C file and parse it with gawk.
Note however that this PR is still incomplete and I will need help on the following points:

VisualStudio project file needs to be updated to trigger the generation of the asm_defines.h file.
This might also require the addition of (g)awk.exe (?) as a build dependency.
(bonus point if the asm_defines.h file is re-generated when structures it depends upon are changed).
new_dynarec/ARM: @Gillou68310 any thought on how to proceed with this ?
general testing to ensure no regression.

Also, I might not have much free time to work on that for the coming months, so expect slow progress.","Sorry I've been out of it lately.  I was out of town for several weeks at the end of December, and I've been busy with everything else.  My inbox is overflowing with Mupen64plus stuff to review; I'll get to it before long. :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,215,2016-12-06T10:40:41Z,2017-02-01T06:05:46Z,2017-02-01T10:15:34Z,MERGED,True,3,3,1,https://github.com/Gillou68310,Fix assertion failure when starting Kuiki Uhabi Suigo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/215,https://github.com/Gillou68310,1,https://github.com/mupen64plus/mupen64plus-core/pull/215,The parameter of isspace should be in the range 0-255.,The parameter of isspace should be in the range 0-255.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,215,2016-12-06T10:40:41Z,2017-02-01T06:05:46Z,2017-02-01T10:15:34Z,MERGED,True,3,3,1,https://github.com/Gillou68310,Fix assertion failure when starting Kuiki Uhabi Suigo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/215,https://github.com/richard42,2,https://github.com/mupen64plus/mupen64plus-core/pull/215#issuecomment-265358443,The parameter of isspace should be in the range 0-255.,wouldn't it be better just to change the pointer definitions to unsigned char * than to typecast the dereferenced chars?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,215,2016-12-06T10:40:41Z,2017-02-01T06:05:46Z,2017-02-01T10:15:34Z,MERGED,True,3,3,1,https://github.com/Gillou68310,Fix assertion failure when starting Kuiki Uhabi Suigo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/215,https://github.com/Gillou68310,3,https://github.com/mupen64plus/mupen64plus-core/pull/215#issuecomment-265396249,The parameter of isspace should be in the range 0-255.,"Do you mean casting the pointer to (unsigned char *) before dereferencing it?
*((unsigned char*)start)
If you mean changing char *start = str; to unsigned char *start = str; it means implicit cast of str from char* to unsigned char* I would rather use explicit cast.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,216,2016-12-06T11:42:38Z,2016-12-07T05:21:42Z,2016-12-10T08:24:43Z,MERGED,True,328,193,7,https://github.com/Gillou68310,Fix new dynarec interrupt management,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/216,https://github.com/Gillou68310,1,https://github.com/mupen64plus/mupen64plus-core/pull/216,This also fixes soft reset.,This also fixes soft reset.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,220,2016-12-25T03:07:08Z,2017-02-02T06:33:28Z,2017-10-14T18:34:09Z,MERGED,True,6,6,1,None,Fix Kirby 64 save size,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/220,None,1,https://github.com/mupen64plus/mupen64plus-core/pull/220,"My cart for Kirby 64 (U) has the BK16D 9851 eeprom chip.
The (J) V1.0+V1.1 seem to use sram. The emulator creates .sra, which matches Project64's behavior as well.","My cart for Kirby 64 (U) has the BK16D 9851 eeprom chip.
The (J) V1.0+V1.1 seem to use sram. The emulator creates .sra, which matches Project64's behavior as well.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,227,2017-01-22T15:15:00Z,2017-02-03T06:17:50Z,2017-02-03T17:07:02Z,MERGED,True,1871,1876,162,https://github.com/bsmiles32,Device refactorings,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/227,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/227,"This PR depends on the work done in PR 213 (no globals).
Main concern of this PR is to move all the emulation logic inside the device directory.
Also backends are partly reworked to ease their usage in the upcoming gameboy/transferpak support.","This PR depends on the work done in PR 213 (no globals).
Main concern of this PR is to move all the emulation logic inside the device directory.
Also backends are partly reworked to ease their usage in the upcoming gameboy/transferpak support.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,227,2017-01-22T15:15:00Z,2017-02-03T06:17:50Z,2017-02-03T17:07:02Z,MERGED,True,1871,1876,162,https://github.com/bsmiles32,Device refactorings,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/227,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/227#issuecomment-277008397,"This PR depends on the work done in PR 213 (no globals).
Main concern of this PR is to move all the emulation logic inside the device directory.
Also backends are partly reworked to ease their usage in the upcoming gameboy/transferpak support.",Rebased against master.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,229,2017-01-30T19:57:26Z,2017-02-08T18:13:20Z,2017-06-02T16:44:14Z,CLOSED,False,61,3,2,https://github.com/loganmc10,Allow libretro to save states to memory,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/229,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/229,Fixes #228,Fixes #228,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,229,2017-01-30T19:57:26Z,2017-02-08T18:13:20Z,2017-06-02T16:44:14Z,CLOSED,False,61,3,2,https://github.com/loganmc10,Allow libretro to save states to memory,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/229,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/229#issuecomment-276240963,Fixes #228,"Thanks for your contribution !
The deep  issue this pr addresses is that upstream saves/loads to/from file (and compress/uncompress) savestates. While convenient for upstream, this is not desirable for libretro, which would benefit from savestates to memory.
Your proposed solution, while acceptable in the short term, will complicate long term maintainance (lots of ifdef).
What I personnally would prefer for the long term is to split the serialization logic from the actual destination (memory for libretro, compressed file for m64p). That way would avoid the ifdef and improve upstream code 🙂",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,229,2017-01-30T19:57:26Z,2017-02-08T18:13:20Z,2017-06-02T16:44:14Z,CLOSED,False,61,3,2,https://github.com/loganmc10,Allow libretro to save states to memory,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/229,https://github.com/rlabrecque,3,https://github.com/mupen64plus/mupen64plus-core/pull/229#issuecomment-276467620,Fixes #228,"I agree with bobby, I'd rather this be accepted but having a cleanup pass on it would be even better.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,229,2017-01-30T19:57:26Z,2017-02-08T18:13:20Z,2017-06-02T16:44:14Z,CLOSED,False,61,3,2,https://github.com/loganmc10,Allow libretro to save states to memory,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/229,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/229#issuecomment-276974160,Fixes #228,"No problem, you can hold off merging this until I clean it up/make it less intrusive",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,231,2017-02-01T14:59:23Z,2017-02-02T02:39:07Z,2017-06-02T16:44:13Z,CLOSED,False,1,0,1,https://github.com/loganmc10,Fix for #230,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/231,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/231,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,231,2017-02-01T14:59:23Z,2017-02-02T02:39:07Z,2017-06-02T16:44:13Z,CLOSED,False,1,0,1,https://github.com/loganmc10,Fix for #230,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/231,https://github.com/richard42,2,https://github.com/mupen64plus/mupen64plus-core/pull/231#issuecomment-276851754,,"thanks, but I fixed it a different way.  Having a macro called DEFAULT just seems like a bad idea.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,232,2017-02-02T22:55:57Z,2017-02-03T06:46:04Z,2017-06-02T16:44:11Z,MERGED,True,11,1,1,https://github.com/loganmc10,Disable OSD if OpenGL core context is in use,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/232,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/232,The OSD is incompatible with an OpenGL core context. Having it enabled while using a core context causes GL errors and even graphical glitches.,The OSD is incompatible with an OpenGL core context. Having it enabled while using a core context causes GL errors and even graphical glitches.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,233,2017-02-03T23:24:16Z,2017-02-04T05:22:35Z,2017-02-04T05:22:35Z,MERGED,True,5,5,1,https://github.com/joolswills,fix include paths / fixes building on arm/neon,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/233,https://github.com/joolswills,1,https://github.com/mupen64plus/mupen64plus-core/pull/233,"Include paths were wrong after #227 (or another recent change)
I adjusted some paths with ../../ relative to the src folder too to simplify things (which matched other code I saw).
main/main.h was included twice - I guess the second one could be removed but I left it for now.","Include paths were wrong after #227 (or another recent change)
I adjusted some paths with ../../ relative to the src folder too to simplify things (which matched other code I saw).
main/main.h was included twice - I guess the second one could be removed but I left it for now.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,235,2017-02-06T11:43:42Z,2017-02-07T00:29:14Z,2017-02-10T01:09:04Z,MERGED,True,7190,8100,10,https://github.com/Gillou68310,new_dynarec: Code cleanup,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/235,https://github.com/Gillou68310,1,https://github.com/mupen64plus/mupen64plus-core/pull/235,"@bsmiles32 I noticed that both mingw and osx new dynarec build are broken because the AWK command does not match the objdump structure.
MinGW: mingw.txt
OSX: llvm8.txt
Do you think it's possible to fix this issue with a generic AWK command? Or do we need to have a specific command for all platforms?
Also newer version of objdump might change the dump format, so a generic command would be preferred ;-)","@bsmiles32 I noticed that both mingw and osx new dynarec build are broken because the AWK command does not match the objdump structure.
MinGW: mingw.txt
OSX: llvm8.txt
Do you think it's possible to fix this issue with a generic AWK command? Or do we need to have a specific command for all platforms?
Also newer version of objdump might change the dump format, so a generic command would be preferred ;-)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,235,2017-02-06T11:43:42Z,2017-02-07T00:29:14Z,2017-02-10T01:09:04Z,MERGED,True,7190,8100,10,https://github.com/Gillou68310,new_dynarec: Code cleanup,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/235,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/235#issuecomment-277881916,"@bsmiles32 I noticed that both mingw and osx new dynarec build are broken because the AWK command does not match the objdump structure.
MinGW: mingw.txt
OSX: llvm8.txt
Do you think it's possible to fix this issue with a generic AWK command? Or do we need to have a specific command for all platforms?
Also newer version of objdump might change the dump format, so a generic command would be preferred ;-)",I'm afraid platform specific commands is required here...,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,235,2017-02-06T11:43:42Z,2017-02-07T00:29:14Z,2017-02-10T01:09:04Z,MERGED,True,7190,8100,10,https://github.com/Gillou68310,new_dynarec: Code cleanup,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/235,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/235#issuecomment-277884599,"@bsmiles32 I noticed that both mingw and osx new dynarec build are broken because the AWK command does not match the objdump structure.
MinGW: mingw.txt
OSX: llvm8.txt
Do you think it's possible to fix this issue with a generic AWK command? Or do we need to have a specific command for all platforms?
Also newer version of objdump might change the dump format, so a generic command would be preferred ;-)","Or maybe use nm instead of objdump, which seems to have a more standardized output ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,235,2017-02-06T11:43:42Z,2017-02-07T00:29:14Z,2017-02-10T01:09:04Z,MERGED,True,7190,8100,10,https://github.com/Gillou68310,new_dynarec: Code cleanup,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/235,https://github.com/Gillou68310,4,https://github.com/mupen64plus/mupen64plus-core/pull/235#issuecomment-278700645,"@bsmiles32 I noticed that both mingw and osx new dynarec build are broken because the AWK command does not match the objdump structure.
MinGW: mingw.txt
OSX: llvm8.txt
Do you think it's possible to fix this issue with a generic AWK command? Or do we need to have a specific command for all platforms?
Also newer version of objdump might change the dump format, so a generic command would be preferred ;-)","I check nm and you're right outputs are much more similar between platforms.
osx:
0000000000000001 C _offsetof_struct_cached_interp_invalid_code
0000000000000225 C _offsetof_struct_cp0_count_per_op
0000000000000221 C _offsetof_struct_cp0_last_addr
0000000000000219 C _offsetof_struct_cp0_next_interrupt
0000000000000001 C _offsetof_struct_cp0_regs
0000000000000229 C _offsetof_struct_cp0_tlb
0000000001104391 C _offsetof_struct_device_mem
0000000000000001 C _offsetof_struct_device_r4300
00000000011041c9 C _offsetof_struct_device_ri
0000000000000011 C _offsetof_struct_memory_address
0000000000000009 C _offsetof_struct_memory_wbyte
0000000000000009 C _offsetof_struct_memory_wdword
0000000000000009 C _offsetof_struct_memory_whword
0000000000000009 C _offsetof_struct_memory_wword
0000000000000ae9 C _offsetof_struct_r4300_core_cached_interp
0000000000900c29 C _offsetof_struct_r4300_core_cp0
0000000000000101 C _offsetof_struct_r4300_core_hi
0000000000000109 C _offsetof_struct_r4300_core_lo
0000000000000001 C _offsetof_struct_r4300_core_regs
0000000000000a11 C _offsetof_struct_r4300_core_return_address
0000000000000a09 C _offsetof_struct_r4300_core_save_rip
0000000000000a01 C _offsetof_struct_r4300_core_save_rsp
0000000000000135 C _offsetof_struct_r4300_core_stop
0000000000000029 C _offsetof_struct_rdram_dram
0000000000000021 C _offsetof_struct_ri_controller_rdram
0000000000000681 C _offsetof_struct_tlb_LUT_r
0000000000400681 C _offsetof_struct_tlb_LUT_w
0000000000000001 C _offsetof_struct_tlb_entries

Mingw:
00000000 b .bss
00000000 d .data
00000000 i .drectve
00000000 r .rdata$zzz
00000000 t .text
00000001 C _offsetof_struct_cached_interp_invalid_code
00000199 C _offsetof_struct_cp0_count_per_op
00000195 C _offsetof_struct_cp0_last_addr
0000018d C _offsetof_struct_cp0_next_interrupt
00000001 C _offsetof_struct_cp0_regs
0000019d C _offsetof_struct_cp0_tlb
00d03c41 C _offsetof_struct_device_mem
00000001 C _offsetof_struct_device_r4300
00d03ae1 C _offsetof_struct_device_ri
00000011 C _offsetof_struct_memory_address
00000009 C _offsetof_struct_memory_wbyte
00000009 C _offsetof_struct_memory_wdword
00000009 C _offsetof_struct_memory_whword
00000009 C _offsetof_struct_memory_wword
00000655 C _offsetof_struct_r4300_core_cached_interp
0050071d C _offsetof_struct_r4300_core_cp0
00000101 C _offsetof_struct_r4300_core_hi
00000109 C _offsetof_struct_r4300_core_lo
00000001 C _offsetof_struct_r4300_core_regs
000005cd C _offsetof_struct_r4300_core_return_address
000005b5 C _offsetof_struct_r4300_core_save_ebp
000005b9 C _offsetof_struct_r4300_core_save_ebx
000005c1 C _offsetof_struct_r4300_core_save_edi
000005c9 C _offsetof_struct_r4300_core_save_eip
000005bd C _offsetof_struct_r4300_core_save_esi
000005c5 C _offsetof_struct_r4300_core_save_esp
0000012d C _offsetof_struct_r4300_core_stop
00000029 C _offsetof_struct_rdram_dram
00000021 C _offsetof_struct_ri_controller_rdram
00000001 C _offsetof_struct_tlb_entries
00000681 C _offsetof_struct_tlb_LUT_r
00400681 C _offsetof_struct_tlb_LUT_w

Do you know an easy way to detect the leading underscore and remove it if necessary with awk?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,235,2017-02-06T11:43:42Z,2017-02-07T00:29:14Z,2017-02-10T01:09:04Z,MERGED,True,7190,8100,10,https://github.com/Gillou68310,new_dynarec: Code cleanup,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/235,https://github.com/bsmiles32,5,https://github.com/mupen64plus/mupen64plus-core/pull/235#issuecomment-278817612,"@bsmiles32 I noticed that both mingw and osx new dynarec build are broken because the AWK command does not match the objdump structure.
MinGW: mingw.txt
OSX: llvm8.txt
Do you think it's possible to fix this issue with a generic AWK command? Or do we need to have a specific command for all platforms?
Also newer version of objdump might change the dump format, so a generic command would be preferred ;-)",Use the substr function,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,235,2017-02-06T11:43:42Z,2017-02-07T00:29:14Z,2017-02-10T01:09:04Z,MERGED,True,7190,8100,10,https://github.com/Gillou68310,new_dynarec: Code cleanup,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/235,https://github.com/Gillou68310,6,https://github.com/mupen64plus/mupen64plus-core/pull/235#issuecomment-278822760,"@bsmiles32 I noticed that both mingw and osx new dynarec build are broken because the AWK command does not match the objdump structure.
MinGW: mingw.txt
OSX: llvm8.txt
Do you think it's possible to fix this issue with a generic AWK command? Or do we need to have a specific command for all platforms?
Also newer version of objdump might change the dump format, so a generic command would be preferred ;-)","Yeah I know about the substr function, my question was more about how to conditionally use it to remove the leading underscore if one exists?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,235,2017-02-06T11:43:42Z,2017-02-07T00:29:14Z,2017-02-10T01:09:04Z,MERGED,True,7190,8100,10,https://github.com/Gillou68310,new_dynarec: Code cleanup,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/235,https://github.com/ddugovic,7,https://github.com/mupen64plus/mupen64plus-core/pull/235#issuecomment-278827774,"@bsmiles32 I noticed that both mingw and osx new dynarec build are broken because the AWK command does not match the objdump structure.
MinGW: mingw.txt
OSX: llvm8.txt
Do you think it's possible to fix this issue with a generic AWK command? Or do we need to have a specific command for all platforms?
Also newer version of objdump might change the dump format, so a generic command would be preferred ;-)",([0-9a-f]{8} \w )_?(.+) seems to work on regex101.com .  I don't remember sed/awk syntax.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,237,2017-02-09T16:00:12Z,2017-05-20T05:57:54Z,2017-06-02T16:43:53Z,MERGED,True,205,2,6,https://github.com/loganmc10,Add ConfigExternalGetParameter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/237,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/237,"This adds a new API function: ConfigExternalGetParameter.
Basically you pass it the path to an ini file, the section, and the parameter name, and it returns the value. This will allow plugins to leverage the already existing ini parser built into mupen64plus-core.
GLideN64 will use this to read it's custom ini file with game specific settings.","This adds a new API function: ConfigExternalGetParameter.
Basically you pass it the path to an ini file, the section, and the parameter name, and it returns the value. This will allow plugins to leverage the already existing ini parser built into mupen64plus-core.
GLideN64 will use this to read it's custom ini file with game specific settings.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,237,2017-02-09T16:00:12Z,2017-05-20T05:57:54Z,2017-06-02T16:43:53Z,MERGED,True,205,2,6,https://github.com/loganmc10,Add ConfigExternalGetParameter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/237,https://github.com/richard42,2,https://github.com/mupen64plus/mupen64plus-core/pull/237#issuecomment-279924252,"This adds a new API function: ConfigExternalGetParameter.
Basically you pass it the path to an ini file, the section, and the parameter name, and it returns the value. This will allow plugins to leverage the already existing ini parser built into mupen64plus-core.
GLideN64 will use this to read it's custom ini file with game specific settings.","I like the simplicity of what you've done here, and I like the fact that you updated the documentation, but there are a few problems with this.

It opens and parses the entire file to return a single parameter, so reading all the parameters in a file will be O(N^2).  If there aren't very many parameters then it won't be a problem but if a plugin had a very large config file (like the INI file with rice video) it will be a performance issue.
You are returning a const char * into a char buffer which is allocated on the stack (char buffer[256]).  That is a bug.  You could strdup() it but the documentation would need to make clear that the caller would be responsible for freeing the returned string.
With any change in the core API, we need to update the version number (src/main/version.h) for the modified API, and the API versioning documentation (in Mupen64Plus-v2.0-API-Versioning.mediawiki)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,237,2017-02-09T16:00:12Z,2017-05-20T05:57:54Z,2017-06-02T16:43:53Z,MERGED,True,205,2,6,https://github.com/loganmc10,Add ConfigExternalGetParameter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/237,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/237#issuecomment-280542974,"This adds a new API function: ConfigExternalGetParameter.
Basically you pass it the path to an ini file, the section, and the parameter name, and it returns the value. This will allow plugins to leverage the already existing ini parser built into mupen64plus-core.
GLideN64 will use this to read it's custom ini file with game specific settings.","Thanks for the feedback


I agree it is very inefficient, but making it more efficient would require further extensions to the API (ConfigOpenExternal/CloseExternal or something like that), and some kind of tracking system in the core to keep track of the open files. Since INI parsing should happen before the start of a game, I don't think performance is a huge concern, there shouldn't be a reason for a plugin to parse a config file during any time where performance would be of consequence


Thanks, I don't code in C much. Would it be better to return an m64p_error and have the plugin pass a  char* into the function? Then it should be obvious that they are in charge of managing that memory, but I could also add a note to the doc.


Thanks I can do that as well.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,237,2017-02-09T16:00:12Z,2017-05-20T05:57:54Z,2017-06-02T16:43:53Z,MERGED,True,205,2,6,https://github.com/loganmc10,Add ConfigExternalGetParameter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/237,https://github.com/Papermanzero,4,https://github.com/mupen64plus/mupen64plus-core/pull/237#issuecomment-285278672,"This adds a new API function: ConfigExternalGetParameter.
Basically you pass it the path to an ini file, the section, and the parameter name, and it returns the value. This will allow plugins to leverage the already existing ini parser built into mupen64plus-core.
GLideN64 will use this to read it's custom ini file with game specific settings.","Any update on this one?
Many users would like to see the features to load the config file for GlideN64.
If Bullet 2 and 3 are resolved I would propose to merge it.
Bullet 1 can be improved with future revisions and PRs.
At least for GlideN64 you need anyway performant hardware.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,237,2017-02-09T16:00:12Z,2017-05-20T05:57:54Z,2017-06-02T16:43:53Z,MERGED,True,205,2,6,https://github.com/loganmc10,Add ConfigExternalGetParameter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/237,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/237#issuecomment-286889344,"This adds a new API function: ConfigExternalGetParameter.
Basically you pass it the path to an ini file, the section, and the parameter name, and it returns the value. This will allow plugins to leverage the already existing ini parser built into mupen64plus-core.
GLideN64 will use this to read it's custom ini file with game specific settings.","Ok this PR has been updated to address points 2 & 3. The function now returns an m64p_error. A new variable, ParamPtr, is passed into the function, which is a pre-allocated char array created by the plugin that should be at least 256 bytes. The value is passed into that pointer via strncpy.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,237,2017-02-09T16:00:12Z,2017-05-20T05:57:54Z,2017-06-02T16:43:53Z,MERGED,True,205,2,6,https://github.com/loganmc10,Add ConfigExternalGetParameter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/237,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/237#issuecomment-287662458,"This adds a new API function: ConfigExternalGetParameter.
Basically you pass it the path to an ini file, the section, and the parameter name, and it returns the value. This will allow plugins to leverage the already existing ini parser built into mupen64plus-core.
GLideN64 will use this to read it's custom ini file with game specific settings.","Ok this has been updated to add a ""ParamMaxLength"" variable, which is used to allocate the buffer passed to ini_parse_line(). It is also used as the max value passed to strncpy",True,{'THUMBS_UP': ['https://github.com/Papermanzero']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,237,2017-02-09T16:00:12Z,2017-05-20T05:57:54Z,2017-06-02T16:43:53Z,MERGED,True,205,2,6,https://github.com/loganmc10,Add ConfigExternalGetParameter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/237,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/237#issuecomment-288103361,"This adds a new API function: ConfigExternalGetParameter.
Basically you pass it the path to an ini file, the section, and the parameter name, and it returns the value. This will allow plugins to leverage the already existing ini parser built into mupen64plus-core.
GLideN64 will use this to read it's custom ini file with game specific settings.",Ok it's been updated to use malloc/free,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,237,2017-02-09T16:00:12Z,2017-05-20T05:57:54Z,2017-06-02T16:43:53Z,MERGED,True,205,2,6,https://github.com/loganmc10,Add ConfigExternalGetParameter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/237,https://github.com/Gillou68310,8,https://github.com/mupen64plus/mupen64plus-core/pull/237#issuecomment-288349837,"This adds a new API function: ConfigExternalGetParameter.
Basically you pass it the path to an ini file, the section, and the parameter name, and it returns the value. This will allow plugins to leverage the already existing ini parser built into mupen64plus-core.
GLideN64 will use this to read it's custom ini file with game specific settings.","I wonder if the api should be responsible for opening/closing the file, maybe we should pass the file pointer instead of the filename. What do you guys think?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,237,2017-02-09T16:00:12Z,2017-05-20T05:57:54Z,2017-06-02T16:43:53Z,MERGED,True,205,2,6,https://github.com/loganmc10,Add ConfigExternalGetParameter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/237,https://github.com/loganmc10,9,https://github.com/mupen64plus/mupen64plus-core/pull/237#issuecomment-288378428,"This adds a new API function: ConfigExternalGetParameter.
Basically you pass it the path to an ini file, the section, and the parameter name, and it returns the value. This will allow plugins to leverage the already existing ini parser built into mupen64plus-core.
GLideN64 will use this to read it's custom ini file with game specific settings.","That would certainly improve performance, since right now it is reading the whole file for every individual parameter, but then you need to keep track of file pointers, etc... Because multiple plugins could theoretically be opening multiple config files, etc..",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,237,2017-02-09T16:00:12Z,2017-05-20T05:57:54Z,2017-06-02T16:43:53Z,MERGED,True,205,2,6,https://github.com/loganmc10,Add ConfigExternalGetParameter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/237,https://github.com/loganmc10,10,https://github.com/mupen64plus/mupen64plus-core/pull/237#issuecomment-288382939,"This adds a new API function: ConfigExternalGetParameter.
Basically you pass it the path to an ini file, the section, and the parameter name, and it returns the value. This will allow plugins to leverage the already existing ini parser built into mupen64plus-core.
GLideN64 will use this to read it's custom ini file with game specific settings.","I don't mind doing that but I'd like some guidance before I do, so I don't end up rewriting it.
I would add ConfigExternalOpen(file path, &myHandle) and ConfigExternalClose(myHandle). ConfigExternalGetParameter would stay the same (from the perspective of the plugin), except the plugin would pass myHandle instead of the filepath, does that seem reasonable?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,237,2017-02-09T16:00:12Z,2017-05-20T05:57:54Z,2017-06-02T16:43:53Z,MERGED,True,205,2,6,https://github.com/loganmc10,Add ConfigExternalGetParameter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/237,https://github.com/loganmc10,11,https://github.com/mupen64plus/mupen64plus-core/pull/237#issuecomment-288545277,"This adds a new API function: ConfigExternalGetParameter.
Basically you pass it the path to an ini file, the section, and the parameter name, and it returns the value. This will allow plugins to leverage the already existing ini parser built into mupen64plus-core.
GLideN64 will use this to read it's custom ini file with game specific settings.","Alright I swallowed my pride and created a ConfigExternalOpen() and ConfigExternalClose()
ConfigExternalOpen() reads the whole file and copies the contents into a buffer it allocates, which is pointed to by a m64p_handle, it returns the size of the buffer.
ConfigExternalGetParameter() takes that pointer and parses through the buffer to read the parameters.
ConfigExternalClose() free's the buffer created by ConfigExternalOpen()
This should perform a lot better since it only reads the file once. It's still not quite as high performance as the native config file, since it still parses through the whole buffer every time a parameter is read, but it's reading memory instead of disk, so it will be much faster.",True,{'THUMBS_UP': ['https://github.com/Papermanzero']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,237,2017-02-09T16:00:12Z,2017-05-20T05:57:54Z,2017-06-02T16:43:53Z,MERGED,True,205,2,6,https://github.com/loganmc10,Add ConfigExternalGetParameter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/237,https://github.com/rlabrecque,12,https://github.com/mupen64plus/mupen64plus-core/pull/237#issuecomment-288591704,"This adds a new API function: ConfigExternalGetParameter.
Basically you pass it the path to an ini file, the section, and the parameter name, and it returns the value. This will allow plugins to leverage the already existing ini parser built into mupen64plus-core.
GLideN64 will use this to read it's custom ini file with game specific settings.",It's easy enough to turn that into like a hash table lookup later on. That sounds like an improvement.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,237,2017-02-09T16:00:12Z,2017-05-20T05:57:54Z,2017-06-02T16:43:53Z,MERGED,True,205,2,6,https://github.com/loganmc10,Add ConfigExternalGetParameter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/237,https://github.com/Papermanzero,13,https://github.com/mupen64plus/mupen64plus-core/pull/237#issuecomment-291493838,"This adds a new API function: ConfigExternalGetParameter.
Basically you pass it the path to an ini file, the section, and the parameter name, and it returns the value. This will allow plugins to leverage the already existing ini parser built into mupen64plus-core.
GLideN64 will use this to read it's custom ini file with game specific settings.",any update? Can the PR be merged?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,237,2017-02-09T16:00:12Z,2017-05-20T05:57:54Z,2017-06-02T16:43:53Z,MERGED,True,205,2,6,https://github.com/loganmc10,Add ConfigExternalGetParameter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/237,https://github.com/Gillou68310,14,https://github.com/mupen64plus/mupen64plus-core/pull/237#issuecomment-291817029,"This adds a new API function: ConfigExternalGetParameter.
Basically you pass it the path to an ini file, the section, and the parameter name, and it returns the value. This will allow plugins to leverage the already existing ini parser built into mupen64plus-core.
GLideN64 will use this to read it's custom ini file with game specific settings.","I'm thinking about an alternative implementation for this, I'll try to propose something by the end of the week.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,237,2017-02-09T16:00:12Z,2017-05-20T05:57:54Z,2017-06-02T16:43:53Z,MERGED,True,205,2,6,https://github.com/loganmc10,Add ConfigExternalGetParameter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/237,https://github.com/loganmc10,15,https://github.com/mupen64plus/mupen64plus-core/pull/237#issuecomment-294289261,"This adds a new API function: ConfigExternalGetParameter.
Basically you pass it the path to an ini file, the section, and the parameter name, and it returns the value. This will allow plugins to leverage the already existing ini parser built into mupen64plus-core.
GLideN64 will use this to read it's custom ini file with game specific settings.",Any update on this?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,237,2017-02-09T16:00:12Z,2017-05-20T05:57:54Z,2017-06-02T16:43:53Z,MERGED,True,205,2,6,https://github.com/loganmc10,Add ConfigExternalGetParameter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/237,https://github.com/Papermanzero,16,https://github.com/mupen64plus/mupen64plus-core/pull/237#issuecomment-294426423,"This adds a new API function: ConfigExternalGetParameter.
Basically you pass it the path to an ini file, the section, and the parameter name, and it returns the value. This will allow plugins to leverage the already existing ini parser built into mupen64plus-core.
GLideN64 will use this to read it's custom ini file with game specific settings.",Just a proposal: Why not merging this PR and optimising the feature step by step in later points in time. At least the the feature is available and can be used. So experiences can be collected.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,237,2017-02-09T16:00:12Z,2017-05-20T05:57:54Z,2017-06-02T16:43:53Z,MERGED,True,205,2,6,https://github.com/loganmc10,Add ConfigExternalGetParameter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/237,https://github.com/loganmc10,17,https://github.com/mupen64plus/mupen64plus-core/pull/237#issuecomment-298753805,"This adds a new API function: ConfigExternalGetParameter.
Basically you pass it the path to an ini file, the section, and the parameter name, and it returns the value. This will allow plugins to leverage the already existing ini parser built into mupen64plus-core.
GLideN64 will use this to read it's custom ini file with game specific settings.","Just checking in again. If there is anything that needs changing, I don't mind changing it (if someone can think of a better way to handle this, just explain it to me, I don't mind doing the coding).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,237,2017-02-09T16:00:12Z,2017-05-20T05:57:54Z,2017-06-02T16:43:53Z,MERGED,True,205,2,6,https://github.com/loganmc10,Add ConfigExternalGetParameter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/237,https://github.com/Gillou68310,18,https://github.com/mupen64plus/mupen64plus-core/pull/237#issuecomment-299164403,"This adds a new API function: ConfigExternalGetParameter.
Basically you pass it the path to an ini file, the section, and the parameter name, and it returns the value. This will allow plugins to leverage the already existing ini parser built into mupen64plus-core.
GLideN64 will use this to read it's custom ini file with game specific settings.","Sorry I didn't find time to work on this these days. Anyway here's my remarks:


From what I understand this API will be used to parse a database not a config file, maybe the ""ConfigExternal"" name is not appropriate.


I don't like the idea of passing the file size to ""GetParameter"". One solution is to create a linked list containing all sections from the database and possibly a hash table to speed up section lookup.


The linked list could be created in the ""Open"" API, returning the address into the handle.


""GetParameter"" will look for the section name into the linked list and extract the parameter from the section. We can also add a type parameter (see ConfigGetParameter) for more flexibility?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,237,2017-02-09T16:00:12Z,2017-05-20T05:57:54Z,2017-06-02T16:43:53Z,MERGED,True,205,2,6,https://github.com/loganmc10,Add ConfigExternalGetParameter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/237,https://github.com/loganmc10,19,https://github.com/mupen64plus/mupen64plus-core/pull/237#issuecomment-299249986,"This adds a new API function: ConfigExternalGetParameter.
Basically you pass it the path to an ini file, the section, and the parameter name, and it returns the value. This will allow plugins to leverage the already existing ini parser built into mupen64plus-core.
GLideN64 will use this to read it's custom ini file with game specific settings.","Yeah I guess it's more aimed at parsing INI files, I don't really care what it's called to be honest, so I'm open to any name suggestion.


I agree the size thing was a bit clunky. I've modified the PR so that it allocates a struct now, with one item being a pointer to the file contents, and the other item being the size of the file, so it no longer needs the API to pass that info along.



We can also add a type parameter (see ConfigGetParameter) for more flexibility?

ConfigGetParameter works by passing the data long to ConfigGetParamInt/ConfigGetParamFloat/ConfigGetParamBool/ConfigGetParamString. So if we went this route, we would likely have to add 4 additional functions. It seemed like this would be simpler, the plugin knows what kind of data it is expecting, and it can convert the data from a string to whatever it wants.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,237,2017-02-09T16:00:12Z,2017-05-20T05:57:54Z,2017-06-02T16:43:53Z,MERGED,True,205,2,6,https://github.com/loganmc10,Add ConfigExternalGetParameter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/237,https://github.com/Gillou68310,20,https://github.com/mupen64plus/mupen64plus-core/pull/237#issuecomment-299418907,"This adds a new API function: ConfigExternalGetParameter.
Basically you pass it the path to an ini file, the section, and the parameter name, and it returns the value. This will allow plugins to leverage the already existing ini parser built into mupen64plus-core.
GLideN64 will use this to read it's custom ini file with game specific settings.","Nevermind ConfigExternal is just fine


I'm okay with this solution for now but I really think we should create a list when opening the file to avoid parsing the whole file every time GetParameter is called. Anyway this can be done later as it will have no impact on the current API definition.



ConfigGetParameter works by passing the data long to ConfigGetParamInt/ConfigGetParamFloat/ConfigGetParamBool/ConfigGetParamString. So if we went this route, we would likely have to add 4 additional functions. It seemed like this would be simpler, the plugin knows what kind of data it is expecting, and it can convert the data from a string to whatever it wants.

I agree but the 4 functions could be static to config.c so it will not add complexity to the API.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,237,2017-02-09T16:00:12Z,2017-05-20T05:57:54Z,2017-06-02T16:43:53Z,MERGED,True,205,2,6,https://github.com/loganmc10,Add ConfigExternalGetParameter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/237,https://github.com/loganmc10,21,https://github.com/mupen64plus/mupen64plus-core/pull/237#issuecomment-299541119,"This adds a new API function: ConfigExternalGetParameter.
Basically you pass it the path to an ini file, the section, and the parameter name, and it returns the value. This will allow plugins to leverage the already existing ini parser built into mupen64plus-core.
GLideN64 will use this to read it's custom ini file with game specific settings.",I guess I disagree here. I don't really see the point of making the plugin pass the type in as an argument (the function already has 5 arguments). It's pretty simple for the plugin to just take the string and do atoi or atof if they want to convert it.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,237,2017-02-09T16:00:12Z,2017-05-20T05:57:54Z,2017-06-02T16:43:53Z,MERGED,True,205,2,6,https://github.com/loganmc10,Add ConfigExternalGetParameter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/237,https://github.com/Gillou68310,22,https://github.com/mupen64plus/mupen64plus-core/pull/237#issuecomment-299544522,"This adds a new API function: ConfigExternalGetParameter.
Basically you pass it the path to an ini file, the section, and the parameter name, and it returns the value. This will allow plugins to leverage the already existing ini parser built into mupen64plus-core.
GLideN64 will use this to read it's custom ini file with game specific settings.",I just want to avoid changing the API later if someone thinks that the convertion should be done by the API ;-),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,237,2017-02-09T16:00:12Z,2017-05-20T05:57:54Z,2017-06-02T16:43:53Z,MERGED,True,205,2,6,https://github.com/loganmc10,Add ConfigExternalGetParameter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/237,https://github.com/loganmc10,23,https://github.com/mupen64plus/mupen64plus-core/pull/237#issuecomment-299776840,"This adds a new API function: ConfigExternalGetParameter.
Basically you pass it the path to an ini file, the section, and the parameter name, and it returns the value. This will allow plugins to leverage the already existing ini parser built into mupen64plus-core.
GLideN64 will use this to read it's custom ini file with game specific settings.","Well I agree that the API shouldn't be changed later, the function should stay the same after it gets merged. I guess I'll leave that one up to @richard42 , whatever he wants.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/Gillou68310,1,https://github.com/mupen64plus/mupen64plus-core/pull/238,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.","@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-279210354,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.",Cannot test ATM but looking good. You should add nasm to the .travis.yml so it is installed un the build env.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-279210410,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.",And update the readme for prerequisites,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/Gillou68310,4,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-279631271,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.","Done
Also I moved asm_defines.c to a new asm_defines folder, headers will be generared in that folder and the folder is included at compile time. This is usefull for android where headers are generated for all platforms before compilation even started. Is that ok for you?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/bsmiles32,5,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-279670036,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.",Okay for me. Good work !,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/Gillou68310,6,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-279707700,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.",I still need to check if the PIC version is working otherwise this is ready for merging.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/Gillou68310,7,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-279718461,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.","@fzurita I updated the mupen64plus-core.mk in order to support my latest changes:
https://github.com/mupen64plus-ae/mupen64plus-ae/tree/dyna_start
It builds fine on both ubuntu and windows with ndk-r13b.
Could you check if it's running fine on real devices?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/Gillou68310,8,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-279720107,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.","asm_defines headers are generated for each platforms before compilation, you can find them in
mupen64plus-core\src\asm_defines\armeabi-v7a
mupen64plus-core\src\asm_defines\x86
mupen64plus-core\src\asm_defines\x86\pic (mupen64plus-core-pic variant)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/Gillou68310,9,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-279747175,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.",I just checked the PIC version on ubuntu and everything seems to work fine :-),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/fzurita,10,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-279785998,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.","Sure, I'll try it once I get the chance. I've been pretty busy lately with the GLideN64 refactor.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/Gillou68310,11,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-279802125,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.","Lol yeah I noticed, I'm deleting almost 30 emails per day about GlideN64 refactor ;-)
There's no rush here anyway.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/Gillou68310,12,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-280285054,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.","@richard42 before you merge this, I'm currently adding PIC support for linkage_x86.asm.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/Gillou68310,13,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-280389729,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.","@fzurita I added PIC support for linkage_x86.asm so there's no need to build the mupen64plus-core-pic variant anymore. I updated the android build file consequently:
https://github.com/mupen64plus-ae/mupen64plus-ae/commits/dyna_start",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/fzurita,14,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-280391406,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.","That's awesome, hopefully that means that we can build with clang. I will try that next.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/Gillou68310,15,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-280429008,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.",I'm building with clang on osx without any issue.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/fzurita,16,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-281004184,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.","@Gillou68310 I'm finally getting around to building your branch here: https://github.com/mupen64plus-ae/mupen64plus-ae/commits/dyna_start
I'm not having much luck though:
A subdirectory or file jni\mupen64plus-core\src\asm_defines\armeabi-v7a already exists.
Assembler messages:
Fatal error: can't create C:/Users/Francisco/Documents/workspaces/mupen64plus-ae/app/src/main/jni/mupen64plus-core/src/asm_defines/armeabi-v7a/asm_defines.o: No such file or directory
The system cannot find the path specified.
C:/Users/Francisco/android-sdks/ndk-bundle/build//../prebuilt/windows-x86_64/bin/awk.exe: can't open file C:/Users/Francisco/Documents/workspaces/mupen64plus-ae/app/src/main/jni/mupen64plus-core/src/asm_defines/armeabi-v7a/asm_defines.dump
 source line number 3",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/Gillou68310,17,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-281005496,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.",Weird I don't have this issue. What's your ndk version? Also are you building on windows or linux?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/fzurita,18,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-281006029,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.","I'm building in Window, NDK version is latest. I think I found the problem though. In mupen64plus-core.mk, if I replace:
$(shell mkdir jni\mupen64plus-core\src\asm_defines\$(TARGET_ARCH_ABI))

with
$(shell mkdir src\main\jni\mupen64plus-core\src\asm_defines\$(TARGET_ARCH_ABI))

It seems to work ok. Not sure why the ""current directory"" is different between you and me.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/fzurita,19,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-281006291,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.","Probably just using this should work with everyone:
$(shell $(LOCAL_PATH)\mupen64plus-core\src\asm_defines\$(TARGET_ARCH_ABI))",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/Gillou68310,20,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-281006948,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.",I was building from command line within the app/src/main folder that's probably the difference. I didn't use the LOCAL_PATH variable because of the forward slash issue on windows.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/fzurita,21,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-281007323,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.",I used LOCAL_PATH just now from Android studio and it worked fine in Windows.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/Gillou68310,22,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-281007750,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.","Probably because the armeabi-v7a folder already exists, try to delete it and try again.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/fzurita,23,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-281008231,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.",Errr... you are correct,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/fzurita,24,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-281008403,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.","I think I'll just leave it like this:
$(shell mkdir src\main\jni\mupen64plus-core\src\asm_defines\$(TARGET_ARCH_ABI))",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/Gillou68310,25,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-281008899,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.",Or you can ask android studio to run the ndk-build command from within the app/src/main folder ;-),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/fzurita,26,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-281009161,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.","Hmm.... the non-PIC version runs a LOT faster on the nexus player (x86). Also, I made a few updates to your branch.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/fzurita,27,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-281010013,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.",I think I'm going to merge to master. It seems to work well enough.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/Gillou68310,28,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-281012686,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.",PIC code is expected to be slower on x86 unfortunately.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,238,2017-02-10T15:32:14Z,2017-02-18T05:48:54Z,2017-02-20T08:10:42Z,MERGED,True,707,571,15,https://github.com/Gillou68310,Dyna start,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/238,https://github.com/fzurita,29,https://github.com/mupen64plus/mupen64plus-core/pull/238#issuecomment-281012992,"@bsmiles32 I switched from objdump to nm and created an awk script to generate the asm defines, the script is shared between all platforms . I can confirm that it works on windows (both msvc and mingw), osx 10.12 (llvm8) and Ubuntu(gcc) for both 32bit and 64bit architectures.","Right, we were using the old PIC version. The new PIC version is a lot faster.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,239,2017-02-13T23:21:55Z,2017-02-15T06:02:15Z,2017-06-02T16:44:10Z,MERGED,True,2,2,1,https://github.com/loganmc10,Don't use SDL directly,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/239,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/239,"Sorry when I committed this change before I didn't realize I shouldn't be calling SDL directly, but should be going through the VidExt functions.","Sorry when I committed this change before I didn't realize I shouldn't be calling SDL directly, but should be going through the VidExt functions.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,240,2017-02-19T15:03:45Z,2017-03-17T05:38:05Z,2017-03-24T13:39:28Z,MERGED,True,2444,2263,50,https://github.com/bsmiles32,Avoid g_dev in r4300 code,47,[],https://github.com/mupen64plus/mupen64plus-core/pull/240,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/240,"Small PR which avoids usage of the g_dev global variable inside TLB code.
This a small step toward a ""g_dev free"" emulation code. By that, I mean, emulation code (code residing inside the device directory or any of its subdirectory) should hopefully one day not rely directly on the global variable g_dev. But instead access this structure through pointers. At least, that's what I'm trying to do in the long term.","Small PR which avoids usage of the g_dev global variable inside TLB code.
This a small step toward a ""g_dev free"" emulation code. By that, I mean, emulation code (code residing inside the device directory or any of its subdirectory) should hopefully one day not rely directly on the global variable g_dev. But instead access this structure through pointers. At least, that's what I'm trying to do in the long term.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,240,2017-02-19T15:03:45Z,2017-03-17T05:38:05Z,2017-03-24T13:39:28Z,MERGED,True,2444,2263,50,https://github.com/bsmiles32,Avoid g_dev in r4300 code,47,[],https://github.com/mupen64plus/mupen64plus-core/pull/240,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/240#issuecomment-283618920,"Small PR which avoids usage of the g_dev global variable inside TLB code.
This a small step toward a ""g_dev free"" emulation code. By that, I mean, emulation code (code residing inside the device directory or any of its subdirectory) should hopefully one day not rely directly on the global variable g_dev. But instead access this structure through pointers. At least, that's what I'm trying to do in the long term.",Added some more r4300 refactorings. With these additional changes r4300_core and cached_interp files relies much less on the g_dev global variable.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,240,2017-02-19T15:03:45Z,2017-03-17T05:38:05Z,2017-03-24T13:39:28Z,MERGED,True,2444,2263,50,https://github.com/bsmiles32,Avoid g_dev in r4300 code,47,[],https://github.com/mupen64plus/mupen64plus-core/pull/240,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/240#issuecomment-285408550,"Small PR which avoids usage of the g_dev global variable inside TLB code.
This a small step toward a ""g_dev free"" emulation code. By that, I mean, emulation code (code residing inside the device directory or any of its subdirectory) should hopefully one day not rely directly on the global variable g_dev. But instead access this structure through pointers. At least, that's what I'm trying to do in the long term.",Added some more refactorings to avoid direct usage of g_dev global variable.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,240,2017-02-19T15:03:45Z,2017-03-17T05:38:05Z,2017-03-24T13:39:28Z,MERGED,True,2444,2263,50,https://github.com/bsmiles32,Avoid g_dev in r4300 code,47,[],https://github.com/mupen64plus/mupen64plus-core/pull/240,https://github.com/bsmiles32,4,https://github.com/mupen64plus/mupen64plus-core/pull/240#issuecomment-285785413,"Small PR which avoids usage of the g_dev global variable inside TLB code.
This a small step toward a ""g_dev free"" emulation code. By that, I mean, emulation code (code residing inside the device directory or any of its subdirectory) should hopefully one day not rely directly on the global variable g_dev. But instead access this structure through pointers. At least, that's what I'm trying to do in the long term.","Okay, I've done most of the easy passing of structures inside the r4300 module. I'll very likely wait a bit more before making further changes, so if possible I'd like to get that merged soonish.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,240,2017-02-19T15:03:45Z,2017-03-17T05:38:05Z,2017-03-24T13:39:28Z,MERGED,True,2444,2263,50,https://github.com/bsmiles32,Avoid g_dev in r4300 code,47,[],https://github.com/mupen64plus/mupen64plus-core/pull/240,https://github.com/fzurita,5,https://github.com/mupen64plus/mupen64plus-core/pull/240#issuecomment-287594948,"Small PR which avoids usage of the g_dev global variable inside TLB code.
This a small step toward a ""g_dev free"" emulation code. By that, I mean, emulation code (code residing inside the device directory or any of its subdirectory) should hopefully one day not rely directly on the global variable g_dev. But instead access this structure through pointers. At least, that's what I'm trying to do in the long term.","@bsmiles32 something is wrong in the last set of commits. The core is crashing during shutdown. Here is the backtrace:
Build fingerprint: 'ZTE/P996A01_N/ailsa_ii:7.1.1/NMF26F/20170301.161705:user/release-keys'
pid: 12220, tid: 12404, name: CoreThread  >>> org.mupen64plusae.v3.alpha <<<
signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0xc3fc15f8
#00 pc 00038d9c ./libmupen64plus-core.so: Routine free_blocks at ../mupen64plus-core/src\device/r4300/cached_interp.c:607
#01 pc 0004589c ./libmupen64plus-core.so: Routine run_r4300 at ../mupen64plus-core/src\device/r4300/r4300_core.c:189
#02 pc 0000f5c4 ./libmupen64plus-core.so: Routine main_run at ../mupen64plus-core/src/main/main.c:1116
#03 pc 00004903 ./libmupen64plus-ui-console.so (SDL_main+3738): Routine SDL_main at ../mupen64plus-ui-console/src/main.c:798

The odd thing is the is crashing in the cached interpreter code, but I'm running in dynarec mode. I tried adding some logging to try to determine how it was getting there, and the back trace completely changed....",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,240,2017-02-19T15:03:45Z,2017-03-17T05:38:05Z,2017-03-24T13:39:28Z,MERGED,True,2444,2263,50,https://github.com/bsmiles32,Avoid g_dev in r4300 code,47,[],https://github.com/mupen64plus/mupen64plus-core/pull/240,https://github.com/fzurita,6,https://github.com/mupen64plus/mupen64plus-core/pull/240#issuecomment-287596166,"Small PR which avoids usage of the g_dev global variable inside TLB code.
This a small step toward a ""g_dev free"" emulation code. By that, I mean, emulation code (code residing inside the device directory or any of its subdirectory) should hopefully one day not rely directly on the global variable g_dev. But instead access this structure through pointers. At least, that's what I'm trying to do in the long term.","Why are we initializing and cleaning up cached interpreter blocks in the dynarec anyways? Although, I don't see how that could cause the crashing.
Edit: It doesn't crash if I take out the code to initialize and cleanup the cached interpreter code in r4300_core.c for the new dynarec. I think memory is getting corrupt somewhere.... Also, I see why we call it now, free_block in cached_interp.c is calling into some recompiler functions.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,240,2017-02-19T15:03:45Z,2017-03-17T05:38:05Z,2017-03-24T13:39:28Z,MERGED,True,2444,2263,50,https://github.com/bsmiles32,Avoid g_dev in r4300 code,47,[],https://github.com/mupen64plus/mupen64plus-core/pull/240,https://github.com/bsmiles32,7,https://github.com/mupen64plus/mupen64plus-core/pull/240#issuecomment-287915959,"Small PR which avoids usage of the g_dev global variable inside TLB code.
This a small step toward a ""g_dev free"" emulation code. By that, I mean, emulation code (code residing inside the device directory or any of its subdirectory) should hopefully one day not rely directly on the global variable g_dev. But instead access this structure through pointers. At least, that's what I'm trying to do in the long term.","Didn't experienced that. Can you bisect it ?
I'm unfortunately away for a couple of weeks...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,240,2017-02-19T15:03:45Z,2017-03-17T05:38:05Z,2017-03-24T13:39:28Z,MERGED,True,2444,2263,50,https://github.com/bsmiles32,Avoid g_dev in r4300 code,47,[],https://github.com/mupen64plus/mupen64plus-core/pull/240,https://github.com/Gillou68310,8,https://github.com/mupen64plus/mupen64plus-core/pull/240#issuecomment-288048008,"Small PR which avoids usage of the g_dev global variable inside TLB code.
This a small step toward a ""g_dev free"" emulation code. By that, I mean, emulation code (code residing inside the device directory or any of its subdirectory) should hopefully one day not rely directly on the global variable g_dev. But instead access this structure through pointers. At least, that's what I'm trying to do in the long term.","This is not happening on windows either. So this seems to be an ARM specific issue.
I see 3 possible causes:
-The r4300 pointer has been corrupted. Could you print the value of r4300 before and after new_dyna_start?
-The context has been corrupted. Could you print the content of dynarec_local (64 bytes) before and after new_dyna_start?
-A compiler issue? Could you print the result of an objdump -d on libmupen64plus.so.2.0.0?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,240,2017-02-19T15:03:45Z,2017-03-17T05:38:05Z,2017-03-24T13:39:28Z,MERGED,True,2444,2263,50,https://github.com/bsmiles32,Avoid g_dev in r4300 code,47,[],https://github.com/mupen64plus/mupen64plus-core/pull/240,https://github.com/loganmc10,9,https://github.com/mupen64plus/mupen64plus-core/pull/240#issuecomment-288059575,"Small PR which avoids usage of the g_dev global variable inside TLB code.
This a small step toward a ""g_dev free"" emulation code. By that, I mean, emulation code (code residing inside the device directory or any of its subdirectory) should hopefully one day not rely directly on the global variable g_dev. But instead access this structure through pointers. At least, that's what I'm trying to do in the long term.","I was testing things on my Raspberry Pi (ARM) the other day and I never ran into this, perhaps it's something clang is doing?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,240,2017-02-19T15:03:45Z,2017-03-17T05:38:05Z,2017-03-24T13:39:28Z,MERGED,True,2444,2263,50,https://github.com/bsmiles32,Avoid g_dev in r4300 code,47,[],https://github.com/mupen64plus/mupen64plus-core/pull/240,https://github.com/fzurita,10,https://github.com/mupen64plus/mupen64plus-core/pull/240#issuecomment-288060043,"Small PR which avoids usage of the g_dev global variable inside TLB code.
This a small step toward a ""g_dev free"" emulation code. By that, I mean, emulation code (code residing inside the device directory or any of its subdirectory) should hopefully one day not rely directly on the global variable g_dev. But instead access this structure through pointers. At least, that's what I'm trying to do in the long term.","It didn't happen before these set of commits, so it's probably something wrong in the code somewhere. Clang maybe more sensitive to memory corruption.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,240,2017-02-19T15:03:45Z,2017-03-17T05:38:05Z,2017-03-24T13:39:28Z,MERGED,True,2444,2263,50,https://github.com/bsmiles32,Avoid g_dev in r4300 code,47,[],https://github.com/mupen64plus/mupen64plus-core/pull/240,https://github.com/loganmc10,11,https://github.com/mupen64plus/mupen64plus-core/pull/240#issuecomment-288063117,"Small PR which avoids usage of the g_dev global variable inside TLB code.
This a small step toward a ""g_dev free"" emulation code. By that, I mean, emulation code (code residing inside the device directory or any of its subdirectory) should hopefully one day not rely directly on the global variable g_dev. But instead access this structure through pointers. At least, that's what I'm trying to do in the long term.",I'll try compiling with clang on my Pi today and see what I get,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,240,2017-02-19T15:03:45Z,2017-03-17T05:38:05Z,2017-03-24T13:39:28Z,MERGED,True,2444,2263,50,https://github.com/bsmiles32,Avoid g_dev in r4300 code,47,[],https://github.com/mupen64plus/mupen64plus-core/pull/240,https://github.com/Gillou68310,12,https://github.com/mupen64plus/mupen64plus-core/pull/240#issuecomment-288073168,"Small PR which avoids usage of the g_dev global variable inside TLB code.
This a small step toward a ""g_dev free"" emulation code. By that, I mean, emulation code (code residing inside the device directory or any of its subdirectory) should hopefully one day not rely directly on the global variable g_dev. But instead access this structure through pointers. At least, that's what I'm trying to do in the long term.","One thing you can test is to use the gdev struct instead of using the r4300 pointer passed in the function parameter, if this fixes the issue it's very likely to be a compiler issue. This can only be confirmed by looking at the disassembly.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,240,2017-02-19T15:03:45Z,2017-03-17T05:38:05Z,2017-03-24T13:39:28Z,MERGED,True,2444,2263,50,https://github.com/bsmiles32,Avoid g_dev in r4300 code,47,[],https://github.com/mupen64plus/mupen64plus-core/pull/240,https://github.com/loganmc10,13,https://github.com/mupen64plus/mupen64plus-core/pull/240#issuecomment-288106307,"Small PR which avoids usage of the g_dev global variable inside TLB code.
This a small step toward a ""g_dev free"" emulation code. By that, I mean, emulation code (code residing inside the device directory or any of its subdirectory) should hopefully one day not rely directly on the global variable g_dev. But instead access this structure through pointers. At least, that's what I'm trying to do in the long term.","I couldn't get this to compile with clang, I ran into this issue: #195. Android must pass some parameters to clang when it's used with ndk-build that gets around that problem or something.
Anyway I compiled with gcc and printed out the value of the r4300 pointer before and after new_dyna_start():
Core: Init new dynarec
Core: ARM CPU Features:, Half, Thumb, FastMult, VFP, ESDP, NEON, VFPv3, TLS, VFPv4, IDIVa, IDIVt
address before 0x715745b8
Core Status: Stopping emulation.
address after 0x724921dc
Core: R4300 emulator finished.
Core Status: Rom closed.
Here is the diff from r4300_core.c so you can make sure I did this right:
 #ifdef NEW_DYNAREC
         new_dynarec_init();
+printf(""address before %p\n"",r4300);
         new_dyna_start();
+printf(""address after %p\n"",r4300);
         new_dynarec_cleanup();
 #else
         dyna_start(dynarec_setup_code);",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,240,2017-02-19T15:03:45Z,2017-03-17T05:38:05Z,2017-03-24T13:39:28Z,MERGED,True,2444,2263,50,https://github.com/bsmiles32,Avoid g_dev in r4300 code,47,[],https://github.com/mupen64plus/mupen64plus-core/pull/240,https://github.com/Gillou68310,14,https://github.com/mupen64plus/mupen64plus-core/pull/240#issuecomment-288115163,"Small PR which avoids usage of the g_dev global variable inside TLB code.
This a small step toward a ""g_dev free"" emulation code. By that, I mean, emulation code (code residing inside the device directory or any of its subdirectory) should hopefully one day not rely directly on the global variable g_dev. But instead access this structure through pointers. At least, that's what I'm trying to do in the long term.","It doesn't looks good, could you do an objdump -d on libmupen64plus.so.2.0.0?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,240,2017-02-19T15:03:45Z,2017-03-17T05:38:05Z,2017-03-24T13:39:28Z,MERGED,True,2444,2263,50,https://github.com/bsmiles32,Avoid g_dev in r4300 code,47,[],https://github.com/mupen64plus/mupen64plus-core/pull/240,https://github.com/fzurita,15,https://github.com/mupen64plus/mupen64plus-core/pull/240#issuecomment-288117113,"Small PR which avoids usage of the g_dev global variable inside TLB code.
This a small step toward a ""g_dev free"" emulation code. By that, I mean, emulation code (code residing inside the device directory or any of its subdirectory) should hopefully one day not rely directly on the global variable g_dev. But instead access this structure through pointers. At least, that's what I'm trying to do in the long term.","By the way, the Android NDK make script is smart enough to use the proper arguments based on the file extension. So compilation is failing probably because of some missing arguments needed to compile assembly with clang.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,240,2017-02-19T15:03:45Z,2017-03-17T05:38:05Z,2017-03-24T13:39:28Z,MERGED,True,2444,2263,50,https://github.com/bsmiles32,Avoid g_dev in r4300 code,47,[],https://github.com/mupen64plus/mupen64plus-core/pull/240,https://github.com/Gillou68310,16,https://github.com/mupen64plus/mupen64plus-core/pull/240#issuecomment-288121650,"Small PR which avoids usage of the g_dev global variable inside TLB code.
This a small step toward a ""g_dev free"" emulation code. By that, I mean, emulation code (code residing inside the device directory or any of its subdirectory) should hopefully one day not rely directly on the global variable g_dev. But instead access this structure through pointers. At least, that's what I'm trying to do in the long term.",You may have to specify that linkage_arm.S in an assembly file -x assembler,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,240,2017-02-19T15:03:45Z,2017-03-17T05:38:05Z,2017-03-24T13:39:28Z,MERGED,True,2444,2263,50,https://github.com/bsmiles32,Avoid g_dev in r4300 code,47,[],https://github.com/mupen64plus/mupen64plus-core/pull/240,https://github.com/Gillou68310,17,https://github.com/mupen64plus/mupen64plus-core/pull/240#issuecomment-288122259,"Small PR which avoids usage of the g_dev global variable inside TLB code.
This a small step toward a ""g_dev free"" emulation code. By that, I mean, emulation code (code residing inside the device directory or any of its subdirectory) should hopefully one day not rely directly on the global variable g_dev. But instead access this structure through pointers. At least, that's what I'm trying to do in the long term.","Try changing the following in the unix makefile:
$(OBJDIR)/%.o: $(SRCDIR)/%.S $(SRCDIR)/asm_defines/asm_defines_gas.h
	$(COMPILE.c) -o $@ $<

$(OBJDIR)/%.o: $(SRCDIR)/%.S $(SRCDIR)/asm_defines/asm_defines_gas.h
	$(COMPILE.c) -x assembler -o $@ $<",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,240,2017-02-19T15:03:45Z,2017-03-17T05:38:05Z,2017-03-24T13:39:28Z,MERGED,True,2444,2263,50,https://github.com/bsmiles32,Avoid g_dev in r4300 code,47,[],https://github.com/mupen64plus/mupen64plus-core/pull/240,https://github.com/Gillou68310,18,https://github.com/mupen64plus/mupen64plus-core/pull/240#issuecomment-288126684,"Small PR which avoids usage of the g_dev global variable inside TLB code.
This a small step toward a ""g_dev free"" emulation code. By that, I mean, emulation code (code residing inside the device directory or any of its subdirectory) should hopefully one day not rely directly on the global variable g_dev. But instead access this structure through pointers. At least, that's what I'm trying to do in the long term.","You could also try to change linkage_arm.S to linkage_arm.s updating the makefile consequently.
You can check if the assembly file is parsed correctly directly by building from command line.
Something like clang -c linkage_arm.s or clang -x assembler -c linkage_arm.S",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,240,2017-02-19T15:03:45Z,2017-03-17T05:38:05Z,2017-03-24T13:39:28Z,MERGED,True,2444,2263,50,https://github.com/bsmiles32,Avoid g_dev in r4300 code,47,[],https://github.com/mupen64plus/mupen64plus-core/pull/240,https://github.com/loganmc10,19,https://github.com/mupen64plus/mupen64plus-core/pull/240#issuecomment-288152995,"Small PR which avoids usage of the g_dev global variable inside TLB code.
This a small step toward a ""g_dev free"" emulation code. By that, I mean, emulation code (code residing inside the device directory or any of its subdirectory) should hopefully one day not rely directly on the global variable g_dev. But instead access this structure through pointers. At least, that's what I'm trying to do in the long term.","It doesn't looks good, could you do an objdump -d on libmupen64plus.so.2.0.0?

objdump.txt",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,240,2017-02-19T15:03:45Z,2017-03-17T05:38:05Z,2017-03-24T13:39:28Z,MERGED,True,2444,2263,50,https://github.com/bsmiles32,Avoid g_dev in r4300 code,47,[],https://github.com/mupen64plus/mupen64plus-core/pull/240,https://github.com/Gillou68310,20,https://github.com/mupen64plus/mupen64plus-core/pull/240#issuecomment-288159597,"Small PR which avoids usage of the g_dev global variable inside TLB code.
This a small step toward a ""g_dev free"" emulation code. By that, I mean, emulation code (code residing inside the device directory or any of its subdirectory) should hopefully one day not rely directly on the global variable g_dev. But instead access this structure through pointers. At least, that's what I'm trying to do in the long term.",Woaaa the disassembly looks awfull it seems like function have been inlined. Could you try to build with -fno-inline?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,240,2017-02-19T15:03:45Z,2017-03-17T05:38:05Z,2017-03-24T13:39:28Z,MERGED,True,2444,2263,50,https://github.com/bsmiles32,Avoid g_dev in r4300 code,47,[],https://github.com/mupen64plus/mupen64plus-core/pull/240,https://github.com/loganmc10,21,https://github.com/mupen64plus/mupen64plus-core/pull/240#issuecomment-288164183,"Small PR which avoids usage of the g_dev global variable inside TLB code.
This a small step toward a ""g_dev free"" emulation code. By that, I mean, emulation code (code residing inside the device directory or any of its subdirectory) should hopefully one day not rely directly on the global variable g_dev. But instead access this structure through pointers. At least, that's what I'm trying to do in the long term.","Could you try to build with -fno-inline?

objdump3.txt",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,240,2017-02-19T15:03:45Z,2017-03-17T05:38:05Z,2017-03-24T13:39:28Z,MERGED,True,2444,2263,50,https://github.com/bsmiles32,Avoid g_dev in r4300 code,47,[],https://github.com/mupen64plus/mupen64plus-core/pull/240,https://github.com/Gillou68310,22,https://github.com/mupen64plus/mupen64plus-core/pull/240#issuecomment-288348397,"Small PR which avoids usage of the g_dev global variable inside TLB code.
This a small step toward a ""g_dev free"" emulation code. By that, I mean, emulation code (code residing inside the device directory or any of its subdirectory) should hopefully one day not rely directly on the global variable g_dev. But instead access this structure through pointers. At least, that's what I'm trying to do in the long term.","Thanks, I guess it's time to resurrect my rpi2 to look at this more in details.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,240,2017-02-19T15:03:45Z,2017-03-17T05:38:05Z,2017-03-24T13:39:28Z,MERGED,True,2444,2263,50,https://github.com/bsmiles32,Avoid g_dev in r4300 code,47,[],https://github.com/mupen64plus/mupen64plus-core/pull/240,https://github.com/Gillou68310,23,https://github.com/mupen64plus/mupen64plus-core/pull/240#issuecomment-288811212,"Small PR which avoids usage of the g_dev global variable inside TLB code.
This a small step toward a ""g_dev free"" emulation code. By that, I mean, emulation code (code residing inside the device directory or any of its subdirectory) should hopefully one day not rely directly on the global variable g_dev. But instead access this structure through pointers. At least, that's what I'm trying to do in the long term.","Ok I checked on my rpi2 and the saved context in dynarec_local is being overwritten during the new dynarec execution, I think I know where this is happening. The problem was invisible before because the corrupted register (r4) was not used within the run_r4300 function, but looking at the objdump r4 is now used to store the r4300 pointer, thus the crash ;-)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,240,2017-02-19T15:03:45Z,2017-03-17T05:38:05Z,2017-03-24T13:39:28Z,MERGED,True,2444,2263,50,https://github.com/bsmiles32,Avoid g_dev in r4300 code,47,[],https://github.com/mupen64plus/mupen64plus-core/pull/240,https://github.com/fzurita,24,https://github.com/mupen64plus/mupen64plus-core/pull/240#issuecomment-288815031,"Small PR which avoids usage of the g_dev global variable inside TLB code.
This a small step toward a ""g_dev free"" emulation code. By that, I mean, emulation code (code residing inside the device directory or any of its subdirectory) should hopefully one day not rely directly on the global variable g_dev. But instead access this structure through pointers. At least, that's what I'm trying to do in the long term.","Nice, it's good when a refactor reveals some bugs.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,240,2017-02-19T15:03:45Z,2017-03-17T05:38:05Z,2017-03-24T13:39:28Z,MERGED,True,2444,2263,50,https://github.com/bsmiles32,Avoid g_dev in r4300 code,47,[],https://github.com/mupen64plus/mupen64plus-core/pull/240,https://github.com/Gillou68310,25,https://github.com/mupen64plus/mupen64plus-core/pull/240#issuecomment-289024759,"Small PR which avoids usage of the g_dev global variable inside TLB code.
This a small step toward a ""g_dev free"" emulation code. By that, I mean, emulation code (code residing inside the device directory or any of its subdirectory) should hopefully one day not rely directly on the global variable g_dev. But instead access this structure through pointers. At least, that's what I'm trying to do in the long term.",I opened the PR #255,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,241,2017-02-20T12:45:13Z,2017-03-17T05:44:13Z,2017-03-21T02:54:26Z,MERGED,True,58,38,6,https://github.com/bsmiles32,Minor refac,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/241,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/241,Some minor refactorings to remove some magic constants and rework the si peripherals status command handling.,Some minor refactorings to remove some magic constants and rework the si peripherals status command handling.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,242,2017-02-22T02:06:51Z,2017-03-17T05:45:28Z,2017-03-17T05:45:28Z,MERGED,True,8,0,1,https://github.com/fzurita,Fix excessive warnings when compiling using clang.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/242,https://github.com/fzurita,1,https://github.com/mupen64plus/mupen64plus-core/pull/242,Just a couple of warning fixes. This generates a lot of output when building due to the amount those macros are used.,Just a couple of warning fixes. This generates a lot of output when building due to the amount those macros are used.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,242,2017-02-22T02:06:51Z,2017-03-17T05:45:28Z,2017-03-17T05:45:28Z,MERGED,True,8,0,1,https://github.com/fzurita,Fix excessive warnings when compiling using clang.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/242,https://github.com/Gillou68310,2,https://github.com/mupen64plus/mupen64plus-core/pull/242#issuecomment-281595786,Just a couple of warning fixes. This generates a lot of output when building due to the amount those macros are used.,"This is generating excessive warnings with MSVC:
warning C4550: expression evaluates to a function which is missing an argument list

Using the following fixes the warning:
#define assem_debug(...) nullf(__VA_ARGS__)
#define inv_debug(...) nullf(__VA_ARGS__)

Could you check with clang?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,242,2017-02-22T02:06:51Z,2017-03-17T05:45:28Z,2017-03-17T05:45:28Z,MERGED,True,8,0,1,https://github.com/fzurita,Fix excessive warnings when compiling using clang.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/242,https://github.com/fzurita,3,https://github.com/mupen64plus/mupen64plus-core/pull/242#issuecomment-282460458,Just a couple of warning fixes. This generates a lot of output when building due to the amount those macros are used.,"I just tried that.... Unfortunately, that generates excessive warnings in clang again.... Maybe a compiler specific macro is in order?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,242,2017-02-22T02:06:51Z,2017-03-17T05:45:28Z,2017-03-17T05:45:28Z,MERGED,True,8,0,1,https://github.com/fzurita,Fix excessive warnings when compiling using clang.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/242,https://github.com/fzurita,4,https://github.com/mupen64plus/mupen64plus-core/pull/242#issuecomment-282460734,Just a couple of warning fixes. This generates a lot of output when building due to the amount those macros are used.,"I updated the pull request so the compiler type is checked at compile time. If using clang, it will use a different macro.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,242,2017-02-22T02:06:51Z,2017-03-17T05:45:28Z,2017-03-17T05:45:28Z,MERGED,True,8,0,1,https://github.com/fzurita,Fix excessive warnings when compiling using clang.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/242,https://github.com/Gillou68310,5,https://github.com/mupen64plus/mupen64plus-core/pull/242#issuecomment-282466091,Just a couple of warning fixes. This generates a lot of output when building due to the amount those macros are used.,"What about: #define assem_debug(...)
This will avoid jumping to the nullf function every time assem_debug and inv_debug are called, saving some instructions at the same time and hopefully fix the warnings with clang.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,242,2017-02-22T02:06:51Z,2017-03-17T05:45:28Z,2017-03-17T05:45:28Z,MERGED,True,8,0,1,https://github.com/fzurita,Fix excessive warnings when compiling using clang.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/242,https://github.com/fzurita,6,https://github.com/mupen64plus/mupen64plus-core/pull/242#issuecomment-282466387,Just a couple of warning fixes. This generates a lot of output when building due to the amount those macros are used.,"There are no warnings if the nullf is removed, I'll update the pull request.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,242,2017-02-22T02:06:51Z,2017-03-17T05:45:28Z,2017-03-17T05:45:28Z,MERGED,True,8,0,1,https://github.com/fzurita,Fix excessive warnings when compiling using clang.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/242,https://github.com/Gillou68310,7,https://github.com/mupen64plus/mupen64plus-core/pull/242#issuecomment-282466718,Just a couple of warning fixes. This generates a lot of output when building due to the amount those macros are used.,Cool :-),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,243,2017-02-22T10:13:40Z,2017-03-17T05:46:03Z,2017-03-21T02:54:24Z,MERGED,True,29,29,1,https://github.com/bsmiles32,Fix compilation in msvc as per Gillou's comment.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/243,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/243,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,246,2017-02-27T15:05:57Z,2017-03-17T05:47:18Z,2017-06-02T16:44:05Z,MERGED,True,2,2,1,https://github.com/loganmc10,CountPerOp=3 for CBFD,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/246,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/246,CountPerScanline=2200 was taken from looking at the Project64 RDB file. After a bit of testing it seems that CountPerOp=3 gives the best performance without any timing issues.,CountPerScanline=2200 was taken from looking at the Project64 RDB file. After a bit of testing it seems that CountPerOp=3 gives the best performance without any timing issues.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,1,https://github.com/mupen64plus/mupen64plus-core/pull/250,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.",True,{'THUMBS_UP': ['https://github.com/krnlyng']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-290896503,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Any comment on this?
@krnlyng perhaps you can give this a try and see if it fixes your performance issues?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-291033358,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.",By the way @fzurita does a similar fix need to be applied to audio-sdl? Or does it look ok?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/wareya,4,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-291033513,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","The sdl audio plugin just uses audio backend synchronization, not a timer. Which is a problem because it stalls the emulator as a whole and causes microstuttering.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,5,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-291034865,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.",Yes to what wareya said. It's a different mechanism.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-291262116,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","@fzurita for mupen64plus-ae have you considered just disabling the core speed limiter if the audio plugin is in use, would the audio plugin be able to keep proper speed just by itself?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/wareya,7,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-291262928,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","You can do that but if you do you should make the audio plugin smarter about stalling for the backend to want more audio samples so it doesn't make bad stutter. As is, the framerate limiter can cause audio samples to drop if the framerate limiter's timer runs slightly slower than the audio backend, but it makes gameplay smoother despite that.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-291284036,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Looking through the mupen64plus-ae code, it seems that if ""audioSynchronize"" is enabled, then it uses the audio plugin frame limiter, and if that is disabled, then it uses the core frame limiter, but they won't ever get used at the same time, am I understanding that right @fzurita?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,9,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-291287866,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Yes, this is correct.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/richard42,10,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-292077195,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","yeah this is a fundamental problem.  The grand speed control mechanism needs to be redesigned to make this work properly.  I have a bunch of notes on what I want to do with this, but it will take a fair amount of work.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,11,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306368648,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.",Can this be merged? It should fix slow down when the host machine can't keep up with emulation. I think it would be good until a better fix comes around.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,12,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306372003,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.",I'll do some testing on this tomorrow to make sure there aren't any performance regressions. It would be nice if @krnlyng could verify whether this solves their problem or not.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,13,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306379287,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","I just tested this on my Linux laptop using Rogue Squadron (I ran it using the Pure Interpreter at a high resolution, so it runs about half speed for me).
I didn't notice any difference, good or bad. The FPS was the same in both scenarios for me. I'm using an audio plugin that doesn't have a speed limiter, so the core limiter is the only one in use.
I also tested by making the emulator run for 1000 new_vi() calls. I counted how many seconds total SDL_Delay ran for. With the current master, it waited a total of 2302 ms. With this change, it waited a total of 2386. If I let it run for 2000 VI's, the current master waited 3576 ms, this change was 3717 ms.
They both seem to have an issue when the emulator is speeding up. Like if it was running at 10 FPS, and it went to 20-30 FPS, that's when it would start waiting, in that transition from slower to faster (but not full) speed.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,14,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306379709,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Try setting the game speed to 300% and then compare FPS. 300% is just a speed that your computer can't meet, so set it to 1000% if you have to.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,15,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306381559,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","In that case the current master waited a total of 268 ms, and this changed waited 199 ms.
Once thing I'll also note, they both actually call SDL_Delay(0) sometimes. The current master actually calls that quite frequently (with this change it's very infrequent, but can still happen). I assume this isn't intended behavior, but sleepTime is a double cast to an int, so any value from 0.00000001 to 0.9999999 makes it past the sleepTime > 0.0 test and then SDL_Delay(0) gets called.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,16,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306499779,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","That's ok, it will just sleep less the next time around.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,17,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306501351,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Yeah but why are we calling SDL_Delay(0)? Shouldn't it just get changed to if sleepTime > 1.0, then SDL_Delay(1) would be the minimum sleep. The SDL docs don't even specify what SDL_Delay(0) does.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,18,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306508978,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","That's going to be up to the OS. I believe if you look at the implementation, it's either calling usleep or nanosleep under the hood. If you look up the behavior for those when being called with zero time, you will get your answer.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/wareya,19,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306509157,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.",It's undefined so the code shouldn't do it.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,20,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306510496,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","nanosleep with zero time is allowed by Linux last time I looked (is within the valid range), so it shouldn't be undefined. I'm not sure how long the sleep will be though. I suspect that is OS dependent.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/wareya,21,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306510825,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","If SDL doesn't define how it's supposed to behave in its spec, that means it's literally undefined. Undefined doesn't mean ""undefined behavior"". It's very bad to use behaviors that a library's spec doesn't define, no matter what a particular version is doing under the hood right now on a particular platform.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,22,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306512406,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","usleep and nanosleep are Unix functions. On Windows it probably uses Sleep() and this is what Sleep() does with 0:

A value of zero causes the thread to relinquish the remainder of its time slice to any other thread that is ready to run. If there are no other threads ready to run, the function returns immediately, and the thread continues execution.

It's not really what we want. I think 1 should be the minimum sleep.
As for the change in this PR, it seems fine to me, it does seem to reduce the amount of time slept. When I tested Rogue Squadron, the current speed limiter seemed to insert sleeps intermittently even when things were slow. With this change, it only seemed to insert sleeps when thing were running at 60FPS, or when the speed was increasing (like going from 10FPS to 30FPS)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,23,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306513162,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","@wareya it's not really undefined behavior. The docs say It waits at least the specified time, but possibly longer due to OS scheduling. So you can take that to mean ""It waits at least 0 seconds, maybe more"". But we know that under the hood it calls usleep or nanosleep or Sleep or some other function, and it seems that ""0"" is a special case in some of those functions.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,24,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306513365,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Yeah, that's a good point. SDL forums are saying that Sdl_delay of zero is equivalent to yield. Still, not what we want, but harm should be minimal. Still, I will update the pull request so they we only sleep if sleep is above zero.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/wareya,25,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306515500,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","The definition is ""Use this function to wait a specified number of milliseconds before returning."" The ""This function waits a specified number of milliseconds before returning. It waits at least the specified time, but possibly longer due to OS scheduling."" is in the remarks section. The remark is just saying that the definition doesn't wait an exact number of milliseconds, but it shouldn't be a lot shorter. The definition doesn't really define how time passes, just what the purpose of the function is.
SDL doesn't have very good documentation.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,26,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306645611,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.",Pull request updated to not sleep at all if sleep time is 0.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/krnlyng,27,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306886418,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","hi, sorry for the delay. i will test it as soon as possible :)
EDIT:
with speed limiter i mentioned in #236 the game still runs faster than with this implementation, i did tests with different plugins, gles2n64 drops significantly more frames in this implementation. i can make a video if necessary.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,28,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306905258,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","gles2n64 drops significantly more frames in this implementation

Are you talking about the current master? Or the changes that @fzurita has proposed? Or both?

speed limiter i mentioned in #236 the game still runs faster than with this implementation

I guess the question for now is, does this change from @fzurita improve things at all vs how it is currently? It seems unlikely that someone is going to re-write the speed limiter from scratch in the near future, so if this improves things then it should probably be merged.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/krnlyng,29,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306917333,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","""this implementation"" refers to the latest patch from @fzurita, this patch/implementation makes it worse than current master, so in short:
legacy speed limiter is faster than master and master is faster than this patch.
i think the problem is that the game is not doing any sudden bursts of speed anymore so if it reaches a situation where it is slow it will stay slow (and it doesn't seem to recover). does this make sense?
In any case i tested my theory and removed the entire: if(sleepTime < minSleepNeeded) { StartFPSTime -= minSleepNeeded; }
and the game runs (actually too) fast ;) probably because it is almost never sleeping anymore.
So in some sense the patch improves it by doing the reset only if -5000 is reached but it makes it worse on the other hand by removing the sudden bursts and keeping the game slow the entire time.
i hope we can fix this issue before it gets merged into master, in any case i will test more.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/krnlyng,30,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306932089,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","I have a proposal: https://bpaste.net/show/823cf9090a7e
This speed limiter averages out the sleepTime. This has the effect that we don't: ""wait nothing at all and in the next frame too much"" which was happening in my case. It also takes care of smoothing out the transitions between slow and fast. It is not optimized though but if somebody of you can test it too it i would prepare it.
Why has the speed limiter been changed? I am sure there were good reasons. I will compare my limiter to the one in #236 too.
My version works well on my phone and it works well on my desktop computer (bad case vs good case).
I am not saying that my version is ideal but it makes the games very much playable even on my slow device :). And i am open to suggestions.
EDIT: I am aware that my speed limiter doesn't behave correctly in the first 60 frames after starting or unpausing a game but i would take care of that if it turns out to work good for everyone.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/wareya,31,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306933611,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","AFAIK the old speed limiter ""leaked"" over time, the new one doesn't.",True,{'THUMBS_UP': ['https://github.com/krnlyng']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,32,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306938096,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.",@krnlyng maybe your clock is not reporting elapsed time accurately?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/wareya,33,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306938869,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Clocks are quantized. For example most of the ways of measuring time on windows are multiples of 5ms or 16ms.  Unless the program manages to get a high resolution clock, which isn't always possible, it's going to have a hard time avoiding stutter because of that.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/krnlyng,34,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306939258,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","@fzurita i am pretty sure it does, it is a linux distribution and ii've printed the values in every iteration during my testing and they seem to make sense (Obviously when doing performance tests i removed that code again) but i can do in-depth tests tomorrow. note that we can smooth out the transitions even more by increasing the sample count and we can remove the need for the memmove by using a small ring buffer.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,35,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306940701,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","To be honest, the implementation by @krnlyng (which is similar to the old speed limiter) makes a lot more sense to me. It makes more sense to take the moving average of the frames and using that to calculate the current speed, rather than taking the average based on a cumulative total starting from a (rather arbitrary) reset point.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/wareya,36,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306942561,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","If you do that, you ""leak"" fractions of seconds over time. Calculating the desired Point In Time when the next frame should start is the right way to write a framerate limiter. The thing is that you have to derive that point in time in a way that doesn't ""leak"" over time, and if your frametimes aren't measured in an integral unit (for example, if they're a repeating decimal in the computer's number system: 16.6666...ms), or you average them together somehow in your calculations, you're going to lose or gain fractions of milliseconds and eventually skew slightly away from your target framerate.
Using an ""arbitrary"" reset point (not arbitrary at all, really, just the last time the framerate limiter went from not being needed to being needed) and seeking forwards in time relative to it, you keep numerical precision errors from building up over time, since the error happens for the entire span of frames since then, instead of for each frame individually.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/krnlyng,37,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306947744,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.",the limiter i proposed only computes the moving average over the last 60 frames currently. the actual sleep time computation i have taken from fzuritas patch/master. the average over the last 60 frmes only avoids jumps between negative and positive sleep times in case the hardware is too slow. but we should always converge to the intended framerate.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,38,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306981545,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","@krnlyng Your idea has merit. The way you have it now, I don't think will drift over time. By averaging the sleep times, it will prevent large sleeps.
Although, if the game falls behind, I can see it taking longer to catch back up if the conditions allow it. I think that if you make the number of samples for the average into a smaller number, it should mitigate that. Can you try something like 5 samples and see if your issue is still fixed?
@loganmc10 I don't think it's like the old speed limiter, that one definitely had drift over time. It's like mine, but the sleep times are averaged out.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,39,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306991694,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","@krnlyng I tried your patch. It didn't work at all, there was no speed limit. Are you sure that you have vsync disabled on your computer? It's possible that that patch just unlimited the speed limit for you, and your computer kept it in line with vsync, which gave you better performance",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/krnlyng,40,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306998143,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","@loganmc10 hmm thats interesting. can you make sure the speed limiter is active by running mupen64plus with --verbose? because the message:
""Waiting %ims"" is printed for me in this case, is it for you? (i even changed the message slightly just now to make sure i am running the right binary).
i was using glide64mk2 and both the setting VerticalSync in Video-General and the vsync Setting in glide64mk2 are set to false.
are you sure that the speed limiter is enabled (l_MainSpeedLimit variable) and that l_SpeedFactor is 100?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,41,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-306998384,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","@krnlyng yes, the speed limiter was working, I tested the current master to be sure.
To be honest this all seems like over-thinking it to me. For an NTSC game, a VI should take 16.66666 ms. All you need to do is calculate how long it took you to process a frame, subtract that from 16.66666ms, and that is your sleep time. This is the implementation I came up with, it seems to work perfectly:
#define FRAME_NUM 5

static void apply_speed_limiter(void)
{
    const uint64_t SEC_TO_NSEC = 1000000000;
    static uint64_t oldNS = 0;
    static int frame_index, i = 0;
    static uint64_t averages[FRAME_NUM];
    struct timespec monotime;

    clock_gettime(CLOCK_MONOTONIC, &monotime);
    uint64_t currentNS = monotime.tv_sec * SEC_TO_NSEC + monotime.tv_nsec;

    averages[frame_index++] = currentNS - oldNS;
    if (frame_index == FRAME_NUM)
        frame_index = 0;
    uint64_t frame_average = 0;
    for (i = 0; i < FRAME_NUM; i++)
        frame_average += averages[i];
    frame_average /= FRAME_NUM;

    const uint64_t VINanoSec = (uint64_t)((1000.0 / g_dev.vi.expected_refresh_rate) * 1000000.0);
    if (VINanoSec > frame_average) {
        uint64_t diff = VINanoSec - frame_average;
        monotime.tv_sec = diff / SEC_TO_NSEC;
        monotime.tv_nsec = diff - (monotime.tv_sec * SEC_TO_NSEC);
        nanosleep(&monotime, NULL);
    }
    clock_gettime(CLOCK_MONOTONIC, &monotime);
    oldNS = monotime.tv_sec * SEC_TO_NSEC + monotime.tv_nsec;
}

This implementation averages out the frame time over 5 frames to smooth out any jittering, thoughts? (Right now it doesn't take into account l_MainSpeedLimit or l_SpeedFactor, it also uses nanosleep)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/krnlyng,42,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307000249,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.",@loganmc10 isnt that what @wareya was trying to prevent? because that way we add the error due to clock resolution in every frame don't we?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,43,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307000802,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","The current implementation uses SDL_GetTicks() every frame, wouldn't that lead to the same error? I'm not sure what the difference would be, at least in this implementation it is using nanoseconds for the clock time and sleep time, instead of milliseconds in the current implementation.
I'm not sure how it could ""leak over time"", since the average is only calculated over the last 5 frames, so the only ""time"" that matters is the last 5 frames, it wouldn't get worse as time goes on.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/wareya,44,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307083656,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","The absolute time of the current frame will drift from its intended value if you don't either use integer value math absolutely everywhere or calculate the desired time for the next frame based on an absolute reference point that doesn't change. In this case, ""averages"" is a set of frametimes, not timestamps, and you do non-integer math on it, so whatever you get out of it will drift due to numerical precision or rounding.
It's not enough to converge on the right instantaneous framerate, if you don't converge on the right actual framerate over a long period of time you can desynchronize from the audio plugin if it's not synchronizing stuff itself (and you really shouldn't have two framerate limiters, they're going to fight eachother).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,45,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307097577,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Ok, I updated my pull request. It uses @krnlyng concept to average the sleep times to reduce jitter. I'm using 5 samples currently. @krnlyng could you test the updated pull request to see how it works for you? If needed, can you increase the number of samples if it doesn't work with 5?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,46,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307116246,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Whoops, build error in gcc... it compiled fine in clang.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,47,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307137455,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","@fzurita I think you have a winner here. I tested Rogue Squadron for 2000 VI's on very high/slow settings. With the current master it sleeps 7072 ms on my PC. With this PR it sleeps 5566 ms, so that makes me happy.
As another note (maybe something for another PR, I don't want to make this too complicated). There are a lot of modern machines that are capable of sleeping and keeping time in the nanosecond range. I think on machines that support nanosleep it would be better to use that rather than SDL_Delay/SDL_GetTicks",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/krnlyng,48,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307139341,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","@wareya yes i totally agree but this does have one problem: if the hardware is too slow for the game, e.g. there is almost never time to sleep and additionally there are frames which need too much time then you most likely can never catch up to the correct time. maybe we need the limiter to be aware of both cases, as in the case where we can actually catch up, or don't need to, because the hardware is fast enough and the case where the hardware is too slow and we cannot catch up?
i have done a quick test of the new limiter and it seems to work better, but i will do direct comparisions once i am at home",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/wareya,49,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307141319,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","@krnlyng The easy way to deal with that is to give the simulation run a little behind the framerate limiter without resetting the ""initial"" frametime. That lets the simulation catch up after small hitches that only last for a single frame.
https://github.com/wareya/kotareci/blob/master/src/bengine.cpp#L114
You can also turn off the framerate limiter automatically if the general performance of the past <span of time> is worse than the target framerate, framerate limiter excluded, and turn it back on in the opposite case.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,50,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307142881,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","@wareya That was the intention of this pull request. This line does that : 4302384#diff-c27ac60319310f0e3b936bca81499818R818
It's the same intention.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,51,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307144134,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","You can also turn off the framerate limiter automatically if the general performance of the past  is worse than the target framerate, framerate limiter excluded, and turn it back on in the opposite case.

That will cause a burst of speed if you go from running at 20FPS to being able to run at 80FPS (but you should be running at 60FPS)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/wareya,52,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307144766,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","That was the intention of this pull request.

It already did that, just with a 50ms leeway instead of a 5 second leeway. I was responding to the way logan interpreted the new code. Smoothing out the sleep timer is a different thing that makes up for the low resolution of SDL's clock.
Edit: Shifting StartFPSTime forwards in time by minSleepNeeded when the desired frametime is more than minSleepNeeded in the past doesn't keep it from being reset, it just pretends the game sort of caught up to the game starting next frame.

That will cause a burst of speed if you go from running at 20FPS to being able to run at 80FPS (but you should be running at 60FPS)

It only causes a burst of speed if the logic that turns it back on is way too conservative.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/krnlyng,53,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307146560,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","@loganmc10 i am not aware of the full details but if you don't have a RTOS you will have a hard time sleeping accurately, there are a lot of posts around the web ""complaining"" that the sleep functions in many operating systems do have latency and random results, due to other processes running on the system with higher priority and so on",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,54,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307162584,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Edit: Shifting StartFPSTime forwards in time by minSleepNeeded when the desired frametime is more than minSleepNeeded in the past doesn't keep it from being reset, it just pretends the game sort of caught up to the game starting next frame.

It does prevent it from being reset, before, if sleepTime < minSleepNeeded that would cause a reset, now it doesn't",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/wareya,55,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307162852,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.",That's a different part of the code.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,56,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307166307,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Using my ""Rogue Squadron test"" the current master resets 282 times in 2000 VI's. With this PR, it never resets, so you're wrong about that.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/wareya,57,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307166755,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","I didn't say the PR didn't fix resets. The PR changes the reset threshold from 50 milliseconds overdue to 5000 milliseconds overdue. That would certainly make the framerate limiter reset less.
I said a specific other line doesn't fix resets. Rather, that's not what that specific line's behavior is.
Edit: Okay, let me reword this. The line that shifts StartFPSTime by minSleepNeeded just changes the starting point of the framerate limiter without saying that it reset it. It's the same thing as resetting it, except it's pretending it's not doing so, and it undershoots instead of hard resetting to the current time exactly.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,58,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307169067,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","commenting out
if(sleepTime < minSleepNeeded)
{
    StartFPSTime -= minSleepNeeded;
}

Makes it reset 4 times. Furthermore, leaving those lines in, and changing minSleepNeededForReset from -5000 to -100 makes it reset 79 times (instead of 282 in the current master), so those lines obviously make a difference in how many times it resets.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,59,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307169669,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","It's the same thing as resetting it, except it's pretending it's not doing so, and it undershoots instead of hard resetting to the current time exactly.

Obviously not, since I measured how many ms it sleeps for in both scenarios, and over 2000 VI's it's a difference of roughly 2000ms, so it's not just a wash.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/wareya,60,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307169985,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","those lines obviously make a difference in how many times it resets.

Line. Not lines. I was commenting on a single specific line. Yes, minSleepNeededForReset makes it reset way less. I never said anything contrary to that. That doesn't mean minSleepNeeded doesn't currently (in this PR) do what I said it does, which is reset the framerate limiter without recording a reset.
Communicate. Read the words I'm writing, not what you think I'm writing.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,61,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307170974,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Communicate. Read the words I'm writing, not what you think I'm writing.

You talk a lot, but you've never contributed any code to this project. You talk like you're an expert, but what would really be helpful is if you measured what you're talking about, or if you think you can do a better job of it, then write the code and we can test it out and see how it works. You're not being helpful.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/wareya,62,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307174775,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","You talk a lot, but you've never contributed any code to this project.

I don't need code upstream to understand how the emulator works. Let alone one of the most generic parts of it.
https://github.com/wareya/mupen64plus-core
https://github.com/wareya/mupen64plus-video-rice (never pushed my local branch)
https://github.com/wareya/GLideN64

You talk like you're an expert, but what would really be helpful is if you measured what you're talking about,

Do you understand how framerate limiters function? Do understand what the current framerate limiter's code is doing?
If you modify StartFPSTime, you just did the same thing as resetting the framerate limiter. Full stop. Period. If StartFPSTime changes, then the framerate limiter is no longer keeping the pace it was originally keeping. That's what a reset does.
If the framerate limiter thinks (pseudocode) (frame_timestamps[i+1]) should be at a different time than (frame_timestamps[i] + frametime), that means the framerate limiter got reset. And that's exactly what happens if you change StartFPSTime. You can't change StartFPSTime without changing the framerate limiter's idea of what the timestamp of each frame is supposed to be.
Count modifications of StartFPSTime as resets, you're going to see it resetting more.
Replacing sleepTime < -50 with sleepTime < -5000 alone (which this PR does) is going to make it reset a lot less just by virtue of taking longer to reset if it drifts out of sync. I never said that wouldn't make it reset less. I said something about shifting StartFPSTime.

You're not being helpful.

I'm trying to explain a confusing behavior of the PR's code. It's fine if it works in practice, but you have to know what you're measuring, and shifting StartFPSTime needs to count as a reset.
Before that I explained what would happen if you removed the ""arbitrary starting point"" (StartFPSTime) from the framerate limiter, or in other words, why the StartFPSTime thing was adopted earlier (#150 -- fzurita's first speed limiter PR). That's how I ended up in this conversation. I didn't jump in to bikeshed, don't treat me like that.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,63,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307176053,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Again, your words aren't helpful, post some code or measurements",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/wareya,64,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307176227,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Count modifications of StartFPSTime as resets, you're going to see it resetting more.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,65,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307177737,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","I'm not aware of a compiler that would accept that as code.
Anyway this has obviously gotten away from me, I'm going to ""recuse myself"" from this issue/PR, but my testing does show that it reduces the amount of sleep taken when the game isn't running at full speed, I think it should be merged.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,66,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307177919,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","@wareya just to clarify some of the behavior without getting too involved in this argument. A reset causes a sleep to happen. Shifting the start time doesn't cause any additional sleeps, so it's different in practice. I guess you could say, reset type A and reset type B. Also, it seem, like there is a lot of talking past each other in here....",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/krnlyng,67,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307208196,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","@fzurita
yes the speed limiter works better but there is still a noticeable amount of frames being dropped. commenting out:
if(sleepTime < minSleepNeeded) { StartFPSTime -= minSleepNeeded; }
avoids this problem, but thats not a solution :)
EDIT: there is no significant difference between 5 and 20 samples.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,68,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307219845,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Hmm, interesting. The piece of code you pointed out was the main piece of code intended to fix the problem. If you comment that code out I would expect more sleeps happening. What do you mean by frame drop? No frames should be dropped. Do you mean unintended sleeps?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/krnlyng,69,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307235665,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","@fzurita the version of gles2n64 i am using has auto frame skip built in.
anyways i did further testing and have made the following experiences:
in my case the speed limiter almost always wants to sleep less than 10 ms. this is bad because if we expect a granularity of ~10ms from the operating system (due to higher priority tasks, task switching and the os timer...) then the sleep would always wait ~(>=)10ms even though we only want it to sleep for example for 6ms. this might also be what causes the jitter, since i've tried the following:
https://bpaste.net/show/cdac45e433d6
if we have more than the granularity of the OS timer to sleep we sleep until just before we've reached the granularity, then we do a busy loop for the time thats left to sleep. (I know it's not ideal.) This way we don't give up some precious milliseconds that easily.
note that i've commented out the averaging again and did not notice drawbacks from it (no jitter, or at least not very noticeable).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,70,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307237423,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Busy loop is not very ideal. It's a killer on battery life for mobile devices. If we intend to sleep for 6ms but end up sleeping for 10ms, we will end up sleeping for 4ms less the following time around. Unfortunately, like you said, that is introducing jitter. A lot of this is going to depend on how the kernel for a device is configured, one would hope that a kernel would be configured to have granularity better than 1ms. Unfortunately, there are many linux devices out there all with different settings, which makes the problem hard.
Maybe as a middle ground solution, a setting could be added to the core to make it use a busy loop instead of sleep. This would leave it up to the front end or user to choose whether they want better performance or battery savings.
If you compare this updated pull request to the implementation prior to 0814daa how does it compare in your point of view?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,71,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307242185,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","commenting out if(sleepTime < minSleepNeeded) { StartFPSTime -= minSleepNeeded; } is an acceptable solution, it does actually seem to work well for me.
You can try this:
https://pastebin.com/gGqNDe0k
That is basically just adding in the averaging bit. Because of the averaging, after a reset, the new sleepTime is just 1 input of 5, so it doesn't necessarily trigger a sleep.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/krnlyng,72,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307242944,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","forget the busy loop, it was probably an unfair test which i did with the charger disconnected in one case which causes more aggressive power saving measures on my device. the current patch with the averaging does work very similar to the one with the busy loop and very similar to the old limiter from before 0814daa so i would be fine with your current patch.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,73,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307283852,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.",@loganmc10 so commenting out if(sleepTime < minSleepNeeded) { StartFPSTime -= minSleepNeeded; } in the pull request gives you the same result? If so I might as well take that part out.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,74,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307284391,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.",Let me compare the 2 just to be sure and I'll let you know,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,75,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307286232,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Yes, I tested this PR as it is now, and also this PR with if(sleepTime < minSleepNeeded) { StartFPSTime -= minSleepNeeded; } removed. I also removed minSleepNeededForReset and sleepMs < maxSleepNeeded*SpeedFactorMultiple. So basically the averaging is the only thing new.
Same Rogue Squadron test, one slept for 2311ms, one slept for 2358ms, close enough for me (I'm testing this on a different, slower computer than before, which is why it is sleeping less than my earlier tests). I will also say that it does a really good job of not sleeping when things are slow, or even when it's speeding up, it only sleeps when it is running 60 VI/s, very nice.
The diff is here if it's helpful:
diff --git a/src/main/main.c b/src/main/main.c
index 527b78f..81e827c 100644
--- a/src/main/main.c
+++ b/src/main/main.c
@@ -760,6 +760,7 @@ void new_frame(void)
     }
 }
 
+#define SAMPLE_COUNT 5
 static void apply_speed_limiter(void)
 {
     static unsigned long totalVIs = 0;
@@ -768,6 +769,8 @@ static void apply_speed_limiter(void)
     static unsigned int StartFPSTime = 0;
     static const double defaultSpeedFactor = 100.0;
     unsigned int CurrentFPSTime = SDL_GetTicks();
+    static double sleepTimes[SAMPLE_COUNT];
+    static unsigned int sleepTimesIndex = 0;
 
     // calculate frame duration based upon ROM setting (50/60hz) and mupen64plus speed adjustment
     const double VILimitMilliseconds = 1000.0 / g_dev.vi.expected_refresh_rate;
@@ -805,13 +808,30 @@ static void apply_speed_limiter(void)
     {
        resetOnce = 0;
     }
-    else if(sleepTime > 0.0 && l_MainSpeedLimit)
-    {
-       DebugMessage(M64MSG_VERBOSE, ""    apply_speed_limiter(): Waiting %ims"", (int) sleepTime);
 
-       SDL_Delay((int) sleepTime);
+    sleepTimes[sleepTimesIndex%SAMPLE_COUNT] = sleepTime;
+    sleepTimesIndex++;
+
+    int elementsForAverage = sleepTimesIndex > SAMPLE_COUNT ? SAMPLE_COUNT : sleepTimesIndex;
+
+    // compute the average sleepTime
+    double sum = 0;
+    unsigned int index;
+    for(index = 0; index < elementsForAverage; index++)
+    {
+        sum += sleepTimes[index];
     }
 
+    double averageSleep = sum/elementsForAverage;
+
+    int sleepMs = (int)averageSleep;
+
+    if(sleepMs > 0 && l_MainSpeedLimit)
+    {
+       DebugMessage(M64MSG_VERBOSE, ""    apply_speed_limiter(): Waiting %ims"", sleepMs);
+
+       SDL_Delay(sleepMs);
+    }
     timed_section_end(TIMED_SECTION_IDLE);
 }",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,76,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307288169,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Ok, I'll update my pull request so that it only does the averaging.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,77,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307289375,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.",@loganmc10 and @krnlyng Please give the pull request one more try to make sure everything is in order. I appreciate the help.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,78,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307294822,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","hm no there is still something wrong. I was testing how it operated when things were slow, I didn't test much how things were when it ran normally. It's running too fast, the audio is falling behind. It gets worse the larger SAMPLE_COUNT gets, and better the smaller I make that number.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,79,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307295044,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","So if you set sample_count to 1, does it go back to normal?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,80,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307296160,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","I believe the problem is that sleepTime can be negative, so you are actually adding negative values into the average. If the number is less than 0, you should add 0 to the average (to signify ""I didn't sleep at all that time""). I made this change, and it fixed the timing with the audio, but the bad news is that it also re-introduced the micro-stuttering into Rogue Squadron when things are slow.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,81,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307296342,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.",Looks like I need to re-add some of the logic I had before.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,82,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307296495,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","I'll do it tomorrow, it's getting late for me tonight. Feel free to experiment with adding it back.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,83,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307296568,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Yeah I was just gonna say, re-adding if(sleepTime < minSleepNeeded) { StartFPSTime -= minSleepNeeded; }  and -5000 for the reset time reduced (but didn't eliminate) the amount of time it spent sleeping when Rogue Squadron was slow, I'll take proper measurements tomorrow",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/krnlyng,84,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307302580,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","i think removing negative values from the sleep is also not the correct solution :/ because that way you increase the overall time it spends sleeping. if you add the negative sleeps to the average you balance it out, i think that is also why i am seeing the slowdowns in the first place, because if the sleep was negative in the original approach that was also not taken into account",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/krnlyng,85,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307388891,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","I've done some measurements:
Setup: Ocarina of Time with glide64mk2 running for 60s, 6 runs each, no buttons ever touched, charger connected in all cases, screen on
results:
fzuritas current version: 1996ms time spent sleeping on average
my busy wait: 2151ms time spent sleeping on average with 2130ms spent in the busy loop itself on average (almost everything so very bad for battery life)
limiter from before 0814daa: 1892ms time spent sleeping on average
and i think this has to be interpreted in the following way:
If we assume that the speed limiter works properly, e.g. is not waiting too much that means more sleep is actually better since the emulator can give up more time when it is running better.
NOTE: that i've accumulated the calculated sleep time, not the time it actually spent sleeping (for which would need clock_gettime but if it is interesting to somebody i can measure that too)
So in my opinion we can keep fzuritas current version and optionally keep an optional option for the busy loop method. But we can also forget about the busy loop since the effect on gameplay is not very noticeable.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,86,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307406612,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","@loganmc10 if we don't allow some negative sleep times, we will have drift over time. Negative sleep times are normal even when running full speed. You say that we are running too fast because audio lag is increasing over time because audio is not playing fast enough to keep up? How much of a difference are you seeing?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,87,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307407489,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.",It's fairly significant and causes the audio to crackle. I'll do some more testing today,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,88,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307408137,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Hmm, that sounds like the opposite. If you hear cracking, that means that audio buffers are not being kept full. This can only happen if the core is not running fast enough to keep up with the audio playback rate. So we are sleeping for too long.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,89,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307409546,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","No it is going too fast. The audio plugin I use fills a buffer with samples. It checks if the buffer is getting too big (audio is falling behind), if it is, then it skips filling the buffer to let it catch up:
https://github.com/m64p/mupen64plus-audio-sdl2/blob/master/src/main.c#L318-L322
That is what causes the crackling. So I know it is falling behind because I see AiLenChanged(): Skipping some audio playback to keep in sync. printed to the console quite frequently",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,90,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307410022,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Ok, gotcha, different source of crackling than what I thought.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,91,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307410653,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","I'm looking at the source code of your version of audio SDL, why is there no resampling?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,92,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307415380,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","It just plays it at the native sample rate of the game, trying to keep it simple, I'm not actually sure what the purpose of resampling is if the sound card can use the original sample rate",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,93,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307420766,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Ok, the old SDL didn't seem to make that assumption. Also in my experience with Android, even with Mario 64, I couldn't get the plugin to play at the audio frequency of the game. Maybe it's different with your PC.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,94,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307421702,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Yeah I've used it on Windows and Linux with no issue, but it's probably not the most portable thing. If someone ever complains I'll probably add the resampling back in, I might be the only person using it right now lol",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,95,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307422918,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Back to the topic, can you determine what percentage of samples you are dropping on your version of audio SDL? It would tell us how much faster than normal we are running.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,96,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307427793,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Another experiment, probably a better one than the previous I suggested. Could you change this SecondaryBufferSize * SDL_SAMPLE_BYTES * 2 to something like 10 instead of 2? And see if it recovers before hitting 10. I'm wondering if it has increased jitter when playing at normal speed compared to the old limiter.
Edit: Just from doing some play testing using my device, it seems that the averaging method is actually increasing jitter a lot when the game is running at normal speeds. It's very visible to me. It doesn't feel ""smooth"". Although, on average the game is running at the correct pace, just not smooth. I think that explains your results. Averaging is sounding like a bad idea.
I think I'm going to go back to what I originally had in this pull request and add an option to use a busy loop to decrease jitter.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,97,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307430733,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Sure I'll test both, first test:
Using the current master, 2000 calls to AiLenChanged, it never skips. All 2000 sample ""chunks"" played.
With this PR, it skipped 51 ""chunks"" and played 1949.
Changing * 2 to * 4 solves it completely, it doesn't miss any (I would have expected it to miss around 25 if it was permanently behind)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,98,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307431040,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","That confirms that this is increasing jitter when running at normal speeds, not good. See my above edit to what I think I'll do next.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,99,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307432112,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","If I try the regular audio SDL plugin, I don't hear any issues though. It sounds good, and it doesn't print out any messages about an overflow (https://github.com/mupen64plus/mupen64plus-audio-sdl/blob/master/src/main.c#L447) which I would expect if it's getting behind.
Maybe my audio plugin needs a greater tolerance. Maybe testing it on an Android device with time stretching disabled would be a good test?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,100,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307432490,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Yeah, I did do that. It sounds fine. But the additional jitter is very visible. It's ok if you are just sitting in place, but if you start moving around you can see it speed up and slow down irregularly.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,101,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307434281,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Maybe 5 is just too big of a sample size? If I change it to 3, then I get all 2000 audio sample chunks at * 2 tolerance, and it doesn't sleep during my Rogue Squadron tests when it's slow",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,102,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307434707,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.",I'll give 3 a shot,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,103,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307442781,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.",I see no issues with the value set to three. So that's probably good enough.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,104,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307536487,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Ok, pull request updated. Hopefully for the last time ;). @bsmiles32 Do you think this could be merged?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,105,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307545277,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","Just to confirm, using my ""Rogue Squadron test"" of 2000 VI's. The current master slept for 3768 ms, with the PR as it is right now, it slept for 2618 ms. So a big improvement. The audio also sounds good and it's keeping in sync. I think it's ready to be merged.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/krnlyng,106,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307569934,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","@fzurita not sure if this is a problem but i've printed the FPS count on my device, and it seems that if sample count is small, e.g. 3 the game will sometimes show more than 60 frames per second (compensating later). if it is increased to 5 again that doesn't happen as often, because it is averaged out.
I've only noticed it because i was dynamically adjusting the speed of the sound playback to the game speed :D and audio was sometimes too fast. (I did this to avoid stuttering audio/crackling but it doesn't sound too good if frame rates really drop :D)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/fzurita,107,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307570810,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.",It's expected for the current algorithm to sometimes go slightly too fast to catch up if it fell behind earlier. It does this because it's trying to keep the game time aligned to the real time.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,108,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307571306,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","My tests showed that it kept the audio pretty tightly aligned with the video, it wasn't dropping any of the audio samples with the way the PR is now",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/krnlyng,109,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-307576396,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.","@fzurita yes i was just thinking whether it really makes sense to go fast for one second, then slow for one second, then fast again... but probably thats fine at least visually it looks alright at ~60fps (with the occasional framerate jump up and down).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/loganmc10,110,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-309583700,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.",Just a reminder @bsmiles32 @richard42 that this has been tested fairly thoroughly and should be ok to be merged,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,250,2017-03-05T05:40:55Z,2017-06-23T02:30:35Z,2017-06-23T02:30:35Z,MERGED,True,25,3,1,https://github.com/fzurita,Don't reset the speed limiter when falling behind,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/250,https://github.com/bsmiles32,111,https://github.com/mupen64plus/mupen64plus-core/pull/250#issuecomment-310554439,"Don't reset the speed limiter when falling behind. Instead adjust the time. This prevents unwanted resets when the game is falling behind on slower devices. These resets cause unneeded sleeps on slower devices which make the game run even slower.
See:
#236
This code change was taking from https://github.com/mupen64plus-ae/mupen64plus-ae/blob/d5c5f321548fc4d7a1d72d19364671e3fcc207a5/app/src/main/jni/mupen64plus-audio-sles/main.cpp
A similar fix was made there by me.",Thank you guys for working on this. Merging this now.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,253,2017-03-10T06:04:14Z,2017-03-17T06:58:54Z,2017-03-17T07:13:37Z,MERGED,True,1,1,1,https://github.com/fzurita,Restore old behavior when allocating memory for RDRAM,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/253,https://github.com/fzurita,1,https://github.com/mupen64plus/mupen64plus-core/pull/253,"As seen in 
  
    
      mupen64plus-core/src/main/main.h
    
    
         Line 48
      in
      b67105b
    
  
  
    

        
          
           extern ALIGN(16, uint32_t g_rdram[RDRAM_MAX_SIZE/4]); 
        
    
  


Correct me if I'm wrong, but it seems like we always used to allocated the full RDRAM size even though the expansion pak was disabled. After the refactor we are allocating just enough.
This is causing a crash when loading and saving save states because we try to copy the full expansion pak size to and from the save state. This pull request fixes the crash.
This is the commit that broke it:
99d489d","As seen in 
  
    
      mupen64plus-core/src/main/main.h
    
    
         Line 48
      in
      b67105b
    
  
  
    

        
          
           extern ALIGN(16, uint32_t g_rdram[RDRAM_MAX_SIZE/4]); 
        
    
  


Correct me if I'm wrong, but it seems like we always used to allocated the full RDRAM size even though the expansion pak was disabled. After the refactor we are allocating just enough.
This is causing a crash when loading and saving save states because we try to copy the full expansion pak size to and from the save state. This pull request fixes the crash.
This is the commit that broke it:
99d489d",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,253,2017-03-10T06:04:14Z,2017-03-17T06:58:54Z,2017-03-17T07:13:37Z,MERGED,True,1,1,1,https://github.com/fzurita,Restore old behavior when allocating memory for RDRAM,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/253,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/253#issuecomment-285720142,"As seen in 
  
    
      mupen64plus-core/src/main/main.h
    
    
         Line 48
      in
      b67105b
    
  
  
    

        
          
           extern ALIGN(16, uint32_t g_rdram[RDRAM_MAX_SIZE/4]); 
        
    
  


Correct me if I'm wrong, but it seems like we always used to allocated the full RDRAM size even though the expansion pak was disabled. After the refactor we are allocating just enough.
This is causing a crash when loading and saving save states because we try to copy the full expansion pak size to and from the save state. This pull request fixes the crash.
This is the commit that broke it:
99d489d",How would you determine how big the expansion pak is in the save state when loading it? I guess we would need a new parameter stored in the file.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,253,2017-03-10T06:04:14Z,2017-03-17T06:58:54Z,2017-03-17T07:13:37Z,MERGED,True,1,1,1,https://github.com/fzurita,Restore old behavior when allocating memory for RDRAM,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/253,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/253#issuecomment-285746705,"As seen in 
  
    
      mupen64plus-core/src/main/main.h
    
    
         Line 48
      in
      b67105b
    
  
  
    

        
          
           extern ALIGN(16, uint32_t g_rdram[RDRAM_MAX_SIZE/4]); 
        
    
  


Correct me if I'm wrong, but it seems like we always used to allocated the full RDRAM size even though the expansion pak was disabled. After the refactor we are allocating just enough.
This is causing a crash when loading and saving save states because we try to copy the full expansion pak size to and from the save state. This pull request fixes the crash.
This is the commit that broke it:
99d489d","That's exactly the problem, the RDRAM size is not saved in the savestate, so it's not possible to know.
Adding that to the savestate would break backward compatibility, so I'd prefer to delay that change at a later time when we have enough reason to break backward compatibility. Overallocating 8M of RDRAM is a cheap fix and far easier than to change the savestate format.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,253,2017-03-10T06:04:14Z,2017-03-17T06:58:54Z,2017-03-17T07:13:37Z,MERGED,True,1,1,1,https://github.com/fzurita,Restore old behavior when allocating memory for RDRAM,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/253,https://github.com/fzurita,4,https://github.com/mupen64plus/mupen64plus-core/pull/253#issuecomment-287283594,"As seen in 
  
    
      mupen64plus-core/src/main/main.h
    
    
         Line 48
      in
      b67105b
    
  
  
    

        
          
           extern ALIGN(16, uint32_t g_rdram[RDRAM_MAX_SIZE/4]); 
        
    
  


Correct me if I'm wrong, but it seems like we always used to allocated the full RDRAM size even though the expansion pak was disabled. After the refactor we are allocating just enough.
This is causing a crash when loading and saving save states because we try to copy the full expansion pak size to and from the save state. This pull request fixes the crash.
This is the commit that broke it:
99d489d","I just thought about this, a simple fix for the save state format would be to not change the save state format at all. Instead, if the expansion pak is disabled, just load the first 4MB of RDRAM. That way the memory footprint can be reduced.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,255,2017-03-24T13:37:38Z,2017-03-26T11:05:19Z,2017-04-19T08:15:44Z,MERGED,True,63,39,2,https://github.com/Gillou68310,new_dynarec: Fix crash during shutdown,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/255,https://github.com/Gillou68310,1,https://github.com/mupen64plus/mupen64plus-core/pull/255,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,255,2017-03-24T13:37:38Z,2017-03-26T11:05:19Z,2017-04-19T08:15:44Z,MERGED,True,63,39,2,https://github.com/Gillou68310,new_dynarec: Fix crash during shutdown,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/255,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/255#issuecomment-289047775,,"I don't really understand assembly at all, but is that stack_space actually used anywhere?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,255,2017-03-24T13:37:38Z,2017-03-26T11:05:19Z,2017-04-19T08:15:44Z,MERGED,True,63,39,2,https://github.com/Gillou68310,new_dynarec: Fix crash during shutdown,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/255,https://github.com/Gillou68310,3,https://github.com/mupen64plus/mupen64plus-core/pull/255#issuecomment-289064599,,"Yep, this space is used by the recompiled code for pushing/popping caller saved registers before/after C function call.
// Save registers before function call
static void save_regs(u_int reglist)
{
  reglist&=0x100f; // only save the caller-save registers, r0-r3, r12
  if(!reglist) return;
  assem_debug(""stmia fp,{"");
  if(reglist&1) assem_debug(""r0, "");
  if(reglist&2) assem_debug(""r1, "");
  if(reglist&4) assem_debug(""r2, "");
  if(reglist&8) assem_debug(""r3, "");
  if(reglist&0x1000) assem_debug(""r12"");
  assem_debug(""}"");
  output_w32(0xe88b0000|reglist);
}
// Restore registers after function call
static void restore_regs(u_int reglist)
{
  reglist&=0x100f; // only restore the caller-save registers, r0-r3, r12
  if(!reglist) return;
  assem_debug(""ldmia fp,{"");
  if(reglist&1) assem_debug(""r0, "");
  if(reglist&2) assem_debug(""r1, "");
  if(reglist&4) assem_debug(""r2, "");
  if(reglist&8) assem_debug(""r3, "");
  if(reglist&0x1000) assem_debug(""r12"");
  assem_debug(""}"");
  output_w32(0xe89b0000|reglist);
}

For example if the recompiler needs to save r0 before a function call the following code will be generated:
stmia fp, {r0}
This will store r0 at the address in fp or fp points to the address of dynarec_local (which is the same address as stack_space).
I added the stack_space label to help understanding, I guess it didn't help that much :-)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,255,2017-03-24T13:37:38Z,2017-03-26T11:05:19Z,2017-04-19T08:15:44Z,MERGED,True,63,39,2,https://github.com/Gillou68310,new_dynarec: Fix crash during shutdown,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/255,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/255#issuecomment-289253217,,"This appears to have fixed the problem:
Core: Starting R4300 emulator: Dynamic Recompiler
Core: Init new dynarec
Core: ARM CPU Features:, Half, Thumb, FastMult, VFP, ESDP, NEON, VFPv3, TLS, VFPv4, IDIVa, IDIVt
address before 0x715ba5b8
^CCore Status: Stopping emulation.
address after 0x715ba5b8
Core: R4300 emulator finished.
Core Status: Rom closed.

I would merge this ASAP since it represents a fairly serious bug in ARM, especially on Android it seems",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,255,2017-03-24T13:37:38Z,2017-03-26T11:05:19Z,2017-04-19T08:15:44Z,MERGED,True,63,39,2,https://github.com/Gillou68310,new_dynarec: Fix crash during shutdown,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/255,https://github.com/bsmiles32,5,https://github.com/mupen64plus/mupen64plus-core/pull/255#issuecomment-289273241,,Merged as per @loganmc10 request.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,256,2017-04-01T10:17:28Z,2017-04-06T06:12:27Z,2017-05-03T13:46:48Z,MERGED,True,13736,14579,41,https://github.com/bsmiles32,Mips instructions refactorings,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/256,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/256,"This is just some internal reoganization of mips instructions functions.
I merged the various def files together, reordered the functions to make similarities stand out, and do proper formatting.
I did the same for the hacktarux dynarec.
Hopefully this should help further refactorings :)","This is just some internal reoganization of mips instructions functions.
I merged the various def files together, reordered the functions to make similarities stand out, and do proper formatting.
I did the same for the hacktarux dynarec.
Hopefully this should help further refactorings :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/257,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",True,{'THUMBS_UP': ['https://github.com/Papermanzero']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-292623435,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","Cool, I'm sure this will be a very big hint.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-292624572,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","For the uninformed (this is based on my understand of what I read and could be wrong):
WDC and similar games get stuck in doRspCycles, enabling ""SupportCPUSemaphoreLock"" allows it to exit the loop with SP_STATUS_HALT set to 0, instead of the usual 1. This is a hint that it has exited this problematic loop.
I'm not sure what triggers it to set SP_STATUS_HALT to 1 eventually. Right now, it just keeps setting SP_STATUS_HALT to 0 after the loop, that is why I have ""repeat_count"", I just let it do that 100 times, then I force it to quit basically.
I assume that there is a more proper way to deal with that, since 100 was just a random number I chose.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-292633683,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","Also for reference, I based this work mostly off of these comments:
https://code.google.com/archive/p/mupen64plus/issues/614",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-292654717,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","I believe exiting the loop properly (without relying on a counter) involves checking sp->r4300->mi.regs[MI_INTR_REG], like if it's 0 you need to keep repeating, if it's set to something you can stop repeating, something like that.
But I haven't figured out yet how to properly deal with that variable.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-292784661,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","I've updated the PR with a version that doesn't require an arbitrary counter. The results still look just as bad, but now it doesn't just randomly count to 100, it exits naturally.",True,{'HOORAY': ['https://github.com/Papermanzero']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/Gillou68310,7,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296377387,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","I took a quick look at this and it seems that the RSP is locked in an endless loop waiting for a signal from the CPU (SP_STATUS_SIGNAL0 / SP_STATUS_YIELD). Here's the offending code:
04001138: mfc0   r2, SP_STATUS
0400113C: andi   r2, r2, $0080
04001140: bne    r2, 0, $04001124
04001144: nop
04001148: j      $04001138
0400114C: nop

@cxd4 uses the following hack to break the endless loop and give back control to the CPU.
#ifdef WAIT_FOR_CPU_HOST
    if (rd == 0x4)
    {
        ++MFC0_count[rt];
        GET_RCP_REG(SP_STATUS_REG) |= (MFC0_count[rt] >= MF_SP_STATUS_TIMEOUT);
        CPU_running = ~GET_RCP_REG(SP_STATUS_REG) & 1;
    }
#endif

The ""SupportCPUSemaphoreLock"" option should not be necessary for this game.
From what I understand the core should detect that the RSP task ended with the SP_STATUS_HALT/BROKE flags equal 0 and schedule a new RSP interrupt allowing the CPU to continue execution until the new interrupt is triggered.
Here's my implementation, thanks @loganmc10 for the hint ;-)
Gillou68310@b75be1f
I tested WDC and Gauntlet Legend, both game seem to work fine.",True,{'HOORAY': ['https://github.com/loganmc10']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296389015,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","Awesome, I'll test it out tomorrow, I thought that SupportCPUSemaphoreLock was required for the RSP to exit with halt/broke set to 0, but I guess it isn't required",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/Gillou68310,9,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296389350,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",Gauntlet legend has issue with gliden64 but works fine with angrylion.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/fzurita,10,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296389918,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",What about Indiana Jones?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/Gillou68310,11,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296390753,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",The flickering textures are still present if that was the question ;-),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/Gillou68310,12,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296393778,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",Stunt Racer 64 works too but has a lot of stuttering,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/fzurita,13,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296396740,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","Last time I tried Indiana Jones didn't boot. Good that it is I guess with that.
What are the chances of getting this incorporated? It doesn't look like to bad of a hack, at least no worse than Mupen64plus' current inaccuracies.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/fzurita,14,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296398673,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","@Gillou68310  I did a few tests with your change.

Indiana Jones still didn't boot for me.
WDC does boot, but the core is crashing somewhere.
GLideN64 LLE mode does seem to boot Gauntlet Legends, HLE mode still doesn't work.
Stunt racer, boots in LLE mode, but the core quickly crashes.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/loganmc10,15,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296417242,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","Both WDC and Stunt Racer worked for me, no crashing. They are both very choppy though, and the CPU is only at around 25-30%, so unless the GPU is really maxed out (I'll try an Nvidia GPU tomorrow), there seems to be something wrong with it still.
I couldn't get Indiana Jones to boot, perhaps it is a different problem, maybe the same as All Star Baseball 2000/2001? They still don't work either.

GLideN64 LLE mode does seem to boot Gauntlet Legends, HLE mode still doesn't work.

When you say ""HLE mode"", do you mean using rsp-hle? Or using cxd4 with HLE video? This ""hack"" will only work with rsp-cxd4, and I'm not sure if it would work with cxd4 + HLE video",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/fzurita,16,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296417290,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","By HLE mode I mean CXD4 with HLE video.
Edit: Here is the back trace on WDC:
********** Crash dump: **********
Build fingerprint: 'ZTE/P996A01_N/ailsa_ii:7.1.1/NMF26F/20170301.161705:user/release-keys'
pid: 9956, tid: 10261, name: CoreThread  >>> org.mupen64plusae.v3.alpha <<<
signal 4 (SIGILL), code 1 (ILL_ILLOPC), fault addr 0xc8fd492c
Stack frame 04-22 23:39:15.471 10275-10275/? A/DEBUG:     #00 pc 0033592c  <anonymous:c8c9f000>: Unable to open symbol file .\mupen64plus-ae\app\build\intermediates\ndkBuild\release\obj\local\armeabi-v7a/<anonymous:c8c9f000>. Error (22): Invalid argument
Stack frame 04-22 23:39:15.471 10275-10275/? A/DEBUG:     #01 pc ffffffff  <unknown>
PS C:\workspaces>

The only things that stand out on it are
signal 4 (SIGILL), code 1 (ILL_ILLOPC) It seems to be crashing in some assembly code somewhere.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/loganmc10,17,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296419190,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",Maybe it's something in the arm dynarec? I tested it on x86-64,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/Gillou68310,18,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296421876,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","Yes the new dynarec is broken with those games on x86 too, I need to investigate.
This hack only apply to cxd4 in LLE mode.
No problem booting Indiana Jones by my side, also it doesn't require this hack.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/Gillou68310,19,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296426132,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","hey are both very choppy though, and the CPU is only at around 25-30%, so unless the GPU is really maxed out (I'll try an Nvidia GPU tomorrow), there seems to be something wrong with it still.

I just realized that WDC is stuttering too on my home computer. I didn't have such issue on my office laptop.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/fzurita,20,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296438500,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",@Gillou68310 what version of Indiana Jones are you using?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/Gillou68310,21,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296443050,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",US version,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/fzurita,22,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296445101,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",Maybe I don't have a good dump of Indiana​ Jones. What is your md5 @Gillou68310 ? Mine is 70DE1EAB508596B6BBEFD168B5D07194,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/Gillou68310,23,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296446510,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","Same md5 here, what's your plugin config?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/fzurita,24,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296446565,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",I'm using CXD4-LLE with Angrylion on Android.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/Gillou68310,25,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296446635,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",New dynarec?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/fzurita,26,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296446645,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",Yes,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/Gillou68310,27,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296446687,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",Try interpreter,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/fzurita,28,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296446704,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","I just did, it's no better.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/fzurita,29,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296446786,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",Any special CXD4 config?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/Gillou68310,30,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296446789,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",Weird,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/Gillou68310,31,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296446831,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",Nope,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/Gillou68310,32,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296446968,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",Well now that you ask it's possible that I was using rsp-z64 when I tested the game.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/Gillou68310,33,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296447048,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",I don't have access to my computer right now so I cannot tell for sure,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/fzurita,34,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296447056,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","Hmm, maybe it's worthwhile to get that ported to Android.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/Gillou68310,35,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296447146,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",rsp-cxd4 is faster,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/Gillou68310,36,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296447254,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",I'll check when I get home if indi is working with cxd4 and let you now,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/fzurita,37,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296447266,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",ok,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/Gillou68310,38,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296447658,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","Hum I remember checking if the semaphore lock option in cxd4 could help with the flickering textures, so I'm pretty sure it was working with it.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/fzurita,39,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296447725,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","Strange, I just tried toggling all the options in CXD4. I couldn't get it to work.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/Gillou68310,40,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296447870,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",Which version of the cxd4 plugin are you using in m64p-ae? Upstream one?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/fzurita,41,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296447939,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","m64p-ae, which should be identical to https://github.com/mupen64plus/mupen64plus-rsp-cxd4",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/Gillou68310,42,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296448060,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",Could you try without the neon optimization?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/fzurita,43,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296448324,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","I just did, no luck.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/Gillou68310,44,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296448328,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",Do you have an x86 android device?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/fzurita,45,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296448405,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","Yeah, I do, I'll give it a shot.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/Gillou68310,46,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296448533,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",Don't use new dynarec I'm pretty sure it's broken with indi.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/fzurita,47,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296448850,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","Yeah, I have been using the cached interpreter.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/fzurita,48,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296449301,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",I tried in the Nexus Player (x86) and it's not booting either. Something must be different. Can you post your mupen64plus.cfg?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/loganmc10,49,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296449391,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","I was using the dynarec during my test, I'll test the interpreter and cxd4 tonight",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/Gillou68310,50,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296452218,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","I'll share my config file tomorrow, one last test you can do in the meantime is to use gliden64 instead of angrylion.
@loganmc10 old dynarec should work fine only new dynarec is broken",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/loganmc10,51,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296482370,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","Here is the fix for Indiana Jones:
#263",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/fzurita,52,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296496282,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","@loganmc10 Thanks for that. That worked. Interestingly, the new dynarec seemed to boot the game just fine.
Edit: Never mind, new dynarec crashes in game. Also GLideN64 in LLE mode gets really good performance in the intro.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/loganmc10,53,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296676863,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","So I just tried WDC on my laptop with an Nvidia GPU and I still get the same stuttering, GLideN64 reports 60 VI/S though, so it seems to think it's running at full speed, therefore I assume it's not the case of the computer not being able to keep up, there must be something wrong.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/Gillou68310,54,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296688126,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",I just checked stunt racer on my office laptop and no stuttering at all!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/Gillou68310,55,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296688357,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",What is happening? CPU low power mode?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/loganmc10,56,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296692403,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",I don't know I'll have to look into it more. I tested Project64 using the same laptop and I don't experience the stuttering there. I used GLideN64 (and HatCat's/cxd4 RSP) for both emulators.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/fzurita,57,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296722941,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",Could it be CountPerOp or CountPerScanline again?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/loganmc10,58,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296728730,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","I tried different values for those settings, no difference.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/loganmc10,59,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296729978,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",So another hint: disabling the audio plugin fixes the stuttering for me. @Gillou68310 are you using audio-sdl? Do you have any special settings for the audio plugin?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/loganmc10,60,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296731249,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","I notice that for an audio RSP event it does:
add_interrupt_event(&sp->r4300->cp0, SP_INT, 4000/*500*/);

And for GFX it does:
add_interrupt_event(&sp->r4300->cp0, SP_INT, 1000);

In Project64, if the RSP task has to repeat, it always uses 0x200 as the timer value. Perhaps it is waiting too long to repeat the RSP task? Again, I don't really know how the interrupt system works, so it's just a wild guess.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/Gillou68310,61,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296743113,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",Nice catch I forgot that I was using the dummy audio plugin at work! Sorry about that. I'll see what I can do about the stuttering issue tomorrow.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/loganmc10,62,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296753894,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",It seems like there may be something wrong with the speed limiter in Audio-SDL. Just commenting out SDL_Delay(WaitTime); seems to fix the stuttering for me.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/wareya,63,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296759147,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","The problem is the length of the period of time the audio plugin waits for SDL to need more samples. It's basically a second framerate limiter, but it limits to a low framerate, and it's out of sync with the main framerate limiter, so you have a 20-audio-chunks-per-second (or whatever) thing on top of a 60fps thing. If the PC can run the game too fast, it'll mess with that.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/loganmc10,64,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296761959,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","The problem is the length of the period of time the audio plugin waits for SDL to need more samples. It's basically a second framerate limiter, but it limits to a low framerate.

Well in this case I assume it is miscalculating where it ""should be"". I have the core speed limiter disabled, so the only speed limiter in use is Audio-SDL's. If I use the dummy audio plugin and the core's speed limiter, then it works properly.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/wareya,65,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296763042,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",What are the SDL audio backend's current settings?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/loganmc10,66,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-296792294,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",Everything is the default.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/loganmc10,67,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-297138529,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","For what it's worth, enabling ""Sync to audio"" in Project64 breaks the timing in WDC, and it works in other games. Perhaps Audio-SDL should have an option to disable the speed limiter?
Is the core's speed limiter not enough to keep the audio in sync? It seems like in Project64, audio sync is disabled by default, and it can be enabled if desired, perhaps it should be the same for Audio-SDL?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/loganmc10,68,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-297143935,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","Besides all these issues, it seems that the changes to the core are working perfectly. I think it's worth submitting a PR for that, since it can be a lengthy process... Plus @Gillou68310 you have a habit of doing awesome work and then never sending a PR :P (I'm looking at you DK bone displacement and RE2 background microcode)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/loganmc10,69,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-297169958,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","Ok I updated this PR with @Gillou68310 implementation, except that I moved rsp_task_locked into the rsp_core struct.
I believe this should be ok to be merged, there are still issues to sort out with the audio speed limiter/synchronization for these games though.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/bsmiles32,70,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-297184093,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.",Thanks for updating ! Looks good to me. Do you want me to merge this or wait for @richard42 to take a look at it ?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/loganmc10,71,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-297184896,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","Well I would wait for Gilles to chime in, but I've tested WDC with these changes (and the Audio-SDL speed limiter disabled) and it works the same as Project64 now.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/Gillou68310,72,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-297325846,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","Thanks @loganmc10 for creating the PR ;-) I think this is ready to be merged since we have the same behavior as project64.
WDC and Stunt racer are both generating audio samples with AI_LEN_REG == 16384. This is problematic with the default buffer size in audio-sdl. The stuttering issue could be fixed by multiplying PRIMARY_BUFFER_SIZE, PRIMARY_BUFFER_TARGET and SECONDARY_BUFFER_SIZE by 16 but the audio latency will be awful! Also it seems like the audio is not handled by an RSP task for those games because the core never calls doRspCycles with sp->mem[0xfc0/4] == 2.
There's no stuttering in Gauntlet legend BTW ;-)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/cxd4,73,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-297718442,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","Awesome, I'll test it out tomorrow, I thought that SupportCPUSemaphoreLock was required for the RSP to exit with halt/broke set to 0, but I guess it isn't required

Nope, just a separate trick that very few games use.  Gauntlets/Boss Games are not among them.
Of all the semaphores there is only one that the CPU uses as a mutex to manually cap the RSP slave time in conjunction with the master.  I only remember Mario no Photopie requiring it.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,257,2017-04-07T18:49:49Z,2017-04-26T13:29:18Z,2017-05-09T05:11:34Z,MERGED,True,29,6,2,https://github.com/loganmc10,Get World Driver Championship booting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/257,https://github.com/olivieryuyu,74,https://github.com/mupen64plus/mupen64plus-core/pull/257#issuecomment-300062946,"This is not something that should be merged, but I figured since there was code involved a PR would be an easier place to look at it than an Issue. Plus it's awesome.
To boot WDC, you need to use rsp-cxd4 and enable ""SupportCPUSemaphoreLock"". That, plus this change, should allow WDC to boot. I assume it will also fix Stunt Racer 64 and similar games.
The graphics are messed up (polygons everywhere). I know nothing about how the N64 works or interrupts or anything. This is just the result of me messing around for the last 4-5 days based on things I had read from HatCat/cxd4, angrylion, etc..
I am hoping that this will be a good hint for people much smarter than me @richard42 @bsmiles32 @Gillou68310 @fzurita @cxd4 and that someone will be able to take it from here and get these games working properly.","can we get WDC running in HLE by any chance? Without that, ucode reverse enginnering would not be possible.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/258,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.","Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/258#issuecomment-293904471,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.",Added some more commits which reduce further direct g_dev variable usage.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/258#issuecomment-297463439,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.","The PR that was just merged created a merge conflict here, FYI",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/bsmiles32,4,https://github.com/mupen64plus/mupen64plus-core/pull/258#issuecomment-297571621,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.",rebased against master,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/bsmiles32,5,https://github.com/mupen64plus/mupen64plus-core/pull/258#issuecomment-299351588,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.",Fixed some errors reported by @dankcushions in PR 269.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/Gillou68310,6,https://github.com/mupen64plus/mupen64plus-core/pull/258#issuecomment-299617942,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.","I just realized that movw and movt are not available on rpi1's armv6. If ARMv5_ONLY is defined you should use literal pool instead.
LDR Rd,=const",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/Gillou68310,7,https://github.com/mupen64plus/mupen64plus-core/pull/258#issuecomment-300122011,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.",You should also remove .cpu arm9tdmi so we can use armv7 instructions,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/bsmiles32,8,https://github.com/mupen64plus/mupen64plus-core/pull/258#issuecomment-300181047,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.","@Gillou68310 : just curious, any downside of removing the .cpu arm9tdmi statement ? If so, maybe trying to help the compiler align struct members properly (eg same as before) could avoid these changes ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/Gillou68310,9,https://github.com/mupen64plus/mupen64plus-core/pull/258#issuecomment-300211963,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.","Removing the .cpu arm9tdmi should have no impact. Also I don't even understand why we are specifying all these attributes in the first place. We should probably let the compiler do it's job.

If so, maybe trying to help the compiler align struct members properly (eg same as before) could avoid these changes ?

Alignment is not really the issue here, the problem is that the compiler added some padding in the hot state structure and there's not much we can do about it.
Also thanks for this 8c3a6a7 ;-)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/bsmiles32,10,https://github.com/mupen64plus/mupen64plus-core/pull/258#issuecomment-300382213,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.","@Gillou68310 : Looking more closely at the new offsets issue, I think it would be possible to use the old code with immediates specified as 8 bit value shifted by an even number. If we look at the faulty members
: restore_candidates (@ 0x4b8) and memory_map (@ 0x6b8), they can be made compatible again if they were @ 0x4c0 and @ 0x6c0, eg 16-byte aligned. We can ask for it with attribute aligned((16)) (GCC extension) or use _Alignas (C11). Or try the packed structure approach and manually insert padding as needed. What do you think would be preferable in term of maintenance/performance ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/Gillou68310,11,https://github.com/mupen64plus/mupen64plus-core/pull/258#issuecomment-300418400,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.",I think it's preferable to let the compiler decide the alignment and adapt the assembly code like we did. It will be easier to maintain and should have no performance impact.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/Gillou68310,12,https://github.com/mupen64plus/mupen64plus-core/pull/258#issuecomment-300419053,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.",extra_memory was previously aligned on 2^12 not sure if this was required for mmap?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/Gillou68310,13,https://github.com/mupen64plus/mupen64plus-core/pull/258#issuecomment-300420064,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.","void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);

If addr is NULL, then the kernel chooses the address at which to
create the mapping; this is the most portable method of creating a
new mapping.  If addr is not NULL, then the kernel takes it as a hint
about where to place the mapping; on Linux, the mapping will be
created at a nearby page boundary.  The address of the new mapping is
returned as the result of the call.

Looks like it is ;-)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/Gillou68310,14,https://github.com/mupen64plus/mupen64plus-core/pull/258#issuecomment-300422245,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.","On ARMv7, both mappings will (in general) work, and any user-allocatable virtual address can be specified provided that it is aligned at a 4KB page boundary.

Found at https://community.arm.com/processors/b/blog/posts/page-colouring-on-armv6-and-a-bit-on-armv7",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/bsmiles32,15,https://github.com/mupen64plus/mupen64plus-core/pull/258#issuecomment-300518597,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.","I thought 4k alignment was for better performance because it would put hot state in it's own page. If required, we will need to tell compiler to align this member at 4k with aligned attribute or _Alignas.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/bsmiles32,16,https://github.com/mupen64plus/mupen64plus-core/pull/258#issuecomment-301360727,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.","@loganmc10, @dankcushions Can you test if this PR works on your ARM device ? That would allow to reduce the range of suspicious commits to look for the breakage.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/loganmc10,17,https://github.com/mupen64plus/mupen64plus-core/pull/258#issuecomment-301363036,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.","I just tested on my Raspberry Pi 3. It didn't segfault. I'm testing this over SSH, I don't have my rpi plugged into my TV so I can't comment on what it looks like.
Tomorrow I'll test the commits in the other PR to track down where the segfault is starting.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/bsmiles32,18,https://github.com/mupen64plus/mupen64plus-core/pull/258#issuecomment-301363818,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.",Thanks. So it looks like this PR is ready ?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/loganmc10,19,https://github.com/mupen64plus/mupen64plus-core/pull/258#issuecomment-301364650,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.","Yeah I would say so. Tomorrow I can test this PR on my Android device to make sure the audio/video is still good, and I'll track down the bad commit in the other PR",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/bsmiles32,20,https://github.com/mupen64plus/mupen64plus-core/pull/258#issuecomment-301364740,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.",Great ! Thanks for your dedication.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/loganmc10,21,https://github.com/mupen64plus/mupen64plus-core/pull/258#issuecomment-301371238,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.","Here are a couple of warnings I see when compiling for Android:
In file included from /home/travis/mupen64plus-ae/app/src/main/jni/./mupen64plus-core/src/device/r4300/new_dynarec/new_dynarec.c:50:
/home/travis/mupen64plus-ae/app/src/main/jni/./mupen64plus-core/src/device/r4300/new_dynarec/x86/assem_x86.h:1:9: warning: 'M64P_DEVICE_R4300_NEW_DYNAREC_X86_ASSEM_X86_H' is used as a header guard here, followed by #define of a different macro [-Wheader-guard]
#ifndef M64P_DEVICE_R4300_NEW_DYNAREC_X86_ASSEM_X86_H
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/home/travis/mupen64plus-ae/app/src/main/jni/./mupen64plus-core/src/device/r4300/new_dynarec/x86/assem_x86.h:2:9: note: 'M64P_DEVICE_R4300_NEW_DYNARER4300_ASSEM_X86_H' is defined here; did you mean 'M64P_DEVICE_R4300_NEW_DYNAREC_X86_ASSEM_X86_H'?
#define M64P_DEVICE_R4300_NEW_DYNARER4300_ASSEM_X86_H
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        M64P_DEVICE_R4300_NEW_DYNAREC_X86_ASSEM_X86_H
/home/travis/mupen64plus-ae/app/src/main/jni/./mupen64plus-core/src/device/r4300/new_dynarec/new_dynarec.c:2234:70: warning: comparison of unsigned expression >= 0 is always true [-Wtautological-compare]
      if((start!=0)&&(page<2048)&&((start-(u_int)g_dev.ri.rdram.dram)>=0)&&((end-(u_int)g_dev.ri.rdram.dram)<0x800000)) {
                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^ ~

/home/travis/mupen64plus-ae/app/src/main/jni/./mupen64plus-core/src/device/r4300/new_dynarec/arm/assem_arm.c:433:8:
warning:
initializing 'int *' with an expression of type 'u_int *' (aka 'unsigned int *') converts between pointers to integer types with different sign [-Wpointer-sign]
  int *ptr=((u_int *)addr)+6;
       ^   ~~~~~~~~~~~~~~~~~
/home/travis/mupen64plus-ae/app/src/main/jni/./mupen64plus-core/src/device/r4300/new_dynarec/new_dynarec.c:2234:70:
warning: 
comparison of unsigned expression >= 0 is always true [-Wtautological-compare]
      if((start!=0)&&(page<2048)&&((start-(u_int)g_dev.ri.rdram.dram)>=0)&&((end-(u_int)g_dev.ri.rdram.dram)<0x800000)) {
                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^ ~
/home/travis/mupen64plus-ae/app/src/main/jni/./mupen64plus-core/src/device/r4300/new_dynarec/new_dynarec.c:10899:35:
warning: 
passing 'u_char *' (aka 'unsigned char *') to parameter of type 'char *' converts between pointers to integer types with different sign [-Wpointer-sign]
  __clear_cache((void *)beginning,out);
                                  ^~~",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/loganmc10,22,https://github.com/mupen64plus/mupen64plus-core/pull/258#issuecomment-301371753,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.","I just tested on my Android ARM device (Shield Tablet) and it all works fine, everything looks good.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/bsmiles32,23,https://github.com/mupen64plus/mupen64plus-core/pull/258#issuecomment-301374209,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.",Great ! I fixed the header guard warning as it was a simple one. However the other warnings (mostly signedess related) predate this PR and might require deeper work.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/bsmiles32,24,https://github.com/mupen64plus/mupen64plus-core/pull/258#issuecomment-301374699,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.","@loganmc10 : Did you noticed any speed regression with this PR ?
@loganmc10 , @Gillou68310 : Any objections before I merge that PR ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/loganmc10,25,https://github.com/mupen64plus/mupen64plus-core/pull/258#issuecomment-301374931,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.","I didn't really look for that. There was no obvious problems, but I didn't look at the FPS or anything. I have no issues with merging it unless someone else wants to do some more detailed performance testing before merging it.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/bsmiles32,26,https://github.com/mupen64plus/mupen64plus-core/pull/258#issuecomment-301375025,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.",Good. Will wait for @Gillou68310 approval then :),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/Gillou68310,27,https://github.com/mupen64plus/mupen64plus-core/pull/258#issuecomment-301427764,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.",Approved ;-),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,258,2017-04-12T09:44:25Z,2017-05-15T14:11:19Z,2017-05-16T09:29:15Z,MERGED,True,8240,7916,46,https://github.com/bsmiles32,Reduce usage of g_dev,50,[],https://github.com/mupen64plus/mupen64plus-core/pull/258,https://github.com/dankcushions,28,https://github.com/mupen64plus/mupen64plus-core/pull/258#issuecomment-301727080,"Still trying to reduce usage of global variable.
In this PR, I unified the way new_dynarec ""hot"" variables are accessed. This allowed me to remove usage of g_dev in many simple accessors (in r4300_core, cp0, cp1 mostly).
Then I did some more refactorings to reduce usage of g_dev inside r4300 module.","just FYI, i just compiled master on my RPI3 and it seems to run fine :) no idea about performance changes, but the ARM dynarec previously didn't come close to maxing the CPU and still doesn't 👍",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,259,2017-04-14T13:31:48Z,2017-04-14T16:53:11Z,2017-04-14T16:53:11Z,CLOSED,False,13747,14583,43,https://github.com/Meriipu,Allow user-requested window position,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/259,https://github.com/Meriipu,1,https://github.com/mupen64plus/mupen64plus-core/pull/259,"Reads the two g_CoreConfig options ScreenPosX and ScreenPosY
Sets the final window to this position, or returns to the old behaviour if unset (checks for default values -1,-1)
I feel these changes are much less clean than the changes I made to ui-console to allow storing the options.
I also have no idea whether screen coordinates work the same way on all platforms, or whether there are other cases where these changes might lead to issues.
Finally they might fill a pretty niche need. For me it was spawning multiple instances at once and having them tiled out rather than all on top of each other.
My attempts to use external applications to move the windows when they were created were not as successful as this change was.","Reads the two g_CoreConfig options ScreenPosX and ScreenPosY
Sets the final window to this position, or returns to the old behaviour if unset (checks for default values -1,-1)
I feel these changes are much less clean than the changes I made to ui-console to allow storing the options.
I also have no idea whether screen coordinates work the same way on all platforms, or whether there are other cases where these changes might lead to issues.
Finally they might fill a pretty niche need. For me it was spawning multiple instances at once and having them tiled out rather than all on top of each other.
My attempts to use external applications to move the windows when they were created were not as successful as this change was.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,259,2017-04-14T13:31:48Z,2017-04-14T16:53:11Z,2017-04-14T16:53:11Z,CLOSED,False,13747,14583,43,https://github.com/Meriipu,Allow user-requested window position,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/259,https://github.com/Meriipu,2,https://github.com/mupen64plus/mupen64plus-core/pull/259#issuecomment-294156849,"Reads the two g_CoreConfig options ScreenPosX and ScreenPosY
Sets the final window to this position, or returns to the old behaviour if unset (checks for default values -1,-1)
I feel these changes are much less clean than the changes I made to ui-console to allow storing the options.
I also have no idea whether screen coordinates work the same way on all platforms, or whether there are other cases where these changes might lead to issues.
Finally they might fill a pretty niche need. For me it was spawning multiple instances at once and having them tiled out rather than all on top of each other.
My attempts to use external applications to move the windows when they were created were not as successful as this change was.","I should probably learn how to use branches/releases sometime
I was a bit surprised to see the last newline change instantly appear",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,259,2017-04-14T13:31:48Z,2017-04-14T16:53:11Z,2017-04-14T16:53:11Z,CLOSED,False,13747,14583,43,https://github.com/Meriipu,Allow user-requested window position,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/259,https://github.com/rlabrecque,3,https://github.com/mupen64plus/mupen64plus-core/pull/259#issuecomment-294181268,"Reads the two g_CoreConfig options ScreenPosX and ScreenPosY
Sets the final window to this position, or returns to the old behaviour if unset (checks for default values -1,-1)
I feel these changes are much less clean than the changes I made to ui-console to allow storing the options.
I also have no idea whether screen coordinates work the same way on all platforms, or whether there are other cases where these changes might lead to issues.
Finally they might fill a pretty niche need. For me it was spawning multiple instances at once and having them tiled out rather than all on top of each other.
My attempts to use external applications to move the windows when they were created were not as successful as this change was.",You're going to need to rebase and squash those commits then force push to your branch. Then there will be just once clean commit if/when this gets merged.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,259,2017-04-14T13:31:48Z,2017-04-14T16:53:11Z,2017-04-14T16:53:11Z,CLOSED,False,13747,14583,43,https://github.com/Meriipu,Allow user-requested window position,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/259,https://github.com/Meriipu,4,https://github.com/mupen64plus/mupen64plus-core/pull/259#issuecomment-294185896,"Reads the two g_CoreConfig options ScreenPosX and ScreenPosY
Sets the final window to this position, or returns to the old behaviour if unset (checks for default values -1,-1)
I feel these changes are much less clean than the changes I made to ui-console to allow storing the options.
I also have no idea whether screen coordinates work the same way on all platforms, or whether there are other cases where these changes might lead to issues.
Finally they might fill a pretty niche need. For me it was spawning multiple instances at once and having them tiled out rather than all on top of each other.
My attempts to use external applications to move the windows when they were created were not as successful as this change was.",I am not sure what is going on with the bsmiles32-commits,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,259,2017-04-14T13:31:48Z,2017-04-14T16:53:11Z,2017-04-14T16:53:11Z,CLOSED,False,13747,14583,43,https://github.com/Meriipu,Allow user-requested window position,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/259,https://github.com/Meriipu,5,https://github.com/mupen64plus/mupen64plus-core/pull/259#issuecomment-294189965,"Reads the two g_CoreConfig options ScreenPosX and ScreenPosY
Sets the final window to this position, or returns to the old behaviour if unset (checks for default values -1,-1)
I feel these changes are much less clean than the changes I made to ui-console to allow storing the options.
I also have no idea whether screen coordinates work the same way on all platforms, or whether there are other cases where these changes might lead to issues.
Finally they might fill a pretty niche need. For me it was spawning multiple instances at once and having them tiled out rather than all on top of each other.
My attempts to use external applications to move the windows when they were created were not as successful as this change was.","no this includes a bunch of changes I did not make sorry.
It might be better to close it and reopen it fixed later, I have no idea how to fix it.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,260,2017-04-14T17:07:41Z,2017-05-10T04:23:26Z,2017-05-10T04:23:26Z,CLOSED,False,11,3,2,https://github.com/Meriipu,Allow user-requested window position,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/260,https://github.com/Meriipu,1,https://github.com/mupen64plus/mupen64plus-core/pull/260,"Reads the two g_CoreConfig options ScreenPosX and ScreenPosY
Sets the final window to this position, or returns to the old behaviour if unset (checks for default values -1,-1)
I feel these changes are much less clean than the changes I made to ui-console to allow storing the options.
I also have no idea whether screen coordinates work the same way on all platforms, or whether there are other cases where these changes might lead to issues.
Finally they might fill a pretty niche need. For me it was spawning multiple instances at once and having them tiled out rather than all on top of each other.
My attempts to use external applications to move the windows when they were created were not as successful as this change was.
Remade request #259 as I had some issue with another pull request being mixed into it that I was not good enough at git to solve","Reads the two g_CoreConfig options ScreenPosX and ScreenPosY
Sets the final window to this position, or returns to the old behaviour if unset (checks for default values -1,-1)
I feel these changes are much less clean than the changes I made to ui-console to allow storing the options.
I also have no idea whether screen coordinates work the same way on all platforms, or whether there are other cases where these changes might lead to issues.
Finally they might fill a pretty niche need. For me it was spawning multiple instances at once and having them tiled out rather than all on top of each other.
My attempts to use external applications to move the windows when they were created were not as successful as this change was.
Remade request #259 as I had some issue with another pull request being mixed into it that I was not good enough at git to solve",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,260,2017-04-14T17:07:41Z,2017-05-10T04:23:26Z,2017-05-10T04:23:26Z,CLOSED,False,11,3,2,https://github.com/Meriipu,Allow user-requested window position,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/260,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/260#issuecomment-300259656,"Reads the two g_CoreConfig options ScreenPosX and ScreenPosY
Sets the final window to this position, or returns to the old behaviour if unset (checks for default values -1,-1)
I feel these changes are much less clean than the changes I made to ui-console to allow storing the options.
I also have no idea whether screen coordinates work the same way on all platforms, or whether there are other cases where these changes might lead to issues.
Finally they might fill a pretty niche need. For me it was spawning multiple instances at once and having them tiled out rather than all on top of each other.
My attempts to use external applications to move the windows when they were created were not as successful as this change was.
Remade request #259 as I had some issue with another pull request being mixed into it that I was not good enough at git to solve","The problem with this is that not every frontend uses SDL (mupen64plus-ui-console is just one of the frontends). So with this change you have 2 new config items for the core (ScreenPosX, ScreenPosY), but they only apply to mupen64plus-ui-console",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,260,2017-04-14T17:07:41Z,2017-05-10T04:23:26Z,2017-05-10T04:23:26Z,CLOSED,False,11,3,2,https://github.com/Meriipu,Allow user-requested window position,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/260,https://github.com/Meriipu,3,https://github.com/mupen64plus/mupen64plus-core/pull/260#issuecomment-300277267,"Reads the two g_CoreConfig options ScreenPosX and ScreenPosY
Sets the final window to this position, or returns to the old behaviour if unset (checks for default values -1,-1)
I feel these changes are much less clean than the changes I made to ui-console to allow storing the options.
I also have no idea whether screen coordinates work the same way on all platforms, or whether there are other cases where these changes might lead to issues.
Finally they might fill a pretty niche need. For me it was spawning multiple instances at once and having them tiled out rather than all on top of each other.
My attempts to use external applications to move the windows when they were created were not as successful as this change was.
Remade request #259 as I had some issue with another pull request being mixed into it that I was not good enough at git to solve","I see how that can be messy, having unapplicable options.
Are there other frontends than ui-python? If (in most cases) not, would including a similar change to qt work out? Or storing the settings in a different category?
Otherwise I would just keep them local to the fork I made",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,260,2017-04-14T17:07:41Z,2017-05-10T04:23:26Z,2017-05-10T04:23:26Z,CLOSED,False,11,3,2,https://github.com/Meriipu,Allow user-requested window position,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/260,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/260#issuecomment-300279358,"Reads the two g_CoreConfig options ScreenPosX and ScreenPosY
Sets the final window to this position, or returns to the old behaviour if unset (checks for default values -1,-1)
I feel these changes are much less clean than the changes I made to ui-console to allow storing the options.
I also have no idea whether screen coordinates work the same way on all platforms, or whether there are other cases where these changes might lead to issues.
Finally they might fill a pretty niche need. For me it was spawning multiple instances at once and having them tiled out rather than all on top of each other.
My attempts to use external applications to move the windows when they were created were not as successful as this change was.
Remade request #259 as I had some issue with another pull request being mixed into it that I was not good enough at git to solve","Well I wrote/use this:
https://github.com/m64p/mupen64plus-gui, similar to ui-python but it's written in C++.
There have been others in the past (CuteMupen, mupen64plus-qt), some of them aren't really frontends though, they are just launchers that launch mupen64plus-ui-console.
I assume something like this could be accomplished via a shell script. Once mupen64plus has launched you could get the process ID and tell the window manager to re-position the window (I assume, I haven't looked into it).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,260,2017-04-14T17:07:41Z,2017-05-10T04:23:26Z,2017-05-10T04:23:26Z,CLOSED,False,11,3,2,https://github.com/Meriipu,Allow user-requested window position,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/260,https://github.com/Meriipu,5,https://github.com/mupen64plus/mupen64plus-core/pull/260#issuecomment-300285417,"Reads the two g_CoreConfig options ScreenPosX and ScreenPosY
Sets the final window to this position, or returns to the old behaviour if unset (checks for default values -1,-1)
I feel these changes are much less clean than the changes I made to ui-console to allow storing the options.
I also have no idea whether screen coordinates work the same way on all platforms, or whether there are other cases where these changes might lead to issues.
Finally they might fill a pretty niche need. For me it was spawning multiple instances at once and having them tiled out rather than all on top of each other.
My attempts to use external applications to move the windows when they were created were not as successful as this change was.
Remade request #259 as I had some issue with another pull request being mixed into it that I was not good enough at git to solve","I tried that, but the race between which application window was created before another required too long delays between window spawns to avoid one spawning before the other and getting placed in the wrong location. I was launching several (15-30 instances) at the same time.
Placing it in the desired location by having the application request its position from the very beginning solved it for me.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,260,2017-04-14T17:07:41Z,2017-05-10T04:23:26Z,2017-05-10T04:23:26Z,CLOSED,False,11,3,2,https://github.com/Meriipu,Allow user-requested window position,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/260,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/260#issuecomment-300286912,"Reads the two g_CoreConfig options ScreenPosX and ScreenPosY
Sets the final window to this position, or returns to the old behaviour if unset (checks for default values -1,-1)
I feel these changes are much less clean than the changes I made to ui-console to allow storing the options.
I also have no idea whether screen coordinates work the same way on all platforms, or whether there are other cases where these changes might lead to issues.
Finally they might fill a pretty niche need. For me it was spawning multiple instances at once and having them tiled out rather than all on top of each other.
My attempts to use external applications to move the windows when they were created were not as successful as this change was.
Remade request #259 as I had some issue with another pull request being mixed into it that I was not good enough at git to solve","Have you tried using the environment variable SDL_VIDEO_WINDOW_POS=x,y?
I just tested doing:
SDL_VIDEO_WINDOW_POS=0,0 ./mupen64plus ~/N64/Super\ Mario\ 64\ \(USA\).n64

And it did indeed put the window at the top left corner.",True,{'HEART': ['https://github.com/Meriipu']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,260,2017-04-14T17:07:41Z,2017-05-10T04:23:26Z,2017-05-10T04:23:26Z,CLOSED,False,11,3,2,https://github.com/Meriipu,Allow user-requested window position,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/260,https://github.com/Meriipu,7,https://github.com/mupen64plus/mupen64plus-core/pull/260#issuecomment-300288101,"Reads the two g_CoreConfig options ScreenPosX and ScreenPosY
Sets the final window to this position, or returns to the old behaviour if unset (checks for default values -1,-1)
I feel these changes are much less clean than the changes I made to ui-console to allow storing the options.
I also have no idea whether screen coordinates work the same way on all platforms, or whether there are other cases where these changes might lead to issues.
Finally they might fill a pretty niche need. For me it was spawning multiple instances at once and having them tiled out rather than all on top of each other.
My attempts to use external applications to move the windows when they were created were not as successful as this change was.
Remade request #259 as I had some issue with another pull request being mixed into it that I was not good enough at git to solve","That works. Nice. I suppose this change is pretty superfluous then.
I suppose I could close it unless there are cases where environment variables do not work?
It does for me.
Oh yeah and disregarding the fact that this still only applies to SDL.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,260,2017-04-14T17:07:41Z,2017-05-10T04:23:26Z,2017-05-10T04:23:26Z,CLOSED,False,11,3,2,https://github.com/Meriipu,Allow user-requested window position,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/260,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/260#issuecomment-300366682,"Reads the two g_CoreConfig options ScreenPosX and ScreenPosY
Sets the final window to this position, or returns to the old behaviour if unset (checks for default values -1,-1)
I feel these changes are much less clean than the changes I made to ui-console to allow storing the options.
I also have no idea whether screen coordinates work the same way on all platforms, or whether there are other cases where these changes might lead to issues.
Finally they might fill a pretty niche need. For me it was spawning multiple instances at once and having them tiled out rather than all on top of each other.
My attempts to use external applications to move the windows when they were created were not as successful as this change was.
Remade request #259 as I had some issue with another pull request being mixed into it that I was not good enough at git to solve","The environment variable trick will work for ui-console. It won't work for other frontends like ui-python, but other frontends can implement their own solutions for repositioning the window if needed, this can probably be closed",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,260,2017-04-14T17:07:41Z,2017-05-10T04:23:26Z,2017-05-10T04:23:26Z,CLOSED,False,11,3,2,https://github.com/Meriipu,Allow user-requested window position,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/260,https://github.com/Meriipu,9,https://github.com/mupen64plus/mupen64plus-core/pull/260#issuecomment-300369908,"Reads the two g_CoreConfig options ScreenPosX and ScreenPosY
Sets the final window to this position, or returns to the old behaviour if unset (checks for default values -1,-1)
I feel these changes are much less clean than the changes I made to ui-console to allow storing the options.
I also have no idea whether screen coordinates work the same way on all platforms, or whether there are other cases where these changes might lead to issues.
Finally they might fill a pretty niche need. For me it was spawning multiple instances at once and having them tiled out rather than all on top of each other.
My attempts to use external applications to move the windows when they were created were not as successful as this change was.
Remade request #259 as I had some issue with another pull request being mixed into it that I was not good enough at git to solve",Already implemented for sdl as environment variable SDL_VIDEO_WINDOW_POS,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,263,2017-04-23T19:24:47Z,2017-04-25T04:48:28Z,2017-06-02T16:44:04Z,MERGED,True,0,4,1,https://github.com/loganmc10,Fix Indiana Jones,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/263,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/263,"These values were taken from Project64 and they don't seem to work here, the game doesn't boot with these settings","These values were taken from Project64 and they don't seem to work here, the game doesn't boot with these settings",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,263,2017-04-23T19:24:47Z,2017-04-25T04:48:28Z,2017-06-02T16:44:04Z,MERGED,True,0,4,1,https://github.com/loganmc10,Fix Indiana Jones,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/263,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/263#issuecomment-296484570,"These values were taken from Project64 and they don't seem to work here, the game doesn't boot with these settings",Hmm... good find. This fixed it for me.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/269,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-298641713,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","I just tested this on Windows x64 (Hacktarux dynarec). I booted up Mario 64, it plays the ""Itsa me, Mario!"" part, but the floating face never comes up. Just a black screen.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-298645504,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","Using the Cached Interpreter works, just not the dynarec",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-298648997,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)",874baff is the commit that broke it,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-298663596,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","Also, I don't have this problem with the x86 Hacktarux dynarec, only x64",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-298667091,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","For the x86 new_dynarec, I get:
Assertion failed!
File: ../../src/device/r4300/new_dynarec/new_dynarec.c, Line 8255

Expression: i<MAXBLOCK-1

Starting in commit 007762f",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,7,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-298807401,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","@loganmc10 can you test if the latest commit fixes Super Mario intro for you. It does for me :)
@Gillou68310 Any idea of what cause the assert in new_dynarec ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-298976977,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","@bsmiles32 yes that change fixes the issue. I've tested around a dozen games using the x86 and x64 Hacktarux dynarec. I don't see any regressions (I just played the first 1-2 minutes of the games).
So to me it looks good besides the assert in the x86 new dynarec. I haven't tested the arm dynarec.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,9,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-299051157,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)",Great ! So we just need to fix new dynarec and we should be good. Thanks for testing.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/dankcushions,10,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-299331589,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","Some warnings/errors building new_dynarec on Raspberry Pi 3 (ARMv71 in 32-bit mode)
    CC  _obj/device/r4300/new_dynarec/new_dynarec.o
In file included from ../../src/device/r4300/new_dynarec/new_dynarec.c:1687:0:
../../src/device/r4300/new_dynarec/arm/assem_arm.c:44:0: warning: ""fp_cp0_regs"" redefined
 #define fp_cp0_regs(x)         (fp_cp0_regs + (x)*sizeof(uint32_t))
 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:43:0: note: this is the location of the previous definition
 #define fp_cp0_regs            (offsetof(struct new_dynarec_hot_state, cp0_regs))
 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:46:0: warning: ""fp_cp1_regs_simple"" redefined
 #define fp_cp1_regs_simple(x)  (fp_cp1_regs_simple + (x)*4)
 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:45:0: note: this is the location of the previous definition
 #define fp_cp1_regs_simple     (offsetof(struct new_dynarec_hot_state, cp1_regs_simple))
 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:48:0: warning: ""fp_cp1_regs_double"" redefined
 #define fp_cp1_regs_double(x)  (fp_cp1_regs_double + (x)*4)
 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:47:0: note: this is the location of the previous definition
 #define fp_cp1_regs_double     (offsetof(struct new_dynarec_hot_state, cp1_regs_double))
 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:56:0: warning: ""fp_mini_ht"" redefined
 #define fp_mini_ht(x,y)        (fp_mini_ht + 4*((y)*32+(x)))
 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:55:0: note: this is the location of the previous definition
 #define fp_mini_ht             (offsetof(struct new_dynarec_hot_state, mini_ht))
 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c: In function ‘isclean’:
../../src/device/r4300/new_dynarec/arm/assem_arm.c:458:12: warning: pointer targets in initialization differ in signedness [-Wpointer-sign]
   int *ptr=((u_int *)addr)+6;
            ^
In file included from ../../src/device/r4300/new_dynarec/new_dynarec.c:1687:0:
../../src/device/r4300/new_dynarec/arm/assem_arm.c: In function ‘alloc_arm_reg’:
../../src/device/r4300/new_dynarec/arm/assem_arm.c:1007:3: warning: array subscript has type ‘char’ [-Wchar-subscripts]
   cur->regmap[hr]=reg;
   ^
In file included from ../../src/device/r4300/new_dynarec/new_dynarec.c:53:0:
../../src/device/r4300/new_dynarec/arm/assem_arm.c: In function ‘genjmp’:
../../src/device/r4300/new_dynarec/arm/assem_arm.h:41:60: error: ‘struct new_dynarec_hot_state’ has no member named ‘extra_memory’
 #define BASE_ADDR ((int)(&g_dev.r4300.new_dynarec_hot_state.extra_memory))
                                                            ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:1099:16: note: in expansion of macro ‘BASE_ADDR’
         offset=BASE_ADDR+(1<<TARGET_SIZE_2)-JUMP_TABLE_SIZE+n*8-(int)out-8;
                ^
In file included from ../../src/device/r4300/new_dynarec/new_dynarec.c:1687:0:
../../src/device/r4300/new_dynarec/arm/assem_arm.c: In function ‘emit_loadreg’:
../../src/device/r4300/new_dynarec/arm/assem_arm.c:44:33: error: ‘fp_cp0_regs’ undeclared (first use in this function)
 #define fp_cp0_regs(x)         (fp_cp0_regs + (x)*sizeof(uint32_t))
                                 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:1261:25: note: in expansion of macro ‘fp_cp0_regs’
     if(r==CSREG) offset=fp_cp0_regs(CP0_STATUS_REG);
                         ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:44:33: note: each undeclared identifier is reported only once for each function it appears in
 #define fp_cp0_regs(x)         (fp_cp0_regs + (x)*sizeof(uint32_t))
                                 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:1261:25: note: in expansion of macro ‘fp_cp0_regs’
     if(r==CSREG) offset=fp_cp0_regs(CP0_STATUS_REG);
                         ^
    CC  _obj/main/zip/ioapi.o
../../src/device/r4300/new_dynarec/arm/assem_arm.c: In function ‘do_readstub’:
../../src/device/r4300/new_dynarec/arm/assem_arm.c:44:33: error: ‘fp_cp0_regs’ undeclared (first use in this function)
 #define fp_cp0_regs(x)         (fp_cp0_regs + (x)*sizeof(uint32_t))
                                 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:2812:61: note: in expansion of macro ‘fp_cp0_regs’
   emit_readword((u_int)&g_dev.r4300.new_dynarec_hot_state + fp_cp0_regs(CP0_COUNT_REG),HOST_TEMPREG);
                                                             ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c: In function ‘inline_readstub’:
../../src/device/r4300/new_dynarec/arm/assem_arm.c:44:33: error: ‘fp_cp0_regs’ undeclared (first use in this function)
 #define fp_cp0_regs(x)         (fp_cp0_regs + (x)*sizeof(uint32_t))
                                 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:2923:61: note: in expansion of macro ‘fp_cp0_regs’
   emit_readword((u_int)&g_dev.r4300.new_dynarec_hot_state + fp_cp0_regs(CP0_COUNT_REG),HOST_TEMPREG);
                                                             ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c: In function ‘do_writestub’:
../../src/device/r4300/new_dynarec/arm/assem_arm.c:44:33: error: ‘fp_cp0_regs’ undeclared (first use in this function)
 #define fp_cp0_regs(x)         (fp_cp0_regs + (x)*sizeof(uint32_t))
                                 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:3059:61: note: in expansion of macro ‘fp_cp0_regs’
   emit_readword((u_int)&g_dev.r4300.new_dynarec_hot_state + fp_cp0_regs(CP0_COUNT_REG),HOST_TEMPREG);
                                                             ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c: In function ‘inline_writestub’:
../../src/device/r4300/new_dynarec/arm/assem_arm.c:44:33: error: ‘fp_cp0_regs’ undeclared (first use in this function)
 #define fp_cp0_regs(x)         (fp_cp0_regs + (x)*sizeof(uint32_t))
                                 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:3160:61: note: in expansion of macro ‘fp_cp0_regs’
   emit_readword((u_int)&g_dev.r4300.new_dynarec_hot_state + fp_cp0_regs(CP0_COUNT_REG),HOST_TEMPREG);
                                                             ^
In file included from ../../src/device/r4300/new_dynarec/new_dynarec.c:1687:0:
../../src/device/r4300/new_dynarec/arm/assem_arm.c: In function ‘do_cop1stub’:
../../src/device/r4300/new_dynarec/arm/assem_arm.c:3239:7: warning: unused variable ‘rs’ [-Wunused-variable]
   int rs=stubs[n][4];
       ^
In file included from ../../src/device/r4300/new_dynarec/new_dynarec.c:1687:0:
../../src/device/r4300/new_dynarec/arm/assem_arm.c: In function ‘cop0_assemble’:
../../src/device/r4300/new_dynarec/arm/assem_arm.c:44:33: error: ‘fp_cp0_regs’ undeclared (first use in this function)
 #define fp_cp0_regs(x)         (fp_cp0_regs + (x)*sizeof(uint32_t))
                                 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:3626:81: note: in expansion of macro ‘fp_cp0_regs’
           emit_writeword(HOST_CCREG,(u_int)&g_dev.r4300.new_dynarec_hot_state + fp_cp0_regs(CP0_COUNT_REG));
                                                                                 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c: In function ‘cop1_assemble’:
../../src/device/r4300/new_dynarec/arm/assem_arm.c:46:33: error: ‘fp_cp1_regs_simple’ undeclared (first use in this function)
 #define fp_cp1_regs_simple(x)  (fp_cp1_regs_simple + (x)*4)
                                 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:3730:65: note: in expansion of macro ‘fp_cp1_regs_simple’
       emit_readword((u_int)&g_dev.r4300.new_dynarec_hot_state + fp_cp1_regs_simple((source[i]>>11)&0x1f),tl);
                                                                 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:48:33: error: ‘fp_cp1_regs_double’ undeclared (first use in this function)
 #define fp_cp1_regs_double(x)  (fp_cp1_regs_double + (x)*4)
                                 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:3738:65: note: in expansion of macro ‘fp_cp1_regs_double’
       emit_readword((u_int)&g_dev.r4300.new_dynarec_hot_state + fp_cp1_regs_double((source[i]>>11)&0x1f),tl);
                                                                 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c: In function ‘fconv_assemble_arm’:
../../src/device/r4300/new_dynarec/arm/assem_arm.c:46:33: error: ‘fp_cp1_regs_simple’ undeclared (first use in this function)
 #define fp_cp1_regs_simple(x)  (fp_cp1_regs_simple + (x)*4)
                                 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:3800:63: note: in expansion of macro ‘fp_cp1_regs_simple’
     emit_readword((u_int)&g_dev.r4300.new_dynarec_hot_state + fp_cp1_regs_simple((source[i]>>11)&0x1f),temp);
                                                               ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:48:33: error: ‘fp_cp1_regs_double’ undeclared (first use in this function)
 #define fp_cp1_regs_double(x)  (fp_cp1_regs_double + (x)*4)
                                 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:3809:63: note: in expansion of macro ‘fp_cp1_regs_double’
     emit_readword((u_int)&g_dev.r4300.new_dynarec_hot_state + fp_cp1_regs_double((source[i]>>11)&0x1f),temp);
                                                               ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c: In function ‘fcomp_assemble’:
../../src/device/r4300/new_dynarec/arm/assem_arm.c:46:33: error: ‘fp_cp1_regs_simple’ undeclared (first use in this function)
 #define fp_cp1_regs_simple(x)  (fp_cp1_regs_simple + (x)*4)
                                 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:4029:63: note: in expansion of macro ‘fp_cp1_regs_simple’
     emit_readword((u_int)&g_dev.r4300.new_dynarec_hot_state + fp_cp1_regs_simple((source[i]>>11)&0x1f),temp);
                                                               ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:48:33: error: ‘fp_cp1_regs_double’ undeclared (first use in this function)
 #define fp_cp1_regs_double(x)  (fp_cp1_regs_double + (x)*4)
                                 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:4052:63: note: in expansion of macro ‘fp_cp1_regs_double’
     emit_readword((u_int)&g_dev.r4300.new_dynarec_hot_state + fp_cp1_regs_double((source[i]>>11)&0x1f),temp);
                                                               ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c: In function ‘float_assemble’:
../../src/device/r4300/new_dynarec/arm/assem_arm.c:46:33: error: ‘fp_cp1_regs_simple’ undeclared (first use in this function)
 #define fp_cp1_regs_simple(x)  (fp_cp1_regs_simple + (x)*4)
                                 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:4148:67: note: in expansion of macro ‘fp_cp1_regs_simple’
         emit_readword((u_int)&g_dev.r4300.new_dynarec_hot_state + fp_cp1_regs_simple((source[i]>>11)&0x1f),temp);
                                                                   ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:48:33: error: ‘fp_cp1_regs_double’ undeclared (first use in this function)
 #define fp_cp1_regs_double(x)  (fp_cp1_regs_double + (x)*4)
                                 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:4154:67: note: in expansion of macro ‘fp_cp1_regs_double’
         emit_readword((u_int)&g_dev.r4300.new_dynarec_hot_state + fp_cp1_regs_double((source[i]>>11)&0x1f),temp);
                                                                   ^
In file included from ../../src/device/r4300/new_dynarec/new_dynarec.c:1687:0:
../../src/device/r4300/new_dynarec/arm/assem_arm.c: In function ‘do_preload_rhtbl’:
../../src/device/r4300/new_dynarec/arm/assem_arm.c:4584:18: error: ‘fp_mini_ht’ undeclared (first use in this function)
   emit_addimm(FP,fp_mini_ht,ht);
                  ^
In file included from ../../src/device/r4300/new_dynarec/new_dynarec.c:1687:0:
../../src/device/r4300/new_dynarec/arm/assem_arm.c: In function ‘do_miniht_insert’:
../../src/device/r4300/new_dynarec/arm/assem_arm.c:56:33: error: ‘fp_mini_ht’ undeclared (first use in this function)
 #define fp_mini_ht(x,y)        (fp_mini_ht + 4*((y)*32+(x)))
                                 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:4618:67: note: in expansion of macro ‘fp_mini_ht’
   emit_writeword(temp,(u_int)&g_dev.r4300.new_dynarec_hot_state + fp_mini_ht((return_address&0xFF)>>3,1));
                                                                   ^
In file included from ../../src/device/r4300/new_dynarec/new_dynarec.c:1687:0:
../../src/device/r4300/new_dynarec/arm/assem_arm.c: In function ‘wb_valid’:
../../src/device/r4300/new_dynarec/arm/assem_arm.c:4651:14: warning: unused variable ‘new_hr’ [-Wunused-variable]
   int hr,reg,new_hr;
              ^
In file included from ../../src/device/r4300/new_dynarec/new_dynarec.c:53:0:
../../src/device/r4300/new_dynarec/arm/assem_arm.c: In function ‘do_clear_cache’:
../../src/device/r4300/new_dynarec/arm/assem_arm.h:41:60: error: ‘struct new_dynarec_hot_state’ has no member named ‘extra_memory’
 #define BASE_ADDR ((int)(&g_dev.r4300.new_dynarec_hot_state.extra_memory))
                                                            ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:4745:17: note: in expansion of macro ‘BASE_ADDR’
           start=BASE_ADDR+i*131072+j*4096;
                 ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c: In function ‘arch_init’:
../../src/device/r4300/new_dynarec/arm/assem_arm.h:41:60: error: ‘struct new_dynarec_hot_state’ has no member named ‘extra_memory’
 #define BASE_ADDR ((int)(&g_dev.r4300.new_dynarec_hot_state.extra_memory))
                                                            ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c:4793:24: note: in expansion of macro ‘BASE_ADDR’
   ptr2=(int *)((void *)BASE_ADDR+(1<<TARGET_SIZE_2)-JUMP_TABLE_SIZE);
                        ^
../../src/device/r4300/new_dynarec/new_dynarec.c: In function ‘store_assemble’:
../../src/device/r4300/new_dynarec/new_dynarec.c:4084:15: warning: unused variable ‘jaddr2’ [-Wunused-variable]
   int jaddr=0,jaddr2,type;
               ^
../../src/device/r4300/new_dynarec/new_dynarec.c: In function ‘storelr_assemble’:
../../src/device/r4300/new_dynarec/new_dynarec.c:4274:15: warning: unused variable ‘jaddr2’ [-Wunused-variable]
   int jaddr=0,jaddr2;
               ^
../../src/device/r4300/new_dynarec/new_dynarec.c: In function ‘c1ls_assemble’:
../../src/device/r4300/new_dynarec/new_dynarec.c:4516:22: warning: unused variable ‘jaddr3’ [-Wunused-variable]
   int jaddr,jaddr2=0,jaddr3,type;
                      ^
    CC  _obj/main/zip/zip.o
In file included from ../../src/device/r4300/new_dynarec/new_dynarec.c:53:0:
../../src/device/r4300/new_dynarec/new_dynarec.c: In function ‘new_dynarec_init’:
../../src/device/r4300/new_dynarec/arm/assem_arm.h:41:60: error: ‘struct new_dynarec_hot_state’ has no member named ‘extra_memory’
 #define BASE_ADDR ((int)(&g_dev.r4300.new_dynarec_hot_state.extra_memory))
                                                            ^
../../src/device/r4300/new_dynarec/new_dynarec.c:7592:36: note: in expansion of macro ‘BASE_ADDR’
   if ((base_addr = mmap ((u_char *)BASE_ADDR, 1<<TARGET_SIZE_2,
                                    ^
../../src/device/r4300/new_dynarec/new_dynarec.c:7625:3: error: ‘invc_ptr’ undeclared (first use in this function)
   invc_ptr=g_dev.r4300.cached_interp.invalid_code;
   ^
In file included from ../../src/device/r4300/new_dynarec/new_dynarec.c:1687:0:
../../src/device/r4300/new_dynarec/new_dynarec.c: At top level:
../../src/device/r4300/new_dynarec/arm/assem_arm.c:1024:13: warning: ‘regname’ defined but not used [-Wunused-variable]
 static char regname[16][4] = {
             ^
    CC  _obj/main/zip/unzip.o
Makefile:700: recipe for target '_obj/device/r4300/new_dynarec/new_dynarec.o' failed",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,11,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-299344439,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)",@dankcushions Thanks for testing ! The compilation errors you mentionned come from my other PR (less_g_dev) which moved many variables around. So I updated both PR to have the fixes. Can you test now with the fixes please ?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/loganmc10,12,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-299354415,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","Just re-tested x86 new_dynarec on Linux to be sure, still getting:
mupen64plus: ../../src/device/r4300/new_dynarec/new_dynarec.c:8255: new_recompile_block: Assertion `i<MAXBLOCK-1' failed.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/loganmc10,13,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-299355020,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","If I comment out that assert, the core exits with this message:
Core Error: Compile at bogus memory address: 80800000

If that gives anyone some kind of idea what the problem is.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/dankcushions,14,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-299404425,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","We're getting closer! Latest compile on ARMv71/RPI3:
    CC  _obj/device/r4300/exception.o
../../src/device/r4300/cp1.c: In function ‘r4300_cp1_regs_simple’:
../../src/device/r4300/cp1.c:59:5: warning: return from incompatible pointer type
     return cp1->new_dynarec_hot_state->cp1_regs_simple;
     ^
../../src/device/r4300/cp1.c: In function ‘r4300_cp1_regs_double’:
../../src/device/r4300/cp1.c:69:5: warning: return from incompatible pointer type
     return cp1->new_dynarec_hot_state->cp1_regs_double;
     ^
    CC  _obj/device/r4300/instr_counters.o
    CC  _obj/device/r4300/interrupt.o
    CC  _obj/device/r4300/mi_controller.o
    CC  _obj/device/r4300/pure_interp.o
    CC  _obj/device/r4300/r4300_core.o
    CC  _obj/device/r4300/recomp.o
    CC  _obj/device/r4300/tlb.o
    CC  _obj/device/rdp/fb.o
    CC  _obj/device/rdp/rdp_core.o
    CC  _obj/device/ri/rdram.o
    CC  _obj/device/ri/rdram_detection_hack.o
    CC  _obj/device/ri/ri_controller.o
    CC  _obj/device/rsp/rsp_core.o
    CC  _obj/device/si/af_rtc.o
    CC  _obj/device/si/cic.o
    CC  _obj/device/si/eeprom.o
    CC  _obj/device/si/game_controller.o
    CC  _obj/device/si/mempak.o
    CC  _obj/device/si/n64_cic_nus_6105.o
    CC  _obj/device/si/pif.o
    CC  _obj/device/si/rumblepak.o
    CC  _obj/device/si/si_controller.o
    CC  _obj/device/si/transferpak.o
    CC  _obj/device/vi/vi_controller.o
    CC  _obj/main/main.o
    CC  _obj/main/util.o
    CC  _obj/main/cheat.o
    CC  _obj/main/eventloop.o
    CC  _obj/main/md5.o
    CC  _obj/main/profile.o
    CC  _obj/main/rom.o
    CC  _obj/main/savestates.o
    CC  _obj/main/sdl_key_converter.o
    CC  _obj/main/file_storage.o
    CC  _obj/main/workqueue.o
    CC  _obj/plugin/emulate_game_controller_via_input_plugin.o
    CC  _obj/plugin/emulate_speaker_via_audio_plugin.o
    CC  _obj/plugin/get_time_using_time_plus_delta.o
    CC  _obj/plugin/rumble_via_input_plugin.o
    CC  _obj/plugin/plugin.o
    CC  _obj/plugin/dummy_video.o
    CC  _obj/plugin/dummy_audio.o
    CC  _obj/plugin/dummy_input.o
    CC  _obj/plugin/dummy_rsp.o
    CC  _obj/osal/dynamiclib_unix.o
    CC  _obj/osal/files_unix.o
    CC  _obj/device/r4300/new_dynarec/arm/arm_cpu_features.o
    CC  _obj/device/r4300/empty_dynarec.o
    CC  _obj/device/r4300/new_dynarec/new_dynarec.o
In file included from ../../src/device/r4300/new_dynarec/new_dynarec.c:1687:0:
../../src/device/r4300/new_dynarec/arm/assem_arm.c: In function ‘isclean’:
../../src/device/r4300/new_dynarec/arm/assem_arm.c:454:12: warning: pointer targets in initialization differ in signedness [-Wpointer-sign]
   int *ptr=((u_int *)addr)+6;
            ^
In file included from ../../src/device/r4300/new_dynarec/new_dynarec.c:1687:0:
../../src/device/r4300/new_dynarec/arm/assem_arm.c: In function ‘alloc_arm_reg’:
../../src/device/r4300/new_dynarec/arm/assem_arm.c:1003:3: warning: array subscript has type ‘char’ [-Wchar-subscripts]
   cur->regmap[hr]=reg;
   ^
../../src/device/r4300/new_dynarec/arm/assem_arm.c: In function ‘do_cop1stub’:
../../src/device/r4300/new_dynarec/arm/assem_arm.c:3235:7: warning: unused variable ‘rs’ [-Wunused-variable]
   int rs=stubs[n][4];
       ^
    CC  _obj/main/zip/ioapi.o
../../src/device/r4300/new_dynarec/arm/assem_arm.c: In function ‘wb_valid’:
../../src/device/r4300/new_dynarec/arm/assem_arm.c:4647:14: warning: unused variable ‘new_hr’ [-Wunused-variable]
   int hr,reg,new_hr;
              ^
../../src/device/r4300/new_dynarec/new_dynarec.c: In function ‘store_assemble’:
../../src/device/r4300/new_dynarec/new_dynarec.c:4084:15: warning: unused variable ‘jaddr2’ [-Wunused-variable]
   int jaddr=0,jaddr2,type;
               ^
../../src/device/r4300/new_dynarec/new_dynarec.c: In function ‘storelr_assemble’:
../../src/device/r4300/new_dynarec/new_dynarec.c:4274:15: warning: unused variable ‘jaddr2’ [-Wunused-variable]
   int jaddr=0,jaddr2;
               ^
../../src/device/r4300/new_dynarec/new_dynarec.c: In function ‘c1ls_assemble’:
../../src/device/r4300/new_dynarec/new_dynarec.c:4516:22: warning: unused variable ‘jaddr3’ [-Wunused-variable]
   int jaddr,jaddr2=0,jaddr3,type;
                      ^
    CC  _obj/main/zip/zip.o
In file included from ../../src/device/r4300/new_dynarec/new_dynarec.c:1687:0:
../../src/device/r4300/new_dynarec/new_dynarec.c: At top level:
../../src/device/r4300/new_dynarec/arm/assem_arm.c:1020:13: warning: ‘regname’ defined but not used [-Wunused-variable]
 static char regname[16][4] = {
             ^
    CC  _obj/main/zip/unzip.o
    CC  _obj/asm_defines/asm_defines.o
    CXX _obj/osd/screenshot.o
nm _obj/asm_defines/asm_defines.o | awk -v dest_dir=""../../src/asm_defines"" -f ../../tools/gen_asm_defines.awk
    CC  _obj/device/r4300/new_dynarec/arm/linkage_arm.o
../../src/device/r4300/new_dynarec/arm/linkage_arm.S: Assembler messages:
../../src/device/r4300/new_dynarec/arm/linkage_arm.S:468: Error: bad instruction `or r0,r0,r12'
../../src/device/r4300/new_dynarec/arm/linkage_arm.S:541: Error: bad instruction `or r0,r0,r2'
{standard input}: Error: invalid operands (*UND* and *UND* sections) for `+' when setting `g_dev_r4300_new_dynarec_hot_state_dynarec_local'
../../src/device/r4300/new_dynarec/arm/linkage_arm.S:190: Error: invalid constant (6b8) after fixup
../../src/device/r4300/new_dynarec/arm/linkage_arm.S:249: Error: invalid constant (4b8) after fixup
../../src/device/r4300/new_dynarec/arm/linkage_arm.S:495: Error: invalid constant (6b8) after fixup
../../src/device/r4300/new_dynarec/arm/linkage_arm.S:507: Error: invalid constant (6b8) after fixup
../../src/device/r4300/new_dynarec/arm/linkage_arm.S:527: Error: invalid constant (6b8) after fixup
../../src/device/r4300/new_dynarec/arm/linkage_arm.S:550: Error: invalid constant (6b8) after fixup
../../src/device/r4300/new_dynarec/arm/linkage_arm.S:619: Error: invalid constant (6b8) after fixup
Makefile:697: recipe for target '_obj/device/r4300/new_dynarec/arm/linkage_arm.o' failed",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,15,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-299437481,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","@dankcushions : Tried to fix some of your errors. However, I'm not sure why I get the invalid constant errors as these values should be the same as before. Can you post the content of the file src/asm_defines/asm_defines_gas.h",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/dankcushions,16,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-299462552,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","@bsmiles32 I don't get an asm_defines_gas.h, but I do get an asm_defines_nasm.h (I guess these are generated?)
%define offsetof_struct_cached_interp_invalid_code (0x00000001-1)
%define offsetof_struct_cp0_count_per_op (0x00000119-1)
%define offsetof_struct_cp0_last_addr (0x00000115-1)
%define offsetof_struct_cp0_tlb (0x0000011d-1)
%define offsetof_struct_device_r4300 (0x00000001-1)
%define offsetof_struct_device_ri (0x03103f19-1)
%define offsetof_struct_new_dynarec_hot_state_address (0x0000005d-1)
%define offsetof_struct_new_dynarec_hot_state_branch_target (0x00000329-1)
%define offsetof_struct_new_dynarec_hot_state_cp0_regs (0x00000199-1)
%define offsetof_struct_new_dynarec_hot_state_cp1_regs_double (0x00000299-1)
%define offsetof_struct_new_dynarec_hot_state_cp1_regs_simple (0x00000219-1)
%define offsetof_struct_new_dynarec_hot_state_cycle_count (0x00000045-1)
%define offsetof_struct_new_dynarec_hot_state_dynarec_local (0x00000001-1)
%define offsetof_struct_new_dynarec_hot_state_fake_pc (0x00000331-1)
%define offsetof_struct_new_dynarec_hot_state_fcr0 (0x0000007d-1)
%define offsetof_struct_new_dynarec_hot_state_fcr31 (0x00000081-1)
%define offsetof_struct_new_dynarec_hot_state_hi (0x00000189-1)
%define offsetof_struct_new_dynarec_hot_state_invc_ptr (0x00000059-1)
%define offsetof_struct_new_dynarec_hot_state_last_count (0x00000049-1)
%define offsetof_struct_new_dynarec_hot_state_lo (0x00000191-1)
%define offsetof_struct_new_dynarec_hot_state_memory_map (0x000006b9-1)
%define offsetof_struct_new_dynarec_hot_state_mini_ht (0x000003b9-1)
%define offsetof_struct_new_dynarec_hot_state_next_interrupt (0x00000041-1)
%define offsetof_struct_new_dynarec_hot_state_pc (0x0000032d-1)
%define offsetof_struct_new_dynarec_hot_state_pcaddr (0x00000051-1)
%define offsetof_struct_new_dynarec_hot_state_pending_exception (0x0000004d-1)
%define offsetof_struct_new_dynarec_hot_state_ram_offset (0x000003b5-1)
%define offsetof_struct_new_dynarec_hot_state_rdword (0x00000061-1)
%define offsetof_struct_new_dynarec_hot_state_regs (0x00000089-1)
%define offsetof_struct_new_dynarec_hot_state_restore_candidate (0x000004b9-1)
%define offsetof_struct_new_dynarec_hot_state_rounding_modes (0x00000319-1)
%define offsetof_struct_new_dynarec_hot_state_stop (0x00000055-1)
%define offsetof_struct_new_dynarec_hot_state_wdword (0x00000071-1)
%define offsetof_struct_new_dynarec_hot_state_wmask (0x00000069-1)
%define offsetof_struct_new_dynarec_hot_state_wword (0x00000079-1)
%define offsetof_struct_r4300_core_cached_interp (0x00000541-1)
%define offsetof_struct_r4300_core_cp0 (0x02900ccd-1)
%define offsetof_struct_r4300_core_extra_memory (0x0050060d-1)
%define offsetof_struct_r4300_core_new_dynarec_hot_state (0x02500611-1)
%define offsetof_struct_r4300_core_return_address (0x000004b9-1)
%define offsetof_struct_r4300_core_save_ebp (0x000004a1-1)
%define offsetof_struct_r4300_core_save_ebx (0x000004a5-1)
%define offsetof_struct_r4300_core_save_edi (0x000004ad-1)
%define offsetof_struct_r4300_core_save_eip (0x000004b5-1)
%define offsetof_struct_r4300_core_save_esi (0x000004a9-1)
%define offsetof_struct_r4300_core_save_esp (0x000004b1-1)
%define offsetof_struct_rdram_dram (0x00000029-1)
%define offsetof_struct_ri_controller_rdram (0x00000021-1)
%define offsetof_struct_tlb_entries (0x00000001-1)
%define offsetof_struct_tlb_LUT_r (0x00000681-1)
%define offsetof_struct_tlb_LUT_w (0x00400681-1)

I still have build errors but maybe that's to do with the above:
    CC  _obj/device/r4300/new_dynarec/arm/linkage_arm.o
../../src/device/r4300/new_dynarec/arm/linkage_arm.S: Assembler messages:
../../src/device/r4300/new_dynarec/arm/linkage_arm.S:110: Error: invalid operands (*UND* and *UND* sections) for `+'
../../src/device/r4300/new_dynarec/arm/linkage_arm.S:190: Error: invalid constant (6b8) after fixup
../../src/device/r4300/new_dynarec/arm/linkage_arm.S:249: Error: invalid constant (4b8) after fixup
../../src/device/r4300/new_dynarec/arm/linkage_arm.S:495: Error: invalid constant (6b8) after fixup
../../src/device/r4300/new_dynarec/arm/linkage_arm.S:507: Error: invalid constant (6b8) after fixup
../../src/device/r4300/new_dynarec/arm/linkage_arm.S:527: Error: invalid constant (6b8) after fixup
../../src/device/r4300/new_dynarec/arm/linkage_arm.S:550: Error: invalid constant (6b8) after fixup
../../src/device/r4300/new_dynarec/arm/linkage_arm.S:619: Error: invalid constant (6b8) after fixup
Makefile:697: recipe for target '_obj/device/r4300/new_dynarec/arm/linkage_arm.o' failed",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/Gillou68310,17,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-299477965,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","I fix the new dynarec x86 up to this commit 2b04d6f the same patch should apply to hword.
Gillou68310@0d30fb5
The main problem is that you're modifying registers that are allocated and used in following instructions.
Just for your knowledge on ARM you can use the never allocated HOST_TEMPREG register.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,18,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-299486642,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","@Gillou68310 Thanks for helping ! If you want you can push your commits directly here as you still have push access to my repo. Also do you have any idea how to fix linkage_arm.S, because @dankcushions reported some failures related to moving variables inside new_dynarec_hot_state ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/Gillou68310,19,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-299506899,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","The immediate value could not be encoded see https://alisdair.mcdiarmid.org/arm-immediate-value-encoding/
Try replacing:
add r3, fp, #fp_restore_candidate

by
movw r3, #:lower16:fp_restore_candidate
movt r3, #:upper16:fp_restore_candidate
add  r3, fp, r3

Same for fp_memory_map
The first error is unclear try adding the offsets to r12 directly in new_dyna_start. Also your code is not PIC compliant you need to add:
.gdevptr_offset  : .word g_dev-(.gdevptr_pic+8)

...
    ldr    r12, .gdevptr_offset
.gdevptr_pic:
    add    r12, pc, r12",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,20,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-299508948,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","Thanks. However I don't get why it worked before and not now ? restore_candidate and memory_map offsets should be the same as before, shouldn't they ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,21,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-299509407,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","I'll try to fix this later, if you don't do it first 😀",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/Gillou68310,22,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-299509920,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)",They probably are not the same as before because the alignement is not the same see .align directive. Moreover the compiler can add padding where there was no padding before.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/loganmc10,23,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-299776504,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","I just briefly tested a few games using the x86 new dynarec and everything seems to be working properly now, no more assert :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/Gillou68310,24,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-300153614,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","I really like the idea of this PR but I'm not a big fan of doing all the shifts within the instruction definition (or recompiled code in case of dynarec). Wouldn't it be easier to just use a ""type"" variable instead of the ""mask"" variable?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,25,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-300183623,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","I indeed moved some more logic in the instructions definition and recompiled code, but I don't see any other way of doing these stuff easily. To give you more context of what I want to achieve (in the long term) is to implement a ""fast mem"" approach where rdram,rom,pifbootrom,imem,dmem,sram,flashram are mmapped at proper addresses so that accessing them is just a mov instruction (and some sign extension stuff for lb,lh). Other regions will trigger a pagefault and a custom handler will call the appropriate r/w handler. So in the long term all this logic will be removed from instruction definition. There will be only a normal memory access in the instruction and the pagefault handler will have this logic, but should be invoked too much :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,26,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-300185738,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","As for the mask, it indeed is more computation in instruction definition (for now), but it simplifies the memory handlers as they only have a mask to apply. Otherwise each of them would have to do that shifting logic themselves which I don't really like. Or maybe I haven't understood your idea correctly ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,27,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-300201787,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)",Rebased against latest less_g_dev. Hope no regression happened :),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/Gillou68310,28,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-300218214,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","Otherwise each of them would have to do that shifting logic themselves which I don't really like.

You're right that's not a good idea either ;-)

I indeed moved some more logic in the instructions definition and recompiled code, but I don't see any other way of doing these stuff easily. To give you more context of what I want to achieve (in the long term) is to implement a ""fast mem"" approach where rdram,rom,pifbootrom,imem,dmem,sram,flashram are mmapped at proper addresses so that accessing them is just a mov instruction (and some sign extension stuff for lb,lh). Other regions will trigger a pagefault and a custom handler will call the appropriate r/w handler. So in the long term all this logic will be removed from instruction definition. There will be only a normal memory access in the instruction and the pagefault handler will have this logic, but should be invoked too much :)

Ok this sounds like a good plan :-)
I just don't like what we are doing in the new dynarec to make it work but if you say that this is just a temporary fix then I'm ok with it ;-)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/dankcushions,29,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-300251696,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","i'm getting a compiler error (RPI3/ARM) at the moment:
Makefile:115: Architecture ""armv7l"" not officially supported.'
    CC  _obj/api/callbacks.o
cc1: internal compiler error: Segmentation fault
Please submit a full bug report,
with preprocessed source if appropriate.
See <file:///usr/share/doc/gcc-4.9/README.Bugs> for instructions.
    CC  _obj/api/common.o
cc1: internal compiler error: Segmentation fault
Please submit a full bug report,
with preprocessed source if appropriate.
See <file:///usr/share/doc/gcc-4.9/README.Bugs> for instructions.
Makefile:700: recipe for target '_obj/api/callbacks.o' failed
make: *** [_obj/api/callbacks.o] Error 1
make: *** Waiting for unfinished jobs....
Makefile:700: recipe for target '_obj/api/common.o' failed
make: *** [_obj/api/common.o] Error 1

not really sure what that means!",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/loganmc10,30,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-300267102,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","You might want to start from a fresh directory (maybe delete and re-clone the repo?), it seems like something is wrong there besides potentially incorrect code",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,31,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-300323123,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","@Gillou68310 Indeed the uglyness of the new dynarec increased a bit with this PR. I really want to implement the mmap based approach because I feel it will speed things up quite a bit, but time is what I miss.... Hope I will get there eventually.
@dankcushions Thanks for trying again ! The internal GCC error is indeed suspicious. Hope starting fresh as suggested by loganmc10 will help.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/dankcushions,32,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-300442740,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","a reboot fixed it, which is very strange for linux, but ok! anyway, latest errors:
    CC  _obj/device/r4300/new_dynarec/arm/linkage_arm.o
../../src/device/r4300/new_dynarec/arm/linkage_arm.S: Assembler messages:
../../src/device/r4300/new_dynarec/arm/linkage_arm.S:397: Error: offset out of range
../../src/device/r4300/new_dynarec/arm/linkage_arm.S:398: Error: offset out of range
Makefile:697: recipe for target '_obj/device/r4300/new_dynarec/arm/linkage_arm.o' failed
make: *** [_obj/device/r4300/new_dynarec/arm/linkage_arm.o] Error 1",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,33,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-300519214,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)",Rebased against latest less_g_dev. @dankcushions can you test ?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/dankcushions,34,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-300538792,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)",it compiles for me now 👍,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,35,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-300600257,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)",Does it runs as expected ? 😀,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/dankcushions,36,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-300903199,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","segfault :(
gdb backtrace (but i don't think it's particularly useful):
pi@retropie:~ $ gdb --args /opt/retropie/emulators/mupen64plus/bin/mupen64plus --noosd --windowed 320x240 --rsp /opt/retropie/emulators/mupen64plus/lib/mupen64plus/mupen64plus-rsp-hle.so --gfx /opt/retropie/emulators/mupen64plus/lib/mupen64plus/mupen64plus-video-GLideN64.so --audio /opt/retropie/emulators/mupen64plus/lib/mupen64plus/mupen64plus-audio-omx.so --configdir /opt/retropie/configs/n64 --datadir /opt/retropie/configs/n64 /home/pi/RetroPie/roms/n64/supermario64.n64
GNU gdb (Raspbian 7.7.1+dfsg-5+rpi1) 7.7.1
Copyright (C) 2014 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type ""show copying""
and ""show warranty"" for details.
This GDB was configured as ""arm-linux-gnueabihf"".
Type ""show configuration"" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type ""help"".
Type ""apropos word"" to search for commands related to ""word""...
Reading symbols from /opt/retropie/emulators/mupen64plus/bin/mupen64plus...(no debugging symbols found)...done.
(gdb) tty /dev/tty1
(gdb) run
Starting program: /opt/retropie/emulators/mupen64plus/bin/mupen64plus --noosd --windowed 320x240 --rsp /opt/retropie/emulators/mupen64plus/lib/mupen64plus/mupen64plus-rsp-hle.so --gfx /opt/retropie/emulators/mupen64plus/lib/mupen64plus/mupen64plus-video-GLideN64.so --audio /opt/retropie/emulators/mupen64plus/lib/mupen64plus/mupen64plus-audio-omx.so --configdir /opt/retropie/configs/n64 --datadir /opt/retropie/configs/n64 /home/pi/RetroPie/roms/n64/supermario64.n64
[Thread debugging using libthread_db enabled]
Using host libthread_db library ""/lib/arm-linux-gnueabihf/libthread_db.so.1"".
[New Thread 0x6a16e460 (LWP 20369)]
[New Thread 0x6896c460 (LWP 20370)]
[New Thread 0x67fff460 (LWP 20371)]
[New Thread 0x677ff460 (LWP 20372)]
[New Thread 0x66fff460 (LWP 20373)]
[New Thread 0x667ff460 (LWP 20374)]
[New Thread 0x65fff460 (LWP 20375)]
[New Thread 0x657ff460 (LWP 20376)]
[New Thread 0x6417d460 (LWP 20377)]
[New Thread 0x6397d460 (LWP 20378)]
[New Thread 0x6317d460 (LWP 20379)]
[Thread 0x6417d460 (LWP 20377) exited]
[Thread 0x6317d460 (LWP 20379) exited]
[Thread 0x6397d460 (LWP 20378) exited]
Cannot access memory at address 0x0

Program received signal SIGSEGV, Segmentation fault.
Cannot access memory at address 0x0
0x6ab9a028 in ?? () from /opt/retropie/emulators/mupen64plus/lib/libmupen64plus.so.2
(gdb) bt
Cannot access memory at address 0x0
#0  0x6ab9a028 in ?? () from /opt/retropie/emulators/mupen64plus/lib/libmupen64plus.so.2
#1  0x6ab9a010 in ?? () from /opt/retropie/emulators/mupen64plus/lib/libmupen64plus.so.2
Cannot access memory at address 0x0
Backtrace stopped: previous frame identical to this frame (corrupt stack?)
(gdb) 

as a control i ran master build through the same gdb launch sequence, and it worked fine. could rebuild in debug /-g mode, perhaps tomorrow.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/dankcushions,37,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-301045161,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","I've tried building with DEBUG=1, DBG_CORE=1 etc and the trace doesn't get any better! out of ideas here, but maybe there's a clue above that i'm missing :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,38,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-301208280,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","Thanks for your feedback. The bt is indeed not very helpful. Either we're lucky and we find the bogus part just reading the code, or I rework the commits to make it bissectable, then we inspect each commit. Hope to have some time in the coming days to work on this.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/loganmc10,39,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-301210933,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)",I'll get my Raspberry Pi working and I'll try to see if I can track down the commit over the next few days,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,40,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-301222209,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)",@dankcushions Can you test if things are OK on ARM up to commit 4853f58 ? That would allow me to merge the less_g_dev PR and reduce the bissection range.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/loganmc10,41,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-301223228,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","@bsmiles32 I got my rpi working, I also get a segfault.
I tried compiling 4853f58, I get:
../../src/device/r4300/new_dynarec/arm/linkage_arm.S:557:0: error: unterminated #else
 #ifdef ARMv5_ONLY",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/loganmc10,42,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-301223425,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","Line 562 has ""endi"" instead of ""endif"" in that commit",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,43,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-301223949,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)",@loganmc10 Just pushed a fix for that typo. Good Catch !,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/loganmc10,44,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-301224098,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","So after fixing that typo, I still get a segfault at 4853f58/628d823. I get a better backtrace though:
#0  emit_storereg (hr=10, r=<optimized out>) at ../../src/device/r4300/new_dynarec/arm/assem_arm.c:1254
#1  wb_register.lto_priv.1080 (r=36 '$', regmap=regmap@entry=0x358448 <error: Cannot access memory at address 0x358448>, dirty=<optimized out>, is32=is32@entry=1)
    at ../../src/device/r4300/new_dynarec/new_dynarec.c:3061
#2  0x6ace6a7c in new_recompile_block (addr=<optimized out>) at ../../src/device/r4300/new_dynarec/new_dynarec.c:10646
#3  0x6ad52b58 in .outptr_pic () at ../../src/device/r4300/new_dynarec/arm/linkage_arm.S:403
Backtrace stopped: previous frame identical to this frame (corrupt stack?)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,45,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-301267524,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)",@Gillou68310 Thanks for thourough review ! I fixed what you pointed me to.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/loganmc10,46,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-301281085,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","Just tested the latest with Mario 64, got this:
Program received signal SIGSEGV, Segmentation fault.
wb_base_reg () at ../../src/device/r4300/new_dynarec/arm/linkage_arm.S:668
668	    ldr    r0, [r8, r7, lsl #2]
(gdb) backtrace
#0  wb_base_reg () at ../../src/device/r4300/new_dynarec/arm/linkage_arm.S:668
#1  0x6ae4e594 in tlb_exception () at ../../src/device/r4300/new_dynarec/arm/linkage_arm.S:644
Backtrace stopped: previous frame identical to this frame (corrupt stack?)

Also a couple of warnings:
In file included from ../../src/device/r4300/new_dynarec/new_dynarec.c:1687:0:
../../src/device/r4300/new_dynarec/arm/assem_arm.c: In function ‘isclean’:
../../src/device/r4300/new_dynarec/arm/assem_arm.c:433:12: warning: pointer targets in initialization differ in signedness [-Wpointer-sign]
   int *ptr=((u_int *)addr)+6;
            ^
In file included from ../../src/device/r4300/new_dynarec/new_dynarec.c:1687:0:
../../src/device/r4300/new_dynarec/arm/assem_arm.c: In function ‘alloc_arm_reg’:
../../src/device/r4300/new_dynarec/arm/assem_arm.c:982:3: warning: array subscript has type ‘char’ [-Wchar-subscripts]
   cur->regmap[hr]=reg;
   ^",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,47,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-301374333,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)",Rebased with latest changes from less_g_dev PR. ARM new dynarec still not working.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/loganmc10,48,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-301493970,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","So I tested the first commit (3e14f9d), and I cherry-picked ea0da04 to get it to compile, this is what I get:
mupen64plus: ../../src/device/r4300/new_dynarec/new_dynarec.c:8272: new_recompile_block: Assertion `i<4096-1' failed.

b4528b8 is when it moves from the assertion failure to a segfault:
wb_base_reg () at ../../src/device/r4300/new_dynarec/arm/linkage_arm.S:707
707         ldr    r0, [r8, r7, lsl #2]
(gdb) backtrace
#0  wb_base_reg () at ../../src/device/r4300/new_dynarec/arm/linkage_arm.S:707
#1  0x6adce798 in tlb_exception () at ../../src/device/r4300/new_dynarec/arm/linkage_arm.S:683
Backtrace stopped: previous frame identical to this frame (corrupt stack?)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,49,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-301494778,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","Rebased this PR against master and reorganized the ""fix up"" commits to ease bissecting.
Edit: rebased again to squash one commit I forgot.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,50,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-301511909,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)",@loganmc10 If you use HOST_TEMPREG instead of rt in write_stubs (both) does that fixes the assert ?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,51,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-301512424,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)",@Gillou68310 Which registers a I allowed to use/trash in the assembly written read/write_XXX_new routines ?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/loganmc10,52,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-301515569,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","I don't understand assembly very well, you'll have to be more specific, am I replacing every instance of rt inside do_writestub and inline_writestub? Or am I just replacing the rt's in the lines that you added?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,53,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-301524715,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","@loganmc10 Added a commit just after wmask introduction to test my hypothesis. If this commit (abbf11b) fixes the assert, we can aply similar fixes for subsequent commits.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/loganmc10,54,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-301528684,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","@bsmiles32 I checked out abbf11b, and yes, that fixes the assert.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/Gillou68310,55,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-301539049,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","Current WIP:
Gillou68310@1e2f704
The purpose of this commit is to reduce changes to the recompiled code.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/Gillou68310,56,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-301539328,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)",I'll try to do the same for ARM this week,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,57,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-301548346,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","@Gillou68310 : If I understand correctly, you moved the shift logic to C functions in order to simplify things down to a simple call. This way we don't have to do the dancing with registers to do the shifting in assembly :) I'll let you take the lead on this until you're done. If you feel like you can update this PR directly as you still have push access to my repo.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/Gillou68310,58,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-301550110,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)",Sure I'll push the commit once I'm done with the ARM backend ;-),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/Gillou68310,59,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-301685008,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","Arf my commit breaks TLB exceptions, I need to wrote those C functions in assembly to keep control over the stack address.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/Gillou68310,60,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-302440474,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","More work on x86 Gillou68310@a33ce25
For some unknown reason dumpbin is returning wrong offset values for readmem/readmemd/writemem/writememd. I managed to fix the issue by assigning a different section name for each tab in asm_defines.c using the __pragma(const_seg(""name"")) directive.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,61,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-302467099,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","@Gillou68310 Nice simplification of the code. The wrong offsets issue is worrying, but god that you've found a way around that. Maybe adding a small comment about why you had to put the pragma would help future reader. Really looking forward for more progress :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/Gillou68310,62,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-302744302,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","Here's the ARM implementation Gillou68310@67e6e0d
It's time to look for regressions ;-)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/dankcushions,63,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-302878922,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)",@Gillou68310 just tested that on RPI3 + mario 64. Seems fine to me 👍,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/Gillou68310,64,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-303045622,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)",Thanks for testing ;-),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,65,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-303554032,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","I'll let some more days for testing, and merge it if nobody finds regressions.
@Gillou68310 : Thanks a lot for your help on this !!!
Thanks also for all the testers :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,66,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-304762272,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)",Added the commits from @Gillou68310 to this PR,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/dankcushions,67,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-305647310,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)",I rebuilt and tested (mario 64) the combined PR on RPI3/ARM - all working :),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,269,2017-05-02T02:23:03Z,2017-06-02T13:28:44Z,2017-06-02T13:52:18Z,MERGED,True,1008,1331,18,https://github.com/bsmiles32,Remove byte and hword accessors,25,[],https://github.com/mupen64plus/mupen64plus-core/pull/269,https://github.com/bsmiles32,68,https://github.com/mupen64plus/mupen64plus-core/pull/269#issuecomment-305786917,"With this PR I'm trying to remove byte and hword memory accessors as it adds lots of duplication and bloat. I already tried and failed in a previous attempt (PR47). This time, I went much more gradually (each commit is buildable and should be easily inspectable in case of any regression). I left the dword accessors for a later PR as it require some more work, and I'd like this PR to get some testing early. I'm looking especially for testing on the dynarecs (both Hacktarux and new_dynarec).
I'm really looking forward to get this tested and merged ! This is something I've been hoping for some years now :)","As nobody complained, I guess I can merge that.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,270,2017-05-02T20:35:31Z,2017-05-10T06:34:05Z,2017-06-02T16:44:03Z,MERGED,True,0,25,1,https://github.com/loganmc10,Remove custom CountPerScanline values,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/270,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/270,"When these were initially committed, I just copied the values from Project64. Given that that change broke Indiana Jones, it's probably best to remove these values. There is no evidence that they make any improvement, so it's safer to remove them.
At least now there is a core option to modify this value, so if someone is so inclined, they could test out different values to see if they make any difference for a particular game.","When these were initially committed, I just copied the values from Project64. Given that that change broke Indiana Jones, it's probably best to remove these values. There is no evidence that they make any improvement, so it's safer to remove them.
At least now there is a core option to modify this value, so if someone is so inclined, they could test out different values to see if they make any difference for a particular game.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,270,2017-05-02T20:35:31Z,2017-05-10T06:34:05Z,2017-06-02T16:44:03Z,MERGED,True,0,25,1,https://github.com/loganmc10,Remove custom CountPerScanline values,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/270,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/270#issuecomment-298957653,"When these were initially committed, I just copied the values from Project64. Given that that change broke Indiana Jones, it's probably best to remove these values. There is no evidence that they make any improvement, so it's safer to remove them.
At least now there is a core option to modify this value, so if someone is so inclined, they could test out different values to see if they make any difference for a particular game.",Are you sure that it was CountPerScanline and not the CountPerOp setting that was breaking Indiana Jones?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,270,2017-05-02T20:35:31Z,2017-05-10T06:34:05Z,2017-06-02T16:44:03Z,MERGED,True,0,25,1,https://github.com/loganmc10,Remove custom CountPerScanline values,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/270,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/270#issuecomment-298973444,"When these were initially committed, I just copied the values from Project64. Given that that change broke Indiana Jones, it's probably best to remove these values. There is no evidence that they make any improvement, so it's safer to remove them.
At least now there is a core option to modify this value, so if someone is so inclined, they could test out different values to see if they make any difference for a particular game.","Sorry by ""these settings"" I mean the CountPerOp/CountPerScanline changes that I took from Project64
Setting CountPerOp to 1 on Indiana Jones breaks the sound for me (on x64), CountPerScanline doesn't seem to make any difference.
CountPerScanline doesn't really seem to make any difference for any game to be honest. Project64 and mupen64plus calculate the timing differently, so they might not do the same thing. My point is that since these settings weren't tested, they were just copied from Project64, they should be removed. If someone tests a game with a certain CountPerScanline, and it improves things, then it should be added. That was my error when I initially committed these values.
However, CountPerOp=3 for Beetle Adventure Racing (which was copied from Project64) does seem to be the right change. If you watch the intro, there is a point where the car jumps off a ramp and crashes into the water, then it says ""Action!"". With CountPerOp=2, ""Action!"" is displayed at the wrong time, with CountPerOp=3, it is displayed correctly, as confirmed via a YouTube clip somebody posted of a real N64 playing the intro. So I've kept that changed.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,271,2017-05-04T14:18:51Z,2017-05-10T06:37:29Z,2017-06-02T16:44:02Z,MERGED,True,6,0,1,https://github.com/loganmc10,DK64 Bone Displacement fix,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/271,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/271,See #145 (comment),See #145 (comment),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,272,2017-05-05T18:24:01Z,2017-05-10T06:41:08Z,2017-06-02T16:43:52Z,MERGED,True,3,0,1,https://github.com/loganmc10,Fix audio in Star Wars Episode I - Racer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/272,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/272,"During the intro scene, there should be audio. There currently isn't.
Setting CountPerOp=1 fixes the audio (it's not just the intro scene that is missing the audio).
Project64 has the same issue (Counter Factor=1 is the default for them for this game, but if you set it to Counter Factor=2, you lose the audio)","During the intro scene, there should be audio. There currently isn't.
Setting CountPerOp=1 fixes the audio (it's not just the intro scene that is missing the audio).
Project64 has the same issue (Counter Factor=1 is the default for them for this game, but if you set it to Counter Factor=2, you lose the audio)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,275,2017-05-15T18:48:22Z,2017-05-15T18:55:33Z,2017-05-15T18:55:48Z,MERGED,True,1,1,1,https://github.com/TheFlagCourier,README.md URL fix,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/275,https://github.com/TheFlagCourier,1,https://github.com/mupen64plus/mupen64plus-core/pull/275,Fixed a small formatting error in the README file's markdown that was improperly linking to the Mupen64Plus site.,Fixed a small formatting error in the README file's markdown that was improperly linking to the Mupen64Plus site.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,275,2017-05-15T18:48:22Z,2017-05-15T18:55:33Z,2017-05-15T18:55:48Z,MERGED,True,1,1,1,https://github.com/TheFlagCourier,README.md URL fix,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/275,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/275#issuecomment-301570234,Fixed a small formatting error in the README file's markdown that was improperly linking to the Mupen64Plus site.,Thanks for your contribution.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,278,2017-05-15T23:53:27Z,2017-05-23T22:37:12Z,2017-05-24T00:08:01Z,MERGED,True,20,11,5,https://github.com/bsmiles32,Avoid usage of g_dev in rdram_deteciton_hack.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/278,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/278,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,279,2017-05-17T17:12:55Z,2017-05-17T17:25:24Z,2017-06-02T16:43:51Z,CLOSED,False,17,17,1,https://github.com/loganmc10,Fix E and J cheat code values for MK64,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/279,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/279,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,279,2017-05-17T17:12:55Z,2017-05-17T17:25:24Z,2017-06-02T16:43:51Z,CLOSED,False,17,17,1,https://github.com/loganmc10,Fix E and J cheat code values for MK64,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/279,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/279#issuecomment-302163053,,I still need to test this so please don't merge yet,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,280,2017-05-17T17:28:02Z,2017-05-23T22:41:20Z,2017-06-02T16:43:49Z,MERGED,True,0,34,1,https://github.com/loganmc10,Remove MK64 cheat for E and J,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/280,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/280,"This cheat code is for the U version of the ROM. Until someone calculates the proper values for E and J, it should be removed.","This cheat code is for the U version of the ROM. Until someone calculates the proper values for E and J, it should be removed.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,281,2017-05-18T04:03:33Z,2017-05-23T22:42:05Z,2017-05-24T00:07:59Z,MERGED,True,434,336,4,https://github.com/bsmiles32,Pass pointer to fcr31 around in fpu.h functions to avoid usage of g_dev.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/281,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/281,Another step toward global variable free emulation code.,Another step toward global variable free emulation code.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,282,2017-05-18T06:46:44Z,2017-05-23T22:41:50Z,2017-05-24T00:07:55Z,MERGED,True,159,91,31,https://github.com/bsmiles32,No g dev in interrupt,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/282,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/282,"Remove usage of g_dev in interrupt. The tricky commit is the last one which reworks how the first VI is triggered. This is because, the code which handle initialization, reset, NMI, pifbootrom, ... is quite bad. But I guess that's will be for another PR.","Remove usage of g_dev in interrupt. The tricky commit is the last one which reworks how the first VI is triggered. This is because, the code which handle initialization, reset, NMI, pifbootrom, ... is quite bad. But I guess that's will be for another PR.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,282,2017-05-18T06:46:44Z,2017-05-23T22:41:50Z,2017-05-24T00:07:55Z,MERGED,True,159,91,31,https://github.com/bsmiles32,No g dev in interrupt,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/282,https://github.com/dankcushions,2,https://github.com/mupen64plus/mupen64plus-core/pull/282#issuecomment-302880455,"Remove usage of g_dev in interrupt. The tricky commit is the last one which reworks how the first VI is triggered. This is because, the code which handle initialization, reset, NMI, pifbootrom, ... is quite bad. But I guess that's will be for another PR.",Tested on RPI3 (ARM) + mario 64. Built and ran fine 👍,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,289,2017-05-24T20:21:56Z,2017-05-25T23:54:39Z,2017-06-02T16:43:41Z,MERGED,True,38,9,8,https://github.com/loganmc10,Fix Twisted Edge audio,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/289,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/289,"Fixes #285
This is a combination of these 2 commits:
project64/project64@f24c464
Azimer/AziAudio@7140f74
Firstly, AI_LEN_REG should be a multiple of 8, so I modified get_remaining_dma_length accordingly. This may fix other audio issues if they exist, I'm not sure. This is what allowed the audio samples to start getting sent to the audio plugin.
Secondly, Twisted Edge has some strange behaviour with AI_DRAM_ADDR_REG, it points to the wrong address. The ""FixedAudioPos"" hack takes the first AI_DRAM_ADDR_REG value, and uses that for the rest of the game, ignoring future values.
I compared to Project64 and it sounds the same to me.","Fixes #285
This is a combination of these 2 commits:
project64/project64@f24c464
Azimer/AziAudio@7140f74
Firstly, AI_LEN_REG should be a multiple of 8, so I modified get_remaining_dma_length accordingly. This may fix other audio issues if they exist, I'm not sure. This is what allowed the audio samples to start getting sent to the audio plugin.
Secondly, Twisted Edge has some strange behaviour with AI_DRAM_ADDR_REG, it points to the wrong address. The ""FixedAudioPos"" hack takes the first AI_DRAM_ADDR_REG value, and uses that for the rest of the game, ignoring future values.
I compared to Project64 and it sounds the same to me.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,289,2017-05-24T20:21:56Z,2017-05-25T23:54:39Z,2017-06-02T16:43:41Z,MERGED,True,38,9,8,https://github.com/loganmc10,Fix Twisted Edge audio,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/289,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/289#issuecomment-304107770,"Fixes #285
This is a combination of these 2 commits:
project64/project64@f24c464
Azimer/AziAudio@7140f74
Firstly, AI_LEN_REG should be a multiple of 8, so I modified get_remaining_dma_length accordingly. This may fix other audio issues if they exist, I'm not sure. This is what allowed the audio samples to start getting sent to the audio plugin.
Secondly, Twisted Edge has some strange behaviour with AI_DRAM_ADDR_REG, it points to the wrong address. The ""FixedAudioPos"" hack takes the first AI_DRAM_ADDR_REG value, and uses that for the rest of the game, ignoring future values.
I compared to Project64 and it sounds the same to me.","This change (specifically making sure that get_remaining_dma_length returns a multiple of 8) also fixes the choppy engine sound in Top Gear Rally (#200) @fzurita
EDIT: It still doesn't sound perfect to my ear, but it is now exactly on par with Project64 as far as I can tell (whereas before, mupen64plus had choppy engine sound, PJ64 did not).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,289,2017-05-24T20:21:56Z,2017-05-25T23:54:39Z,2017-06-02T16:43:41Z,MERGED,True,38,9,8,https://github.com/loganmc10,Fix Twisted Edge audio,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/289,https://github.com/fzurita,3,https://github.com/mupen64plus/mupen64plus-core/pull/289#issuecomment-304113839,"Fixes #285
This is a combination of these 2 commits:
project64/project64@f24c464
Azimer/AziAudio@7140f74
Firstly, AI_LEN_REG should be a multiple of 8, so I modified get_remaining_dma_length accordingly. This may fix other audio issues if they exist, I'm not sure. This is what allowed the audio samples to start getting sent to the audio plugin.
Secondly, Twisted Edge has some strange behaviour with AI_DRAM_ADDR_REG, it points to the wrong address. The ""FixedAudioPos"" hack takes the first AI_DRAM_ADDR_REG value, and uses that for the rest of the game, ignoring future values.
I compared to Project64 and it sounds the same to me.",Cool! I'll have to try it out.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,289,2017-05-24T20:21:56Z,2017-05-25T23:54:39Z,2017-06-02T16:43:41Z,MERGED,True,38,9,8,https://github.com/loganmc10,Fix Twisted Edge audio,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/289,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/289#issuecomment-304133364,"Fixes #285
This is a combination of these 2 commits:
project64/project64@f24c464
Azimer/AziAudio@7140f74
Firstly, AI_LEN_REG should be a multiple of 8, so I modified get_remaining_dma_length accordingly. This may fix other audio issues if they exist, I'm not sure. This is what allowed the audio samples to start getting sent to the audio plugin.
Secondly, Twisted Edge has some strange behaviour with AI_DRAM_ADDR_REG, it points to the wrong address. The ""FixedAudioPos"" hack takes the first AI_DRAM_ADDR_REG value, and uses that for the rest of the game, ignoring future values.
I compared to Project64 and it sounds the same to me.",Ok I've updated the PR. I agree that a hack is not ideal. At least it's fairly non-intrusive/small. Hopefully somebody in the future can figure out how it should work properly.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,290,2017-05-25T16:02:04Z,2017-05-25T21:03:53Z,2017-06-02T16:43:42Z,MERGED,True,3,3,1,https://github.com/loganmc10,Fix audio in RE2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/290,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/290,"This fixes the audio in the FMV's in RE2. The voices are now back, and the audio is in sync with the video.
I tested the U version. GLideN64 + CXD4 (HLE video). 32-bit Mupen64Plus with new dynarec","This fixes the audio in the FMV's in RE2. The voices are now back, and the audio is in sync with the video.
I tested the U version. GLideN64 + CXD4 (HLE video). 32-bit Mupen64Plus with new dynarec",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,293,2017-05-27T19:37:53Z,2017-05-27T19:42:14Z,2017-06-02T13:52:24Z,MERGED,True,336,434,4,https://github.com/bsmiles32,"Revert ""Pass pointer to fcr31 around in fpu.h functions to avoid usag…",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/293,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/293,"…e of g_dev.""
This reverts commit 936c00c.
This commit caused crashes on the ARM new dynarec. Need further investigation.","…e of g_dev.""
This reverts commit 936c00c.
This commit caused crashes on the ARM new dynarec. Need further investigation.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,295,2017-05-27T21:06:09Z,2017-06-23T02:43:20Z,2017-06-23T02:44:28Z,MERGED,True,434,336,4,https://github.com/bsmiles32,[WIP] Pass pointer to fcr31 around in fpu.h functions to avoid usage of g_dev.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/295,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/295,Reopening this PR with the hope of fixing the remaining issue with ARM dynarec.,Reopening this PR with the hope of fixing the remaining issue with ARM dynarec.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,295,2017-05-27T21:06:09Z,2017-06-23T02:43:20Z,2017-06-23T02:44:28Z,MERGED,True,434,336,4,https://github.com/bsmiles32,[WIP] Pass pointer to fcr31 around in fpu.h functions to avoid usage of g_dev.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/295,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/295#issuecomment-305797917,Reopening this PR with the hope of fixing the remaining issue with ARM dynarec.,@Gillou68310 I also assigned you this one as you are way more competent for finding why this breaks the ARM dynarec.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,295,2017-05-27T21:06:09Z,2017-06-23T02:43:20Z,2017-06-23T02:44:28Z,MERGED,True,434,336,4,https://github.com/bsmiles32,[WIP] Pass pointer to fcr31 around in fpu.h functions to avoid usage of g_dev.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/295,https://github.com/Gillou68310,3,https://github.com/mupen64plus/mupen64plus-core/pull/295#issuecomment-309711421,Reopening this PR with the hope of fixing the remaining issue with ARM dynarec.,"emit_readword((u_int)&g_dev.r4300.new_dynarec_hot_state.fcr31,ARG1_REG);
The above will read the value of fcr31 into ARG1_REG.
To read the address of fcr31 into ARG1_REG you should use:
emit_movimm((u_int)&g_dev.r4300.new_dynarec_hot_state.fcr31,ARG1_REG);",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,295,2017-05-27T21:06:09Z,2017-06-23T02:43:20Z,2017-06-23T02:44:28Z,MERGED,True,434,336,4,https://github.com/bsmiles32,[WIP] Pass pointer to fcr31 around in fpu.h functions to avoid usage of g_dev.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/295,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/295#issuecomment-310435574,Reopening this PR with the hope of fixing the remaining issue with ARM dynarec.,"I tried the fix suggested on Android (https://github.com/loganmc10/mupen64plus-ae/commit/ca1feba28f3d05b583a99954d34f1bcd7ec61baf)
It seems to work, no segfaults anymore.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,295,2017-05-27T21:06:09Z,2017-06-23T02:43:20Z,2017-06-23T02:44:28Z,MERGED,True,434,336,4,https://github.com/bsmiles32,[WIP] Pass pointer to fcr31 around in fpu.h functions to avoid usage of g_dev.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/295,https://github.com/bsmiles32,5,https://github.com/mupen64plus/mupen64plus-core/pull/295#issuecomment-310555219,Reopening this PR with the hope of fixing the remaining issue with ARM dynarec.,"@Gillou68310 : Thank you or looking into this, I wouldn't have guessed myself :)
@loganmc10 : Also thanks for testing @Gillou68310 suggestion, I had already done the fix myself some days ago, but couldn't push them because was offline for a couple of day.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,296,2017-05-28T05:50:04Z,2017-06-02T13:41:12Z,2017-09-15T05:06:24Z,MERGED,True,47,47,3,https://github.com/comex,Fix undefined behavior in the interpreter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/296,https://github.com/comex,1,https://github.com/mupen64plus/mupen64plus-core/pull/296,"Partially fixes #87, but there are probably more potential overflows lurking in there; I didn't go over it too thoroughly.
FYI: In C, integer overflow when adding and multiplying signed integers is undefined, as is shifting any integer by too high a width, and left-shifting a signed integer if it changes the sign.  GCC started performing optimizations based on these a decade ago, but those optimizations don't usually apply in any particular situation, so usually you just get away with it.
But on my system, with clang-802.0.42, Mario 64 actually fails to boot in the interpreter without this patch: it fails the ROM checksum test performed early on (at 0x800001AC).  (Not sure exactly which operation was responsible; I compiled with -fsanitize=undefined, fixed everything that made it crash under that and some nearby code, and now Mario 64 works.  However, all of the changes here should be correct/necessary.)","Partially fixes #87, but there are probably more potential overflows lurking in there; I didn't go over it too thoroughly.
FYI: In C, integer overflow when adding and multiplying signed integers is undefined, as is shifting any integer by too high a width, and left-shifting a signed integer if it changes the sign.  GCC started performing optimizations based on these a decade ago, but those optimizations don't usually apply in any particular situation, so usually you just get away with it.
But on my system, with clang-802.0.42, Mario 64 actually fails to boot in the interpreter without this patch: it fails the ROM checksum test performed early on (at 0x800001AC).  (Not sure exactly which operation was responsible; I compiled with -fsanitize=undefined, fixed everything that made it crash under that and some nearby code, and now Mario 64 works.  However, all of the changes here should be correct/necessary.)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,296,2017-05-28T05:50:04Z,2017-06-02T13:41:12Z,2017-09-15T05:06:24Z,MERGED,True,47,47,3,https://github.com/comex,Fix undefined behavior in the interpreter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/296,https://github.com/comex,2,https://github.com/mupen64plus/mupen64plus-core/pull/296#issuecomment-304752406,"Partially fixes #87, but there are probably more potential overflows lurking in there; I didn't go over it too thoroughly.
FYI: In C, integer overflow when adding and multiplying signed integers is undefined, as is shifting any integer by too high a width, and left-shifting a signed integer if it changes the sign.  GCC started performing optimizations based on these a decade ago, but those optimizations don't usually apply in any particular situation, so usually you just get away with it.
But on my system, with clang-802.0.42, Mario 64 actually fails to boot in the interpreter without this patch: it fails the ROM checksum test performed early on (at 0x800001AC).  (Not sure exactly which operation was responsible; I compiled with -fsanitize=undefined, fixed everything that made it crash under that and some nearby code, and now Mario 64 works.  However, all of the changes here should be correct/necessary.)",Added another fix.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,296,2017-05-28T05:50:04Z,2017-06-02T13:41:12Z,2017-09-15T05:06:24Z,MERGED,True,47,47,3,https://github.com/comex,Fix undefined behavior in the interpreter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/296,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/296#issuecomment-304760162,"Partially fixes #87, but there are probably more potential overflows lurking in there; I didn't go over it too thoroughly.
FYI: In C, integer overflow when adding and multiplying signed integers is undefined, as is shifting any integer by too high a width, and left-shifting a signed integer if it changes the sign.  GCC started performing optimizations based on these a decade ago, but those optimizations don't usually apply in any particular situation, so usually you just get away with it.
But on my system, with clang-802.0.42, Mario 64 actually fails to boot in the interpreter without this patch: it fails the ROM checksum test performed early on (at 0x800001AC).  (Not sure exactly which operation was responsible; I compiled with -fsanitize=undefined, fixed everything that made it crash under that and some nearby code, and now Mario 64 works.  However, all of the changes here should be correct/necessary.)","Thanks for your contribution. I had a quick look on your PR and except for the shift masks which seems to differ from the official documentation, it looks OK.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,296,2017-05-28T05:50:04Z,2017-06-02T13:41:12Z,2017-09-15T05:06:24Z,MERGED,True,47,47,3,https://github.com/comex,Fix undefined behavior in the interpreter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/296,https://github.com/comex,4,https://github.com/mupen64plus/mupen64plus-core/pull/296#issuecomment-305064935,"Partially fixes #87, but there are probably more potential overflows lurking in there; I didn't go over it too thoroughly.
FYI: In C, integer overflow when adding and multiplying signed integers is undefined, as is shifting any integer by too high a width, and left-shifting a signed integer if it changes the sign.  GCC started performing optimizations based on these a decade ago, but those optimizations don't usually apply in any particular situation, so usually you just get away with it.
But on my system, with clang-802.0.42, Mario 64 actually fails to boot in the interpreter without this patch: it fails the ROM checksum test performed early on (at 0x800001AC).  (Not sure exactly which operation was responsible; I compiled with -fsanitize=undefined, fixed everything that made it crash under that and some nearby code, and now Mario 64 works.  However, all of the changes here should be correct/necessary.)",Apologies for the incorrect masks; fixed.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,296,2017-05-28T05:50:04Z,2017-06-02T13:41:12Z,2017-09-15T05:06:24Z,MERGED,True,47,47,3,https://github.com/comex,Fix undefined behavior in the interpreter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/296,https://github.com/comex,5,https://github.com/mupen64plus/mupen64plus-core/pull/296#issuecomment-305065444,"Partially fixes #87, but there are probably more potential overflows lurking in there; I didn't go over it too thoroughly.
FYI: In C, integer overflow when adding and multiplying signed integers is undefined, as is shifting any integer by too high a width, and left-shifting a signed integer if it changes the sign.  GCC started performing optimizations based on these a decade ago, but those optimizations don't usually apply in any particular situation, so usually you just get away with it.
But on my system, with clang-802.0.42, Mario 64 actually fails to boot in the interpreter without this patch: it fails the ROM checksum test performed early on (at 0x800001AC).  (Not sure exactly which operation was responsible; I compiled with -fsanitize=undefined, fixed everything that made it crash under that and some nearby code, and now Mario 64 works.  However, all of the changes here should be correct/necessary.)","Er, except I guess the masks on rsa aren't needed since it's extracted from a 5-bit field to start with.  Oops.  The only actual issue with the shift instructions is the signed left shifting in DSLL and DSLLV.
Updated again to remove those changes.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,296,2017-05-28T05:50:04Z,2017-06-02T13:41:12Z,2017-09-15T05:06:24Z,MERGED,True,47,47,3,https://github.com/comex,Fix undefined behavior in the interpreter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/296,https://github.com/richard42,6,https://github.com/mupen64plus/mupen64plus-core/pull/296#issuecomment-329682517,"Partially fixes #87, but there are probably more potential overflows lurking in there; I didn't go over it too thoroughly.
FYI: In C, integer overflow when adding and multiplying signed integers is undefined, as is shifting any integer by too high a width, and left-shifting a signed integer if it changes the sign.  GCC started performing optimizations based on these a decade ago, but those optimizations don't usually apply in any particular situation, so usually you just get away with it.
But on my system, with clang-802.0.42, Mario 64 actually fails to boot in the interpreter without this patch: it fails the ROM checksum test performed early on (at 0x800001AC).  (Not sure exactly which operation was responsible; I compiled with -fsanitize=undefined, fixed everything that made it crash under that and some nearby code, and now Mario 64 works.  However, all of the changes here should be correct/necessary.)",I don't think all of the casting 32-bit integers to (uint32_t) will change the output in any way. Adding is sign-agnostic,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,297,2017-05-28T22:32:53Z,2017-06-02T13:23:01Z,2017-06-02T13:23:01Z,MERGED,True,18,3,1,https://github.com/comex,Fix M64P_GL_SWAP_CONTROL with SDL>=1.3 and no video extension,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/297,https://github.com/comex,1,https://github.com/mupen64plus/mupen64plus-core/pull/297,"It originally mapped to SDL_GL_SWAP_CONTROL, which was removed in SDL 1.3; whoever wrote this decided to replace it with SDL_RENDERER_PRESENTVSYNC.  However, SDL_RENDERER_PRESENTVSYNC is not a GL attribute: it's a setting used when creating a 2D renderer, which this code doesn't use at all.  If passed to SDL_GL_(Get|Set)Attribute, it'll be interpreted as the SDL_GLattr value which happens to have the same numeric value, 4, namely SDL_GL_BUFFER_SIZE.
This changes the code to use the functions SDL_GL_(Get|Set)SwapInterval instead.","It originally mapped to SDL_GL_SWAP_CONTROL, which was removed in SDL 1.3; whoever wrote this decided to replace it with SDL_RENDERER_PRESENTVSYNC.  However, SDL_RENDERER_PRESENTVSYNC is not a GL attribute: it's a setting used when creating a 2D renderer, which this code doesn't use at all.  If passed to SDL_GL_(Get|Set)Attribute, it'll be interpreted as the SDL_GLattr value which happens to have the same numeric value, 4, namely SDL_GL_BUFFER_SIZE.
This changes the code to use the functions SDL_GL_(Get|Set)SwapInterval instead.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,297,2017-05-28T22:32:53Z,2017-06-02T13:23:01Z,2017-06-02T13:23:01Z,MERGED,True,18,3,1,https://github.com/comex,Fix M64P_GL_SWAP_CONTROL with SDL>=1.3 and no video extension,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/297,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/297#issuecomment-305785558,"It originally mapped to SDL_GL_SWAP_CONTROL, which was removed in SDL 1.3; whoever wrote this decided to replace it with SDL_RENDERER_PRESENTVSYNC.  However, SDL_RENDERER_PRESENTVSYNC is not a GL attribute: it's a setting used when creating a 2D renderer, which this code doesn't use at all.  If passed to SDL_GL_(Get|Set)Attribute, it'll be interpreted as the SDL_GLattr value which happens to have the same numeric value, 4, namely SDL_GL_BUFFER_SIZE.
This changes the code to use the functions SDL_GL_(Get|Set)SwapInterval instead.","I'll trust you on that, and revert if somebody complains :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,298,2017-05-28T22:44:58Z,2017-06-23T02:25:25Z,2017-06-26T09:48:30Z,MERGED,True,59,43,7,https://github.com/comex,Various Mac-related build fixes,7,[],https://github.com/mupen64plus/mupen64plus-core/pull/298,https://github.com/comex,1,https://github.com/mupen64plus/mupen64plus-core/pull/298,"Some Makefile fixes, fixes for Clang warnings, and revamping asm_defines because the old version didn't seem to work properly on Mac.  Please see the commit messages for details.","Some Makefile fixes, fixes for Clang warnings, and revamping asm_defines because the old version didn't seem to work properly on Mac.  Please see the commit messages for details.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,298,2017-05-28T22:44:58Z,2017-06-23T02:25:25Z,2017-06-26T09:48:30Z,MERGED,True,59,43,7,https://github.com/comex,Various Mac-related build fixes,7,[],https://github.com/mupen64plus/mupen64plus-core/pull/298,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/298#issuecomment-304756686,"Some Makefile fixes, fixes for Clang warnings, and revamping asm_defines because the old version didn't seem to work properly on Mac.  Please see the commit messages for details.","Clever way of avoiding objdump/nm. A bit unorthodox but does the job well :)
Tested on my setup with gcc 7.1.1 and everything seems OK.
Can someone test this on msvc to confirm no regression happened ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,298,2017-05-28T22:44:58Z,2017-06-23T02:25:25Z,2017-06-26T09:48:30Z,MERGED,True,59,43,7,https://github.com/comex,Various Mac-related build fixes,7,[],https://github.com/mupen64plus/mupen64plus-core/pull/298,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/298#issuecomment-305785253,"Some Makefile fixes, fixes for Clang warnings, and revamping asm_defines because the old version didn't seem to work properly on Mac.  Please see the commit messages for details.","@loganmc10, @Gillou68310  Can you also test on your setup if it works for you please ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,298,2017-05-28T22:44:58Z,2017-06-23T02:25:25Z,2017-06-26T09:48:30Z,MERGED,True,59,43,7,https://github.com/comex,Various Mac-related build fixes,7,[],https://github.com/mupen64plus/mupen64plus-core/pull/298,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/298#issuecomment-305792076,"Some Makefile fixes, fixes for Clang warnings, and revamping asm_defines because the old version didn't seem to work properly on Mac.  Please see the commit messages for details.",It has some conflicts with the current master,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,298,2017-05-28T22:44:58Z,2017-06-23T02:25:25Z,2017-06-26T09:48:30Z,MERGED,True,59,43,7,https://github.com/comex,Various Mac-related build fixes,7,[],https://github.com/mupen64plus/mupen64plus-core/pull/298,https://github.com/bsmiles32,5,https://github.com/mupen64plus/mupen64plus-core/pull/298#issuecomment-305796987,"Some Makefile fixes, fixes for Clang warnings, and revamping asm_defines because the old version didn't seem to work properly on Mac.  Please see the commit messages for details.","@loganmc10 : Ok, I resolved the conflicts. Can you test ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,298,2017-05-28T22:44:58Z,2017-06-23T02:25:25Z,2017-06-26T09:48:30Z,MERGED,True,59,43,7,https://github.com/comex,Various Mac-related build fixes,7,[],https://github.com/mupen64plus/mupen64plus-core/pull/298,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/298#issuecomment-305836419,"Some Makefile fixes, fixes for Clang warnings, and revamping asm_defines because the old version didn't seem to work properly on Mac.  Please see the commit messages for details.","I tested 32 and 64 bit Windows using MinGW and 64-bit Linux using GCC. No issues. I also tested my Raspberry Pi over SSH (it compiled and ran without crashing, but I can't see the screen to verify what it looks like) and there were no issues.
The only thing I didn't test was Visual Studio, since I don't have that setup.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,298,2017-05-28T22:44:58Z,2017-06-23T02:25:25Z,2017-06-26T09:48:30Z,MERGED,True,59,43,7,https://github.com/comex,Various Mac-related build fixes,7,[],https://github.com/mupen64plus/mupen64plus-core/pull/298,https://github.com/bsmiles32,7,https://github.com/mupen64plus/mupen64plus-core/pull/298#issuecomment-305931991,"Some Makefile fixes, fixes for Clang warnings, and revamping asm_defines because the old version didn't seem to work properly on Mac.  Please see the commit messages for details.",Thanks ! Will wait for confirmation that msvc works before merging.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,298,2017-05-28T22:44:58Z,2017-06-23T02:25:25Z,2017-06-26T09:48:30Z,MERGED,True,59,43,7,https://github.com/comex,Various Mac-related build fixes,7,[],https://github.com/mupen64plus/mupen64plus-core/pull/298,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/298#issuecomment-308731612,"Some Makefile fixes, fixes for Clang warnings, and revamping asm_defines because the old version didn't seem to work properly on Mac.  Please see the commit messages for details.","@comex I see you updated the Visual Studio makefile, did you test this on Visual Studio? We don't seem to be getting any takers for testing on VS",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,298,2017-05-28T22:44:58Z,2017-06-23T02:25:25Z,2017-06-26T09:48:30Z,MERGED,True,59,43,7,https://github.com/comex,Various Mac-related build fixes,7,[],https://github.com/mupen64plus/mupen64plus-core/pull/298,https://github.com/Gillou68310,9,https://github.com/mupen64plus/mupen64plus-core/pull/298#issuecomment-309699646,"Some Makefile fixes, fixes for Clang warnings, and revamping asm_defines because the old version didn't seem to work properly on Mac.  Please see the commit messages for details.",I check on VS and everything looks good. @bsmiles32 why did you merge the master branch into mac-fixes instead of rebasing against master?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,298,2017-05-28T22:44:58Z,2017-06-23T02:25:25Z,2017-06-26T09:48:30Z,MERGED,True,59,43,7,https://github.com/comex,Various Mac-related build fixes,7,[],https://github.com/mupen64plus/mupen64plus-core/pull/298,https://github.com/bsmiles32,10,https://github.com/mupen64plus/mupen64plus-core/pull/298#issuecomment-310553910,"Some Makefile fixes, fixes for Clang warnings, and revamping asm_defines because the old version didn't seem to work properly on Mac.  Please see the commit messages for details.","@Gillou68310 : I just used the ""online Github editor"" to resolve the conflict and that's what I got by clicking the various buttons... Not (yet) a git expert sadly.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,298,2017-05-28T22:44:58Z,2017-06-23T02:25:25Z,2017-06-26T09:48:30Z,MERGED,True,59,43,7,https://github.com/comex,Various Mac-related build fixes,7,[],https://github.com/mupen64plus/mupen64plus-core/pull/298,https://github.com/Gillou68310,11,https://github.com/mupen64plus/mupen64plus-core/pull/298#issuecomment-310627748,"Some Makefile fixes, fixes for Clang warnings, and revamping asm_defines because the old version didn't seem to work properly on Mac.  Please see the commit messages for details.","I see, the problem is that it makes the history unreadable as the merged commits are not placed on top of master.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,298,2017-05-28T22:44:58Z,2017-06-23T02:25:25Z,2017-06-26T09:48:30Z,MERGED,True,59,43,7,https://github.com/comex,Various Mac-related build fixes,7,[],https://github.com/mupen64plus/mupen64plus-core/pull/298,https://github.com/Gillou68310,12,https://github.com/mupen64plus/mupen64plus-core/pull/298#issuecomment-310627873,"Some Makefile fixes, fixes for Clang warnings, and revamping asm_defines because the old version didn't seem to work properly on Mac.  Please see the commit messages for details.",Try to use the rebase function as much as you can.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,298,2017-05-28T22:44:58Z,2017-06-23T02:25:25Z,2017-06-26T09:48:30Z,MERGED,True,59,43,7,https://github.com/comex,Various Mac-related build fixes,7,[],https://github.com/mupen64plus/mupen64plus-core/pull/298,https://github.com/loganmc10,13,https://github.com/mupen64plus/mupen64plus-core/pull/298#issuecomment-310663596,"Some Makefile fixes, fixes for Clang warnings, and revamping asm_defines because the old version didn't seem to work properly on Mac.  Please see the commit messages for details.","Yeah I agree that the ""Merge branch master into...."" commits are a little scary. On GitHub it's really hard to see what the actual impact of those commits is.
I realized though that doing a git show 949625d in Linux (or Windows I'm sure) will show you the ""actual impact"" of the commit, so it's a little less scary, but yeah doing a git rebase master and manually resolving the merge conflicts makes it a lot cleaner",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,298,2017-05-28T22:44:58Z,2017-06-23T02:25:25Z,2017-06-26T09:48:30Z,MERGED,True,59,43,7,https://github.com/comex,Various Mac-related build fixes,7,[],https://github.com/mupen64plus/mupen64plus-core/pull/298,None,14,https://github.com/mupen64plus/mupen64plus-core/pull/298#issuecomment-310992953,"Some Makefile fixes, fixes for Clang warnings, and revamping asm_defines because the old version didn't seem to work properly on Mac.  Please see the commit messages for details.","It looks like this broke the build. It stops with:
awk -v dest_dir=""../../src/asm_defines"" -f ../../tools/gen_asm_defines.awk ""_obj/asm_defines/asm_defines.o""                                                                                                                                                               
    AS  _obj/device/r4300/x86_64/dyna_start.o                                                                                                                                                                                                                             
../../src/device/r4300/x86_64/dyna_start.asm:21: fatal: unable to open include file `asm_defines_nasm.h'                                                                                                                                                                  
Makefile:697: recipe for target '_obj/device/r4300/x86_64/dyna_start.o' failed                                                                                                                                                                                            
make: *** [_obj/device/r4300/x86_64/dyna_start.o] Error 1                                                                                                                                                                                                                 
make: *** Waiting for unfinished jobs....

Please revert 7b6ffc2 to fix this problem.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,298,2017-05-28T22:44:58Z,2017-06-23T02:25:25Z,2017-06-26T09:48:30Z,MERGED,True,59,43,7,https://github.com/comex,Various Mac-related build fixes,7,[],https://github.com/mupen64plus/mupen64plus-core/pull/298,None,15,https://github.com/mupen64plus/mupen64plus-core/pull/298#issuecomment-310995452,"Some Makefile fixes, fixes for Clang warnings, and revamping asm_defines because the old version didn't seem to work properly on Mac.  Please see the commit messages for details.","@bsmiles32  This awk script is not compatible with mawk (default on many systems). Either do following change in the makefile
-AWK      ?= awk
+AWK      ?= gawk

Or revert the commit 7b6ffc2",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,298,2017-05-28T22:44:58Z,2017-06-23T02:25:25Z,2017-06-26T09:48:30Z,MERGED,True,59,43,7,https://github.com/comex,Various Mac-related build fixes,7,[],https://github.com/mupen64plus/mupen64plus-core/pull/298,https://github.com/comex,16,https://github.com/mupen64plus/mupen64plus-core/pull/298#issuecomment-311013566,"Some Makefile fixes, fixes for Clang warnings, and revamping asm_defines because the old version didn't seem to work properly on Mac.  Please see the commit messages for details.",My bad.  I just submitted #322 to fix this.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,300,2017-05-29T14:08:05Z,2017-05-29T15:32:47Z,2017-06-02T16:43:40Z,MERGED,True,3,0,1,https://github.com/loganmc10,CountPerScanline=1600 for Twisted Edge,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/300,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/300,"Every now and then with Twisted Edge Snowboarding, you get an ear full of static instead of proper audio. Setting CountPerScanline=1600 makes it far less likely (it still happens on rare occasion).","Every now and then with Twisted Edge Snowboarding, you get an ear full of static instead of proper audio. Setting CountPerScanline=1600 makes it far less likely (it still happens on rare occasion).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,301,2017-05-30T00:01:33Z,2017-06-02T13:20:55Z,2017-06-02T13:52:18Z,MERGED,True,17,11,6,https://github.com/bsmiles32,Avoid usage of global variable g_delay_si.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/301,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/301,One less global variable used inside the emulation core.,One less global variable used inside the emulation core.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,301,2017-05-30T00:01:33Z,2017-06-02T13:20:55Z,2017-06-02T13:52:18Z,MERGED,True,17,11,6,https://github.com/bsmiles32,Avoid usage of global variable g_delay_si.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/301,https://github.com/dankcushions,2,https://github.com/mupen64plus/mupen64plus-core/pull/301#issuecomment-305737399,One less global variable used inside the emulation core.,built and tested on RPI3/ARM + mario64 - fine here :),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,302,2017-05-30T04:50:52Z,2017-09-14T03:27:33Z,2017-09-20T16:37:08Z,CLOSED,False,4,0,2,https://github.com/fzurita,Be more selective on which interrupts we can load or save states,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/302,https://github.com/fzurita,1,https://github.com/mupen64plus/mupen64plus-core/pull/302,"This seems to fix the issue encountered in #294.
I have no idea if this is the correct fix or what kind of side effects it could have, but after making this change, I'm unable to reproduce the above issue.","This seems to fix the issue encountered in #294.
I have no idea if this is the correct fix or what kind of side effects it could have, but after making this change, I'm unable to reproduce the above issue.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,302,2017-05-30T04:50:52Z,2017-09-14T03:27:33Z,2017-09-20T16:37:08Z,CLOSED,False,4,0,2,https://github.com/fzurita,Be more selective on which interrupts we can load or save states,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/302,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/302#issuecomment-329227637,"This seems to fix the issue encountered in #294.
I have no idea if this is the correct fix or what kind of side effects it could have, but after making this change, I'm unable to reproduce the above issue.",Is this still a problem? I've still never been able to reproduce this issue on Android,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,302,2017-05-30T04:50:52Z,2017-09-14T03:27:33Z,2017-09-20T16:37:08Z,CLOSED,False,4,0,2,https://github.com/fzurita,Be more selective on which interrupts we can load or save states,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/302,https://github.com/fzurita,3,https://github.com/mupen64plus/mupen64plus-core/pull/302#issuecomment-329236544,"This seems to fix the issue encountered in #294.
I have no idea if this is the correct fix or what kind of side effects it could have, but after making this change, I'm unable to reproduce the above issue.","I don't know, I have this workaround included in the play store version of Mupen64plus AE so I don't see it there and that's the one I usually use.
I'll give it a shot soon.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,302,2017-05-30T04:50:52Z,2017-09-14T03:27:33Z,2017-09-20T16:37:08Z,CLOSED,False,4,0,2,https://github.com/fzurita,Be more selective on which interrupts we can load or save states,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/302,https://github.com/fzurita,4,https://github.com/mupen64plus/mupen64plus-core/pull/302#issuecomment-329359437,"This seems to fix the issue encountered in #294.
I have no idea if this is the correct fix or what kind of side effects it could have, but after making this change, I'm unable to reproduce the above issue.",I tried for a while and couldn't make it happen. It was very easily reproducible for me before. I'll close and re-open if the issue shows up again.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,302,2017-05-30T04:50:52Z,2017-09-14T03:27:33Z,2017-09-20T16:37:08Z,CLOSED,False,4,0,2,https://github.com/fzurita,Be more selective on which interrupts we can load or save states,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/302,https://github.com/fzurita,5,https://github.com/mupen64plus/mupen64plus-core/pull/302#issuecomment-330903942,"This seems to fix the issue encountered in #294.
I have no idea if this is the correct fix or what kind of side effects it could have, but after making this change, I'm unable to reproduce the above issue.",I just had the issue happen in Golden Eye. I guess it's still happening but much rarer.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,302,2017-05-30T04:50:52Z,2017-09-14T03:27:33Z,2017-09-20T16:37:08Z,CLOSED,False,4,0,2,https://github.com/fzurita,Be more selective on which interrupts we can load or save states,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/302,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/302#issuecomment-330905340,"This seems to fix the issue encountered in #294.
I have no idea if this is the correct fix or what kind of side effects it could have, but after making this change, I'm unable to reproduce the above issue.","Do you still have the save state? I remember when I was testing this, I did have GoldenEye freeze when trying to load the save state once (on Android), but when I tried to open the save state using the cached interpreter, it worked, just not with the arm dynarec",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,302,2017-05-30T04:50:52Z,2017-09-14T03:27:33Z,2017-09-20T16:37:08Z,CLOSED,False,4,0,2,https://github.com/fzurita,Be more selective on which interrupts we can load or save states,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/302,https://github.com/fzurita,7,https://github.com/mupen64plus/mupen64plus-core/pull/302#issuecomment-330906156,"This seems to fix the issue encountered in #294.
I have no idea if this is the correct fix or what kind of side effects it could have, but after making this change, I'm unable to reproduce the above issue.","I'm pretty sure the issue is due to TLB, on the save states where the issue happened, TLB address translation did not seem to be working correctly. the new dynarec has its own TLB implementation.
I'll check if I still have the save state.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,302,2017-05-30T04:50:52Z,2017-09-14T03:27:33Z,2017-09-20T16:37:08Z,CLOSED,False,4,0,2,https://github.com/fzurita,Be more selective on which interrupts we can load or save states,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/302,https://github.com/fzurita,8,https://github.com/mupen64plus/mupen64plus-core/pull/302#issuecomment-330908885,"This seems to fix the issue encountered in #294.
I have no idea if this is the correct fix or what kind of side effects it could have, but after making this change, I'm unable to reproduce the above issue.","Here is the save state:
golden_eye_freeze.sav.zip",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,302,2017-05-30T04:50:52Z,2017-09-14T03:27:33Z,2017-09-20T16:37:08Z,CLOSED,False,4,0,2,https://github.com/fzurita,Be more selective on which interrupts we can load or save states,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/302,https://github.com/loganmc10,9,https://github.com/mupen64plus/mupen64plus-core/pull/302#issuecomment-330909590,"This seems to fix the issue encountered in #294.
I have no idea if this is the correct fix or what kind of side effects it could have, but after making this change, I'm unable to reproduce the above issue.","Yeah I can open that savestate on my PC no problem, doesn't freeze. I think it's something up with the new dynarec",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,306,2017-06-02T01:47:16Z,2017-06-02T13:19:40Z,2017-06-02T16:43:39Z,MERGED,True,7,89,1,https://github.com/loganmc10,INI cheat cleanup,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/306,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/306,"Mainly, remove Pokemon Snap cheats.
You can read about why these Pokemon Snap cheats were added in the first place here: 252fa6f
Basically, the tutorial doesn't unlock the controls until you take a picture. Most graphics plugins aren't accurate enough to recognize when you've captured a Pokemon, so the controls never unlock. The cheat forced the controls to unlock. Kind of a silly thing to do, since you still can't get it to recognize the Pokemon in your picture.
Anyway, accurate graphics plugins like Angrylion or GLideN64 allow you to take a picture, so the controls unlock. This hack isn't needed, and probably should have never been added in the first place. I played through the whole first level without this cheat using GLideN64, and everything works fine, including Professor Oak's picture check, etc...
The rest is mostly cosmetic, reordering the Zelda cheat from 1 to 0. Removing the commented out hack to produce shadows in Pilot Wings. Again, an accurate graphics plugin like GLideN64 shows the shadows. I also removed all the Mario Kart multiplayer timing hacks from everything but the main entry, which keeps it in line with the other ROMs.","Mainly, remove Pokemon Snap cheats.
You can read about why these Pokemon Snap cheats were added in the first place here: 252fa6f
Basically, the tutorial doesn't unlock the controls until you take a picture. Most graphics plugins aren't accurate enough to recognize when you've captured a Pokemon, so the controls never unlock. The cheat forced the controls to unlock. Kind of a silly thing to do, since you still can't get it to recognize the Pokemon in your picture.
Anyway, accurate graphics plugins like Angrylion or GLideN64 allow you to take a picture, so the controls unlock. This hack isn't needed, and probably should have never been added in the first place. I played through the whole first level without this cheat using GLideN64, and everything works fine, including Professor Oak's picture check, etc...
The rest is mostly cosmetic, reordering the Zelda cheat from 1 to 0. Removing the commented out hack to produce shadows in Pilot Wings. Again, an accurate graphics plugin like GLideN64 shows the shadows. I also removed all the Mario Kart multiplayer timing hacks from everything but the main entry, which keeps it in line with the other ROMs.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,306,2017-06-02T01:47:16Z,2017-06-02T13:19:40Z,2017-06-02T16:43:39Z,MERGED,True,7,89,1,https://github.com/loganmc10,INI cheat cleanup,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/306,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/306#issuecomment-305667715,"Mainly, remove Pokemon Snap cheats.
You can read about why these Pokemon Snap cheats were added in the first place here: 252fa6f
Basically, the tutorial doesn't unlock the controls until you take a picture. Most graphics plugins aren't accurate enough to recognize when you've captured a Pokemon, so the controls never unlock. The cheat forced the controls to unlock. Kind of a silly thing to do, since you still can't get it to recognize the Pokemon in your picture.
Anyway, accurate graphics plugins like Angrylion or GLideN64 allow you to take a picture, so the controls unlock. This hack isn't needed, and probably should have never been added in the first place. I played through the whole first level without this cheat using GLideN64, and everything works fine, including Professor Oak's picture check, etc...
The rest is mostly cosmetic, reordering the Zelda cheat from 1 to 0. Removing the commented out hack to produce shadows in Pilot Wings. Again, an accurate graphics plugin like GLideN64 shows the shadows. I also removed all the Mario Kart multiplayer timing hacks from everything but the main entry, which keeps it in line with the other ROMs.","Here is a screenshot showing that the shadows work without that hack (I assume this is what it means by ""land shadows""):",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,307,2017-06-02T04:25:35Z,2017-06-03T15:08:28Z,2017-08-22T14:48:55Z,MERGED,True,9,52,3,https://github.com/loganmc10,Trust plugins to trigger SP interrupts,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/307,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/307,"This is based on work by @bsmiles32 in bsmiles32@a1b6df0, brought on by debugging #181
I've tested this ever so briefly on a few games like Super Mario 64 and World Driver Champ. I'm just posting this here to get some feedback and perhaps some testing.
I've also posed a few questions in comments in the code that I was a little unclear on, I'd appreciate if anyone has some insight on those lines.","This is based on work by @bsmiles32 in bsmiles32@a1b6df0, brought on by debugging #181
I've tested this ever so briefly on a few games like Super Mario 64 and World Driver Champ. I'm just posting this here to get some feedback and perhaps some testing.
I've also posed a few questions in comments in the code that I was a little unclear on, I'd appreciate if anyone has some insight on those lines.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,307,2017-06-02T04:25:35Z,2017-06-03T15:08:28Z,2017-08-22T14:48:55Z,MERGED,True,9,52,3,https://github.com/loganmc10,Trust plugins to trigger SP interrupts,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/307,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/307#issuecomment-305883066,"This is based on work by @bsmiles32 in bsmiles32@a1b6df0, brought on by debugging #181
I've tested this ever so briefly on a few games like Super Mario 64 and World Driver Champ. I'm just posting this here to get some feedback and perhaps some testing.
I've also posed a few questions in comments in the code that I was a little unclear on, I'd appreciate if anyone has some insight on those lines.","I've tested this with quite a few games now, both HLE and LLE graphics plugins. It seems pretty solid, I don't see any regressions. It does fix the crashing in Top Gear Rally 2, and removes the need for the Perfect Dark hack. I assume it also fixes other stability problems as well.
There are still a few items that I'm not sure if I'm getting right, does cp0_update_count(sp->r4300); need to appear before every add_interrupt_event() call?
Also, in the current version it schedules a DP interrupt with a value/counter of 1000. This is necessary for Pokemon detection in Pokemon Snap (also Kirby 64's HUD, probably other things as well). After this change, 1000 no longer worked, but 4000 does. Project64 uses 0x1000 (4096), which is where I got the idea for 4000. But is 4000 right? How are these numbers determined?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,307,2017-06-02T04:25:35Z,2017-06-03T15:08:28Z,2017-08-22T14:48:55Z,MERGED,True,9,52,3,https://github.com/loganmc10,Trust plugins to trigger SP interrupts,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/307,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/307#issuecomment-305931794,"This is based on work by @bsmiles32 in bsmiles32@a1b6df0, brought on by debugging #181
I've tested this ever so briefly on a few games like Super Mario 64 and World Driver Champ. I'm just posting this here to get some feedback and perhaps some testing.
I've also posed a few questions in comments in the code that I was a little unclear on, I'd appreciate if anyone has some insight on those lines.","add_interrupt_event needs an updated COUNT register as all events are compared using it. That's why we make sure to call cp0_update_count before.
As for the other values, I really don't know where they come from. I guess it's purely empirical as everything timing related  is unfortunately.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,307,2017-06-02T04:25:35Z,2017-06-03T15:08:28Z,2017-08-22T14:48:55Z,MERGED,True,9,52,3,https://github.com/loganmc10,Trust plugins to trigger SP interrupts,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/307,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/307#issuecomment-305946832,"This is based on work by @bsmiles32 in bsmiles32@a1b6df0, brought on by debugging #181
I've tested this ever so briefly on a few games like Super Mario 64 and World Driver Champ. I'm just posting this here to get some feedback and perhaps some testing.
I've also posed a few questions in comments in the code that I was a little unclear on, I'd appreciate if anyone has some insight on those lines.","Ok understood. I've updated the PR to cleanup the code. I've tested this with quite a few games. Including the ones that have been more sensitive to RSP interrupt changes (Perfect Dark, Kirby, Banjo 1/2, Blast Corps, DK64, Pokemon Snap, etc...).
I've played several races in Top Gear Rally 2 and several levels in Perfect Dark, no more crashing.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,307,2017-06-02T04:25:35Z,2017-06-03T15:08:28Z,2017-08-22T14:48:55Z,MERGED,True,9,52,3,https://github.com/loganmc10,Trust plugins to trigger SP interrupts,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/307,https://github.com/bsmiles32,5,https://github.com/mupen64plus/mupen64plus-core/pull/307#issuecomment-305980729,"This is based on work by @bsmiles32 in bsmiles32@a1b6df0, brought on by debugging #181
I've tested this ever so briefly on a few games like Super Mario 64 and World Driver Champ. I'm just posting this here to get some feedback and perhaps some testing.
I've also posed a few questions in comments in the code that I was a little unclear on, I'd appreciate if anyone has some insight on those lines.",@loganmc10 I also tested on my end and it seems to work correctly. I'm not sure why it works correctly though. I'll merge it now and revert if somebody complains.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,307,2017-06-02T04:25:35Z,2017-06-03T15:08:28Z,2017-08-22T14:48:55Z,MERGED,True,9,52,3,https://github.com/loganmc10,Trust plugins to trigger SP interrupts,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/307,https://github.com/fzurita,6,https://github.com/mupen64plus/mupen64plus-core/pull/307#issuecomment-306201608,"This is based on work by @bsmiles32 in bsmiles32@a1b6df0, brought on by debugging #181
I've tested this ever so briefly on a few games like Super Mario 64 and World Driver Champ. I'm just posting this here to get some feedback and perhaps some testing.
I've also posed a few questions in comments in the code that I was a little unclear on, I'd appreciate if anyone has some insight on those lines.",I'll get this out to a wider audience and see how many people complain or are happy about it.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,307,2017-06-02T04:25:35Z,2017-06-03T15:08:28Z,2017-08-22T14:48:55Z,MERGED,True,9,52,3,https://github.com/loganmc10,Trust plugins to trigger SP interrupts,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/307,https://github.com/Gillou68310,7,https://github.com/mupen64plus/mupen64plus-core/pull/307#issuecomment-324016499,"This is based on work by @bsmiles32 in bsmiles32@a1b6df0, brought on by debugging #181
I've tested this ever so briefly on a few games like Super Mario 64 and World Driver Champ. I'm just posting this here to get some feedback and perhaps some testing.
I've also posed a few questions in comments in the code that I was a little unclear on, I'd appreciate if anyone has some insight on those lines.","I don't think this implementation is correct, I don't even understand why it works because no SP interrupts are ever triggered when the RSP is done with a task.
On the real hardware the CPU and RSP run in parallel:
-The CPU starts the RSP
-The RSP process its task while the CPU is still running.
-When the RSP is done with its task it causes an SP interrupt on the CPU side.
On the emulator the CPU and RSP are obviously not running in parallel:
-The CPU starts the RSP
-The RSP process its task
-When the RSP is done with its task an SP interrupt is scheduled with a configurable delay.
-The CPU runs until the SP interrupt is triggered.
The SP interrupt configurable delay is an approximation of the time the RSP spends executing its task.
@loganmc10 If you see this Core Warning: two events of type 0x80 in interrupt queue it's because the CPU is starting the RSP before the last SP interrupt has been triggered. You could try reducing the configurable delay to see if it fixes the issue.
Now that I think about it we should probably clear SP_STATUS_BROKE and SP_STATUS_HALT bits when returning from doRspCycles and set them back in rsp_interrupt_event.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,307,2017-06-02T04:25:35Z,2017-06-03T15:08:28Z,2017-08-22T14:48:55Z,MERGED,True,9,52,3,https://github.com/loganmc10,Trust plugins to trigger SP interrupts,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/307,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/307#issuecomment-324031777,"This is based on work by @bsmiles32 in bsmiles32@a1b6df0, brought on by debugging #181
I've tested this ever so briefly on a few games like Super Mario 64 and World Driver Champ. I'm just posting this here to get some feedback and perhaps some testing.
I've also posed a few questions in comments in the code that I was a little unclear on, I'd appreciate if anyone has some insight on those lines.","I don't even understand why it works because no SP interrupts are ever triggered when the RSP is done with a task.

The RSP plugin sets the interrupt bit: https://github.com/mupen64plus/mupen64plus-rsp-hle/blob/master/src/hle.c#L165
So basically this is the difference between having ""DelaySI"" on or off. With the way it is now, there is no delay, the SP interrupt is raised the next time interrupts are checked. With the old implementation, we would check if the RSP plugin set the MI interrupt bit, if it did, we would unset it, and schedule the RSP interrupt for later.
The problem with the old implementation is that, like you mentioned, sometimes it would ""double up"" and schedule a new RSP task before the old one was finished, which caused issues in Top Gear Rally 2, Perfect Dark, and probably other games.
You are probably right, perhaps if we cleared HALT and BROKE after the RSP task, then it would know not to start a new task. I'll try that out sometime today.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,307,2017-06-02T04:25:35Z,2017-06-03T15:08:28Z,2017-08-22T14:48:55Z,MERGED,True,9,52,3,https://github.com/loganmc10,Trust plugins to trigger SP interrupts,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/307,https://github.com/loganmc10,9,https://github.com/mupen64plus/mupen64plus-core/pull/307#issuecomment-324034006,"This is based on work by @bsmiles32 in bsmiles32@a1b6df0, brought on by debugging #181
I've tested this ever so briefly on a few games like Super Mario 64 and World Driver Champ. I'm just posting this here to get some feedback and perhaps some testing.
I've also posed a few questions in comments in the code that I was a little unclear on, I'd appreciate if anyone has some insight on those lines.","@Gillou68310 actually now that I really look at the RSP plugin, it does:
*hle->mi_intr |= MI_INTR_SP;
HleCheckInterrupts(hle->user_defined);

So it actually checks the interrupt itself as well, by having the emulator core also call a delayed interrupt, wouldn't we be calling 2 interrupts for the same RSP task?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,307,2017-06-02T04:25:35Z,2017-06-03T15:08:28Z,2017-08-22T14:48:55Z,MERGED,True,9,52,3,https://github.com/loganmc10,Trust plugins to trigger SP interrupts,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/307,https://github.com/Gillou68310,10,https://github.com/mupen64plus/mupen64plus-core/pull/307#issuecomment-324034738,"This is based on work by @bsmiles32 in bsmiles32@a1b6df0, brought on by debugging #181
I've tested this ever so briefly on a few games like Super Mario 64 and World Driver Champ. I'm just posting this here to get some feedback and perhaps some testing.
I've also posed a few questions in comments in the code that I was a little unclear on, I'd appreciate if anyone has some insight on those lines.",IIRC the CheckInterrupts API points to an EmptyFunc,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,307,2017-06-02T04:25:35Z,2017-06-03T15:08:28Z,2017-08-22T14:48:55Z,MERGED,True,9,52,3,https://github.com/loganmc10,Trust plugins to trigger SP interrupts,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/307,https://github.com/Gillou68310,11,https://github.com/mupen64plus/mupen64plus-core/pull/307#issuecomment-324037138,"This is based on work by @bsmiles32 in bsmiles32@a1b6df0, brought on by debugging #181
I've tested this ever so briefly on a few games like Super Mario 64 and World Driver Champ. I'm just posting this here to get some feedback and perhaps some testing.
I've also posed a few questions in comments in the code that I was a little unclear on, I'd appreciate if anyone has some insight on those lines.",I just checked and rsp_interrupt_event is never called!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,307,2017-06-02T04:25:35Z,2017-06-03T15:08:28Z,2017-08-22T14:48:55Z,MERGED,True,9,52,3,https://github.com/loganmc10,Trust plugins to trigger SP interrupts,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/307,https://github.com/Gillou68310,12,https://github.com/mupen64plus/mupen64plus-core/pull/307#issuecomment-324048060,"This is based on work by @bsmiles32 in bsmiles32@a1b6df0, brought on by debugging #181
I've tested this ever so briefly on a few games like Super Mario 64 and World Driver Champ. I'm just posting this here to get some feedback and perhaps some testing.
I've also posed a few questions in comments in the code that I was a little unclear on, I'd appreciate if anyone has some insight on those lines.","Oh I see, the SP interrupt is raised as a CHECK_INT that's why it works.
So what we are doing here is that we almost nullified the execution time of the RSP, I guess using ```add_interrupt_event(&sp->r4300->cp0, SP_INT, A)```` with A being a small value should produce the same results. Well sorry if I sound rude but I don't like this :-(",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,307,2017-06-02T04:25:35Z,2017-06-03T15:08:28Z,2017-08-22T14:48:55Z,MERGED,True,9,52,3,https://github.com/loganmc10,Trust plugins to trigger SP interrupts,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/307,https://github.com/loganmc10,13,https://github.com/mupen64plus/mupen64plus-core/pull/307#issuecomment-324048955,"This is based on work by @bsmiles32 in bsmiles32@a1b6df0, brought on by debugging #181
I've tested this ever so briefly on a few games like Super Mario 64 and World Driver Champ. I'm just posting this here to get some feedback and perhaps some testing.
I've also posed a few questions in comments in the code that I was a little unclear on, I'd appreciate if anyone has some insight on those lines.","No I totally agree, see #371",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,307,2017-06-02T04:25:35Z,2017-06-03T15:08:28Z,2017-08-22T14:48:55Z,MERGED,True,9,52,3,https://github.com/loganmc10,Trust plugins to trigger SP interrupts,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/307,https://github.com/Gillou68310,14,https://github.com/mupen64plus/mupen64plus-core/pull/307#issuecomment-324050220,"This is based on work by @bsmiles32 in bsmiles32@a1b6df0, brought on by debugging #181
I've tested this ever so briefly on a few games like Super Mario 64 and World Driver Champ. I'm just posting this here to get some feedback and perhaps some testing.
I've also posed a few questions in comments in the code that I was a little unclear on, I'd appreciate if anyone has some insight on those lines.",Well I was not expecting such great results :-),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,308,2017-06-02T22:11:18Z,2017-06-03T15:10:06Z,2017-06-03T15:10:06Z,MERGED,True,1,0,1,https://github.com/loganmc10,Add note for NBA Showtime - NBA on NBC,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/308,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/308,"I know you've all been dying to play this title, so I thought I would add a note on how to get it to work. I'm not sure where else this kind of thing could go, so I put it here. Might be helpful in the future to someone that tries to get it working.","I know you've all been dying to play this title, so I thought I would add a note on how to get it to work. I'm not sure where else this kind of thing could go, so I put it here. Might be helpful in the future to someone that tries to get it working.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,308,2017-06-02T22:11:18Z,2017-06-03T15:10:06Z,2017-06-03T15:10:06Z,MERGED,True,1,0,1,https://github.com/loganmc10,Add note for NBA Showtime - NBA on NBC,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/308,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/308#issuecomment-305930582,"I know you've all been dying to play this title, so I thought I would add a note on how to get it to work. I'm not sure where else this kind of thing could go, so I put it here. Might be helpful in the future to someone that tries to get it working.",Not sure where to put that info either but I'm OK with that.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,310,2017-06-05T17:18:52Z,2017-06-12T18:08:13Z,2017-06-12T18:08:13Z,MERGED,True,5,5,1,https://github.com/loganmc10,Fix reading CP0_RANDOM_REG,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/310,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/310,"From the r4300i datasheet:

This register will decrement on every instruction executed. The values range between a low value determined by the TLB Wired register, and an upper bound of TLBENTRIES-1. The TLB Random register is used to specify the entry in the TLB affected by the TLBWR instruction

Right now, CP0_RANDOM_REG is only updated before a TLB Write (https://github.com/loganmc10/mupen64plus-core/blob/b3b5d5cae1ba97013a54ad8b9410a725b67449aa/src/device/r4300/mips_instructions.def#L1332-L1334) because that is the only time it is really useful.
However, the value can also be read from, so this change updates the value of CP0_RANDOM_REG before it is read.
Fixes #309","From the r4300i datasheet:

This register will decrement on every instruction executed. The values range between a low value determined by the TLB Wired register, and an upper bound of TLBENTRIES-1. The TLB Random register is used to specify the entry in the TLB affected by the TLBWR instruction

Right now, CP0_RANDOM_REG is only updated before a TLB Write (https://github.com/loganmc10/mupen64plus-core/blob/b3b5d5cae1ba97013a54ad8b9410a725b67449aa/src/device/r4300/mips_instructions.def#L1332-L1334) because that is the only time it is really useful.
However, the value can also be read from, so this change updates the value of CP0_RANDOM_REG before it is read.
Fixes #309",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,310,2017-06-05T17:18:52Z,2017-06-12T18:08:13Z,2017-06-12T18:08:13Z,MERGED,True,5,5,1,https://github.com/loganmc10,Fix reading CP0_RANDOM_REG,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/310,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/310#issuecomment-307871023,"From the r4300i datasheet:

This register will decrement on every instruction executed. The values range between a low value determined by the TLB Wired register, and an upper bound of TLBENTRIES-1. The TLB Random register is used to specify the entry in the TLB affected by the TLBWR instruction

Right now, CP0_RANDOM_REG is only updated before a TLB Write (https://github.com/loganmc10/mupen64plus-core/blob/b3b5d5cae1ba97013a54ad8b9410a725b67449aa/src/device/r4300/mips_instructions.def#L1332-L1334) because that is the only time it is really useful.
However, the value can also be read from, so this change updates the value of CP0_RANDOM_REG before it is read.
Fixes #309",Tested. Works great. Merging :),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/312,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-307813967,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"I tested a number of games on x86 new dynarec and x64 dynarec. No issues, it all seems good. Didn't test ARM",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-307819219,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"Here is a kind of interesting one though. I was testing International Track & Field 2000, which doesn't currently boot (#311)
Before this PR, it just sat in an endless loop. But with this PR, using the x86 new dynarec, it actually segfaults.
Thread 1 ""mupen64plus"" received signal SIGSEGV, Segmentation fault.
MTC0.lto_priv.339 () at ../../src/device/r4300/mips_instructions.def:1287
1287	        cp0_update_count(r4300);
(gdb) backtrace
#0  MTC0.lto_priv.339 () at ../../src/device/r4300/mips_instructions.def:1287
#1  0xe6445c11 in ?? ()
Backtrace stopped: Cannot access memory at address 0x3

Doesn't happen with the Cached Interpreter or the x64 dynarec. I'm not saying there is something wrong with the PR, since this game never worked before, I guess it's just ""exposing the bad behavior"" in a different way.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/bsmiles32,4,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-308771234,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,Updated with a minor fix to flashram MMIO squashed into commit 302f781,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-308809450,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"Compiling this for Android I get:
/home/travis/android-ndk-r14b/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/lib/gcc/arm-linux-androideabi/4.9.x/../../../../arm-linux-androideabi/bin/ld: error: /home/travis/mupen64plus-ae/app/build/intermediates/ndkBuild/release/obj/local/armeabi-v7a/objs/mupen64plus-core/./mupen64plus-core/src/device/r4300/new_dynarec/arm/linkage_arm.o: requires unsupported dynamic reloc R_ARM_MOVW_ABS_NC; recompile with -fPIC
/home/travis/android-ndk-r14b/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/lib/gcc/arm-linux-androideabi/4.9.x/../../../../arm-linux-androideabi/bin/ld: warning: shared library text segment is not shareable
clang++: error: linker command failed with exit code 1 (use -v to see invocation)

I'm compiling with fPIC now, I'll post my results in a bit. I assume the Raspberry Pi will have a similar issue, I'll test tonight, we may have to update the Unix makefile to add -fPIC for arm",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-308810932,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"I still get that error even after doing this: https://github.com/loganmc10/mupen64plus-ae/commit/dc3fb9e3f0196c92edbf497f2db97f8982d954c8
I'm not really an Android pro, perhaps @fzurita can try getting it to compile. I'll try on my Raspberry Pi tonight",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/bsmiles32,7,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-308812848,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,Thanks for your tests. I'm unfortunately not knowledgable about the ARM side.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/fzurita,8,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-308823334,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"Hmmm, sounds like we are doing something that is not PIC complaint. I'm usually not good at deciphering those thing but @Gillou68310 had in the past.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/bsmiles32,9,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-309639421,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"Updated. I changed the way dynarec_{read,write}_aligned_dword is called and hopefully this should fix the ""PIC"" issue.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/Gillou68310,10,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-309738537,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"The current implementation will break code invalidation and tlb exceptions with the new dynarec.
One solution I can think of is to call write_rdram_new/write_nomem_new twice within the write_dword_new function, updating address/wword/wmask between the 2 calls.
We still need to find a workaround for read_nomemd_new.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/loganmc10,11,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-310462387,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"I just tested this PR on Android with a few games and it seems to be working, no more PIC errors and no crashes.
I assume the issues that Gilles is talking about relate to #313, which still doesn't work on ARM or x86 new dynarec.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/bsmiles32,12,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-310565221,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"Tried to solve merge conflicts.
@Gillou68310 I don't get why this PR would break code invalidation nor TLB exceptions. Maybe you are referring to my other PR313 (which is based on this one, and goes a bit further with the refactorings) ? Or could you elaborate more on why so ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/dankcushions,13,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-310630160,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"build error on RPI3/ARM:
In file included from ../../src/device/r4300/new_dynarec/new_dynarec.c:1678:0:
../../src/device/r4300/new_dynarec/new_dynarec.c: At top level:
../../src/device/r4300/new_dynarec/arm/assem_arm.c:1011:13: warning: ‘regname’ defined but not used [-Wunused-variable]
 static char regname[16][4] = {
             ^
    CC  _obj/main/zip/unzip.o
    CC  _obj/asm_defines/asm_defines.o
    CXX _obj/osd/screenshot.o
awk -v dest_dir=""../../src/asm_defines"" -f ../../tools/gen_asm_defines.awk ""_obj/asm_defines/asm_defines.o""
    CC  _obj/device/r4300/new_dynarec/arm/linkage_arm.o
../../src/device/r4300/new_dynarec/arm/linkage_arm.S:69:29: fatal error: asm_defines_gas.h: No such file or directory
 #include ""asm_defines_gas.h""
                             ^
compilation terminated.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/Gillou68310,14,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-310630344,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"This it what the history looks like on this branch. What a mess!!!
Could you please revert your last 2 commits and rebase against master?
Sorry if I sound like a psycho ;-)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/Gillou68310,15,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-310637080,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"You cannot call a C functions because you need to keep control over the stack address in case of a tlb exception.
When a tlb exception occurs the stack address is restored with the value of the stack address right before the read/write_byte/hword/word/dword_new call.
Code invalidation is not impacted this was a mistake.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/loganmc10,16,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-310721931,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"I tested a bunch of games on the x86 new dynarec and they all seemed to work properly with this PR, but it does segfault on the next PR with the new dynarec",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/bsmiles32,17,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-310861917,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,@Gillou68310 Thank you for your valuable input. I will rebase properly against master and rework it as to not break byte and hword accesses.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/Gillou68310,18,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-310897360,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,@bsmiles32 don't spend to much time on this because I'm planning to rework the tlb exception part for the new dynarec.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/bsmiles32,19,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-311546621,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"I rebased against master, and removed forcing the word access alignment up until readw/writew functions so that eventual BADVADDR will get the correct address. Please test and double check everything so we can move on with this one :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/loganmc10,20,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-311691781,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"I tested about a dozen games using the x86 new dynarec (about 1-2 minutes per game), no issues that I can see",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/bsmiles32,21,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-312528227,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"@Gillou68310 Does it looks OK for you ? I'd like to get that merged in the coming days/weeks so I can work on the next memory refactoring PR. Thanks.
edit : rebased against master, cleaned up some commits.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/dankcushions,22,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-312706874,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,builds and works on ARM/RPI3 :),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/fzurita,23,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-312707567,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,Any good speedups on ARM?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/bsmiles32,24,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-312726469,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,Thanks for testing 😀,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/dankcushions,25,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-312729298,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,@fzurita not that I could notice. but i think it's always GPU that's a bottleneck on the RPI3.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/ricrpi,26,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-312938870,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"I tried timing the call to eglSwapBuffers() to see if the implicit glFlush() blocked. However on a Pi B I never saw it wait for the GPU. Although I guess with the more modern ARM cores, the CPU could get to the next VI before GPU has finished.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/dankcushions,27,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-312949827,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"Interesting! My go-to bottleneck area is mario 64 - the start of bobomb battlefield (immediately after the text) gets choppy with distorted sound. CPU usage isn't that high so I presume it's GPU, but maybe it's memory or something else. Other than that it seems locked at 30 for everything previous. I'd love to figure out for certain.
That's with a Pi 3, though. It never seems to max out a core in mupen, so I guess it has enough CPU grunt for the dynarec.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/bsmiles32,28,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-313110852,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"@fzurita provided that it works, you might have some more performance in the next PR (memory_refactorings).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/fzurita,29,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-313111662,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"Ok, I think I was confusing this PR with that one.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/ricrpi,30,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-313202181,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,Mupen64plus is mainly single threaded so maybe a PI 3 can't max out a quad core CPU.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/bsmiles32,31,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-315662960,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,@Gillou68310 : Is it okay if I merge this ?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/Gillou68310,32,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-315748292,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"You cannot call a C functions because you need to keep control over the stack address in case of a tlb exception.
When a tlb exception occurs the stack address is restored with the value of the stack address right before the read/write_byte/hword/word/dword_new call.

This is still true, the only reason why it's not crashing is probably because read/write dword never trigger a tlb exception. I started reworking the tlb exception code Gillou68310@feb52e7 but I don't have much time to work on it these days so progress is really slow, sorry about that.
The main idea is to remove all read/write assembly routine and use C code instead. This should make refactoring easier in the future ;-)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/loganmc10,33,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-320389641,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"@bsmiles32 if it was me I would just merge this. I don't think it's right to let the new dynarec to hold up the emulator's progress (this is coming from a guy that uses Android for mupen64plus by the way).
The x86 new dynarec is already currently broken on Android. I think all you can do is do your best to make it work with the new dynarec, and just merge it. If someone can keep up with the new dynarec then awesome, if not then it'll have to ""fall by the wayside""
This isn't meant to be a slight on anyone by the way. People are busy and we unfortunately don't have a lot of people knowledgeable with ARM assembly code to maintain it properly, especially since it reimplements things like the TLB which make it even more complicated",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/loganmc10,34,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-320390093,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"I wasn't around when the new dynarec was developed so this might make me sound like a complete idiot, but I'm not sure why the ""old dynarec"" wasn't just ported to arm. Even a device like the Raspberry Pi is only usually around 70% CPU utilization with the new dynarec, so even if the older one was a bit slower, it would probably still work well.
If I ran the zoo, I would just port the old dynarec to arm and blow away the new dynarec, it would make the code 1000% more maintainable. I'd even be willing to learn arm assembly and fumble through that task if I knew that meant we could get rid of the new dynarec",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/bsmiles32,35,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-320393989,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"@Gillou68310 Thanks for answering. I'll see if I can update the PR to address your concern, or wait after you're done with the TLB refactorings. I'm also not able to work much on this currently (and maybe for several more weeks).
@loganmc10 new dynarec is indeed difficult to maintain and slows refactorings, but unless we can replace it with something equivalent, I don't think removing it is the right way to go.
I have plans for unifying all the r4300 cores (pure_interpreter, cached_interpreter, and both dynarecs), but I wanted to finish all the memory refactorings first (eg PR 312, 313 and the fast_mem issue 277 for which I have a basic PoC locally, but I'm not getting the performance improvement I seek). The idea to unify them is to leverage LLVM infrastructure : describe mips instructions using LLVM IR, compile them so they can be called by the pure_interpreter or the cached_interpreter, or JIT them with additional optimization passes for the dynarec. This will effectively unify all r4300 cores and provide support for x86, x64, ARM and MIPS :) But that is for later, and maybe I should create an issue to open the discussion :).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/bsmiles32,36,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-334261077,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"Rebased against master, and tentative fix for ARM dynarec.
@Gillou68310 can you check if my last commit addresses your concerns please ?
I use the very same technique to call C functions as when it used to call {read,write}memd[address >> 16], but now I call dynarec{read,write}_aligned_dword.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/Gillou68310,37,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-335864748,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"@bsmiles32 I finally took some time to finish reworking the new dynarec tlb exception code https://github.com/Gillou68310/mupen64plus-core/tree/tlb_exception_rework
Once this is merged you should be able to integrate the remove_memd branch without too much trouble ;-)
@loganmc10 @fzurita This should be intensively tested (especially on ARM where I did almost no testing) before being merged!
Also I'm a bit concerned about the performance impact, could you guys try to make some measurements?
@fzurita This also fix #426",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/fzurita,38,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-335866327,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"Thanks, I'll try this as soon as I can.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/fzurita,39,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-335876525,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"It seems to be working ok in ARM. I'm trying CBFD. Performance seems identical from the FPS counter with the limiter disabled.
Goldeneye seems to work fine in ARM. I'm not seeing any performance differences.
Edit: I can confirm it fixes the freezing in CBFD intro as well.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/bsmiles32,40,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-335964618,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,@Gillou68310 Thanks for working on this ! I'll wait for this to be merged and rebase this and hopefully the other memory PR after.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/fzurita,41,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-336010160,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"@Gillou68310 You should merge your tlb_exception_rework soon, since it fixes the x86 new dynarec freezing with TLB.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/Gillou68310,42,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-336116555,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,Ok I'll merge it then.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/Gillou68310,43,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-336122935,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,Done,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/bsmiles32,44,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-336301052,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"Rebased against master. @Gillou68310 thank you very much for making progress on this, it indeed greatly simplify my work on the memory subsystem.",True,{'HOORAY': ['https://github.com/rlabrecque']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/loganmc10,45,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-336484939,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"Seems to work well on Linux (x64), no issues",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/bsmiles32,46,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-336587797,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"A superset of this PR is available here : #313
Depending on how much work we want to merge, it might be preferable to directly merge the PR 313.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/loganmc10,47,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-336588462,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"I know the last time I tested all this, this PR worked with the new dynarec but 313 crashed. It might be different now after Gillou68310's work though. I'd probably merge this and then we can focus on doing a bit more testing on 313, including making sure the memory allocation isn't an issue.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/fzurita,48,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-336589488,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"Maybe known regressions should be taken care of before merging this.
See #385",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/bsmiles32,49,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-336591340,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"@fzurita After @Gillou68310's work the only time I touched the new_dynarec in this PR (and PR 313) is for :

extra spaces in linkage_arm.S and linkage_x86.S
removing unneeded protypes in new_dynarec.c
and replacing usages of {read,write}_{d,}word_in_memory in new_dynarec.c

So I don't think this PR has high chances of breaking more the new_dynarec than what it is now. Still I can understand why we might want delay this work a little bit.
But please, don't delay this work too much, because it is quite massive therefore resolving conflicts is always tedious and I've been trying to do this refactoring for almost 3 years now (I started with the now defunct PR #47)... So I will be very happy when all these memory refactorings will be merged :)",True,{'HOORAY': ['https://github.com/rlabrecque']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/fzurita,50,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-336607903,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,@bsmiles32 Loading save states is causing crashes after this last set of commits. At least with the arm new dynarec. I haven't tried anything else.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/bsmiles32,51,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-336619883,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,@fzurita Can you get backtrace of the crash ? Or bisect more precisely (may or may not be possible) ?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/fzurita,52,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-336628631,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"Yeah, I will try. I didn't have much time last night.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/fzurita,53,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-336633482,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"Ok, here is a backtrace as of 8f918f4:
********** Crash dump: **********
Build fingerprint: 'motorola/quark_verizon/quark:6.0.1/MCG24.251-5/9:user/release-keys'
pid: 8273, tid: 8353, name: ServiceStartArg  >>> paulscode.android.mupen64plusae.GameActivity <<<
signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x0
Stack frame #00 pc 0002911c  libmupen64plus-core.so: Routine set_rumble_reg at ./mupen64plus-core/src/device/controllers/paks/rumblepak.c:32
Stack frame #01 pc 00016a50  libmupen64plus-core.so: Routine savestates_load_m64p at ./mupen64plus-core/src/main/savestates.c:643
Stack frame #02 pc 00017210  libmupen64plus-core.so: Routine savestates_load at ./mupen64plus-core/src/main/savestates.c:1152
Stack frame #03 pc 000b45ac  libmupen64plus-core.so: Routine .E1 at linkage_arm.S:?

This happens when loading a save state at startup or when loading a save state after the emulator has started.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/loganmc10,54,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-336710637,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"I also just got a report about crashing save states, this is on Windows:
https://github.com/m64p/mupen64plus-GLideN64/issues/22",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,312,2017-06-08T13:25:33Z,2017-10-14T01:00:04Z,2017-11-02T01:53:40Z,MERGED,True,674,975,42,https://github.com/bsmiles32,Remove memd,51,[],https://github.com/mupen64plus/mupen64plus-core/pull/312,https://github.com/bsmiles32,55,https://github.com/mupen64plus/mupen64plus-core/pull/312#issuecomment-336714117,Some more refactorings which allows to get rid of dword memory accessors. Some more will come in this PR or later PR depending on feedback. Please test and report regressions.,"@fzurita  @loganmc10 Can you test #439 ?
Also it was not related to this PR but on the one about SI refactorings.
Hope it fixes this issue as I will be away for a couple of days...
Sorry for the inconvenience.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,313,2017-06-15T00:53:10Z,2017-10-14T01:00:02Z,2017-11-02T01:53:36Z,MERGED,True,940,1566,52,https://github.com/bsmiles32,Memory refactorings,66,[],https://github.com/mupen64plus/mupen64plus-core/pull/313,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/313,"DON'T MERGE !
This is a WIP, with several refactorings concerning mainly the memory module :

now the memory module only deals with ""physical"" mappings (virtual to physical translation is done in r4300)
no more usage of global variables in this module
single allocation of memory for all device memories. I allocate 512M, but only a fraction gets used (eg RAM, ROM, PIF_RAM, SP_MEM). This simplify the fast_mem_access function which gives a nice speed boost on the pure_interpreter. This also paves the way for the ""fast memory"" implementation.
memory mappings are defined in the device module
pifbootrom has been reworked to not use the device structure, but only r4300_core struct. This also paves the way for external PIFBootROM support. Not there yet, but closer.

edit: It also breaks the cached_interpreter, don't know why. And I didn't really bother with the new_dynarec so it should break it quite badly.
When I get some time, I will try to rework it and put it into shape. But early testers are welcome :)
Especially, I'd like to know if it improves the emulation speed on other computers without bad regressions.","DON'T MERGE !
This is a WIP, with several refactorings concerning mainly the memory module :

now the memory module only deals with ""physical"" mappings (virtual to physical translation is done in r4300)
no more usage of global variables in this module
single allocation of memory for all device memories. I allocate 512M, but only a fraction gets used (eg RAM, ROM, PIF_RAM, SP_MEM). This simplify the fast_mem_access function which gives a nice speed boost on the pure_interpreter. This also paves the way for the ""fast memory"" implementation.
memory mappings are defined in the device module
pifbootrom has been reworked to not use the device structure, but only r4300_core struct. This also paves the way for external PIFBootROM support. Not there yet, but closer.

edit: It also breaks the cached_interpreter, don't know why. And I didn't really bother with the new_dynarec so it should break it quite badly.
When I get some time, I will try to rework it and put it into shape. But early testers are welcome :)
Especially, I'd like to know if it improves the emulation speed on other computers without bad regressions.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,313,2017-06-15T00:53:10Z,2017-10-14T01:00:02Z,2017-11-02T01:53:36Z,MERGED,True,940,1566,52,https://github.com/bsmiles32,Memory refactorings,66,[],https://github.com/mupen64plus/mupen64plus-core/pull/313,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/313#issuecomment-308603687,"DON'T MERGE !
This is a WIP, with several refactorings concerning mainly the memory module :

now the memory module only deals with ""physical"" mappings (virtual to physical translation is done in r4300)
no more usage of global variables in this module
single allocation of memory for all device memories. I allocate 512M, but only a fraction gets used (eg RAM, ROM, PIF_RAM, SP_MEM). This simplify the fast_mem_access function which gives a nice speed boost on the pure_interpreter. This also paves the way for the ""fast memory"" implementation.
memory mappings are defined in the device module
pifbootrom has been reworked to not use the device structure, but only r4300_core struct. This also paves the way for external PIFBootROM support. Not there yet, but closer.

edit: It also breaks the cached_interpreter, don't know why. And I didn't really bother with the new_dynarec so it should break it quite badly.
When I get some time, I will try to rework it and put it into shape. But early testers are welcome :)
Especially, I'd like to know if it improves the emulation speed on other computers without bad regressions.","I tried Super Mario and Smash Bros, neither booted with x64 dynarec or either interpreter, it didn't crash, but CPU was at 100%, here is what GDB had if I Ctrl+C'ed out of the program:
(gdb) backtrace
#0  SPECIAL (PC=3915365300, inst=<optimized out>) at ../..//su.c:1702
#1  run_task () at ../..//su.c:2006
#2  0x00007fffccc1e7c9 in DoRspCycles (cycles=4294967295) at ../..//module.c:375
#3  0x00007ffff05edead in do_SP_Task (sp=0x7ffff1939718 <g_dev+17834392>) at ../../src/device/rsp/rsp_core.c:297
#4  0x00007ffff05eb583 in r4300_write_aligned_word (r4300=0x7ffff0837580 <g_dev>, address=67371024, value=1, mask=<optimized out>) at ../../src/device/r4300/r4300_core.c:393
#5  0x00007ffff05d0eee in pifbootrom_hle_execute (r4300=0x7ffff0837580 <g_dev>) at ../../src/device/pifbootrom/pifbootrom.c:74
#6  0x00007ffff05f5e64 in main_run () at ../../src/main/main.c:1120
#7  0x00007ffff05d834d in CoreDoCommand (Command=<optimized out>, ParamInt=<optimized out>, ParamPtr=<optimized out>, ParamPtr=<optimized out>, ParamInt=<optimized out>, 
    Command=<optimized out>) at ../../src/api/frontend.c:225
#8  0x0000000000402e7f in main (argc=<optimized out>, argv=<optimized out>) at ../../src/main.c:798

I tested this using rsp-cxd4 in HLE video mode",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,313,2017-06-15T00:53:10Z,2017-10-14T01:00:02Z,2017-11-02T01:53:36Z,MERGED,True,940,1566,52,https://github.com/bsmiles32,Memory refactorings,66,[],https://github.com/mupen64plus/mupen64plus-core/pull/313,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/313#issuecomment-308608262,"DON'T MERGE !
This is a WIP, with several refactorings concerning mainly the memory module :

now the memory module only deals with ""physical"" mappings (virtual to physical translation is done in r4300)
no more usage of global variables in this module
single allocation of memory for all device memories. I allocate 512M, but only a fraction gets used (eg RAM, ROM, PIF_RAM, SP_MEM). This simplify the fast_mem_access function which gives a nice speed boost on the pure_interpreter. This also paves the way for the ""fast memory"" implementation.
memory mappings are defined in the device module
pifbootrom has been reworked to not use the device structure, but only r4300_core struct. This also paves the way for external PIFBootROM support. Not there yet, but closer.

edit: It also breaks the cached_interpreter, don't know why. And I didn't really bother with the new_dynarec so it should break it quite badly.
When I get some time, I will try to rework it and put it into shape. But early testers are welcome :)
Especially, I'd like to know if it improves the emulation speed on other computers without bad regressions.","Also, malloc'ing 512MB of RAM will be pretty tight on some ARM devices. A lot of Android devices only have 2GB of RAM, my Shield Tablet has 2GB and it says only 487 is free right now (although I assume it would just close some old apps if an app requested memory, so it's probably not a problem). The Raspberry Pi also has 1GB of RAM.
Is there some way to have a ""fallback mode""? Either if the malloc fails or if the user requests it. I'm really excited for fast memory access so I think it should go forward, but it might mean that performance actually suffers on low memory devices",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,313,2017-06-15T00:53:10Z,2017-10-14T01:00:02Z,2017-11-02T01:53:36Z,MERGED,True,940,1566,52,https://github.com/bsmiles32,Memory refactorings,66,[],https://github.com/mupen64plus/mupen64plus-core/pull/313,https://github.com/bsmiles32,4,https://github.com/mupen64plus/mupen64plus-core/pull/313#issuecomment-308617581,"DON'T MERGE !
This is a WIP, with several refactorings concerning mainly the memory module :

now the memory module only deals with ""physical"" mappings (virtual to physical translation is done in r4300)
no more usage of global variables in this module
single allocation of memory for all device memories. I allocate 512M, but only a fraction gets used (eg RAM, ROM, PIF_RAM, SP_MEM). This simplify the fast_mem_access function which gives a nice speed boost on the pure_interpreter. This also paves the way for the ""fast memory"" implementation.
memory mappings are defined in the device module
pifbootrom has been reworked to not use the device structure, but only r4300_core struct. This also paves the way for external PIFBootROM support. Not there yet, but closer.

edit: It also breaks the cached_interpreter, don't know why. And I didn't really bother with the new_dynarec so it should break it quite badly.
When I get some time, I will try to rework it and put it into shape. But early testers are welcome :)
Especially, I'd like to know if it improves the emulation speed on other computers without bad regressions.","Normally the kernel should lazy alloc it, so only pages that are really accessed are allocated. I guess it should be no problem.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,313,2017-06-15T00:53:10Z,2017-10-14T01:00:02Z,2017-11-02T01:53:36Z,MERGED,True,940,1566,52,https://github.com/bsmiles32,Memory refactorings,66,[],https://github.com/mupen64plus/mupen64plus-core/pull/313,https://github.com/bsmiles32,5,https://github.com/mupen64plus/mupen64plus-core/pull/313#issuecomment-308772273,"DON'T MERGE !
This is a WIP, with several refactorings concerning mainly the memory module :

now the memory module only deals with ""physical"" mappings (virtual to physical translation is done in r4300)
no more usage of global variables in this module
single allocation of memory for all device memories. I allocate 512M, but only a fraction gets used (eg RAM, ROM, PIF_RAM, SP_MEM). This simplify the fast_mem_access function which gives a nice speed boost on the pure_interpreter. This also paves the way for the ""fast memory"" implementation.
memory mappings are defined in the device module
pifbootrom has been reworked to not use the device structure, but only r4300_core struct. This also paves the way for external PIFBootROM support. Not there yet, but closer.

edit: It also breaks the cached_interpreter, don't know why. And I didn't really bother with the new_dynarec so it should break it quite badly.
When I get some time, I will try to rework it and put it into shape. But early testers are welcome :)
Especially, I'd like to know if it improves the emulation speed on other computers without bad regressions.","Several fixes which re-enable the cached interpreter and improve pifbootrom hle implementation.
As far as I understand, only new dynarec needs fixing and that is mostly at commit 424938e because memory mappings are now defined with physical addresses instead of virtual addresses.
@Gillou68310 : any ideas on how to fix this. Because previously the new_dynarec hooked his own MMIO routines to do its own TLB operations. But with physical mappings this hooking is out of question.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,313,2017-06-15T00:53:10Z,2017-10-14T01:00:02Z,2017-11-02T01:53:36Z,MERGED,True,940,1566,52,https://github.com/bsmiles32,Memory refactorings,66,[],https://github.com/mupen64plus/mupen64plus-core/pull/313,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/313#issuecomment-308778754,"DON'T MERGE !
This is a WIP, with several refactorings concerning mainly the memory module :

now the memory module only deals with ""physical"" mappings (virtual to physical translation is done in r4300)
no more usage of global variables in this module
single allocation of memory for all device memories. I allocate 512M, but only a fraction gets used (eg RAM, ROM, PIF_RAM, SP_MEM). This simplify the fast_mem_access function which gives a nice speed boost on the pure_interpreter. This also paves the way for the ""fast memory"" implementation.
memory mappings are defined in the device module
pifbootrom has been reworked to not use the device structure, but only r4300_core struct. This also paves the way for external PIFBootROM support. Not there yet, but closer.

edit: It also breaks the cached_interpreter, don't know why. And I didn't really bother with the new_dynarec so it should break it quite badly.
When I get some time, I will try to rework it and put it into shape. But early testers are welcome :)
Especially, I'd like to know if it improves the emulation speed on other computers without bad regressions.","Crashing is fixed for me, tested several games on x64 dynarec and Cached/Pure Interpreter, seems to be working well now",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,313,2017-06-15T00:53:10Z,2017-10-14T01:00:02Z,2017-11-02T01:53:36Z,MERGED,True,940,1566,52,https://github.com/bsmiles32,Memory refactorings,66,[],https://github.com/mupen64plus/mupen64plus-core/pull/313,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/313#issuecomment-308847339,"DON'T MERGE !
This is a WIP, with several refactorings concerning mainly the memory module :

now the memory module only deals with ""physical"" mappings (virtual to physical translation is done in r4300)
no more usage of global variables in this module
single allocation of memory for all device memories. I allocate 512M, but only a fraction gets used (eg RAM, ROM, PIF_RAM, SP_MEM). This simplify the fast_mem_access function which gives a nice speed boost on the pure_interpreter. This also paves the way for the ""fast memory"" implementation.
memory mappings are defined in the device module
pifbootrom has been reworked to not use the device structure, but only r4300_core struct. This also paves the way for external PIFBootROM support. Not there yet, but closer.

edit: It also breaks the cached_interpreter, don't know why. And I didn't really bother with the new_dynarec so it should break it quite badly.
When I get some time, I will try to rework it and put it into shape. But early testers are welcome :)
Especially, I'd like to know if it improves the emulation speed on other computers without bad regressions.","Just tried compiling x86 new dynarec, I get this error on linking:
_obj/device/r4300/new_dynarec/x86/linkage_x86.o:../../src/device/r:(.text+0x5c8): undefined reference to `write_mi'

I'm not sure if the error is a result of a commit from this PR or the previous one",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,313,2017-06-15T00:53:10Z,2017-10-14T01:00:02Z,2017-11-02T01:53:36Z,MERGED,True,940,1566,52,https://github.com/bsmiles32,Memory refactorings,66,[],https://github.com/mupen64plus/mupen64plus-core/pull/313,https://github.com/bsmiles32,8,https://github.com/mupen64plus/mupen64plus-core/pull/313#issuecomment-308849113,"DON'T MERGE !
This is a WIP, with several refactorings concerning mainly the memory module :

now the memory module only deals with ""physical"" mappings (virtual to physical translation is done in r4300)
no more usage of global variables in this module
single allocation of memory for all device memories. I allocate 512M, but only a fraction gets used (eg RAM, ROM, PIF_RAM, SP_MEM). This simplify the fast_mem_access function which gives a nice speed boost on the pure_interpreter. This also paves the way for the ""fast memory"" implementation.
memory mappings are defined in the device module
pifbootrom has been reworked to not use the device structure, but only r4300_core struct. This also paves the way for external PIFBootROM support. Not there yet, but closer.

edit: It also breaks the cached_interpreter, don't know why. And I didn't really bother with the new_dynarec so it should break it quite badly.
When I get some time, I will try to rework it and put it into shape. But early testers are welcome :)
Especially, I'd like to know if it improves the emulation speed on other computers without bad regressions.","New_dynarec requires some more work unfortunately. I will need help from Gillou on this, because I'm not familiar with how the new_dynarec does code invalidation, and TLB translation.
Still if you manage to hack around and get the pure or cached interpreters to run on your rpi I'm interested in your results 😀",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,313,2017-06-15T00:53:10Z,2017-10-14T01:00:02Z,2017-11-02T01:53:36Z,MERGED,True,940,1566,52,https://github.com/bsmiles32,Memory refactorings,66,[],https://github.com/mupen64plus/mupen64plus-core/pull/313,https://github.com/loganmc10,9,https://github.com/mupen64plus/mupen64plus-core/pull/313#issuecomment-308855825,"DON'T MERGE !
This is a WIP, with several refactorings concerning mainly the memory module :

now the memory module only deals with ""physical"" mappings (virtual to physical translation is done in r4300)
no more usage of global variables in this module
single allocation of memory for all device memories. I allocate 512M, but only a fraction gets used (eg RAM, ROM, PIF_RAM, SP_MEM). This simplify the fast_mem_access function which gives a nice speed boost on the pure_interpreter. This also paves the way for the ""fast memory"" implementation.
memory mappings are defined in the device module
pifbootrom has been reworked to not use the device structure, but only r4300_core struct. This also paves the way for external PIFBootROM support. Not there yet, but closer.

edit: It also breaks the cached_interpreter, don't know why. And I didn't really bother with the new_dynarec so it should break it quite badly.
When I get some time, I will try to rework it and put it into shape. But early testers are welcome :)
Especially, I'd like to know if it improves the emulation speed on other computers without bad regressions.","I've tested the Pure Interpreter inside my VMware machine. In my testing this PR saves about 2% CPU time in Pure Interpreter mode on average. Sometimes it was pretty much the same, I would just run the same scene in both versions and compare what I saw in ""top"", so the testing wasn't anything too scientific. I don't see any regressions anyway.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,313,2017-06-15T00:53:10Z,2017-10-14T01:00:02Z,2017-11-02T01:53:36Z,MERGED,True,940,1566,52,https://github.com/bsmiles32,Memory refactorings,66,[],https://github.com/mupen64plus/mupen64plus-core/pull/313,https://github.com/bsmiles32,10,https://github.com/mupen64plus/mupen64plus-core/pull/313#issuecomment-308856730,"DON'T MERGE !
This is a WIP, with several refactorings concerning mainly the memory module :

now the memory module only deals with ""physical"" mappings (virtual to physical translation is done in r4300)
no more usage of global variables in this module
single allocation of memory for all device memories. I allocate 512M, but only a fraction gets used (eg RAM, ROM, PIF_RAM, SP_MEM). This simplify the fast_mem_access function which gives a nice speed boost on the pure_interpreter. This also paves the way for the ""fast memory"" implementation.
memory mappings are defined in the device module
pifbootrom has been reworked to not use the device structure, but only r4300_core struct. This also paves the way for external PIFBootROM support. Not there yet, but closer.

edit: It also breaks the cached_interpreter, don't know why. And I didn't really bother with the new_dynarec so it should break it quite badly.
When I get some time, I will try to rework it and put it into shape. But early testers are welcome :)
Especially, I'd like to know if it improves the emulation speed on other computers without bad regressions.","Good ! Thanks for testing ! 2% now, hope for some more with full fast mem 😀",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,313,2017-06-15T00:53:10Z,2017-10-14T01:00:02Z,2017-11-02T01:53:36Z,MERGED,True,940,1566,52,https://github.com/bsmiles32,Memory refactorings,66,[],https://github.com/mupen64plus/mupen64plus-core/pull/313,https://github.com/bsmiles32,11,https://github.com/mupen64plus/mupen64plus-core/pull/313#issuecomment-308857201,"DON'T MERGE !
This is a WIP, with several refactorings concerning mainly the memory module :

now the memory module only deals with ""physical"" mappings (virtual to physical translation is done in r4300)
no more usage of global variables in this module
single allocation of memory for all device memories. I allocate 512M, but only a fraction gets used (eg RAM, ROM, PIF_RAM, SP_MEM). This simplify the fast_mem_access function which gives a nice speed boost on the pure_interpreter. This also paves the way for the ""fast memory"" implementation.
memory mappings are defined in the device module
pifbootrom has been reworked to not use the device structure, but only r4300_core struct. This also paves the way for external PIFBootROM support. Not there yet, but closer.

edit: It also breaks the cached_interpreter, don't know why. And I didn't really bother with the new_dynarec so it should break it quite badly.
When I get some time, I will try to rework it and put it into shape. But early testers are welcome :)
Especially, I'd like to know if it improves the emulation speed on other computers without bad regressions.",This also validate the big allocation approach. So this is good.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,313,2017-06-15T00:53:10Z,2017-10-14T01:00:02Z,2017-11-02T01:53:36Z,MERGED,True,940,1566,52,https://github.com/bsmiles32,Memory refactorings,66,[],https://github.com/mupen64plus/mupen64plus-core/pull/313,https://github.com/loganmc10,12,https://github.com/mupen64plus/mupen64plus-core/pull/313#issuecomment-308857252,"DON'T MERGE !
This is a WIP, with several refactorings concerning mainly the memory module :

now the memory module only deals with ""physical"" mappings (virtual to physical translation is done in r4300)
no more usage of global variables in this module
single allocation of memory for all device memories. I allocate 512M, but only a fraction gets used (eg RAM, ROM, PIF_RAM, SP_MEM). This simplify the fast_mem_access function which gives a nice speed boost on the pure_interpreter. This also paves the way for the ""fast memory"" implementation.
memory mappings are defined in the device module
pifbootrom has been reworked to not use the device structure, but only r4300_core struct. This also paves the way for external PIFBootROM support. Not there yet, but closer.

edit: It also breaks the cached_interpreter, don't know why. And I didn't really bother with the new_dynarec so it should break it quite badly.
When I get some time, I will try to rework it and put it into shape. But early testers are welcome :)
Especially, I'd like to know if it improves the emulation speed on other computers without bad regressions.",My dream would be to get to the point where the cached interpreter would be fast enough on mobile devices to get rid of the dynarec's altogether (but this is probably an unrealistic dream). I think having an arm dynarec without anyone with enough time or knowledge to maintain it is really going to hold things back.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,313,2017-06-15T00:53:10Z,2017-10-14T01:00:02Z,2017-11-02T01:53:36Z,MERGED,True,940,1566,52,https://github.com/bsmiles32,Memory refactorings,66,[],https://github.com/mupen64plus/mupen64plus-core/pull/313,https://github.com/bsmiles32,13,https://github.com/mupen64plus/mupen64plus-core/pull/313#issuecomment-308858883,"DON'T MERGE !
This is a WIP, with several refactorings concerning mainly the memory module :

now the memory module only deals with ""physical"" mappings (virtual to physical translation is done in r4300)
no more usage of global variables in this module
single allocation of memory for all device memories. I allocate 512M, but only a fraction gets used (eg RAM, ROM, PIF_RAM, SP_MEM). This simplify the fast_mem_access function which gives a nice speed boost on the pure_interpreter. This also paves the way for the ""fast memory"" implementation.
memory mappings are defined in the device module
pifbootrom has been reworked to not use the device structure, but only r4300_core struct. This also paves the way for external PIFBootROM support. Not there yet, but closer.

edit: It also breaks the cached_interpreter, don't know why. And I didn't really bother with the new_dynarec so it should break it quite badly.
When I get some time, I will try to rework it and put it into shape. But early testers are welcome :)
Especially, I'd like to know if it improves the emulation speed on other computers without bad regressions.","I feel the same way ! Only one person knows how to work with the new dynarec... And its not me. So all my refactorings take much more time than needed. I have hope (and maybe a long term plan) to unify the pure,cached and both dynarec. But this will take more time than I have now.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,313,2017-06-15T00:53:10Z,2017-10-14T01:00:02Z,2017-11-02T01:53:36Z,MERGED,True,940,1566,52,https://github.com/bsmiles32,Memory refactorings,66,[],https://github.com/mupen64plus/mupen64plus-core/pull/313,https://github.com/bsmiles32,14,https://github.com/mupen64plus/mupen64plus-core/pull/313#issuecomment-309263886,"DON'T MERGE !
This is a WIP, with several refactorings concerning mainly the memory module :

now the memory module only deals with ""physical"" mappings (virtual to physical translation is done in r4300)
no more usage of global variables in this module
single allocation of memory for all device memories. I allocate 512M, but only a fraction gets used (eg RAM, ROM, PIF_RAM, SP_MEM). This simplify the fast_mem_access function which gives a nice speed boost on the pure_interpreter. This also paves the way for the ""fast memory"" implementation.
memory mappings are defined in the device module
pifbootrom has been reworked to not use the device structure, but only r4300_core struct. This also paves the way for external PIFBootROM support. Not there yet, but closer.

edit: It also breaks the cached_interpreter, don't know why. And I didn't really bother with the new_dynarec so it should break it quite badly.
When I get some time, I will try to rework it and put it into shape. But early testers are welcome :)
Especially, I'd like to know if it improves the emulation speed on other computers without bad regressions.","Tried something to fix the new dynarec. Don't know if it will work, but it's a step closer I guess.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,313,2017-06-15T00:53:10Z,2017-10-14T01:00:02Z,2017-11-02T01:53:36Z,MERGED,True,940,1566,52,https://github.com/bsmiles32,Memory refactorings,66,[],https://github.com/mupen64plus/mupen64plus-core/pull/313,https://github.com/ricrpi,15,https://github.com/mupen64plus/mupen64plus-core/pull/313#issuecomment-309274730,"DON'T MERGE !
This is a WIP, with several refactorings concerning mainly the memory module :

now the memory module only deals with ""physical"" mappings (virtual to physical translation is done in r4300)
no more usage of global variables in this module
single allocation of memory for all device memories. I allocate 512M, but only a fraction gets used (eg RAM, ROM, PIF_RAM, SP_MEM). This simplify the fast_mem_access function which gives a nice speed boost on the pure_interpreter. This also paves the way for the ""fast memory"" implementation.
memory mappings are defined in the device module
pifbootrom has been reworked to not use the device structure, but only r4300_core struct. This also paves the way for external PIFBootROM support. Not there yet, but closer.

edit: It also breaks the cached_interpreter, don't know why. And I didn't really bother with the new_dynarec so it should break it quite badly.
When I get some time, I will try to rework it and put it into shape. But early testers are welcome :)
Especially, I'd like to know if it improves the emulation speed on other computers without bad regressions.","What if only 128MB + ROM size is used and a catch for PIF access?
Also how does Linux handle lazy allocation if MAP_LOCKED is used with mmap() to try and reduce page faults?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,313,2017-06-15T00:53:10Z,2017-10-14T01:00:02Z,2017-11-02T01:53:36Z,MERGED,True,940,1566,52,https://github.com/bsmiles32,Memory refactorings,66,[],https://github.com/mupen64plus/mupen64plus-core/pull/313,https://github.com/bsmiles32,16,https://github.com/mupen64plus/mupen64plus-core/pull/313#issuecomment-309282416,"DON'T MERGE !
This is a WIP, with several refactorings concerning mainly the memory module :

now the memory module only deals with ""physical"" mappings (virtual to physical translation is done in r4300)
no more usage of global variables in this module
single allocation of memory for all device memories. I allocate 512M, but only a fraction gets used (eg RAM, ROM, PIF_RAM, SP_MEM). This simplify the fast_mem_access function which gives a nice speed boost on the pure_interpreter. This also paves the way for the ""fast memory"" implementation.
memory mappings are defined in the device module
pifbootrom has been reworked to not use the device structure, but only r4300_core struct. This also paves the way for external PIFBootROM support. Not there yet, but closer.

edit: It also breaks the cached_interpreter, don't know why. And I didn't really bother with the new_dynarec so it should break it quite badly.
When I get some time, I will try to rework it and put it into shape. But early testers are welcome :)
Especially, I'd like to know if it improves the emulation speed on other computers without bad regressions.","Not really sure, but from what I undestand it allocates 512MB of virtual memory, then when accesses are made physical pages are allocated when needed. Of all of these 512MB only ram_size+rom_size+rsp_mem_size+pif_boot_rom_size+pif_ram_size+rounding to next physical page size will get physically allocated (approximately).
Note that for now no pagefault mecanism is in use (this is not yet the fast mem approach). This just make all N64 memories accessible through à single pointer, which gives a small speed boost on fast_mem_address due to the removed if/else logic at the cost of a small increase of memory usage.
The next step is indeed to change memory protection of region with mmio semantic in order to trigger a pagefault which will allow to call the appropriate mmio handler. But that's for later.
Still I'm interested to know if this big allocation works reliably on 32bit systems such as the rpi.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,313,2017-06-15T00:53:10Z,2017-10-14T01:00:02Z,2017-11-02T01:53:36Z,MERGED,True,940,1566,52,https://github.com/bsmiles32,Memory refactorings,66,[],https://github.com/mupen64plus/mupen64plus-core/pull/313,https://github.com/dankcushions,17,https://github.com/mupen64plus/mupen64plus-core/pull/313#issuecomment-309488600,"DON'T MERGE !
This is a WIP, with several refactorings concerning mainly the memory module :

now the memory module only deals with ""physical"" mappings (virtual to physical translation is done in r4300)
no more usage of global variables in this module
single allocation of memory for all device memories. I allocate 512M, but only a fraction gets used (eg RAM, ROM, PIF_RAM, SP_MEM). This simplify the fast_mem_access function which gives a nice speed boost on the pure_interpreter. This also paves the way for the ""fast memory"" implementation.
memory mappings are defined in the device module
pifbootrom has been reworked to not use the device structure, but only r4300_core struct. This also paves the way for external PIFBootROM support. Not there yet, but closer.

edit: It also breaks the cached_interpreter, don't know why. And I didn't really bother with the new_dynarec so it should break it quite badly.
When I get some time, I will try to rework it and put it into shape. But early testers are welcome :)
Especially, I'd like to know if it improves the emulation speed on other computers without bad regressions.","build error with arm + RPI3:
   CC  _obj/asm_defines/asm_defines.o
    CXX _obj/osd/screenshot.o
nm _obj/asm_defines/asm_defines.o | awk -v dest_dir=""../../src/asm_defines"" -f ../../tools/gen_asm_defines.awk
    CC  _obj/device/r4300/new_dynarec/arm/linkage_arm.o
    LD  libmupen64plus.so.2.0.0
/usr/bin/ld: _obj/device/r4300/new_dynarec/arm/linkage_arm.o: relocation R_ARM_MOVW_ABS_NC against `dynarec_read_aligned_dword' can not be used when making a shared object; recompile with -fPIC
_obj/device/r4300/new_dynarec/arm/linkage_arm.o: error adding symbols: Bad value
collect2: error: ld returned 1 exit status
Makefile:706: recipe for target 'libmupen64plus.so.2.0.0' failed
make: *** [libmupen64plus.so.2.0.0] Error 1

this might be a compilation options issue with -fPIC, but by default I get this.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,313,2017-06-15T00:53:10Z,2017-10-14T01:00:02Z,2017-11-02T01:53:36Z,MERGED,True,940,1566,52,https://github.com/bsmiles32,Memory refactorings,66,[],https://github.com/mupen64plus/mupen64plus-core/pull/313,https://github.com/loganmc10,18,https://github.com/mupen64plus/mupen64plus-core/pull/313#issuecomment-309633057,"DON'T MERGE !
This is a WIP, with several refactorings concerning mainly the memory module :

now the memory module only deals with ""physical"" mappings (virtual to physical translation is done in r4300)
no more usage of global variables in this module
single allocation of memory for all device memories. I allocate 512M, but only a fraction gets used (eg RAM, ROM, PIF_RAM, SP_MEM). This simplify the fast_mem_access function which gives a nice speed boost on the pure_interpreter. This also paves the way for the ""fast memory"" implementation.
memory mappings are defined in the device module
pifbootrom has been reworked to not use the device structure, but only r4300_core struct. This also paves the way for external PIFBootROM support. Not there yet, but closer.

edit: It also breaks the cached_interpreter, don't know why. And I didn't really bother with the new_dynarec so it should break it quite badly.
When I get some time, I will try to rework it and put it into shape. But early testers are welcome :)
Especially, I'd like to know if it improves the emulation speed on other computers without bad regressions.","I briefly tested a few games with the x86 new dynarec and it seems to be working properly.
EDIT: Actually I must have been pointing to the wrong thing, I still get this with x86 new dynarec:
UI-Console Error: dlopen('./libmupen64plus.so.2') failed: ./libmupen64plus.so.2: undefined symbol: write_mi",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,313,2017-06-15T00:53:10Z,2017-10-14T01:00:02Z,2017-11-02T01:53:36Z,MERGED,True,940,1566,52,https://github.com/bsmiles32,Memory refactorings,66,[],https://github.com/mupen64plus/mupen64plus-core/pull/313,https://github.com/bsmiles32,19,https://github.com/mupen64plus/mupen64plus-core/pull/313#issuecomment-309639507,"DON'T MERGE !
This is a WIP, with several refactorings concerning mainly the memory module :

now the memory module only deals with ""physical"" mappings (virtual to physical translation is done in r4300)
no more usage of global variables in this module
single allocation of memory for all device memories. I allocate 512M, but only a fraction gets used (eg RAM, ROM, PIF_RAM, SP_MEM). This simplify the fast_mem_access function which gives a nice speed boost on the pure_interpreter. This also paves the way for the ""fast memory"" implementation.
memory mappings are defined in the device module
pifbootrom has been reworked to not use the device structure, but only r4300_core struct. This also paves the way for external PIFBootROM support. Not there yet, but closer.

edit: It also breaks the cached_interpreter, don't know why. And I didn't really bother with the new_dynarec so it should break it quite badly.
When I get some time, I will try to rework it and put it into shape. But early testers are welcome :)
Especially, I'd like to know if it improves the emulation speed on other computers without bad regressions.","Updated with 2 fixes :

one from remove_memd PR concerning the way I called dynarec_{read,write}_aligned_dword
one for the missing write_mi function

Thank you guys for testing  :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,313,2017-06-15T00:53:10Z,2017-10-14T01:00:02Z,2017-11-02T01:53:36Z,MERGED,True,940,1566,52,https://github.com/bsmiles32,Memory refactorings,66,[],https://github.com/mupen64plus/mupen64plus-core/pull/313,https://github.com/dankcushions,20,https://github.com/mupen64plus/mupen64plus-core/pull/313#issuecomment-310493797,"DON'T MERGE !
This is a WIP, with several refactorings concerning mainly the memory module :

now the memory module only deals with ""physical"" mappings (virtual to physical translation is done in r4300)
no more usage of global variables in this module
single allocation of memory for all device memories. I allocate 512M, but only a fraction gets used (eg RAM, ROM, PIF_RAM, SP_MEM). This simplify the fast_mem_access function which gives a nice speed boost on the pure_interpreter. This also paves the way for the ""fast memory"" implementation.
memory mappings are defined in the device module
pifbootrom has been reworked to not use the device structure, but only r4300_core struct. This also paves the way for external PIFBootROM support. Not there yet, but closer.

edit: It also breaks the cached_interpreter, don't know why. And I didn't really bother with the new_dynarec so it should break it quite badly.
When I get some time, I will try to rework it and put it into shape. But early testers are welcome :)
Especially, I'd like to know if it improves the emulation speed on other computers without bad regressions.","builds! but segfaults for me. unfortunately i think the backtrace is not useful:
[Thread debugging using libthread_db enabled]
Using host libthread_db library ""/lib/arm-linux-gnueabihf/libthread_db.so.1"".
[New Thread 0x478aa460 (LWP 15533)]
[New Thread 0x46ef3460 (LWP 15534)]
[New Thread 0x464ff460 (LWP 15535)]
[New Thread 0x45cff460 (LWP 15536)]
[New Thread 0x454ff460 (LWP 15537)]
[New Thread 0x44cff460 (LWP 15538)]
[New Thread 0x444ff460 (LWP 15539)]

Program received signal SIGSEGV, Segmentation fault.
0x61746144 in ?? ()
(gdb) bt
#0  0x61746144 in ?? ()
#1  0x67ade5e0 in ?? () from /opt/retropie/emulators/mupen64plus/lib/libmupen64plus.so.2
Backtrace stopped: previous frame identical to this frame (corrupt stack?)

went back to master and everything worked ok via gdb. that's all i've got, sorry :(",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,313,2017-06-15T00:53:10Z,2017-10-14T01:00:02Z,2017-11-02T01:53:36Z,MERGED,True,940,1566,52,https://github.com/bsmiles32,Memory refactorings,66,[],https://github.com/mupen64plus/mupen64plus-core/pull/313,https://github.com/bsmiles32,21,https://github.com/mupen64plus/mupen64plus-core/pull/313#issuecomment-310565393,"DON'T MERGE !
This is a WIP, with several refactorings concerning mainly the memory module :

now the memory module only deals with ""physical"" mappings (virtual to physical translation is done in r4300)
no more usage of global variables in this module
single allocation of memory for all device memories. I allocate 512M, but only a fraction gets used (eg RAM, ROM, PIF_RAM, SP_MEM). This simplify the fast_mem_access function which gives a nice speed boost on the pure_interpreter. This also paves the way for the ""fast memory"" implementation.
memory mappings are defined in the device module
pifbootrom has been reworked to not use the device structure, but only r4300_core struct. This also paves the way for external PIFBootROM support. Not there yet, but closer.

edit: It also breaks the cached_interpreter, don't know why. And I didn't really bother with the new_dynarec so it should break it quite badly.
When I get some time, I will try to rework it and put it into shape. But early testers are welcome :)
Especially, I'd like to know if it improves the emulation speed on other computers without bad regressions.","@dankcushions Thanks for testing.
I guess, this PR will be on hold until we can merge PR312 ""remove_memd"".",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,313,2017-06-15T00:53:10Z,2017-10-14T01:00:02Z,2017-11-02T01:53:36Z,MERGED,True,940,1566,52,https://github.com/bsmiles32,Memory refactorings,66,[],https://github.com/mupen64plus/mupen64plus-core/pull/313,https://github.com/bsmiles32,22,https://github.com/mupen64plus/mupen64plus-core/pull/313#issuecomment-312563746,"DON'T MERGE !
This is a WIP, with several refactorings concerning mainly the memory module :

now the memory module only deals with ""physical"" mappings (virtual to physical translation is done in r4300)
no more usage of global variables in this module
single allocation of memory for all device memories. I allocate 512M, but only a fraction gets used (eg RAM, ROM, PIF_RAM, SP_MEM). This simplify the fast_mem_access function which gives a nice speed boost on the pure_interpreter. This also paves the way for the ""fast memory"" implementation.
memory mappings are defined in the device module
pifbootrom has been reworked to not use the device structure, but only r4300_core struct. This also paves the way for external PIFBootROM support. Not there yet, but closer.

edit: It also breaks the cached_interpreter, don't know why. And I didn't really bother with the new_dynarec so it should break it quite badly.
When I get some time, I will try to rework it and put it into shape. But early testers are welcome :)
Especially, I'd like to know if it improves the emulation speed on other computers without bad regressions.","Rebased against master, includes the changes from PR remove_memd, cleaned up commits.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,313,2017-06-15T00:53:10Z,2017-10-14T01:00:02Z,2017-11-02T01:53:36Z,MERGED,True,940,1566,52,https://github.com/bsmiles32,Memory refactorings,66,[],https://github.com/mupen64plus/mupen64plus-core/pull/313,https://github.com/bsmiles32,23,https://github.com/mupen64plus/mupen64plus-core/pull/313#issuecomment-336587448,"DON'T MERGE !
This is a WIP, with several refactorings concerning mainly the memory module :

now the memory module only deals with ""physical"" mappings (virtual to physical translation is done in r4300)
no more usage of global variables in this module
single allocation of memory for all device memories. I allocate 512M, but only a fraction gets used (eg RAM, ROM, PIF_RAM, SP_MEM). This simplify the fast_mem_access function which gives a nice speed boost on the pure_interpreter. This also paves the way for the ""fast memory"" implementation.
memory mappings are defined in the device module
pifbootrom has been reworked to not use the device structure, but only r4300_core struct. This also paves the way for external PIFBootROM support. Not there yet, but closer.

edit: It also breaks the cached_interpreter, don't know why. And I didn't really bother with the new_dynarec so it should break it quite badly.
When I get some time, I will try to rework it and put it into shape. But early testers are welcome :)
Especially, I'd like to know if it improves the emulation speed on other computers without bad regressions.","Rebased against master.
Finally, this PR should be ready for merging.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,313,2017-06-15T00:53:10Z,2017-10-14T01:00:02Z,2017-11-02T01:53:36Z,MERGED,True,940,1566,52,https://github.com/bsmiles32,Memory refactorings,66,[],https://github.com/mupen64plus/mupen64plus-core/pull/313,https://github.com/Gillou68310,24,https://github.com/mupen64plus/mupen64plus-core/pull/313#issuecomment-338372854,"DON'T MERGE !
This is a WIP, with several refactorings concerning mainly the memory module :

now the memory module only deals with ""physical"" mappings (virtual to physical translation is done in r4300)
no more usage of global variables in this module
single allocation of memory for all device memories. I allocate 512M, but only a fraction gets used (eg RAM, ROM, PIF_RAM, SP_MEM). This simplify the fast_mem_access function which gives a nice speed boost on the pure_interpreter. This also paves the way for the ""fast memory"" implementation.
memory mappings are defined in the device module
pifbootrom has been reworked to not use the device structure, but only r4300_core struct. This also paves the way for external PIFBootROM support. Not there yet, but closer.

edit: It also breaks the cached_interpreter, don't know why. And I didn't really bother with the new_dynarec so it should break it quite badly.
When I get some time, I will try to rework it and put it into shape. But early testers are welcome :)
Especially, I'd like to know if it improves the emulation speed on other computers without bad regressions.",@bsmiles32 something in this PR broke the reset functionality,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,313,2017-06-15T00:53:10Z,2017-10-14T01:00:02Z,2017-11-02T01:53:36Z,MERGED,True,940,1566,52,https://github.com/bsmiles32,Memory refactorings,66,[],https://github.com/mupen64plus/mupen64plus-core/pull/313,https://github.com/Gillou68310,25,https://github.com/mupen64plus/mupen64plus-core/pull/313#issuecomment-338391945,"DON'T MERGE !
This is a WIP, with several refactorings concerning mainly the memory module :

now the memory module only deals with ""physical"" mappings (virtual to physical translation is done in r4300)
no more usage of global variables in this module
single allocation of memory for all device memories. I allocate 512M, but only a fraction gets used (eg RAM, ROM, PIF_RAM, SP_MEM). This simplify the fast_mem_access function which gives a nice speed boost on the pure_interpreter. This also paves the way for the ""fast memory"" implementation.
memory mappings are defined in the device module
pifbootrom has been reworked to not use the device structure, but only r4300_core struct. This also paves the way for external PIFBootROM support. Not there yet, but closer.

edit: It also breaks the cached_interpreter, don't know why. And I didn't really bother with the new_dynarec so it should break it quite badly.
When I get some time, I will try to rework it and put it into shape. But early testers are welcome :)
Especially, I'd like to know if it improves the emulation speed on other computers without bad regressions.",It was introduced by 1c01c23,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,317,2017-06-21T03:13:28Z,2017-06-23T02:22:14Z,2017-08-09T14:04:57Z,MERGED,True,2,2,1,https://github.com/loganmc10,Allow using compiler other than gcc,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/317,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/317,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,317,2017-06-21T03:13:28Z,2017-06-23T02:22:14Z,2017-08-09T14:04:57Z,MERGED,True,2,2,1,https://github.com/loganmc10,Allow using compiler other than gcc,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/317,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/317#issuecomment-310861376,,"OK, reverted all commits. Thank you for reporting this issue.
Really sorry about this. 3rd time in few days that I break master... :(",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,317,2017-06-21T03:13:28Z,2017-06-23T02:22:14Z,2017-08-09T14:04:57Z,MERGED,True,2,2,1,https://github.com/loganmc10,Allow using compiler other than gcc,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/317,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/317#issuecomment-310868092,,"No that was my bad, I didn't realize that make sets the CC variable",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,317,2017-06-21T03:13:28Z,2017-06-23T02:22:14Z,2017-08-09T14:04:57Z,MERGED,True,2,2,1,https://github.com/loganmc10,Allow using compiler other than gcc,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/317,https://github.com/fzurita,4,https://github.com/mupen64plus/mupen64plus-core/pull/317#issuecomment-310940992,,You could use a different environment variable other than CC. You would just have to change where CC is used to the new environment variable.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,317,2017-06-21T03:13:28Z,2017-06-23T02:22:14Z,2017-08-09T14:04:57Z,MERGED,True,2,2,1,https://github.com/loganmc10,Allow using compiler other than gcc,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/317,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/317#issuecomment-310946335,,It seems that you can still override CC by doing make CC=clang all so that should suffice,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,318,2017-06-23T02:58:08Z,2017-06-23T03:07:21Z,2017-07-03T02:47:12Z,MERGED,True,46,68,6,https://github.com/bsmiles32,Fix random resets in South Park 64,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/318,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/318,#316,#316,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,320,2017-06-24T19:22:12Z,2017-06-24T19:34:06Z,2017-07-03T02:44:24Z,MERGED,True,2,2,1,https://github.com/bsmiles32,"Revert ""Allow using compiler other than gcc""",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/320,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/320,This reverts commit c6506ec.,This reverts commit c6506ec.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,322,2017-06-26T09:47:59Z,2017-06-27T03:53:18Z,2017-06-27T03:53:18Z,MERGED,True,2,1,1,https://github.com/comex,Fix asm_defines w/ mawk by setting LANG=C,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/322,https://github.com/comex,1,https://github.com/mupen64plus/mupen64plus-core/pull/322,"Otherwise it silently exits with code 127, presumably because the input (binary) is not valid text in the system encoding.","Otherwise it silently exits with code 127, presumably because the input (binary) is not valid text in the system encoding.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,322,2017-06-26T09:47:59Z,2017-06-27T03:53:18Z,2017-06-27T03:53:18Z,MERGED,True,2,1,1,https://github.com/comex,Fix asm_defines w/ mawk by setting LANG=C,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/322,None,2,https://github.com/mupen64plus/mupen64plus-core/pull/322#issuecomment-311022530,"Otherwise it silently exits with code 127, presumably because the input (binary) is not valid text in the system encoding.",Btw. the return code of the mawk call is 0 in my case and it didn't work. My version is of mawk is 1.3.3-17+b3 (Debian),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,322,2017-06-26T09:47:59Z,2017-06-27T03:53:18Z,2017-06-27T03:53:18Z,MERGED,True,2,1,1,https://github.com/comex,Fix asm_defines w/ mawk by setting LANG=C,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/322,https://github.com/comex,3,https://github.com/mupen64plus/mupen64plus-core/pull/322#issuecomment-311080665,"Otherwise it silently exits with code 127, presumably because the input (binary) is not valid text in the system encoding.","Bleh, I thought I tested this but I must have messed something up, given
BUGS
       mawk  cannot  handle ascii NUL \0 in the source or data files.  You can output NUL using printf
       with %c, and any other 8 bit character is acceptable input.

But I don't want to depend on gawk on platforms that might not have it, e.g. macOS.  I just updated the PR to instead pipe strings to awk.  Windows can stay the way it is: there, strings may not exist, but awk is gawk, directly from mupen64plus-win32-deps.  On Unix, strings should definitely exist with the same cross-compile prefix as gcc, so we can use that always.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,322,2017-06-26T09:47:59Z,2017-06-27T03:53:18Z,2017-06-27T03:53:18Z,MERGED,True,2,1,1,https://github.com/comex,Fix asm_defines w/ mawk by setting LANG=C,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/322,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/322#issuecomment-311190593,"Otherwise it silently exits with code 127, presumably because the input (binary) is not valid text in the system encoding.","I ran into this same problem when testing Ubuntu 17.04, which uses mawk by default. This PR (using strings) did indeed fix the problem.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,324,2017-06-27T03:39:40Z,2017-06-27T03:52:42Z,2017-08-09T14:04:56Z,MERGED,True,3,0,1,https://github.com/loganmc10,Add CP0_ERROREPC_REG to MTC0,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/324,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/324,"Fixes #323
(Allows NHL Breakaway 98 and WCW Backstage Assault to boot)","Fixes #323
(Allows NHL Breakaway 98 and WCW Backstage Assault to boot)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,326,2017-06-27T15:34:58Z,2017-07-03T01:07:44Z,2017-08-09T14:04:54Z,MERGED,True,28,12,6,https://github.com/loganmc10,Updates to DisableExtraMem,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/326,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/326,"This PR does a number of things:
It moves the initialization of (g_)rdram_size from CoreStartup to main_run, with the rest of the config variables. @bsmiles32 I didn't see any need for this to be a global, am I correct in my understanding?
It allows DisableExtraMem to be set in mupen64plus.ini, and enables it for Iggy's Reckin' Balls, where it is required.","This PR does a number of things:
It moves the initialization of (g_)rdram_size from CoreStartup to main_run, with the rest of the config variables. @bsmiles32 I didn't see any need for this to be a global, am I correct in my understanding?
It allows DisableExtraMem to be set in mupen64plus.ini, and enables it for Iggy's Reckin' Balls, where it is required.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,326,2017-06-27T15:34:58Z,2017-07-03T01:07:44Z,2017-08-09T14:04:54Z,MERGED,True,28,12,6,https://github.com/loganmc10,Updates to DisableExtraMem,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/326,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/326#issuecomment-311407231,"This PR does a number of things:
It moves the initialization of (g_)rdram_size from CoreStartup to main_run, with the rest of the config variables. @bsmiles32 I didn't see any need for this to be a global, am I correct in my understanding?
It allows DisableExtraMem to be set in mupen64plus.ini, and enables it for Iggy's Reckin' Balls, where it is required.","It was a global just to keep it close to g_rdram which is required to be a global. I'm okay with your changes, and anyway when we get to merge my other work about memory, g_rdram will be renammed to g_mem_base and g_rdram_size would also have been (re)moved like you did. So good work ! Will merge it later if other want to test it a bit more.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,327,2017-06-28T14:28:52Z,2017-08-08T00:51:17Z,2017-08-09T14:04:45Z,MERGED,True,39,5,8,https://github.com/loganmc10,"Implement ""Audio Signal""",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/327,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/327,"PR #307 actually broke a few games (NBA on NBC, Hydro Thunder).
Project64 has a setting/hack called ""RSP Audio Signal"" https://github.com/project64/project64/blob/master/Source/Project64-core/N64System/Mips/MemoryVirtualMem.cpp#L1148-L1152
This fixes games like Hydro Thunder and NBA on NBC. I tested it and it works here as well. It is enabled for: NBA on NBC, Hydro Thunder, Tarzan, and Rugrats in Paris (these games were taken from the Project64 RDB)
Of course we could also revert #307, but I think that was a positive change, it simplified the code and allowed us to remove the strange Perfect Dark hack that was in place, it also fixed freezing in Top Gear Rally 2.","PR #307 actually broke a few games (NBA on NBC, Hydro Thunder).
Project64 has a setting/hack called ""RSP Audio Signal"" https://github.com/project64/project64/blob/master/Source/Project64-core/N64System/Mips/MemoryVirtualMem.cpp#L1148-L1152
This fixes games like Hydro Thunder and NBA on NBC. I tested it and it works here as well. It is enabled for: NBA on NBC, Hydro Thunder, Tarzan, and Rugrats in Paris (these games were taken from the Project64 RDB)
Of course we could also revert #307, but I think that was a positive change, it simplified the code and allowed us to remove the strange Perfect Dark hack that was in place, it also fixed freezing in Top Gear Rally 2.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,327,2017-06-28T14:28:52Z,2017-08-08T00:51:17Z,2017-08-09T14:04:45Z,MERGED,True,39,5,8,https://github.com/loganmc10,"Implement ""Audio Signal""",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/327,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/327#issuecomment-311994738,"PR #307 actually broke a few games (NBA on NBC, Hydro Thunder).
Project64 has a setting/hack called ""RSP Audio Signal"" https://github.com/project64/project64/blob/master/Source/Project64-core/N64System/Mips/MemoryVirtualMem.cpp#L1148-L1152
This fixes games like Hydro Thunder and NBA on NBC. I tested it and it works here as well. It is enabled for: NBA on NBC, Hydro Thunder, Tarzan, and Rugrats in Paris (these games were taken from the Project64 RDB)
Of course we could also revert #307, but I think that was a positive change, it simplified the code and allowed us to remove the strange Perfect Dark hack that was in place, it also fixed freezing in Top Gear Rally 2.","Because mupen64plus is not cycle accurate,  I think some hacks are acceptable to get all games running. I can't see any other way... I guess you have to pick which hacks are better than others.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,327,2017-06-28T14:28:52Z,2017-08-08T00:51:17Z,2017-08-09T14:04:45Z,MERGED,True,39,5,8,https://github.com/loganmc10,"Implement ""Audio Signal""",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/327,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/327#issuecomment-311995402,"PR #307 actually broke a few games (NBA on NBC, Hydro Thunder).
Project64 has a setting/hack called ""RSP Audio Signal"" https://github.com/project64/project64/blob/master/Source/Project64-core/N64System/Mips/MemoryVirtualMem.cpp#L1148-L1152
This fixes games like Hydro Thunder and NBA on NBC. I tested it and it works here as well. It is enabled for: NBA on NBC, Hydro Thunder, Tarzan, and Rugrats in Paris (these games were taken from the Project64 RDB)
Of course we could also revert #307, but I think that was a positive change, it simplified the code and allowed us to remove the strange Perfect Dark hack that was in place, it also fixed freezing in Top Gear Rally 2.","Yeah it does seem to be some kind of timing issue, running these games with RSP-CXD4 and SupportCPUSemaphoreLock enabled will also fix this problem. This approach is sort of the ""HLE"" approach that allows them to work with rsp-hle as well.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,327,2017-06-28T14:28:52Z,2017-08-08T00:51:17Z,2017-08-09T14:04:45Z,MERGED,True,39,5,8,https://github.com/loganmc10,"Implement ""Audio Signal""",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/327,https://github.com/bsmiles32,4,https://github.com/mupen64plus/mupen64plus-core/pull/327#issuecomment-320819349,"PR #307 actually broke a few games (NBA on NBC, Hydro Thunder).
Project64 has a setting/hack called ""RSP Audio Signal"" https://github.com/project64/project64/blob/master/Source/Project64-core/N64System/Mips/MemoryVirtualMem.cpp#L1148-L1152
This fixes games like Hydro Thunder and NBA on NBC. I tested it and it works here as well. It is enabled for: NBA on NBC, Hydro Thunder, Tarzan, and Rugrats in Paris (these games were taken from the Project64 RDB)
Of course we could also revert #307, but I think that was a positive change, it simplified the code and allowed us to remove the strange Perfect Dark hack that was in place, it also fixed freezing in Top Gear Rally 2.",Tested and indeed fixes these games. Merging this but hope that a less hackish way of fixing this will be found :),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,329,2017-07-03T03:49:50Z,2017-07-23T17:33:10Z,2017-09-14T23:44:03Z,MERGED,True,6,5,1,https://github.com/bsmiles32,Print accelerator when GB cart supports it.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/329,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/329,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,330,2017-07-04T01:49:30Z,2017-08-19T22:32:39Z,2017-08-20T01:34:47Z,MERGED,True,29,11,10,https://github.com/loganmc10,Add hack for Rat Attack!,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/330,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/330,"Yes I know... another game specific hack. Project64 employs a similar hack (they disable TLB for the game).
I also took the opportunity to remove the global variable, and I used the same variable for the GoldenEye, and now Rat Attack, hack.
I'm open to suggestions on variables names, I was never very good at naming things...","Yes I know... another game specific hack. Project64 employs a similar hack (they disable TLB for the game).
I also took the opportunity to remove the global variable, and I used the same variable for the GoldenEye, and now Rat Attack, hack.
I'm open to suggestions on variables names, I was never very good at naming things...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,330,2017-07-04T01:49:30Z,2017-08-19T22:32:39Z,2017-08-20T01:34:47Z,MERGED,True,29,11,10,https://github.com/loganmc10,Add hack for Rat Attack!,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/330,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/330#issuecomment-312763549,"Yes I know... another game specific hack. Project64 employs a similar hack (they disable TLB for the game).
I also took the opportunity to remove the global variable, and I used the same variable for the GoldenEye, and now Rat Attack, hack.
I'm open to suggestions on variables names, I was never very good at naming things...","I never tested this with the new dynarec, I don't know if it would need a different solution
EDIT: Yeah this doesn't work with the new dynarec, but I'm not familiar enough with the TLB stuff in the new dynarec to implement this there.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,330,2017-07-04T01:49:30Z,2017-08-19T22:32:39Z,2017-08-20T01:34:47Z,MERGED,True,29,11,10,https://github.com/loganmc10,Add hack for Rat Attack!,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/330,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/330#issuecomment-312881530,"Yes I know... another game specific hack. Project64 employs a similar hack (they disable TLB for the game).
I also took the opportunity to remove the global variable, and I used the same variable for the GoldenEye, and now Rat Attack, hack.
I'm open to suggestions on variables names, I was never very good at naming things...",Got it working with the new dynarec,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,330,2017-07-04T01:49:30Z,2017-08-19T22:32:39Z,2017-08-20T01:34:47Z,MERGED,True,29,11,10,https://github.com/loganmc10,Add hack for Rat Attack!,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/330,https://github.com/bsmiles32,4,https://github.com/mupen64plus/mupen64plus-core/pull/330#issuecomment-320830085,"Yes I know... another game specific hack. Project64 employs a similar hack (they disable TLB for the game).
I also took the opportunity to remove the global variable, and I used the same variable for the GoldenEye, and now Rat Attack, hack.
I'm open to suggestions on variables names, I was never very good at naming things...","On my end, it indeed allow the game to boot, but I can't get in-game with the European version as I get a :
Core Error: NI() @ 0x800702C0
Core Error: opcode not implemented: 800702C0:D
The USA version seems OK, still in-game there seems to be some missing objects but I don't know if it's a core issue or a gfx issue.
Tested with Pure Interpreter, and GlideN64 plugin.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,330,2017-07-04T01:49:30Z,2017-08-19T22:32:39Z,2017-08-20T01:34:47Z,MERGED,True,29,11,10,https://github.com/loganmc10,Add hack for Rat Attack!,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/330,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/330#issuecomment-320830521,"Yes I know... another game specific hack. Project64 employs a similar hack (they disable TLB for the game).
I also took the opportunity to remove the global variable, and I used the same variable for the GoldenEye, and now Rat Attack, hack.
I'm open to suggestions on variables names, I was never very good at naming things...","The gfx issues are from GLideN64, it works with Glide64.
You can hold off on this for a bit, I'll see if I can track down a better fix, or at least one that also works for the E version",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,330,2017-07-04T01:49:30Z,2017-08-19T22:32:39Z,2017-08-20T01:34:47Z,MERGED,True,29,11,10,https://github.com/loganmc10,Add hack for Rat Attack!,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/330,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/330#issuecomment-321072776,"Yes I know... another game specific hack. Project64 employs a similar hack (they disable TLB for the game).
I also took the opportunity to remove the global variable, and I used the same variable for the GoldenEye, and now Rat Attack, hack.
I'm open to suggestions on variables names, I was never very good at naming things...","CountPerOp=1 fixes the European version for me, I've updated the PR. Interestingly, CountPerOp=1 breaks the USA version in the same way the European version was broken. Another unfortunate timing situation it seems.
I looked at 1964 to see if they had fixed it, but they have TLB disabled for this game as well. The European version also crashes in PJ64, so it's a pretty common issue it seems.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,330,2017-07-04T01:49:30Z,2017-08-19T22:32:39Z,2017-08-20T01:34:47Z,MERGED,True,29,11,10,https://github.com/loganmc10,Add hack for Rat Attack!,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/330,https://github.com/bsmiles32,7,https://github.com/mupen64plus/mupen64plus-core/pull/330#issuecomment-323551507,"Yes I know... another game specific hack. Project64 employs a similar hack (they disable TLB for the game).
I also took the opportunity to remove the global variable, and I used the same variable for the GoldenEye, and now Rat Attack, hack.
I'm open to suggestions on variables names, I was never very good at naming things...","Merging this, but I don't like the special rom approach much. It is yet another way to enable hacks. Hope we'll find a more generic solution to this issue.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,332,2017-07-05T16:35:12Z,2017-07-11T04:08:20Z,2017-08-09T14:04:51Z,CLOSED,False,45,16,12,https://github.com/loganmc10,Fix Indiana Jones,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/332,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/332,"This PR is dependent on #330. Fixes #331
I would like someone to test this and review before it's merged, I don't mind if it sits here for a while.
This does a number of things:
It sets CountPerOp=1 and CountPerScanline=2200. This fixes random freezing and some graphical glitches
It also introduces pi->interrupt_mod, basically, for Indiana Jones, it divides the pi interrupt timers by 2. This fixes the black screen/hanging at the end of the levels. I think this is acceptable, since the current value (0x1000 usually), seems like a guess/approximation.
I played through the first 2 levels using the x64 dynarec without issue. But like I said, I would like someone else to test/comment before it's merged. This was mostly the result of trial/error.
I tested the U rom, I did not test the PAL rom","This PR is dependent on #330. Fixes #331
I would like someone to test this and review before it's merged, I don't mind if it sits here for a while.
This does a number of things:
It sets CountPerOp=1 and CountPerScanline=2200. This fixes random freezing and some graphical glitches
It also introduces pi->interrupt_mod, basically, for Indiana Jones, it divides the pi interrupt timers by 2. This fixes the black screen/hanging at the end of the levels. I think this is acceptable, since the current value (0x1000 usually), seems like a guess/approximation.
I played through the first 2 levels using the x64 dynarec without issue. But like I said, I would like someone else to test/comment before it's merged. This was mostly the result of trial/error.
I tested the U rom, I did not test the PAL rom",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,332,2017-07-05T16:35:12Z,2017-07-11T04:08:20Z,2017-08-09T14:04:51Z,CLOSED,False,45,16,12,https://github.com/loganmc10,Fix Indiana Jones,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/332,https://github.com/AmbientMalice,2,https://github.com/mupen64plus/mupen64plus-core/pull/332#issuecomment-313276511,"This PR is dependent on #330. Fixes #331
I would like someone to test this and review before it's merged, I don't mind if it sits here for a while.
This does a number of things:
It sets CountPerOp=1 and CountPerScanline=2200. This fixes random freezing and some graphical glitches
It also introduces pi->interrupt_mod, basically, for Indiana Jones, it divides the pi interrupt timers by 2. This fixes the black screen/hanging at the end of the levels. I think this is acceptable, since the current value (0x1000 usually), seems like a guess/approximation.
I played through the first 2 levels using the x64 dynarec without issue. But like I said, I would like someone else to test/comment before it's merged. This was mostly the result of trial/error.
I tested the U rom, I did not test the PAL rom","This is fantastic work, dude. I've been looking through the github over the past week, and I'm really surprised and pleased by how mupen64plus is coming along. Huge strides.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,332,2017-07-05T16:35:12Z,2017-07-11T04:08:20Z,2017-08-09T14:04:51Z,CLOSED,False,45,16,12,https://github.com/loganmc10,Fix Indiana Jones,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/332,https://github.com/AmbientMalice,3,https://github.com/mupen64plus/mupen64plus-core/pull/332#issuecomment-313343567,"This PR is dependent on #330. Fixes #331
I would like someone to test this and review before it's merged, I don't mind if it sits here for a while.
This does a number of things:
It sets CountPerOp=1 and CountPerScanline=2200. This fixes random freezing and some graphical glitches
It also introduces pi->interrupt_mod, basically, for Indiana Jones, it divides the pi interrupt timers by 2. This fixes the black screen/hanging at the end of the levels. I think this is acceptable, since the current value (0x1000 usually), seems like a guess/approximation.
I played through the first 2 levels using the x64 dynarec without issue. But like I said, I would like someone else to test/comment before it's merged. This was mostly the result of trial/error.
I tested the U rom, I did not test the PAL rom","Would it be possible for you to upload the modified mupen64plus.dll? I'd be happy to test this, but I'm having trouble building the emulator. It keeps complaining about ""more than one input file specified"" for mupen64plus-core.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,332,2017-07-05T16:35:12Z,2017-07-11T04:08:20Z,2017-08-09T14:04:51Z,CLOSED,False,45,16,12,https://github.com/loganmc10,Fix Indiana Jones,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/332,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/332#issuecomment-313520676,"This PR is dependent on #330. Fixes #331
I would like someone to test this and review before it's merged, I don't mind if it sits here for a while.
This does a number of things:
It sets CountPerOp=1 and CountPerScanline=2200. This fixes random freezing and some graphical glitches
It also introduces pi->interrupt_mod, basically, for Indiana Jones, it divides the pi interrupt timers by 2. This fixes the black screen/hanging at the end of the levels. I think this is acceptable, since the current value (0x1000 usually), seems like a guess/approximation.
I played through the first 2 levels using the x64 dynarec without issue. But like I said, I would like someone else to test/comment before it's merged. This was mostly the result of trial/error.
I tested the U rom, I did not test the PAL rom","Yeah no problem, I can get it to you. It'll have to wait until Monday though when I have access to my Windows computer. Thanks a lot for testing.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,332,2017-07-05T16:35:12Z,2017-07-11T04:08:20Z,2017-08-09T14:04:51Z,CLOSED,False,45,16,12,https://github.com/loganmc10,Fix Indiana Jones,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/332,https://github.com/fzurita,5,https://github.com/mupen64plus/mupen64plus-core/pull/332#issuecomment-313721487,"This PR is dependent on #330. Fixes #331
I would like someone to test this and review before it's merged, I don't mind if it sits here for a while.
This does a number of things:
It sets CountPerOp=1 and CountPerScanline=2200. This fixes random freezing and some graphical glitches
It also introduces pi->interrupt_mod, basically, for Indiana Jones, it divides the pi interrupt timers by 2. This fixes the black screen/hanging at the end of the levels. I think this is acceptable, since the current value (0x1000 usually), seems like a guess/approximation.
I played through the first 2 levels using the x64 dynarec without issue. But like I said, I would like someone else to test/comment before it's merged. This was mostly the result of trial/error.
I tested the U rom, I did not test the PAL rom","This is pretty cool, now if we can get the new dynarec in ARM to stop crashing in this game.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,332,2017-07-05T16:35:12Z,2017-07-11T04:08:20Z,2017-08-09T14:04:51Z,CLOSED,False,45,16,12,https://github.com/loganmc10,Fix Indiana Jones,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/332,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/332#issuecomment-314114574,"This PR is dependent on #330. Fixes #331
I would like someone to test this and review before it's merged, I don't mind if it sits here for a while.
This does a number of things:
It sets CountPerOp=1 and CountPerScanline=2200. This fixes random freezing and some graphical glitches
It also introduces pi->interrupt_mod, basically, for Indiana Jones, it divides the pi interrupt timers by 2. This fixes the black screen/hanging at the end of the levels. I think this is acceptable, since the current value (0x1000 usually), seems like a guess/approximation.
I played through the first 2 levels using the x64 dynarec without issue. But like I said, I would like someone else to test/comment before it's merged. This was mostly the result of trial/error.
I tested the U rom, I did not test the PAL rom","Ok @AmbientMalice here is a version to test. I can only build using MinGW, so it needs a few ""support DLL's"". I've attached the version I build at m64p.github.io with this Indiana Jones fix.
If you're going to test, I'd suggest opening mupen64plus-gui.exe, going to Settings->Plugin Settings, and click ""Reset All Settings"" at the bottom, just to make sure you're dealing with a fresh config.
mupen64plus-Jones-Fix.zip",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,332,2017-07-05T16:35:12Z,2017-07-11T04:08:20Z,2017-08-09T14:04:51Z,CLOSED,False,45,16,12,https://github.com/loganmc10,Fix Indiana Jones,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/332,https://github.com/AmbientMalice,7,https://github.com/mupen64plus/mupen64plus-core/pull/332#issuecomment-314275781,"This PR is dependent on #330. Fixes #331
I would like someone to test this and review before it's merged, I don't mind if it sits here for a while.
This does a number of things:
It sets CountPerOp=1 and CountPerScanline=2200. This fixes random freezing and some graphical glitches
It also introduces pi->interrupt_mod, basically, for Indiana Jones, it divides the pi interrupt timers by 2. This fixes the black screen/hanging at the end of the levels. I think this is acceptable, since the current value (0x1000 usually), seems like a guess/approximation.
I played through the first 2 levels using the x64 dynarec without issue. But like I said, I would like someone else to test/comment before it's merged. This was mostly the result of trial/error.
I tested the U rom, I did not test the PAL rom","@loganmc10 Thanks a lot. I'm a huge admirer of this game, and it's great some effort is going into fixing it.
I'll give it a test and keep you posted. GLideN64 has a serious depth problem with this game, so I'll use z64gl from another build of mupen64plus. I'll just point out that this is possibly the most unstable ""commercial"" N64 game, notorious for stuff like the music suddenly looping rapidly and then the screen turning into ""rainbow barf"" before the console resets. Which means that random crashes don't necessarily mean the emulator is at fault, and makes troubleshooting a bit inherently unreliable.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,332,2017-07-05T16:35:12Z,2017-07-11T04:08:20Z,2017-08-09T14:04:51Z,CLOSED,False,45,16,12,https://github.com/loganmc10,Fix Indiana Jones,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/332,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/332#issuecomment-314277303,"This PR is dependent on #330. Fixes #331
I would like someone to test this and review before it's merged, I don't mind if it sits here for a while.
This does a number of things:
It sets CountPerOp=1 and CountPerScanline=2200. This fixes random freezing and some graphical glitches
It also introduces pi->interrupt_mod, basically, for Indiana Jones, it divides the pi interrupt timers by 2. This fixes the black screen/hanging at the end of the levels. I think this is acceptable, since the current value (0x1000 usually), seems like a guess/approximation.
I played through the first 2 levels using the x64 dynarec without issue. But like I said, I would like someone else to test/comment before it's merged. This was mostly the result of trial/error.
I tested the U rom, I did not test the PAL rom","Yeah I quite enjoyed playing through the first 2 levels. It's got a pretty good story, especially compared to alot of games from that time.
That's a 64 bit build of mupen64plus so you'll need a 64 bit version of any plugin you use. I can provide a 32 bit version if you need.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,332,2017-07-05T16:35:12Z,2017-07-11T04:08:20Z,2017-08-09T14:04:51Z,CLOSED,False,45,16,12,https://github.com/loganmc10,Fix Indiana Jones,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/332,https://github.com/AmbientMalice,9,https://github.com/mupen64plus/mupen64plus-core/pull/332#issuecomment-314290742,"This PR is dependent on #330. Fixes #331
I would like someone to test this and review before it's merged, I don't mind if it sits here for a while.
This does a number of things:
It sets CountPerOp=1 and CountPerScanline=2200. This fixes random freezing and some graphical glitches
It also introduces pi->interrupt_mod, basically, for Indiana Jones, it divides the pi interrupt timers by 2. This fixes the black screen/hanging at the end of the levels. I think this is acceptable, since the current value (0x1000 usually), seems like a guess/approximation.
I played through the first 2 levels using the x64 dynarec without issue. But like I said, I would like someone else to test/comment before it's merged. This was mostly the result of trial/error.
I tested the U rom, I did not test the PAL rom","So I tried the build you posted, and I'm getting a freeze/crash at the end of the first level, per usual. Tested with both z46gl and GLideN64, and without using save states.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,332,2017-07-05T16:35:12Z,2017-07-11T04:08:20Z,2017-08-09T14:04:51Z,CLOSED,False,45,16,12,https://github.com/loganmc10,Fix Indiana Jones,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/332,https://github.com/loganmc10,10,https://github.com/mupen64plus/mupen64plus-core/pull/332#issuecomment-314293468,"This PR is dependent on #330. Fixes #331
I would like someone to test this and review before it's merged, I don't mind if it sits here for a while.
This does a number of things:
It sets CountPerOp=1 and CountPerScanline=2200. This fixes random freezing and some graphical glitches
It also introduces pi->interrupt_mod, basically, for Indiana Jones, it divides the pi interrupt timers by 2. This fixes the black screen/hanging at the end of the levels. I think this is acceptable, since the current value (0x1000 usually), seems like a guess/approximation.
I played through the first 2 levels using the x64 dynarec without issue. But like I said, I would like someone else to test/comment before it's merged. This was mostly the result of trial/error.
I tested the U rom, I did not test the PAL rom","Ok tomorrow I'll double check that I uploaded the right build. Can you try deleting any .eep/saves you may have? On Windows they should be in C:\you\AppData\Roaming\mupen64plus\save
I'll try that build I posted tomorrow on my Windows PC to make sure, I'm really surprised it didn't work for you.
EDIT: Unbelievable, I just wiped all my saves and tried this again on Linux, and it froze at the end of the level! I wonder what magic happened that allowed me to play through the first 2 levels before.. back to the drawing board I suppose. This seems like some kind of really weird timing issue. I wonder why it doesn't happen  on the Interpreter in PJ64",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,332,2017-07-05T16:35:12Z,2017-07-11T04:08:20Z,2017-08-09T14:04:51Z,CLOSED,False,45,16,12,https://github.com/loganmc10,Fix Indiana Jones,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/332,https://github.com/loganmc10,11,https://github.com/mupen64plus/mupen64plus-core/pull/332#issuecomment-314299201,"This PR is dependent on #330. Fixes #331
I would like someone to test this and review before it's merged, I don't mind if it sits here for a while.
This does a number of things:
It sets CountPerOp=1 and CountPerScanline=2200. This fixes random freezing and some graphical glitches
It also introduces pi->interrupt_mod, basically, for Indiana Jones, it divides the pi interrupt timers by 2. This fixes the black screen/hanging at the end of the levels. I think this is acceptable, since the current value (0x1000 usually), seems like a guess/approximation.
I played through the first 2 levels using the x64 dynarec without issue. But like I said, I would like someone else to test/comment before it's merged. This was mostly the result of trial/error.
I tested the U rom, I did not test the PAL rom","A weird thing with this game, and probably a hint to what is wrong: If you delete your save (eep), and start the game with CountPerOp=2, and do the same thing with CountPerOp=1, the eep file it creates right when the game launches has a different md5sum. This game won't even boot with CountPerOp=1 (but it does create the eep file). However, CountPerOp=1 and CountPerScanline=2200 creates an eep file with a matching md5sum to the eep file created with CountPerOp=2. Basically it seems like the specific timing settings actually modifies what is written to the eep save.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,332,2017-07-05T16:35:12Z,2017-07-11T04:08:20Z,2017-08-09T14:04:51Z,CLOSED,False,45,16,12,https://github.com/loganmc10,Fix Indiana Jones,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/332,https://github.com/AmbientMalice,12,https://github.com/mupen64plus/mupen64plus-core/pull/332#issuecomment-314302152,"This PR is dependent on #330. Fixes #331
I would like someone to test this and review before it's merged, I don't mind if it sits here for a while.
This does a number of things:
It sets CountPerOp=1 and CountPerScanline=2200. This fixes random freezing and some graphical glitches
It also introduces pi->interrupt_mod, basically, for Indiana Jones, it divides the pi interrupt timers by 2. This fixes the black screen/hanging at the end of the levels. I think this is acceptable, since the current value (0x1000 usually), seems like a guess/approximation.
I played through the first 2 levels using the x64 dynarec without issue. But like I said, I would like someone else to test/comment before it's merged. This was mostly the result of trial/error.
I tested the U rom, I did not test the PAL rom","The game is extremely reluctant to boot on PJ64 with certain VI Refresh Rate settings.
I've played the game in the past on mupen64plus, and IIRC, disabling the expansion pack allowed you to get past one Indy's Trading Post crash, but not others. It's a very strange issue, and a casual observer might think it was some kind of anti-piracy technique. But that's doubtful.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,332,2017-07-05T16:35:12Z,2017-07-11T04:08:20Z,2017-08-09T14:04:51Z,CLOSED,False,45,16,12,https://github.com/loganmc10,Fix Indiana Jones,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/332,https://github.com/loganmc10,13,https://github.com/mupen64plus/mupen64plus-core/pull/332#issuecomment-314317352,"This PR is dependent on #330. Fixes #331
I would like someone to test this and review before it's merged, I don't mind if it sits here for a while.
This does a number of things:
It sets CountPerOp=1 and CountPerScanline=2200. This fixes random freezing and some graphical glitches
It also introduces pi->interrupt_mod, basically, for Indiana Jones, it divides the pi interrupt timers by 2. This fixes the black screen/hanging at the end of the levels. I think this is acceptable, since the current value (0x1000 usually), seems like a guess/approximation.
I played through the first 2 levels using the x64 dynarec without issue. But like I said, I would like someone else to test/comment before it's merged. This was mostly the result of trial/error.
I tested the U rom, I did not test the PAL rom","Yeah this seems really strange, when I use HLE graphics, it behaves differently (doesn't print out the DMA error like it does in LLE), but it seems like it still froze, it's hard to tell, but it definitely is sending different DMA data using HLE graphics.
There are other games that lock up using LLE graphics (Perfect Dark comes to mind), in both PJ64 and mupen64plus. Given that the ucode for this game is likely to be deciphered in a year or so (granted this is probably wishful thinking, but if Rogue Squadron gets done, Naboo/Indiana might not be far behind), I think I'm going to put this aside for now, and revisit if/when HLE graphics are accomplished for the game. Everything I am trying feels really hacky and probably not the right way to do it, maybe we'll get lucky with HLE!",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,332,2017-07-05T16:35:12Z,2017-07-11T04:08:20Z,2017-08-09T14:04:51Z,CLOSED,False,45,16,12,https://github.com/loganmc10,Fix Indiana Jones,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/332,https://github.com/AmbientMalice,14,https://github.com/mupen64plus/mupen64plus-core/pull/332#issuecomment-314318517,"This PR is dependent on #330. Fixes #331
I would like someone to test this and review before it's merged, I don't mind if it sits here for a while.
This does a number of things:
It sets CountPerOp=1 and CountPerScanline=2200. This fixes random freezing and some graphical glitches
It also introduces pi->interrupt_mod, basically, for Indiana Jones, it divides the pi interrupt timers by 2. This fixes the black screen/hanging at the end of the levels. I think this is acceptable, since the current value (0x1000 usually), seems like a guess/approximation.
I played through the first 2 levels using the x64 dynarec without issue. But like I said, I would like someone else to test/comment before it's merged. This was mostly the result of trial/error.
I tested the U rom, I did not test the PAL rom","I think that's the right approach. Good stab at it, anyway.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,333,2017-07-10T14:04:47Z,2017-07-23T17:33:28Z,2017-08-09T14:04:49Z,MERGED,True,8,0,1,https://github.com/loganmc10,Multiplayer timing fix for Mario Kart E and J,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/333,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/333,Credits to @Nekokabu (from project64/project64#1317),Credits to @Nekokabu (from project64/project64#1317),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,334,2017-07-10T18:33:49Z,2017-07-23T17:34:28Z,2017-08-09T14:04:47Z,MERGED,True,5,2,2,https://github.com/loganmc10,Fix write_cart_rom/read_cart_rom,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/334,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/334,This fixes #311 (International Track & Field 2000 and Midway's Greatest Arcade Hits Vol. 1),This fixes #311 (International Track & Field 2000 and Midway's Greatest Arcade Hits Vol. 1),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,334,2017-07-10T18:33:49Z,2017-07-23T17:34:28Z,2017-08-09T14:04:47Z,MERGED,True,5,2,2,https://github.com/loganmc10,Fix write_cart_rom/read_cart_rom,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/334,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/334#issuecomment-314199685,This fixes #311 (International Track & Field 2000 and Midway's Greatest Arcade Hits Vol. 1),"They don't work in the new dynarec either, but it looks like the new dynarec implements it's own version of the opcodes, so this would need to get implemented over there as well to work with the new dynarec.
EDIT: I guess I should look at the code more carefully, it seems that all the dynarec's implement their own opcodes (for the most part)..",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,334,2017-07-10T18:33:49Z,2017-07-23T17:34:28Z,2017-08-09T14:04:47Z,MERGED,True,5,2,2,https://github.com/loganmc10,Fix write_cart_rom/read_cart_rom,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/334,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/334#issuecomment-314203514,This fixes #311 (International Track & Field 2000 and Midway's Greatest Arcade Hits Vol. 1),"There is already a similar logic in pi/cart_rom.c
I didn't know which game used that, now I know ;)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,334,2017-07-10T18:33:49Z,2017-07-23T17:34:28Z,2017-08-09T14:04:47Z,MERGED,True,5,2,2,https://github.com/loganmc10,Fix write_cart_rom/read_cart_rom,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/334,https://github.com/bsmiles32,4,https://github.com/mupen64plus/mupen64plus-core/pull/334#issuecomment-314204339,This fixes #311 (International Track & Field 2000 and Midway's Greatest Arcade Hits Vol. 1),But it doesn't work with zero value because we use zero as sentinel value. See last_write,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,334,2017-07-10T18:33:49Z,2017-07-23T17:34:28Z,2017-08-09T14:04:47Z,MERGED,True,5,2,2,https://github.com/loganmc10,Fix write_cart_rom/read_cart_rom,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/334,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/334#issuecomment-314214711,This fixes #311 (International Track & Field 2000 and Midway's Greatest Arcade Hits Vol. 1),"Do you think there is a ""common place"" that is can be implemented? Or will it need to be implemented in each dynarec as well as the interpreter?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,334,2017-07-10T18:33:49Z,2017-07-23T17:34:28Z,2017-08-09T14:04:47Z,MERGED,True,5,2,2,https://github.com/loganmc10,Fix write_cart_rom/read_cart_rom,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/334,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/334#issuecomment-314216677,This fixes #311 (International Track & Field 2000 and Midway's Greatest Arcade Hits Vol. 1),"Oh I misunderstood what you were saying.
Changing last_write's default value from 0 to -1 (I changed it to a signed int) solved the problem! the games boot! Such an easy fix. Much less hacky as well.
@bsmiles32 what would be a good default value besides 0? I'm not sure if changing it to a signed int will cause problems because of the lower max value. Is there some value that you know would be bogus that we could use?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,334,2017-07-10T18:33:49Z,2017-07-23T17:34:28Z,2017-08-09T14:04:47Z,MERGED,True,5,2,2,https://github.com/loganmc10,Fix write_cart_rom/read_cart_rom,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/334,https://github.com/bsmiles32,7,https://github.com/mupen64plus/mupen64plus-core/pull/334#issuecomment-314217157,This fixes #311 (International Track & Field 2000 and Midway's Greatest Arcade Hits Vol. 1),"I guess just fixing the read,write_cart_rom should be enough. No need to touch LW/SW.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,334,2017-07-10T18:33:49Z,2017-07-23T17:34:28Z,2017-08-09T14:04:47Z,MERGED,True,5,2,2,https://github.com/loganmc10,Fix write_cart_rom/read_cart_rom,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/334,https://github.com/bsmiles32,8,https://github.com/mupen64plus/mupen64plus-core/pull/334#issuecomment-314218380,This fixes #311 (International Track & Field 2000 and Midway's Greatest Arcade Hits Vol. 1),Adding a separate rom_written flag instead of using 0 for last_write should be ok,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,334,2017-07-10T18:33:49Z,2017-07-23T17:34:28Z,2017-08-09T14:04:47Z,MERGED,True,5,2,2,https://github.com/loganmc10,Fix write_cart_rom/read_cart_rom,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/334,https://github.com/loganmc10,9,https://github.com/mupen64plus/mupen64plus-core/pull/334#issuecomment-314220871,This fixes #311 (International Track & Field 2000 and Midway's Greatest Arcade Hits Vol. 1),"Right, okay I've updated the PR, this does fix both games in the dynarec and interpreter. Might fix other things as well, who knows! A lot cleaner now as well, thanks for helping with this",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,336,2017-07-14T17:00:59Z,2017-07-24T12:13:33Z,2017-08-09T14:04:46Z,MERGED,True,6,0,1,https://github.com/loganmc10,Ignore TLB write if TLB entry is unmapping itself,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/336,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/336,"Fixes #221
This was adapted from:
https://github.com/project64/project64/blob/master/Source/Project64-core/N64System/Mips/TLBclass.cpp#L128-L146
It allows the games mentioned in #221 to boot. I haven't done extensive testing to see if this breaks other games.","Fixes #221
This was adapted from:
https://github.com/project64/project64/blob/master/Source/Project64-core/N64System/Mips/TLBclass.cpp#L128-L146
It allows the games mentioned in #221 to boot. I haven't done extensive testing to see if this breaks other games.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,336,2017-07-14T17:00:59Z,2017-07-24T12:13:33Z,2017-08-09T14:04:46Z,MERGED,True,6,0,1,https://github.com/loganmc10,Ignore TLB write if TLB entry is unmapping itself,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/336,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/336#issuecomment-315431899,"Fixes #221
This was adapted from:
https://github.com/project64/project64/blob/master/Source/Project64-core/N64System/Mips/TLBclass.cpp#L128-L146
It allows the games mentioned in #221 to boot. I haven't done extensive testing to see if this breaks other games.","By the way, once this, along with the other PR's I have waiting are merged, we are at ""compatibility parity"" with Project64 as far as I can tell. I don't know of any game that doesn't boot with mupen64plus that works in PJ64. This of course excludes the 64DD games.
There might be games that could use a better CountPerOp or CountPerScanline setting, PJ64's RDB receives a little more love and attention compared to mupen64plus's INI, but those are easy things to play with.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,336,2017-07-14T17:00:59Z,2017-07-24T12:13:33Z,2017-08-09T14:04:46Z,MERGED,True,6,0,1,https://github.com/loganmc10,Ignore TLB write if TLB entry is unmapping itself,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/336,https://github.com/gizmo98,3,https://github.com/mupen64plus/mupen64plus-core/pull/336#issuecomment-315443506,"Fixes #221
This was adapted from:
https://github.com/project64/project64/blob/master/Source/Project64-core/N64System/Mips/TLBclass.cpp#L128-L146
It allows the games mentioned in #221 to boot. I haven't done extensive testing to see if this breaks other games.","@loganmc10
Just a question. Shouldn't all ported Project 64 fixes show up under credits? I have seen someone on reddit complaining about license violation.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,336,2017-07-14T17:00:59Z,2017-07-24T12:13:33Z,2017-08-09T14:04:46Z,MERGED,True,6,0,1,https://github.com/loganmc10,Ignore TLB write if TLB entry is unmapping itself,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/336,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/336#issuecomment-315446334,"Fixes #221
This was adapted from:
https://github.com/project64/project64/blob/master/Source/Project64-core/N64System/Mips/TLBclass.cpp#L128-L146
It allows the games mentioned in #221 to boot. I haven't done extensive testing to see if this breaks other games.","Well I'm not a GPL license expert first off. I think the ""credits"" thing is possible, but it's not a license requirement, more of a nice gesture? I try to be transparent/open about where I'm getting this stuff from, so I mention it in the PR's, which is my way of giving credit.
As far as actual licenses is concerned: the code wasn't copied, I looked at the code and how it worked, and re-implemented it here, so I don't think any copyright was violated.
The person that seems to have the issue with licenses (and it is 1 person, and that person isn't even in the copyright notice of the code they are complaining about), seemed to take issue with a PR I made in mupen64plus-rsp-hle. Basically zilmar copied mupen64plus-rsp-hle into PJ64 for his Android version, and didn't retain any of the copyright notices. bsmiles32 brought it to his attention, and he added the copyright notices. Then, PJ64 made a few minor bug fixes, which were ported back (mupen64plus/mupen64plus-rsp-hle#40, mupen64plus/mupen64plus-rsp-hle#43)
Anyway I asked bsmiles32 about it and he didn't seem concerned about it, since the code that was copied was so minor, we're talking a basically moving a few brackets around and moving some lines of code around.
So no, I wouldn't be worried about any copyrights, since nothing here was actually copied.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,336,2017-07-14T17:00:59Z,2017-07-24T12:13:33Z,2017-08-09T14:04:46Z,MERGED,True,6,0,1,https://github.com/loganmc10,Ignore TLB write if TLB entry is unmapping itself,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/336,https://github.com/gizmo98,5,https://github.com/mupen64plus/mupen64plus-core/pull/336#issuecomment-315450412,"Fixes #221
This was adapted from:
https://github.com/project64/project64/blob/master/Source/Project64-core/N64System/Mips/TLBclass.cpp#L128-L146
It allows the games mentioned in #221 to boot. I haven't done extensive testing to see if this breaks other games.","@loganmc10
Seems legit. I didn't unterstand the complaint.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,336,2017-07-14T17:00:59Z,2017-07-24T12:13:33Z,2017-08-09T14:04:46Z,MERGED,True,6,0,1,https://github.com/loganmc10,Ignore TLB write if TLB entry is unmapping itself,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/336,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/336#issuecomment-315450536,"Fixes #221
This was adapted from:
https://github.com/project64/project64/blob/master/Source/Project64-core/N64System/Mips/TLBclass.cpp#L128-L146
It allows the games mentioned in #221 to boot. I haven't done extensive testing to see if this breaks other games.","Personally when it comes to emulators I think copyright is a bit of a silly argument. We are all trying to emulate the same system, so the code is going to look very similar, it's also going to act very similar.
For instance (https://copyleft.org/guide/comprehensive-gpl-guidech5.html):

As an introductory matter, it is important to note that literal copying of a significant portion of source code is not always sufficient to establish that a second work is a derivative work of an original program. Conversely, a second work can be a derivative work of an original program even though absolutely no copying of the literal source code of the original program has been made. This is the case because copyright protection does not always extend to all portions of a program’s code, while, at the same time, it can extend beyond the literal code of a program to its non-literal aspects, such as its architecture, structure, sequence, organization, operational modules, and computer-user interface.

So really it could be argued that whoever ""got there first"" (UltraHLE, 1964, whatever older N64 emulators existed) and implemented a certain opcode or function owns the copyright to that function, and anyone who implements it after is creating a ""derivative work"". If you look at cen64's code it's going to look pretty similar to PJ64 or mupen64plus, but nobody is too concerned about copyright, since all of us (or most of us) are just trying to have a little fun with a hobby.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,336,2017-07-14T17:00:59Z,2017-07-24T12:13:33Z,2017-08-09T14:04:46Z,MERGED,True,6,0,1,https://github.com/loganmc10,Ignore TLB write if TLB entry is unmapping itself,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/336,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/336#issuecomment-315451343,"Fixes #221
This was adapted from:
https://github.com/project64/project64/blob/master/Source/Project64-core/N64System/Mips/TLBclass.cpp#L128-L146
It allows the games mentioned in #221 to boot. I haven't done extensive testing to see if this breaks other games.","The important thing is that the code is protected by the GPL, so some company can't (or shouldn't) come along, steal the code, and try to sell a closed source emulator based on it. The copyright is important because that is the person that controls the decision around the licenses.
For instance, some guy claiming to be from LG just asked gonetz if he would re-license GLideN64 for them so they can use a piece of the code (amusingly it was actually code written by you lol) without releasing the source of their application. GLideN64 has it's own strange license situation so it's unclear whether gonetz would even really have that authority, but assuming he did, he could re-license it to something other than GPL if he wanted. That's the ""power"" of being a copyright holder.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,336,2017-07-14T17:00:59Z,2017-07-24T12:13:33Z,2017-08-09T14:04:46Z,MERGED,True,6,0,1,https://github.com/loganmc10,Ignore TLB write if TLB entry is unmapping itself,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/336,https://github.com/gizmo98,8,https://github.com/mupen64plus/mupen64plus-core/pull/336#issuecomment-315595806,"Fixes #221
This was adapted from:
https://github.com/project64/project64/blob/master/Source/Project64-core/N64System/Mips/TLBclass.cpp#L128-L146
It allows the games mentioned in #221 to boot. I haven't done extensive testing to see if this breaks other games.","I always thought it is common practice to share code so all emulators benefit. Snes emulators benefit from each other. Libretro cores benefit more or less from upstream. Upstream benefits sometimes from libretro and so on.
And there is this guy who is complaining who was first as if there is a competition.
This LG guy is really funny. I also do not really now who is the right copyright holder of this piece of code. Reicast for example asked all contributors if relicensing of their contributed code is possible.

Contributions to the reicast project (excluding mine). Copyright belongs to the contributors, we use them via GPL.

skmp/reicast-emulator#455.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,336,2017-07-14T17:00:59Z,2017-07-24T12:13:33Z,2017-08-09T14:04:46Z,MERGED,True,6,0,1,https://github.com/loganmc10,Ignore TLB write if TLB entry is unmapping itself,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/336,https://github.com/loganmc10,9,https://github.com/mupen64plus/mupen64plus-core/pull/336#issuecomment-317316331,"Fixes #221
This was adapted from:
https://github.com/project64/project64/blob/master/Source/Project64-core/N64System/Mips/TLBclass.cpp#L128-L146
It allows the games mentioned in #221 to boot. I haven't done extensive testing to see if this breaks other games.","I tested this with about 15 games (first 1-2 minutes of each game) and I didn't see any regression, given that this is already implemented successfully in another N64 emulator I think it's pretty safe.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,336,2017-07-14T17:00:59Z,2017-07-24T12:13:33Z,2017-08-09T14:04:46Z,MERGED,True,6,0,1,https://github.com/loganmc10,Ignore TLB write if TLB entry is unmapping itself,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/336,https://github.com/bsmiles32,10,https://github.com/mupen64plus/mupen64plus-core/pull/336#issuecomment-317409545,"Fixes #221
This was adapted from:
https://github.com/project64/project64/blob/master/Source/Project64-core/N64System/Mips/TLBclass.cpp#L128-L146
It allows the games mentioned in #221 to boot. I haven't done extensive testing to see if this breaks other games.","Sorry for the delay, I'm away from home with limited connectivity. That's why I did only merged ""safe"" PR. I will tackle the remaining one later. Can you suggest an order for me to merge your work ? With all your work on the audio side things are getting very interesting ! Maybe you could also ask @richard42 write permission. Thanks for your dedication.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,336,2017-07-14T17:00:59Z,2017-07-24T12:13:33Z,2017-08-09T14:04:46Z,MERGED,True,6,0,1,https://github.com/loganmc10,Ignore TLB write if TLB entry is unmapping itself,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/336,https://github.com/loganmc10,11,https://github.com/mupen64plus/mupen64plus-core/pull/336#issuecomment-317510869,"Fixes #221
This was adapted from:
https://github.com/project64/project64/blob/master/Source/Project64-core/N64System/Mips/TLBclass.cpp#L128-L146
It allows the games mentioned in #221 to boot. I haven't done extensive testing to see if this breaks other games.","The order shouldn't matter, they are all independent of each other. If a merge conflict is created after one is merged I can sort it out.

Maybe you could also ask @richard42 write permission.

I'd rather not be merging my own PR's, it's nice to know at least one other person looked at it. After the current batch of PR's is merged there isn't much I was planning on working on anyway, besides maybe trying to get Indiana Jones to work. I'm open to suggestions though.

Thanks for your dedication

Thanks, I enjoy it, it's pretty satisfying to solve these problems, it's almost more fun than actually playing the games lol",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/337,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45",True,{'HOORAY': ['https://github.com/Papermanzero']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-315657548,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","Thanks for tackling this !
I intentionally left it for later because it would have required a change in the API. The way I envisioned it was just to add a load GB cart command to the core.
I'm not a big fan of moving the ROM/ram loading logic to input plugin, I would prefer to have it in the core/frontend (eg same as N64 ROM loading logic). But I welcome other opinions on this, especially from frontend writers.
Changing the log to verbose is the right thing to do (or maybe even placing them inside #if/#endif?)
For the automatic tpak enablement when having a gb_cart loaded see src/plugin/emulate_game_controller_via_input_plugin.c
Also, I don't have access to my laptop ATM that's why I don't merge stuff for now. Sorry for delay.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-315663805,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","Also, I don't have access to my laptop ATM that's why I don't merge stuff for now. Sorry for delay.

No problem there, I'm in no rush.
The input plugin made more sense to me, since it is meant to emulate the controller. The input plugin already chooses which Pak is enabled. In my mind, which GB cart is plugged into the transfer pak is part of ""how is my controller set up"".
Anyway it's not really a deal breaker either way, it could also be done in the core. Something like:
CoreDoCommand(M64CMD_LOAD_GB_ROM, int ControllerNum, char * filepath), and the same for the RAM/Save file, was that what you were envisioning?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-315788475,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","In case it helps anyone, this is what I was envisioning the ""user experience"" would be like with this kind of setup:
https://youtu.be/hiA0ZSBK6WI
If it was handled by the core, I would probably add a ""Load GB ROM File"" and ""Load GB RAM File"" option somewhere in the GUI, which would execute CoreDoCommand(M64CMD_LOAD........ The one issue I see with this is that it wouldn't be persistent, the user would need to do that every time they launched the emulator if they wanted to use the transfer pak.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/fzurita,5,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-315788777,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","Doing it through CoreDoCommand does seem simpler to me. Less API change and should be backwards compatible with old input plugins.
I don't see an issue with always having to call ""CoreDoCommand"". This can be easily automated by the front-end.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-315793367,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","I think the persistence thing is an issue. Picture the ""worst case scenario"" where there is a transfer pak plugged into each controller. That means you need to load 8 files. If you're using mupen64plus-ui-console, that means we'd probably have to modify it to take a command-line argument like:
./mupen64plus --gb-rom-1 ./romfile1.gb --gb-ram-1 ./ramfile1.sav --gb-rom-2 ./romfile2.gb --gb-ram-2 ./ramfile2.sav --gb-rom-3 ./romfile3.gb --gb-ram-3 ./ramfile3.sav --gb-rom-4 ./romfile4.gb --gb-ram-4 ./ramfile4.sav ./pokemonstadium.n64
And you'd have to do that every time you launch the game.
Even with a GUI that can store it's own settings. You'd still have to have a ""Load GB ROM"" and ""Load GB RAM"" button, that asked the user for the controller number and filename. Then the GUI would need to store the controller number and filename. Then it would have to implement some logic to call CoreDoCommand multiple times before a game launch if those settings are set (not difficult, but I think the frontend changes in this scenario are more complex than the input plugin changes).
It's a controller specific setting, it makes sense to me that it should be stored with the controller settings.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/fzurita,7,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-315803125,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","Why would you have to load it with UI console? Wouldn't CoreDoCommand be enough?
I guess it could also be done through the core config options.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-315803684,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","Maybe I don't understand, what is calling CoreDoCommand if not UI console? You would have to pass those parameters to ui-console when it launches so that it can call CoreDoCommand with the proper values.
EDIT: ya you could add it to the core config options, but you would still need 8 options (2 for each controller), it would just seem strange to me since there is already a config area for each controller",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/fzurita,9,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-315809232,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","With the way mupen64plus-ae does it, CoreDoCommand can be called at any time, not just at startup.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/loganmc10,10,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-315811313,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","Yeah but ui-console doesn't have that capability (well you could have hotkeys that execute certain CoreDoCommand's, but there is no way to pass it parameters like a filename while the game is running). With a gui frontend you can call it anytime, but in this particular case it would need to be called before the game starts anyway, it wouldn't do anything if you called it while the game was running.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/fzurita,11,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-315813149,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","Right, I guess it could also be part of the UI console config. There are definitely a lot of options for this...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/loganmc10,12,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-315813248,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","Anyway I'm open to other ways of doing it, but I can't think of a really clean way to implement it using CoreDoCommand that would work well with ui-console. It seems like either you'd have to pass it a ton of commandline parameters, or you'd have to add 8 config options to either ui-console (and every other frontend) or the core, and at that point it seems like you might as well just add it to the controller configs.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/bsmiles32,13,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-320834618,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","I took the liberty to cherry-pick the log level part of your PR and merge it right away. It will decrease the ""noise"" while we review the other part of the PR.
I stil don't have the definite answer yet on how to proceed, but I will give more perspective on the initial work :

each gb cart can have various extra devices inside of them such as a RAM, RTC, rumbling device or accelerometer
we don't have de db for gb cartridges so some heuristic based on GB header is used to know what kind of device is present inside the cartridge
The gb cart loading code provides this heuristics and only ask the caller (via some callbacks) to initialize the corresponding backend when needed (storage backend for ROM and RAM, rtc backend for rtc if present)
If multiple tpak are connected, save files should be differents to avoid corrupting them

I'd like to delegate all the ROM,RAM and RTC initialization to the ui.
Pak selection used to be dictated by the input plugin, but in my book this is mistake that is due to the zilmar spec : emulation code pertain to the core, plugins should only take care of plateform specificities. Otherwise we get different level of support, and/or copy pasting horrors as is currently happening in gfx plugins. That is also why I crafted the ""backends"" which only take care of platform stuff and don't use/require emulation code.
Will try to thing more about it, and come back with suggestions later.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/Mastergatto,14,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-321048727,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","Pak selection used to be dictated by the input plugin, but in my book this is mistake that is due to the zilmar spec : emulation code pertain to the core, plugins should only take care of plateform specificities.

Forgive me if I join the discussion like this, but if the pak selection moves to the core, then could this spell trouble for mupen64plus-input-raphnetraw? This input plugin allows the real pak accessories to be used directly in mupen64plus through N64 pad and USB adapter and I'm not sure if this would be still possible with the pak selection in the core.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/bsmiles32,15,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-321085568,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","Thanks for joining the discussion and bringing this use case. Hopefully we can find a way to also have it work. Something like if we use emulated controller let the core do the pak selection, otherwise we're in ""passthrough"" mode and everything is delegated to the plug-in. Reworking the input handling is on my to-do list, but I guess it will be for after the next release.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/Mastergatto,16,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-321253356,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","The passthrough mode sounds like a good idea, but this could mean that some changes are needed also on the other side. I hope it won't be too much an issue.
Also, keep up the good work 👍",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/loganmc10,17,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-328281905,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","@bsmiles32 I'd like come to some kind of solution on this. I don't mind it being handled by the core, would something like this be acceptable:
CoreDoCommand(M64CMD_SET_GB_ROM, int controllerNum, &filePath);
CoreDoCommand(M64CMD_SET_GB_RAM, int controllerNum, &filePath);

And then just let the frontend handle calling those functions? We can just specify that it needs to be done before the ROM is opened.
I'm not sure how the raphnet plugin would be affected, but it doesn't seem like this system would work any differently than the system I have currently proposed in that respect.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/bsmiles32,18,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-329538003,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","@loganmc10 : I've been thinking about it lately and maybe I have an intermediate solution which doesn't require any changes in the API and leave the input plugin alone.
GB carts setups will be stored inside the mupen64plus.cfg file under a game-specific section :
[Perfect Dark (E) !]
tpak-{0,1,2,3}-rom=file path to gb rom
tpak-{0,1,2,3}-ram=file path to gb ram
Numbers indicate which controller (0 to 3) it applies to.
Here I used the GoodName, because its user-friendly but gameid (4 letters) should also be an option.
With that the core will be fully responsible for loading the gb cart.
Frontends just need to let user edit these configuration variables. To help that we should add in our gamedb which games are compatible with the tpak, so that frontends can know if they have to check for a transferpak configuration variables.
Maybe we could also allow for multiple gb carts per controller and allow with a single key press to toggle between gb carts. Could be useful for pokemon stadium which is compatible with several gb carts.
Hope it makes sense. Comments welcome.
Also (not strictly related, but still intersting), I've been reworking the si subsystem to extract controllers and paks logic. In there I have a proof of concept with pak switching (some kind of caroussel) which could be extended for gb carts when there are multiples. This is still very WIP and may not be how I will submit it, but it shows where I want to go with all this handling of n64 accessories.
https://github.com/bsmiles32/mupen64plus-core/tree/pif_and_other_things",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/loganmc10,19,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-329545986,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","I don't think writing game specific settings to mupen64plus.cfg is a great idea, seems a little messy. But what's more, I don't think it's a good idea to expect frontends to write directly to that file (outside the API I mean, right now all writes/reads go through the API).
I don't think this is really urgent, so I wouldn't really look to any intermediate solution. If pak switching is implemented, wouldn't it make sense to just extend CoreDoCommand like I mentioned?
CoreDoCommand(M64CMD_SET_GB_ROM, int controllerNum, &filePath);
CoreDoCommand(M64CMD_SET_GB_RAM, int controllerNum, &filePath);

If the frontend executes that command, it would trigger a pak switch/load. The frontend can be in charge of keeping track of which pak is for what game, etc...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/bsmiles32,20,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-329593450,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","@loganmc10 Thanks for commenting, I'll try to better argue/explain my point :)
I suggested storing tpak's configuration inside mupen64plus.cfg because it is the file that the core uses. Besides, it stores will store user's specific GB carts path, so I think it has is place inside this file.
Yes it is game-specific, but usually compatible GB carts are game-specific as well so it's not like it's a hack or something.
Frontends can (and should !) access these variables via the Config API so I guess everything is already in place for it to work.
Benefits of this approach is that once what I proposed is implemented in the core, all ui can benefit from that without needing updating. Yes user will have to manually edit the mupen64pls.cfg in this case, but eventually ui will be updated and will allow users to directly edit these variables from inside the ui.
Also it will be much easier to implement both pak switching and gb cart switching inside the core than hope that frontends will implement that properly (especially for the ui-console which is not really an interactive interface... eg once you run the game, we expect no user input (no gb cart path) until the end of execution).
Hope to have cleared some of your concerns. Still open to suggestions and comments as I can have missed something here.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/loganmc10,21,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-329599055,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","Frontends can (and should !) access these variables via the Config API so I guess everything is already in place for it to work.

Sorry yes I realized I had a bit of a ""brain freeze"" there.
I guess it just seems a bit clunky to me, but it makes sense.

Frontends just need to let user edit these configuration variables. To help that we should add in our gamedb which games are compatible with the tpak, so that frontends can know if they have to check for a transferpak configuration variables.

I'm still a little weary of the per-game thing, and I'm not sure how letting the frontend know which ROM's support tpaks would help. Picture a traditional desktop GUI. If a user downloads that GUI and the first thing they want to do is play Pokemon Stadium with a GB cart, they'll go to the configuration area and set everything up before they ever open the ROM. The frontend won't know what ROM they want until the game has already started. Or are you picturing the frontend having some kind of ""dropdown"" with a list of games that support the tpak? I doubt many frontends would go to all that work, it's probably better to just make it a general thing, and if the user wants to play a different game, they modify the config to point to the correct GB cart",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/loganmc10,22,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-329612264,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","I would just do it like this:
[TransferPak]
tpak-{1,2,3,4}-rom=file/path/to/gb.rom,file/path/to/gb2.rom
tpak-{1,2,3,4}-ram=file/path/to/gb.ram,file/path/to/gb2.ram

Just separate the files by commas to allow switching, and number them 1-4 (just because computers start from 0 doesn't mean we have to make the humans do it ;) )
Anyway I've come around to the mupen64plus.cfg option, I'm just not sure about the game specific thing, maybe someone else can offer their opinion",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/bsmiles32,23,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-329615260,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","Thanks for coming up with the GUI use-case.
Indeed, right away, you can't really configure the tpak because we don't know yet which game will be loaded. But you can delay effectively writing the config until the user has selected launched a ROM, but just before starting the emulation. Eg : Don't allow configuring the tpak right away. After the user has selected a ROM, ask the core if that ROM is tpak compatible, if so, ask the user if he/she wants to plug a gb cart inside, then update the config, then start emulation.
Or only allow tpak configuration (or any game specific stuff, maybe mempak file in the future) when the user right-click on the game in the list.
I know you're reluctant for game-specific setup, but I really think it will ease user experience because they only have to setup stuff once and not every time they change game.
Separating file paths by comma could be confusing lisibility-wise with path of different sizes ?
Maybe something like:
tpak-{1,2,3,4}-[0...N-1]-rom=my_gb_rom.gb
tpak-{1,2,3,4}-[0...N-1]-ram=my_gb_rom.sav

Counting controllers from 1 instead of 0 is also OK for me. It might indeed be less confusing for end-user.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/loganmc10,24,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-329620626,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","I just think given the relatively low development activity related to the frontends, it's unlikely that sort of system would see widespread adoption. Even with a more generic approach, a frontend could still choose to manage transfer pak association per game itself (store the per game configurations itself, and then modify the [TransferPak] section of mupen64plus.cfg right before the game starts).
ui-console could adopt your per-game system for instance, and then copy the relevant info into the [TransferPak] section when it knows what ROM is about to be opened.
I think that gives the frontends the flexibility to implement a really good per-game system if they want, but there could still be an easier to implement generic solution as well.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/bsmiles32,25,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-329624704,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","I just think given the relatively low development activity related to the frontends, it's unlikely that sort of system would see widespread adoption.

Maybe, but even in that case, if we document these config variables, users will be able to edit them by hand and it will work. That way we don't force frontend writers to update their code if they don't want, while still letting user enjoy this feature.
Letting the frontend manage the game-specific-ness of the configuration as you suggests is indeed a viable option, but will leave each frontend to write it's own implementation of this, whereas if it's in the core, you get it (almost) for free.
Edit : to be clear, I would be okay with letting the frontend manage the game-specific-ness side of configuration, if that's what other prefers.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/tony971,26,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-329651826,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","This is one application where I wouldn't mind per-game info in mupen64plus.cfg. The list of games that support transfer packs is common knowledge. There isn't any game that will accidentally be included when it shouldn't be or vice versa. It's something that will be populated once and forgotten (Hacks excluded, but they should know what they're doing).
Edit: But as an end-user, it really doesn't matter to me where the list is kept. I'll just be happy that it exists and that I can use it.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/fzurita,27,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-329916336,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","For Mupen64plus-AE it doesn't really matter where it's kept, since it's actively developed. Keeping it in the Mupen64plus.cfg file does mean that the front end does not need to be updated.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/richard42,28,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-331054171,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","Sorry for coming so late to the party. This is a tricky architectural design issue. A lot of points have already been brought up in the previous comments, so I'll start by addressing some of them. Personally I really don't like the idea of adding per-game setting to the main config file. It reminds of the disaster that Microsoft created (and the world pays for) with the Windows NT registry. I would rather keep the scope of the config file limited to the current configuration of the emulator. I see how it would be advantageous for certain use cases, and the per-game setting even wouldn't be used by most people at the beginning, but I think it's a start down the wrong path.
Regarding the command-line options for the paths with the ui-console front-end, I don't see that as a problem. The 8-path case is really an extreme situation, and in most cases the user would only enter 2 paths. For people who are okay with typing, this is not a big deal. For people who can't handle typing, they're not using the ui-console front-end anyway.
I'm okay with adding filepaths for currently connected transfer paks to the core section or maybe the input sections, but I'm not convinced that this is clearly the right approach either. One problem with putting the paths in the input plugin controller sections is that the auto-config logic might blow them away if the controller is changed.
Stepping back and thinking about the whole system, you could make the case that in order to most closely mimic the operation of the real N64, the API should be changed so that the core can make a function call to get the actual contents (byte buffers) of the GB ram and rom data from the input plugin. This might be the best option for supporting the real hardware with a plugin like Raphnet. If we did this, the SDL-Input plugin would have the logic for determining the filenames and reading the files. It could even be enhanced to support per-game file paths in its own config sections, but then again could suffer from data loss if the sections were deleted by the auto-config logic. There are tradeoffs.
Another possibility is to put this GB RAM/ROM paths in the mupen64plus.ini file, which already has all of the per-game sections. The downside here is that this is supposed to be a global file and not contain user-specific configuration data.
Here's another question: for the transfer pak support, does the input plugin need to add more keyboard/joystick mapping options, to be able to select mem, rumble, or transfer pak?
Getting back to the ram/rom path issue, here is another possible solution. Extend the Core-FrontEnd API by adding functions (DoCoreCommand) for setting the paths. These should be usable at any time, even while the game is running. Add command-line options to the ui-console front-end so that the user can specify these. But then also extend the ui-console so that it will take a path to a directory containing ram/rom images with specially formatted filenames. The format can be something like
GameName-ControllerID.ram/.rom
Where GameName can be a GoodName or CRC or MD5 or gameid or whatever you want, and ControllerID is a number from 1 to 4. Then the front-end could look for any applicable files after loading the ROM and automatically set the proper paths before running the emulation. On unix systems you could even use symbolic links to make multiple games or controllers use the same files.",True,{'THUMBS_UP': ['https://github.com/Narann']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/bsmiles32,29,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-331437202,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","@richard42 thanks for joining the discussion.
Given that game-specific config is not popular, I think the best way to go then is extend the API with something like that :

the UI register a set of callbacks that initialize the various components of a GB cart (eg ROM, RAM, RTC,... )

DoCoreCommand(M64CMD_SET_GB_CART_LOADER, sizeof(gb_cart_loader), &gb_cart_loader);

struct gb_cart_loader {
voir* cb_data; // allow UI to carry some state to the following callbacks
int (*init_rom)(void* cb_data, int controller_num, const char** rom_filename);
int (*init_ram)(void* cb_data, int controller_num, const char** ram_filename);
int (*init_rtc)(void* cb_data, int controller_num, time_t* rtc_date); // can be added in a future revision if needed ?
};


the core calls these callbacks appropriately depending on what hardware is present inside the GB cart when a tpak is connected for the first time (eg not when switching between mempak,rumblepak and transferpak) and when a new GB cart is connected to tpak. This might require an extra per-controller button to trigger this action. Maybe we can repurpose the {Mem,Rumble}pak switch buttons : 1 for Pak switching (mem -> rumble -> tpak -> none -> mem -> ....) depending on what paks are compatible with the game, 1 for GB cart switching when a tpak is connected.

Notes:

That way the UI doesn't need to know how to parse a GB cart, the core does it
All the persistence of GB paths is up to the UI, so we keep core config game agnostic
If we don't need to change between multiple GB carts, GB cart loading is done only once at first tpak connection (eg potentially bother the user once). Still we support changing GB cart en live. Interactive UI (eg desktop GUI) can popup a file picker dialog to select appropriate files. Non interactive UI (eg ui-console) can select between several pre-selected GB carts in a carousel fashion. Or any other scheme that the UI wants to implement.
if we need to extend the gb_cart_loader because one crazy hardware shows up (GB camera ?), we just need to add a new field (say init_camera) and add proper struct size check inside the core command handler.
I would prefer if the input plugin is left untouched (except maybe for the extra per-controller GB cart changing button) because :
I plan, in the future, to replace input plugins with controller_input_backends (which only abstract gamepad buttons and joystick state - no paks, rumble or GB cart logic) directly backed into the core. And for input plugins that needs more than that (eg raphnet) there will be a joybus_device interface which allow for ""raw"" pif commands processing.
Moving this GB cart logic to the input plugin will lead to different level of support for the different input plugins. Also it doesn't make sense for all of them : for instance the raphnet plugin wouldn't need that at all because the real N64 controller already handle paks accesses for us (eg it's not emulated, it's the real deal)

What do you think ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/loganmc10,30,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-331445990,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45","Seems good to me, I'm a little confused about the purpose of init_rtc(). What is the frontend supposed to do there? Isn't it something that the core can handle? What information would the frontend be privy to that the core isn't?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/bsmiles32,31,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-331482875,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45",I think RTC has an internal counter to keep track of time. Core or UI can setup this counter to start from a previous time or give the current time. For the first iteration we can omit it I guess.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,337,2017-07-16T21:23:33Z,2017-09-28T14:08:18Z,2017-09-28T14:09:18Z,CLOSED,False,46,46,11,https://github.com/loganmc10,[WIP] Transfer pak connection to frontend,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/337,https://github.com/richard42,32,https://github.com/mupen64plus/mupen64plus-core/pull/337#issuecomment-331586424,"This was my attempt to connect the transfer pak code to the end users.
It introduces a new input plugin API function (GetGBCartInfo). So basically the core can query the input plugin to determine what files the user has chosen for the GB ROM/RAM files.
I also changed some of the log output that is generated to ""verbose"".
Thoughts? I know that I would also have to update the API docs and version numbers. I'll do that if this gets a ""thumbs up""
@bsmiles32 one thing I noticed, it doesn't seem to matter what ""plugin"" I have chosen in the input plugin, the transfer pak always works if I have a valid path to a ROM/RAM chosen
See also mupen64plus/mupen64plus-input-sdl#45",I'm fine with this proposal.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,339,2017-07-18T01:35:32Z,2017-08-08T00:54:22Z,2017-08-09T14:04:44Z,MERGED,True,3,3,2,https://github.com/loganmc10,Use count_per_op instead of 2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/339,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/339,"Someone can correct me if I'm wrong, but I'm fairly certain that is ""2"" is supposed to represent the ""count_per_op"" setting","Someone can correct me if I'm wrong, but I'm fairly certain that is ""2"" is supposed to represent the ""count_per_op"" setting",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,339,2017-07-18T01:35:32Z,2017-08-08T00:54:22Z,2017-08-09T14:04:44Z,MERGED,True,3,3,2,https://github.com/loganmc10,Use count_per_op instead of 2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/339,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/339#issuecomment-317890608,"Someone can correct me if I'm wrong, but I'm fairly certain that is ""2"" is supposed to represent the ""count_per_op"" setting","Given that this is supposed to be a random number, and CEN64 literally just returns a random number:
https://github.com/tj90241/cen64/blob/0d0e042817a73950cc5350719c0481be149d5b45/vr4300/cp0.c#L261
It's probably not a big deal, but I think using count_per_op is more ""correct""",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,341,2017-07-20T06:08:02Z,2017-08-05T21:50:02Z,2017-08-09T14:04:40Z,CLOSED,False,17,35,8,https://github.com/loganmc10,Proper fix for Twisted Edge audio,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/341,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/341,"This mostly reverts #289
This was taken from mamedev/mame@aee1510 so credits to @Happy-yappH
The author states that this behavior is actually the result of a hardware bug. I'm not aware of any game besides Twisted Edge that runs into this, but at least this is a generic solution instead of being game specific.
In practice is does the same thing, so there is no real difference, other than a more proper solution, and perhaps this also fixes some audio issue is another game, I'm not sure.","This mostly reverts #289
This was taken from mamedev/mame@aee1510 so credits to @Happy-yappH
The author states that this behavior is actually the result of a hardware bug. I'm not aware of any game besides Twisted Edge that runs into this, but at least this is a generic solution instead of being game specific.
In practice is does the same thing, so there is no real difference, other than a more proper solution, and perhaps this also fixes some audio issue is another game, I'm not sure.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,341,2017-07-20T06:08:02Z,2017-08-05T21:50:02Z,2017-08-09T14:04:40Z,CLOSED,False,17,35,8,https://github.com/loganmc10,Proper fix for Twisted Edge audio,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/341,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/341#issuecomment-317073978,"This mostly reverts #289
This was taken from mamedev/mame@aee1510 so credits to @Happy-yappH
The author states that this behavior is actually the result of a hardware bug. I'm not aware of any game besides Twisted Edge that runs into this, but at least this is a generic solution instead of being game specific.
In practice is does the same thing, so there is no real difference, other than a more proper solution, and perhaps this also fixes some audio issue is another game, I'm not sure.","Wow, this is some pretty good research you have been doing lately.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,342,2017-07-20T22:08:13Z,2017-07-21T20:24:52Z,2017-08-09T14:04:38Z,CLOSED,False,65,9,13,https://github.com/loganmc10,[WIP] Add support for streaming audio buffer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/342,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/342,"This PR proposes a change to the API, so I haven't updated the docs yet, I'll do that if the API change gets a thumbs up.
This fixes audio in Boss Games (Stunt Racer, World Driver Championship, Top Gear Rally, Twisted Edge Snowboarding).
You can read my explanation of the problem/solution here:
#200 (comment)
Basically in this PR, every time AI_LEN_REG is read, we update the contents of the audio buffer. These games update the audio data while the DMA is happening, so we can't just copy the memory at the beginning of the DMA and send it to the audio plugin.
Because of this, I created a new audio API function (PlayAudio), which just takes a buffer and plays the audio in it, instead of having to read from DMEM.
You can see the change I made to the audio plugin here:
m64p/mupen64plus-audio-sdl2@79fef8d
These games don't seem to play nice with audio speed limiters/""sync to audio"" settings, so if you're going to test it, you'll probably need to test it with that sort of thing disabled.
I'm hoping some people can test this, I can provide a binary build if needed.
(technically this is actually the more accurate way to emulate the AI, but since it will add some audio latency because the audio plugin won't start playing the audio until the end of the DMA, I've only enabled it for these Boss games)","This PR proposes a change to the API, so I haven't updated the docs yet, I'll do that if the API change gets a thumbs up.
This fixes audio in Boss Games (Stunt Racer, World Driver Championship, Top Gear Rally, Twisted Edge Snowboarding).
You can read my explanation of the problem/solution here:
#200 (comment)
Basically in this PR, every time AI_LEN_REG is read, we update the contents of the audio buffer. These games update the audio data while the DMA is happening, so we can't just copy the memory at the beginning of the DMA and send it to the audio plugin.
Because of this, I created a new audio API function (PlayAudio), which just takes a buffer and plays the audio in it, instead of having to read from DMEM.
You can see the change I made to the audio plugin here:
m64p/mupen64plus-audio-sdl2@79fef8d
These games don't seem to play nice with audio speed limiters/""sync to audio"" settings, so if you're going to test it, you'll probably need to test it with that sort of thing disabled.
I'm hoping some people can test this, I can provide a binary build if needed.
(technically this is actually the more accurate way to emulate the AI, but since it will add some audio latency because the audio plugin won't start playing the audio until the end of the DMA, I've only enabled it for these Boss games)",True,"{'THUMBS_UP': ['https://github.com/AmbientMalice', 'https://github.com/MarcoEstevez']}"
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,342,2017-07-20T22:08:13Z,2017-07-21T20:24:52Z,2017-08-09T14:04:38Z,CLOSED,False,65,9,13,https://github.com/loganmc10,[WIP] Add support for streaming audio buffer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/342,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/342#issuecomment-316845291,"This PR proposes a change to the API, so I haven't updated the docs yet, I'll do that if the API change gets a thumbs up.
This fixes audio in Boss Games (Stunt Racer, World Driver Championship, Top Gear Rally, Twisted Edge Snowboarding).
You can read my explanation of the problem/solution here:
#200 (comment)
Basically in this PR, every time AI_LEN_REG is read, we update the contents of the audio buffer. These games update the audio data while the DMA is happening, so we can't just copy the memory at the beginning of the DMA and send it to the audio plugin.
Because of this, I created a new audio API function (PlayAudio), which just takes a buffer and plays the audio in it, instead of having to read from DMEM.
You can see the change I made to the audio plugin here:
m64p/mupen64plus-audio-sdl2@79fef8d
These games don't seem to play nice with audio speed limiters/""sync to audio"" settings, so if you're going to test it, you'll probably need to test it with that sort of thing disabled.
I'm hoping some people can test this, I can provide a binary build if needed.
(technically this is actually the more accurate way to emulate the AI, but since it will add some audio latency because the audio plugin won't start playing the audio until the end of the DMA, I've only enabled it for these Boss games)","Some of these games could use a bit of tweaking, World Driver Championship seems to be more smooth with CountPerOp=1, but I'll leave that kind of thing for another PR",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,342,2017-07-20T22:08:13Z,2017-07-21T20:24:52Z,2017-08-09T14:04:38Z,CLOSED,False,65,9,13,https://github.com/loganmc10,[WIP] Add support for streaming audio buffer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/342,https://github.com/AmbientMalice,3,https://github.com/mupen64plus/mupen64plus-core/pull/342#issuecomment-316948481,"This PR proposes a change to the API, so I haven't updated the docs yet, I'll do that if the API change gets a thumbs up.
This fixes audio in Boss Games (Stunt Racer, World Driver Championship, Top Gear Rally, Twisted Edge Snowboarding).
You can read my explanation of the problem/solution here:
#200 (comment)
Basically in this PR, every time AI_LEN_REG is read, we update the contents of the audio buffer. These games update the audio data while the DMA is happening, so we can't just copy the memory at the beginning of the DMA and send it to the audio plugin.
Because of this, I created a new audio API function (PlayAudio), which just takes a buffer and plays the audio in it, instead of having to read from DMEM.
You can see the change I made to the audio plugin here:
m64p/mupen64plus-audio-sdl2@79fef8d
These games don't seem to play nice with audio speed limiters/""sync to audio"" settings, so if you're going to test it, you'll probably need to test it with that sort of thing disabled.
I'm hoping some people can test this, I can provide a binary build if needed.
(technically this is actually the more accurate way to emulate the AI, but since it will add some audio latency because the audio plugin won't start playing the audio until the end of the DMA, I've only enabled it for these Boss games)","Great work, man.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,342,2017-07-20T22:08:13Z,2017-07-21T20:24:52Z,2017-08-09T14:04:38Z,CLOSED,False,65,9,13,https://github.com/loganmc10,[WIP] Add support for streaming audio buffer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/342,https://github.com/fzurita,4,https://github.com/mupen64plus/mupen64plus-core/pull/342#issuecomment-317075383,"This PR proposes a change to the API, so I haven't updated the docs yet, I'll do that if the API change gets a thumbs up.
This fixes audio in Boss Games (Stunt Racer, World Driver Championship, Top Gear Rally, Twisted Edge Snowboarding).
You can read my explanation of the problem/solution here:
#200 (comment)
Basically in this PR, every time AI_LEN_REG is read, we update the contents of the audio buffer. These games update the audio data while the DMA is happening, so we can't just copy the memory at the beginning of the DMA and send it to the audio plugin.
Because of this, I created a new audio API function (PlayAudio), which just takes a buffer and plays the audio in it, instead of having to read from DMEM.
You can see the change I made to the audio plugin here:
m64p/mupen64plus-audio-sdl2@79fef8d
These games don't seem to play nice with audio speed limiters/""sync to audio"" settings, so if you're going to test it, you'll probably need to test it with that sort of thing disabled.
I'm hoping some people can test this, I can provide a binary build if needed.
(technically this is actually the more accurate way to emulate the AI, but since it will add some audio latency because the audio plugin won't start playing the audio until the end of the DMA, I've only enabled it for these Boss games)","This is really good work. Is the amount of latency that it adds noticeable? If it's in the milliseconds range and it's a more accurate way of emulating audio, why not have it always enabled?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,342,2017-07-20T22:08:13Z,2017-07-21T20:24:52Z,2017-08-09T14:04:38Z,CLOSED,False,65,9,13,https://github.com/loganmc10,[WIP] Add support for streaming audio buffer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/342,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/342#issuecomment-317077464,"This PR proposes a change to the API, so I haven't updated the docs yet, I'll do that if the API change gets a thumbs up.
This fixes audio in Boss Games (Stunt Racer, World Driver Championship, Top Gear Rally, Twisted Edge Snowboarding).
You can read my explanation of the problem/solution here:
#200 (comment)
Basically in this PR, every time AI_LEN_REG is read, we update the contents of the audio buffer. These games update the audio data while the DMA is happening, so we can't just copy the memory at the beginning of the DMA and send it to the audio plugin.
Because of this, I created a new audio API function (PlayAudio), which just takes a buffer and plays the audio in it, instead of having to read from DMEM.
You can see the change I made to the audio plugin here:
m64p/mupen64plus-audio-sdl2@79fef8d
These games don't seem to play nice with audio speed limiters/""sync to audio"" settings, so if you're going to test it, you'll probably need to test it with that sort of thing disabled.
I'm hoping some people can test this, I can provide a binary build if needed.
(technically this is actually the more accurate way to emulate the AI, but since it will add some audio latency because the audio plugin won't start playing the audio until the end of the DMA, I've only enabled it for these Boss games)","I haven't measured the latency, but the ""chunks"" are 16384 bytes, the sample rate is 22000Hz (in World Driver Championship) if I remember correctly, and there are 4 bytes per sample. So I think that works out to roughly 1/5 of a second if I did the math right (could be wrong)
In driving games like these I don't think audio latency is as noticeable, platformers or fighters might make it more noticeable.
In most games it will make absolutely no difference since the audio buffer doesn't change mid-DMA, if there are other games with bad audio we can test this setting to see if it helps. It just seemed like there wasn't a need to introduce any latency if it wasn't going to improve anything",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,342,2017-07-20T22:08:13Z,2017-07-21T20:24:52Z,2017-08-09T14:04:38Z,CLOSED,False,65,9,13,https://github.com/loganmc10,[WIP] Add support for streaming audio buffer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/342,https://github.com/fzurita,6,https://github.com/mupen64plus/mupen64plus-core/pull/342#issuecomment-317092776,"This PR proposes a change to the API, so I haven't updated the docs yet, I'll do that if the API change gets a thumbs up.
This fixes audio in Boss Games (Stunt Racer, World Driver Championship, Top Gear Rally, Twisted Edge Snowboarding).
You can read my explanation of the problem/solution here:
#200 (comment)
Basically in this PR, every time AI_LEN_REG is read, we update the contents of the audio buffer. These games update the audio data while the DMA is happening, so we can't just copy the memory at the beginning of the DMA and send it to the audio plugin.
Because of this, I created a new audio API function (PlayAudio), which just takes a buffer and plays the audio in it, instead of having to read from DMEM.
You can see the change I made to the audio plugin here:
m64p/mupen64plus-audio-sdl2@79fef8d
These games don't seem to play nice with audio speed limiters/""sync to audio"" settings, so if you're going to test it, you'll probably need to test it with that sort of thing disabled.
I'm hoping some people can test this, I can provide a binary build if needed.
(technically this is actually the more accurate way to emulate the AI, but since it will add some audio latency because the audio plugin won't start playing the audio until the end of the DMA, I've only enabled it for these Boss games)","For games that are not affected, wouldn't the buffer sizes be a lot smaller, so the latency would be a lot less?
But yeah, 16384 bytes at 22Khz is ~0.18 seconds or 180 ms.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,342,2017-07-20T22:08:13Z,2017-07-21T20:24:52Z,2017-08-09T14:04:38Z,CLOSED,False,65,9,13,https://github.com/loganmc10,[WIP] Add support for streaming audio buffer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/342,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/342#issuecomment-317095901,"This PR proposes a change to the API, so I haven't updated the docs yet, I'll do that if the API change gets a thumbs up.
This fixes audio in Boss Games (Stunt Racer, World Driver Championship, Top Gear Rally, Twisted Edge Snowboarding).
You can read my explanation of the problem/solution here:
#200 (comment)
Basically in this PR, every time AI_LEN_REG is read, we update the contents of the audio buffer. These games update the audio data while the DMA is happening, so we can't just copy the memory at the beginning of the DMA and send it to the audio plugin.
Because of this, I created a new audio API function (PlayAudio), which just takes a buffer and plays the audio in it, instead of having to read from DMEM.
You can see the change I made to the audio plugin here:
m64p/mupen64plus-audio-sdl2@79fef8d
These games don't seem to play nice with audio speed limiters/""sync to audio"" settings, so if you're going to test it, you'll probably need to test it with that sort of thing disabled.
I'm hoping some people can test this, I can provide a binary build if needed.
(technically this is actually the more accurate way to emulate the AI, but since it will add some audio latency because the audio plugin won't start playing the audio until the end of the DMA, I've only enabled it for these Boss games)","Yeah that's true, most games use a much smaller buffer, like 2k or so.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,342,2017-07-20T22:08:13Z,2017-07-21T20:24:52Z,2017-08-09T14:04:38Z,CLOSED,False,65,9,13,https://github.com/loganmc10,[WIP] Add support for streaming audio buffer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/342,https://github.com/fzurita,8,https://github.com/mupen64plus/mupen64plus-core/pull/342#issuecomment-317099732,"This PR proposes a change to the API, so I haven't updated the docs yet, I'll do that if the API change gets a thumbs up.
This fixes audio in Boss Games (Stunt Racer, World Driver Championship, Top Gear Rally, Twisted Edge Snowboarding).
You can read my explanation of the problem/solution here:
#200 (comment)
Basically in this PR, every time AI_LEN_REG is read, we update the contents of the audio buffer. These games update the audio data while the DMA is happening, so we can't just copy the memory at the beginning of the DMA and send it to the audio plugin.
Because of this, I created a new audio API function (PlayAudio), which just takes a buffer and plays the audio in it, instead of having to read from DMEM.
You can see the change I made to the audio plugin here:
m64p/mupen64plus-audio-sdl2@79fef8d
These games don't seem to play nice with audio speed limiters/""sync to audio"" settings, so if you're going to test it, you'll probably need to test it with that sort of thing disabled.
I'm hoping some people can test this, I can provide a binary build if needed.
(technically this is actually the more accurate way to emulate the AI, but since it will add some audio latency because the audio plugin won't start playing the audio until the end of the DMA, I've only enabled it for these Boss games)",Which is like 2ms at 22KHz. I don't think a human would perceive that.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,342,2017-07-20T22:08:13Z,2017-07-21T20:24:52Z,2017-08-09T14:04:38Z,CLOSED,False,65,9,13,https://github.com/loganmc10,[WIP] Add support for streaming audio buffer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/342,https://github.com/fzurita,9,https://github.com/mupen64plus/mupen64plus-core/pull/342#issuecomment-317099921,"This PR proposes a change to the API, so I haven't updated the docs yet, I'll do that if the API change gets a thumbs up.
This fixes audio in Boss Games (Stunt Racer, World Driver Championship, Top Gear Rally, Twisted Edge Snowboarding).
You can read my explanation of the problem/solution here:
#200 (comment)
Basically in this PR, every time AI_LEN_REG is read, we update the contents of the audio buffer. These games update the audio data while the DMA is happening, so we can't just copy the memory at the beginning of the DMA and send it to the audio plugin.
Because of this, I created a new audio API function (PlayAudio), which just takes a buffer and plays the audio in it, instead of having to read from DMEM.
You can see the change I made to the audio plugin here:
m64p/mupen64plus-audio-sdl2@79fef8d
These games don't seem to play nice with audio speed limiters/""sync to audio"" settings, so if you're going to test it, you'll probably need to test it with that sort of thing disabled.
I'm hoping some people can test this, I can provide a binary build if needed.
(technically this is actually the more accurate way to emulate the AI, but since it will add some audio latency because the audio plugin won't start playing the audio until the end of the DMA, I've only enabled it for these Boss games)",Maybe it's the case that the only games that use such large buffer are the one that use the streaming technique.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,342,2017-07-20T22:08:13Z,2017-07-21T20:24:52Z,2017-08-09T14:04:38Z,CLOSED,False,65,9,13,https://github.com/loganmc10,[WIP] Add support for streaming audio buffer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/342,https://github.com/loganmc10,10,https://github.com/mupen64plus/mupen64plus-core/pull/342#issuecomment-317103940,"This PR proposes a change to the API, so I haven't updated the docs yet, I'll do that if the API change gets a thumbs up.
This fixes audio in Boss Games (Stunt Racer, World Driver Championship, Top Gear Rally, Twisted Edge Snowboarding).
You can read my explanation of the problem/solution here:
#200 (comment)
Basically in this PR, every time AI_LEN_REG is read, we update the contents of the audio buffer. These games update the audio data while the DMA is happening, so we can't just copy the memory at the beginning of the DMA and send it to the audio plugin.
Because of this, I created a new audio API function (PlayAudio), which just takes a buffer and plays the audio in it, instead of having to read from DMEM.
You can see the change I made to the audio plugin here:
m64p/mupen64plus-audio-sdl2@79fef8d
These games don't seem to play nice with audio speed limiters/""sync to audio"" settings, so if you're going to test it, you'll probably need to test it with that sort of thing disabled.
I'm hoping some people can test this, I can provide a binary build if needed.
(technically this is actually the more accurate way to emulate the AI, but since it will add some audio latency because the audio plugin won't start playing the audio until the end of the DMA, I've only enabled it for these Boss games)","Thanks for asking these questions and getting me to think! I've thought up a much simpler solution to this problem that shouldn't affect the latency in a noticeable way. I created a new PR so I can keep this code around if I ever want to look at it again.
#343",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,343,2017-07-21T20:23:54Z,2017-08-08T01:42:35Z,2017-08-09T14:04:21Z,MERGED,True,35,37,8,https://github.com/loganmc10,Send audio data to plugin as the DMA drains,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/343,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/343,"This is an improved version of #342. Please read that for details on the problem that this fixes.
This version is much simpler and doesn't require any changes to the API. Instead of sending all the audio data to the plugin at the beginning of the DMA, we send it piece by piece as the DMA happens. Then, at the end of the DMA, we send whatever is leftover.
This should be a ""global solution"" that doesn't add any noticeable latency, while still fixing the audio in these games.","This is an improved version of #342. Please read that for details on the problem that this fixes.
This version is much simpler and doesn't require any changes to the API. Instead of sending all the audio data to the plugin at the beginning of the DMA, we send it piece by piece as the DMA happens. Then, at the end of the DMA, we send whatever is leftover.
This should be a ""global solution"" that doesn't add any noticeable latency, while still fixing the audio in these games.",True,"{'THUMBS_UP': ['https://github.com/AmbientMalice', 'https://github.com/inactive123']}"
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,343,2017-07-21T20:23:54Z,2017-08-08T01:42:35Z,2017-08-09T14:04:21Z,MERGED,True,35,37,8,https://github.com/loganmc10,Send audio data to plugin as the DMA drains,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/343,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/343#issuecomment-317743232,"This is an improved version of #342. Please read that for details on the problem that this fixes.
This version is much simpler and doesn't require any changes to the API. Instead of sending all the audio data to the plugin at the beginning of the DMA, we send it piece by piece as the DMA happens. Then, at the end of the DMA, we send whatever is leftover.
This should be a ""global solution"" that doesn't add any noticeable latency, while still fixing the audio in these games.","I tested this, along with #341 with a good number of games. I didn't hear any regressions.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,343,2017-07-21T20:23:54Z,2017-08-08T01:42:35Z,2017-08-09T14:04:21Z,MERGED,True,35,37,8,https://github.com/loganmc10,Send audio data to plugin as the DMA drains,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/343,https://github.com/AmbientMalice,3,https://github.com/mupen64plus/mupen64plus-core/pull/343#issuecomment-317746966,"This is an improved version of #342. Please read that for details on the problem that this fixes.
This version is much simpler and doesn't require any changes to the API. Instead of sending all the audio data to the plugin at the beginning of the DMA, we send it piece by piece as the DMA happens. Then, at the end of the DMA, we send whatever is leftover.
This should be a ""global solution"" that doesn't add any noticeable latency, while still fixing the audio in these games.","Out of curiosity, does this help with Body Harvest, at all?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,343,2017-07-21T20:23:54Z,2017-08-08T01:42:35Z,2017-08-09T14:04:21Z,MERGED,True,35,37,8,https://github.com/loganmc10,Send audio data to plugin as the DMA drains,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/343,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/343#issuecomment-317750410,"This is an improved version of #342. Please read that for details on the problem that this fixes.
This version is much simpler and doesn't require any changes to the API. Instead of sending all the audio data to the plugin at the beginning of the DMA, we send it piece by piece as the DMA happens. Then, at the end of the DMA, we send whatever is leftover.
This should be a ""global solution"" that doesn't add any noticeable latency, while still fixing the audio in these games.","Do you want to hear something really weird about Body Harvest?
When I'm playing Body Harvest, the Anti-Virus on my PC goes crazy, maxing out the CPU, and it slows down the game to the point where it gets choppy. Other N64 games don't do this. It doesn't seem to happen on Project64. But besides that it works perfectly (like on Linux it sounds perfect).
What issues are you having with Body Harvest exactly? Actually I noticed that Body Harvest triggers the same issue that Twisted Edge had with audio. You know how Twisted Edge has no sound in Project64? Well the same thing that causes Twisted Edge to have no sound happens in Body Harvest, but it happens intermittently, and it is fixed by #341",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,343,2017-07-21T20:23:54Z,2017-08-08T01:42:35Z,2017-08-09T14:04:21Z,MERGED,True,35,37,8,https://github.com/loganmc10,Send audio data to plugin as the DMA drains,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/343,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/343#issuecomment-317751264,"This is an improved version of #342. Please read that for details on the problem that this fixes.
This version is much simpler and doesn't require any changes to the API. Instead of sending all the audio data to the plugin at the beginning of the DMA, we send it piece by piece as the DMA happens. Then, at the end of the DMA, we send whatever is leftover.
This should be a ""global solution"" that doesn't add any noticeable latency, while still fixing the audio in these games.","@AmbientMalice if you or anyone else wants to try out these audio fixes I've attached a version of https://m64p.github.io with the audio fixes applied
mupen64plus-audio-fix.zip",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,343,2017-07-21T20:23:54Z,2017-08-08T01:42:35Z,2017-08-09T14:04:21Z,MERGED,True,35,37,8,https://github.com/loganmc10,Send audio data to plugin as the DMA drains,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/343,https://github.com/inactive123,6,https://github.com/mupen64plus/mupen64plus-core/pull/343#issuecomment-318815977,"This is an improved version of #342. Please read that for details on the problem that this fixes.
This version is much simpler and doesn't require any changes to the API. Instead of sending all the audio data to the plugin at the beginning of the DMA, we send it piece by piece as the DMA happens. Then, at the end of the DMA, we send whatever is leftover.
This should be a ""global solution"" that doesn't add any noticeable latency, while still fixing the audio in these games.","Have you tested if this PR is safe with savestate loading? I ask because I have experienced plenty of crashing problems so far when attempting to load a savestate. Sometimes it works without crashing, other times it crashes on accessing the buffer.
It happens inside the push_audio_samples function.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,343,2017-07-21T20:23:54Z,2017-08-08T01:42:35Z,2017-08-09T14:04:21Z,MERGED,True,35,37,8,https://github.com/loganmc10,Send audio data to plugin as the DMA drains,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/343,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/343#issuecomment-318832037,"This is an improved version of #342. Please read that for details on the problem that this fixes.
This version is much simpler and doesn't require any changes to the API. Instead of sending all the audio data to the plugin at the beginning of the DMA, we send it piece by piece as the DMA happens. Then, at the end of the DMA, we send whatever is leftover.
This should be a ""global solution"" that doesn't add any noticeable latency, while still fixing the audio in these games.","I tested a bunch of games, no issue with save states. Save states don't really work reliably with World Driver Championship or Stunt Racer. I assume it's because the value of rsp_task_locked isn't stored within the save state.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,343,2017-07-21T20:23:54Z,2017-08-08T01:42:35Z,2017-08-09T14:04:21Z,MERGED,True,35,37,8,https://github.com/loganmc10,Send audio data to plugin as the DMA drains,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/343,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/343#issuecomment-320472304,"This is an improved version of #342. Please read that for details on the problem that this fixes.
This version is much simpler and doesn't require any changes to the API. Instead of sending all the audio data to the plugin at the beginning of the DMA, we send it piece by piece as the DMA happens. Then, at the end of the DMA, we send whatever is leftover.
This should be a ""global solution"" that doesn't add any noticeable latency, while still fixing the audio in these games.","I combined this PR with #341 since they would have created merge conflicts with each other, and they are mildly related",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,343,2017-07-21T20:23:54Z,2017-08-08T01:42:35Z,2017-08-09T14:04:21Z,MERGED,True,35,37,8,https://github.com/loganmc10,Send audio data to plugin as the DMA drains,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/343,https://github.com/loganmc10,9,https://github.com/mupen64plus/mupen64plus-core/pull/343#issuecomment-320822920,"This is an improved version of #342. Please read that for details on the problem that this fixes.
This version is much simpler and doesn't require any changes to the API. Instead of sending all the audio data to the plugin at the beginning of the DMA, we send it piece by piece as the DMA happens. Then, at the end of the DMA, we send whatever is leftover.
This should be a ""global solution"" that doesn't add any noticeable latency, while still fixing the audio in these games.",I fixed the merge conflicts that arose,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,343,2017-07-21T20:23:54Z,2017-08-08T01:42:35Z,2017-08-09T14:04:21Z,MERGED,True,35,37,8,https://github.com/loganmc10,Send audio data to plugin as the DMA drains,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/343,https://github.com/bsmiles32,10,https://github.com/mupen64plus/mupen64plus-core/pull/343#issuecomment-320823069,"This is an improved version of #342. Please read that for details on the problem that this fixes.
This version is much simpler and doesn't require any changes to the API. Instead of sending all the audio data to the plugin at the beginning of the DMA, we send it piece by piece as the DMA happens. Then, at the end of the DMA, we send whatever is leftover.
This should be a ""global solution"" that doesn't add any noticeable latency, while still fixing the audio in these games.","I think I did it also using the github editor, but you beat me to it :)
Just a matter of waiting Travis to finish and I merge it.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,347,2017-07-25T19:41:58Z,2017-07-25T20:08:52Z,2018-03-04T13:41:47Z,CLOSED,False,6,3,1,https://github.com/loganmc10,Fix timing in DK64,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/347,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/347,"I'm hoping a couple people can test this out before it gets merged.
I believe this improves the timing in DK64 because:
During the intro, right after the rap sequence, there is a ""Press Start"" screen. In Project64, and currently in mupen64plus, Donkey Kong jumps into the water, climbs up a hill, and then jumps into the water again, missing the vines.
With this change, he correctly climbs up the hill, then jumps across the vines and into the cannon. This is the correct sequence for the intro of the game.
I've never really played this game much, so I'm hoping some people can test this out in various stages of the game. The settings are CountPerOp=3 and CountPerScanline=1750. You should be able to just modify mupen64plus.cfg to test this, no need to recompile anything","I'm hoping a couple people can test this out before it gets merged.
I believe this improves the timing in DK64 because:
During the intro, right after the rap sequence, there is a ""Press Start"" screen. In Project64, and currently in mupen64plus, Donkey Kong jumps into the water, climbs up a hill, and then jumps into the water again, missing the vines.
With this change, he correctly climbs up the hill, then jumps across the vines and into the cannon. This is the correct sequence for the intro of the game.
I've never really played this game much, so I'm hoping some people can test this out in various stages of the game. The settings are CountPerOp=3 and CountPerScanline=1750. You should be able to just modify mupen64plus.cfg to test this, no need to recompile anything",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,347,2017-07-25T19:41:58Z,2017-07-25T20:08:52Z,2018-03-04T13:41:47Z,CLOSED,False,6,3,1,https://github.com/loganmc10,Fix timing in DK64,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/347,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/347#issuecomment-317854852,"I'm hoping a couple people can test this out before it gets merged.
I believe this improves the timing in DK64 because:
During the intro, right after the rap sequence, there is a ""Press Start"" screen. In Project64, and currently in mupen64plus, Donkey Kong jumps into the water, climbs up a hill, and then jumps into the water again, missing the vines.
With this change, he correctly climbs up the hill, then jumps across the vines and into the cannon. This is the correct sequence for the intro of the game.
I've never really played this game much, so I'm hoping some people can test this out in various stages of the game. The settings are CountPerOp=3 and CountPerScanline=1750. You should be able to just modify mupen64plus.cfg to test this, no need to recompile anything","By the way, there are other settings that will allow DK to catch the vine in the intro, CountPerOp=2 and CountPerScanline=1100 also works.
The other issue with this game is the timed sections. There are sections where you have 60 seconds to complete a task for instance.
With CountPerOp=2 and CountPerScanline=1100, the timer for the 60 second section took 75 seconds.
With CountPerOp=3 and CountPerScanline=1750, the timer for the 60 second section took 50 seconds.
Basically it seems like if we could do a ""CountPerOp=2.5"", the timing would be pretty close to perfect, but this is probably as close as we are going to get with our current timing system.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,347,2017-07-25T19:41:58Z,2017-07-25T20:08:52Z,2018-03-04T13:41:47Z,CLOSED,False,6,3,1,https://github.com/loganmc10,Fix timing in DK64,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/347,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/347#issuecomment-317856990,"I'm hoping a couple people can test this out before it gets merged.
I believe this improves the timing in DK64 because:
During the intro, right after the rap sequence, there is a ""Press Start"" screen. In Project64, and currently in mupen64plus, Donkey Kong jumps into the water, climbs up a hill, and then jumps into the water again, missing the vines.
With this change, he correctly climbs up the hill, then jumps across the vines and into the cannon. This is the correct sequence for the intro of the game.
I've never really played this game much, so I'm hoping some people can test this out in various stages of the game. The settings are CountPerOp=3 and CountPerScanline=1750. You should be able to just modify mupen64plus.cfg to test this, no need to recompile anything","hm actually I just tested the current default settings, and although DK doesn't hit the vine in the intro, the timed section is almost exactly 60 seconds. It's probably more important that the timing in these timed sections is correct, rather than the intro, so I'll close this. What a strange game",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,347,2017-07-25T19:41:58Z,2017-07-25T20:08:52Z,2018-03-04T13:41:47Z,CLOSED,False,6,3,1,https://github.com/loganmc10,Fix timing in DK64,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/347,https://github.com/fzurita,4,https://github.com/mupen64plus/mupen64plus-core/pull/347#issuecomment-318105980,"I'm hoping a couple people can test this out before it gets merged.
I believe this improves the timing in DK64 because:
During the intro, right after the rap sequence, there is a ""Press Start"" screen. In Project64, and currently in mupen64plus, Donkey Kong jumps into the water, climbs up a hill, and then jumps into the water again, missing the vines.
With this change, he correctly climbs up the hill, then jumps across the vines and into the cannon. This is the correct sequence for the intro of the game.
I've never really played this game much, so I'm hoping some people can test this out in various stages of the game. The settings are CountPerOp=3 and CountPerScanline=1750. You should be able to just modify mupen64plus.cfg to test this, no need to recompile anything","I think we need to have a ""variable count per op"" setting. Where count per op is different depending on the instructions being executed.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,347,2017-07-25T19:41:58Z,2017-07-25T20:08:52Z,2018-03-04T13:41:47Z,CLOSED,False,6,3,1,https://github.com/loganmc10,Fix timing in DK64,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/347,https://github.com/fzurita,5,https://github.com/mupen64plus/mupen64plus-core/pull/347#issuecomment-370164842,"I'm hoping a couple people can test this out before it gets merged.
I believe this improves the timing in DK64 because:
During the intro, right after the rap sequence, there is a ""Press Start"" screen. In Project64, and currently in mupen64plus, Donkey Kong jumps into the water, climbs up a hill, and then jumps into the water again, missing the vines.
With this change, he correctly climbs up the hill, then jumps across the vines and into the cannon. This is the correct sequence for the intro of the game.
I've never really played this game much, so I'm hoping some people can test this out in various stages of the game. The settings are CountPerOp=3 and CountPerScanline=1750. You should be able to just modify mupen64plus.cfg to test this, no need to recompile anything",Did the timing for this game change at all when you made count per scanline dynamic?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,347,2017-07-25T19:41:58Z,2017-07-25T20:08:52Z,2018-03-04T13:41:47Z,CLOSED,False,6,3,1,https://github.com/loganmc10,Fix timing in DK64,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/347,https://github.com/fzurita,6,https://github.com/mupen64plus/mupen64plus-core/pull/347#issuecomment-370165246,"I'm hoping a couple people can test this out before it gets merged.
I believe this improves the timing in DK64 because:
During the intro, right after the rap sequence, there is a ""Press Start"" screen. In Project64, and currently in mupen64plus, Donkey Kong jumps into the water, climbs up a hill, and then jumps into the water again, missing the vines.
With this change, he correctly climbs up the hill, then jumps across the vines and into the cannon. This is the correct sequence for the intro of the game.
I've never really played this game much, so I'm hoping some people can test this out in various stages of the game. The settings are CountPerOp=3 and CountPerScanline=1750. You should be able to just modify mupen64plus.cfg to test this, no need to recompile anything","I have the feeling that the game is controlling dk through the timing of some interrupt and changing count per op or count per scanline changes that timing.
Maybe changing sp_delay_time or add_interrupt_event in some places will have some effect on the timing in the intro.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,347,2017-07-25T19:41:58Z,2017-07-25T20:08:52Z,2018-03-04T13:41:47Z,CLOSED,False,6,3,1,https://github.com/loganmc10,Fix timing in DK64,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/347,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/347#issuecomment-370201812,"I'm hoping a couple people can test this out before it gets merged.
I believe this improves the timing in DK64 because:
During the intro, right after the rap sequence, there is a ""Press Start"" screen. In Project64, and currently in mupen64plus, Donkey Kong jumps into the water, climbs up a hill, and then jumps into the water again, missing the vines.
With this change, he correctly climbs up the hill, then jumps across the vines and into the cannon. This is the correct sequence for the intro of the game.
I've never really played this game much, so I'm hoping some people can test this out in various stages of the game. The settings are CountPerOp=3 and CountPerScanline=1750. You should be able to just modify mupen64plus.cfg to test this, no need to recompile anything","Did the timing for this game change at all when you made count per scanline dynamic?

Changing the count per scanline does modify DK's path in the intro, but the change you are referring to only changed it from 1500 to around 1545, not enough to probably make any noticeable difference.

Maybe changing sp_delay_time or add_interrupt_event in some places will have some effect on the timing in the intro.

You are probably right about this, it could be the audio interrupt or any other interrupt, but yes it is probably measuring the time between some interrupt. It seems like if you get the timing right during the intro, it's wrong at the timed in-game sections though. It'll probably be hard to get both of them right",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,347,2017-07-25T19:41:58Z,2017-07-25T20:08:52Z,2018-03-04T13:41:47Z,CLOSED,False,6,3,1,https://github.com/loganmc10,Fix timing in DK64,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/347,https://github.com/fzurita,8,https://github.com/mupen64plus/mupen64plus-core/pull/347#issuecomment-370201935,"I'm hoping a couple people can test this out before it gets merged.
I believe this improves the timing in DK64 because:
During the intro, right after the rap sequence, there is a ""Press Start"" screen. In Project64, and currently in mupen64plus, Donkey Kong jumps into the water, climbs up a hill, and then jumps into the water again, missing the vines.
With this change, he correctly climbs up the hill, then jumps across the vines and into the cannon. This is the correct sequence for the intro of the game.
I've never really played this game much, so I'm hoping some people can test this out in various stages of the game. The settings are CountPerOp=3 and CountPerScanline=1750. You should be able to just modify mupen64plus.cfg to test this, no need to recompile anything","From your initial look at this problem, it seemed that count per op was the only thing that affected the timed sections? So if we set that to 2 and only change the interrupt timing, maybe it will work?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,347,2017-07-25T19:41:58Z,2017-07-25T20:08:52Z,2018-03-04T13:41:47Z,CLOSED,False,6,3,1,https://github.com/loganmc10,Fix timing in DK64,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/347,https://github.com/loganmc10,9,https://github.com/mupen64plus/mupen64plus-core/pull/347#issuecomment-370202272,"I'm hoping a couple people can test this out before it gets merged.
I believe this improves the timing in DK64 because:
During the intro, right after the rap sequence, there is a ""Press Start"" screen. In Project64, and currently in mupen64plus, Donkey Kong jumps into the water, climbs up a hill, and then jumps into the water again, missing the vines.
With this change, he correctly climbs up the hill, then jumps across the vines and into the cannon. This is the correct sequence for the intro of the game.
I've never really played this game much, so I'm hoping some people can test this out in various stages of the game. The settings are CountPerOp=3 and CountPerScanline=1750. You should be able to just modify mupen64plus.cfg to test this, no need to recompile anything","I can't remember exactly. In my experience modifying CountPerOp was a big difference and CountPerScaline was a smaller change, at least for the intro scene.
Changing CountPerScaline is basically just changing the VI interrupt timing, so in that respect it would be no different than trying to modify the audio interrupt timing or something. But DK may be measuring the time between VI interrupts, and in that case you would change that interrupt timing by changing CountPerScaline",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,347,2017-07-25T19:41:58Z,2017-07-25T20:08:52Z,2018-03-04T13:41:47Z,CLOSED,False,6,3,1,https://github.com/loganmc10,Fix timing in DK64,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/347,https://github.com/fzurita,10,https://github.com/mupen64plus/mupen64plus-core/pull/347#issuecomment-370202304,"I'm hoping a couple people can test this out before it gets merged.
I believe this improves the timing in DK64 because:
During the intro, right after the rap sequence, there is a ""Press Start"" screen. In Project64, and currently in mupen64plus, Donkey Kong jumps into the water, climbs up a hill, and then jumps into the water again, missing the vines.
With this change, he correctly climbs up the hill, then jumps across the vines and into the cannon. This is the correct sequence for the intro of the game.
I've never really played this game much, so I'm hoping some people can test this out in various stages of the game. The settings are CountPerOp=3 and CountPerScanline=1750. You should be able to just modify mupen64plus.cfg to test this, no need to recompile anything",Ok,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,347,2017-07-25T19:41:58Z,2017-07-25T20:08:52Z,2018-03-04T13:41:47Z,CLOSED,False,6,3,1,https://github.com/loganmc10,Fix timing in DK64,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/347,https://github.com/fzurita,11,https://github.com/mupen64plus/mupen64plus-core/pull/347#issuecomment-370230236,"I'm hoping a couple people can test this out before it gets merged.
I believe this improves the timing in DK64 because:
During the intro, right after the rap sequence, there is a ""Press Start"" screen. In Project64, and currently in mupen64plus, Donkey Kong jumps into the water, climbs up a hill, and then jumps into the water again, missing the vines.
With this change, he correctly climbs up the hill, then jumps across the vines and into the cannon. This is the correct sequence for the intro of the game.
I've never really played this game much, so I'm hoping some people can test this out in various stages of the game. The settings are CountPerOp=3 and CountPerScanline=1750. You should be able to just modify mupen64plus.cfg to test this, no need to recompile anything","I tried modifying the interrupt times, it didn't affect the game controlled dk movement.
Interestingly, modifying the ai interrupt time made the game run faster or slower.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,348,2017-07-26T04:59:54Z,2017-07-26T20:11:42Z,2017-07-26T20:11:42Z,CLOSED,False,6,0,1,https://github.com/loganmc10,Fix Indiana Jones,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/348,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/348,"This is my latest attempt to get Indiana Jones working.
CountPerOp=1 fixes graphical and stability issues
CountPerScanline=2200 allows the game to boot with CountPerOp=1
DisableExtraMem=1 disables the expansion pak. This seems to fix the hang at the end of the level, right before the Trading Post. The expansion pak brought the game to 640x480, but I think disabling it is worth it to make the game playable, at least until a better fix is found.
I'm going to test this over the next few days to make sure I got this right. These are all just settings you can set in mupen64plus.cfg, so anyone can test this out. If you're going to test I would suggest deleting any save (eep) files associated with the game.","This is my latest attempt to get Indiana Jones working.
CountPerOp=1 fixes graphical and stability issues
CountPerScanline=2200 allows the game to boot with CountPerOp=1
DisableExtraMem=1 disables the expansion pak. This seems to fix the hang at the end of the level, right before the Trading Post. The expansion pak brought the game to 640x480, but I think disabling it is worth it to make the game playable, at least until a better fix is found.
I'm going to test this over the next few days to make sure I got this right. These are all just settings you can set in mupen64plus.cfg, so anyone can test this out. If you're going to test I would suggest deleting any save (eep) files associated with the game.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,348,2017-07-26T04:59:54Z,2017-07-26T20:11:42Z,2017-07-26T20:11:42Z,CLOSED,False,6,0,1,https://github.com/loganmc10,Fix Indiana Jones,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/348,https://github.com/AmbientMalice,2,https://github.com/mupen64plus/mupen64plus-core/pull/348#issuecomment-318039419,"This is my latest attempt to get Indiana Jones working.
CountPerOp=1 fixes graphical and stability issues
CountPerScanline=2200 allows the game to boot with CountPerOp=1
DisableExtraMem=1 disables the expansion pak. This seems to fix the hang at the end of the level, right before the Trading Post. The expansion pak brought the game to 640x480, but I think disabling it is worth it to make the game playable, at least until a better fix is found.
I'm going to test this over the next few days to make sure I got this right. These are all just settings you can set in mupen64plus.cfg, so anyone can test this out. If you're going to test I would suggest deleting any save (eep) files associated with the game.","Disabling the expansion pack causes the music to sound strange, makes one of the levels inaccessible (it gets skipped), and in my playtesting on m64p in the past, the game will proceed to freeze at the end of later missions. If not the second, then the third.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,348,2017-07-26T04:59:54Z,2017-07-26T20:11:42Z,2017-07-26T20:11:42Z,CLOSED,False,6,0,1,https://github.com/loganmc10,Fix Indiana Jones,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/348,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/348#issuecomment-318111569,"This is my latest attempt to get Indiana Jones working.
CountPerOp=1 fixes graphical and stability issues
CountPerScanline=2200 allows the game to boot with CountPerOp=1
DisableExtraMem=1 disables the expansion pak. This seems to fix the hang at the end of the level, right before the Trading Post. The expansion pak brought the game to 640x480, but I think disabling it is worth it to make the game playable, at least until a better fix is found.
I'm going to test this over the next few days to make sure I got this right. These are all just settings you can set in mupen64plus.cfg, so anyone can test this out. If you're going to test I would suggest deleting any save (eep) files associated with the game.","Hm yep it appears you're right. The audio sounds fine to me, but it froze at the end of the 2nd level. Unsetting ""DelaySI"" allowed it to complete the 2nd level, but then I went back and tested the 1st level with DelaySI off and it froze at the end....",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,351,2017-07-28T22:06:55Z,2017-08-09T05:36:12Z,2017-08-09T05:36:12Z,MERGED,True,25,2,5,https://github.com/loganmc10,Add SI_STATUS_DMA_BUSY,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/351,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/351,"This fixes the error:
Core Warning: two events of type 0x8 in interrupt queue

in some games. I've noticed it in Diddy Kong Racing and Mischief Makers (it really spams this message in Mischief Makers).
Anyway they are doing this because they don't know the SI DMA is busy. I added the busy bit, now these errors don't show up anymore.","This fixes the error:
Core Warning: two events of type 0x8 in interrupt queue

in some games. I've noticed it in Diddy Kong Racing and Mischief Makers (it really spams this message in Mischief Makers).
Anyway they are doing this because they don't know the SI DMA is busy. I added the busy bit, now these errors don't show up anymore.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,351,2017-07-28T22:06:55Z,2017-08-09T05:36:12Z,2017-08-09T05:36:12Z,MERGED,True,25,2,5,https://github.com/loganmc10,Add SI_STATUS_DMA_BUSY,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/351,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/351#issuecomment-318932826,"This fixes the error:
Core Warning: two events of type 0x8 in interrupt queue

in some games. I've noticed it in Diddy Kong Racing and Mischief Makers (it really spams this message in Mischief Makers).
Anyway they are doing this because they don't know the SI DMA is busy. I added the busy bit, now these errors don't show up anymore.","I also added SI_STATUS_RD_BUSY, which is only applied for dma_si_read() (a write to SI_PIF_ADDR_RD64B_REG). Perhaps someone could confirm that is correct before this is merged.
rcp.h says that SI_STATUS_RD_BUSY means ""IO read busy"". It's a little unclear to me what that means, but I assume is means ""when the PIF is being read"".
@bsmiles32 does that sound right? It doesn't seem to create any issues.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,351,2017-07-28T22:06:55Z,2017-08-09T05:36:12Z,2017-08-09T05:36:12Z,MERGED,True,25,2,5,https://github.com/loganmc10,Add SI_STATUS_DMA_BUSY,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/351,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/351#issuecomment-320828504,"This fixes the error:
Core Warning: two events of type 0x8 in interrupt queue

in some games. I've noticed it in Diddy Kong Racing and Mischief Makers (it really spams this message in Mischief Makers).
Anyway they are doing this because they don't know the SI DMA is busy. I added the busy bit, now these errors don't show up anymore.","I don't really know how SI_STATUS_RD_BUSY should be interpreted.
While these changes fix the ""two event of type 0x8 in interrupt queue"" spamming, it breaks button presses on my end in Mischief Maker.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,351,2017-07-28T22:06:55Z,2017-08-09T05:36:12Z,2017-08-09T05:36:12Z,MERGED,True,25,2,5,https://github.com/loganmc10,Add SI_STATUS_DMA_BUSY,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/351,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/351#issuecomment-320829515,"This fixes the error:
Core Warning: two events of type 0x8 in interrupt queue

in some games. I've noticed it in Diddy Kong Racing and Mischief Makers (it really spams this message in Mischief Makers).
Anyway they are doing this because they don't know the SI DMA is busy. I added the busy bit, now these errors don't show up anymore.","Hm ok thanks for testing, I'll do some more testing and research",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,351,2017-07-28T22:06:55Z,2017-08-09T05:36:12Z,2017-08-09T05:36:12Z,MERGED,True,25,2,5,https://github.com/loganmc10,Add SI_STATUS_DMA_BUSY,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/351,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/351#issuecomment-320837423,"This fixes the error:
Core Warning: two events of type 0x8 in interrupt queue

in some games. I've noticed it in Diddy Kong Racing and Mischief Makers (it really spams this message in Mischief Makers).
Anyway they are doing this because they don't know the SI DMA is busy. I added the busy bit, now these errors don't show up anymore.","@bsmiles32 do you know why 0x900 was chosen as the interrupt delay time? Or what games need/benefit from the SI delay?
Reducing the 0x900 number fixes Mischief Makers. In my reading, the peak DMA transfer rate for the RSP (I couldn't find any other numbers that were related to DMA transfer rates) is 8 bytes per cycle. So I have a couple questions:
What is the 0x900 number supposed to represent? What is it counting?
If it is supposed to be counting ops or cycles, is PIF_RAM_SIZE / 8 a good approximation? It is a very small number (0x8), I can test this on a few games, I'm just wondering if you had any insight into how the current system came to be.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,351,2017-07-28T22:06:55Z,2017-08-09T05:36:12Z,2017-08-09T05:36:12Z,MERGED,True,25,2,5,https://github.com/loganmc10,Add SI_STATUS_DMA_BUSY,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/351,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/351#issuecomment-320842363,"This fixes the error:
Core Warning: two events of type 0x8 in interrupt queue

in some games. I've noticed it in Diddy Kong Racing and Mischief Makers (it really spams this message in Mischief Makers).
Anyway they are doing this because they don't know the SI DMA is busy. I added the busy bit, now these errors don't show up anymore.","Shortening the interrupt timing broke Body Harvest, so I'm assuming that's not a safe thing to do.
I've modified the PR to get rid of RD_BUSY, since I don't see any benefit of using it. I also added DelaySI as a INI param and disabled it for Mischief Makers. This fixes the input. Does this seem ok? Diddy Kong Racing seems to perform as normal. I'm not aware of any other game that had those error messages.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,351,2017-07-28T22:06:55Z,2017-08-09T05:36:12Z,2017-08-09T05:36:12Z,MERGED,True,25,2,5,https://github.com/loganmc10,Add SI_STATUS_DMA_BUSY,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/351,https://github.com/bsmiles32,7,https://github.com/mupen64plus/mupen64plus-core/pull/351#issuecomment-320843596,"This fixes the error:
Core Warning: two events of type 0x8 in interrupt queue

in some games. I've noticed it in Diddy Kong Racing and Mischief Makers (it really spams this message in Mischief Makers).
Anyway they are doing this because they don't know the SI DMA is busy. I added the busy bit, now these errors don't show up anymore.","Don't know about the 0x900 value nor the delay si behavior. I guess it's pure try and guess what worked for selected titles (like for any timing stuff in m64p).
I'm not sure what speed the SI DMA has, so a test ROM is what we need here.
The updated PR looks OK to me, but some more testing is welcome before I merge it.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,351,2017-07-28T22:06:55Z,2017-08-09T05:36:12Z,2017-08-09T05:36:12Z,MERGED,True,25,2,5,https://github.com/loganmc10,Add SI_STATUS_DMA_BUSY,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/351,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/351#issuecomment-320851071,"This fixes the error:
Core Warning: two events of type 0x8 in interrupt queue

in some games. I've noticed it in Diddy Kong Racing and Mischief Makers (it really spams this message in Mischief Makers).
Anyway they are doing this because they don't know the SI DMA is busy. I added the busy bit, now these errors don't show up anymore.","I guess this was tried once before:
252d09f
And reverted for this same reason:
b77d551
I'll do a fair bit of testing for this change to make sure it doesn't cause issues in any other games",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,351,2017-07-28T22:06:55Z,2017-08-09T05:36:12Z,2017-08-09T05:36:12Z,MERGED,True,25,2,5,https://github.com/loganmc10,Add SI_STATUS_DMA_BUSY,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/351,https://github.com/loganmc10,9,https://github.com/mupen64plus/mupen64plus-core/pull/351#issuecomment-321040492,"This fixes the error:
Core Warning: two events of type 0x8 in interrupt queue

in some games. I've noticed it in Diddy Kong Racing and Mischief Makers (it really spams this message in Mischief Makers).
Anyway they are doing this because they don't know the SI DMA is busy. I added the busy bit, now these errors don't show up anymore.","I tested this with about 60 games. I made sure the input worked in all of them. I also made sure that input and saving works in Diddy Kong Racing and Mischief Makers.
It all looks good to me, no issues. If we ever run across another game like Mischief Makers that has issues, disabling DelaySI will probably do the trick, and now it can just be added to the ini file.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,352,2017-08-05T20:17:55Z,2017-08-08T01:06:24Z,2017-08-09T14:04:23Z,MERGED,True,9,0,1,https://github.com/loganmc10,CountPerOp=1 for Factor5 games,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/352,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/352,All of these games have some graphical flickering without CountPerOp=1.,All of these games have some graphical flickering without CountPerOp=1.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,355,2017-08-08T02:23:34Z,2017-08-08T02:44:44Z,2017-09-14T23:43:22Z,MERGED,True,20,20,2,https://github.com/bsmiles32,Change tpak/gb debug message level to verbose.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/355,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/355,Also fix some typo.,Also fix some typo.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,356,2017-08-09T15:41:46Z,2017-08-19T22:38:07Z,2017-08-20T01:34:07Z,MERGED,True,13,42,8,https://github.com/loganmc10,"Get rid of ""alternate VI timing""",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/356,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/356,"I noticed a while ago (#196 (comment)) that this ""alternate timing"" hack only makes a difference when the result of the calculation makes vi->regs[VI_CURRENT_REG] = 0
I got the idea for ""< 40"" from this comment: https://github.com/tj90241/cen64/blob/master/vi/controller.c#L83-L87
Sometimes vi->next_vi - cp0_regs[CP0_COUNT_REG] can actually be a negative number in Pokemon Puzzle League, so we've already passed the VI interrupt when this math is being done, which screws up the calculation.
Anyway I've tested this with a number of games and I don't see any regressions, however it is modifying the VI interrupt system, which is already a little ""fragile"" as it is, so I will probably do some more testing over the next few days.","I noticed a while ago (#196 (comment)) that this ""alternate timing"" hack only makes a difference when the result of the calculation makes vi->regs[VI_CURRENT_REG] = 0
I got the idea for ""< 40"" from this comment: https://github.com/tj90241/cen64/blob/master/vi/controller.c#L83-L87
Sometimes vi->next_vi - cp0_regs[CP0_COUNT_REG] can actually be a negative number in Pokemon Puzzle League, so we've already passed the VI interrupt when this math is being done, which screws up the calculation.
Anyway I've tested this with a number of games and I don't see any regressions, however it is modifying the VI interrupt system, which is already a little ""fragile"" as it is, so I will probably do some more testing over the next few days.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,356,2017-08-09T15:41:46Z,2017-08-19T22:38:07Z,2017-08-20T01:34:07Z,MERGED,True,13,42,8,https://github.com/loganmc10,"Get rid of ""alternate VI timing""",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/356,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/356#issuecomment-321719364,"I noticed a while ago (#196 (comment)) that this ""alternate timing"" hack only makes a difference when the result of the calculation makes vi->regs[VI_CURRENT_REG] = 0
I got the idea for ""< 40"" from this comment: https://github.com/tj90241/cen64/blob/master/vi/controller.c#L83-L87
Sometimes vi->next_vi - cp0_regs[CP0_COUNT_REG] can actually be a negative number in Pokemon Puzzle League, so we've already passed the VI interrupt when this math is being done, which screws up the calculation.
Anyway I've tested this with a number of games and I don't see any regressions, however it is modifying the VI interrupt system, which is already a little ""fragile"" as it is, so I will probably do some more testing over the next few days.","I tested this with a pretty good number of games and saw no regressions, more testing or comments is always welcome of course",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,356,2017-08-09T15:41:46Z,2017-08-19T22:38:07Z,2017-08-20T01:34:07Z,MERGED,True,13,42,8,https://github.com/loganmc10,"Get rid of ""alternate VI timing""",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/356,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/356#issuecomment-322655333,"I noticed a while ago (#196 (comment)) that this ""alternate timing"" hack only makes a difference when the result of the calculation makes vi->regs[VI_CURRENT_REG] = 0
I got the idea for ""< 40"" from this comment: https://github.com/tj90241/cen64/blob/master/vi/controller.c#L83-L87
Sometimes vi->next_vi - cp0_regs[CP0_COUNT_REG] can actually be a negative number in Pokemon Puzzle League, so we've already passed the VI interrupt when this math is being done, which screws up the calculation.
Anyway I've tested this with a number of games and I don't see any regressions, however it is modifying the VI interrupt system, which is already a little ""fragile"" as it is, so I will probably do some more testing over the next few days.","I think my previous fix was incorrect. Just doing:
if (vi->regs[VI_CURRENT_REG] >= NTSC_VERTICAL_RESOLUTION)
    vi->regs[VI_CURRENT_REG] -= NTSC_VERTICAL_RESOLUTION;

Fixes the issue and it makes a lot more sense to me. VI_CURRENT_REG can't be higher than the number of scan lines (as I understand it). So if we are higher than NTSC_VERTICAL_RESOLUTION (or equal, since the first scanline is represented by ""0""), we wrap around.
I need to test a bit more, and I need to test with PAL as well (I assume it needs a different value), but this feels a lot more correct to me.
EDIT:
Actually it looks like using vi->regs[VI_V_SYNC_REG] is the better way and probably works with PAL too, I'll do some testing over the next few days.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,356,2017-08-09T15:41:46Z,2017-08-19T22:38:07Z,2017-08-20T01:34:07Z,MERGED,True,13,42,8,https://github.com/loganmc10,"Get rid of ""alternate VI timing""",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/356,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/356#issuecomment-323088124,"I noticed a while ago (#196 (comment)) that this ""alternate timing"" hack only makes a difference when the result of the calculation makes vi->regs[VI_CURRENT_REG] = 0
I got the idea for ""< 40"" from this comment: https://github.com/tj90241/cen64/blob/master/vi/controller.c#L83-L87
Sometimes vi->next_vi - cp0_regs[CP0_COUNT_REG] can actually be a negative number in Pokemon Puzzle League, so we've already passed the VI interrupt when this math is being done, which screws up the calculation.
Anyway I've tested this with a number of games and I don't see any regressions, however it is modifying the VI interrupt system, which is already a little ""fragile"" as it is, so I will probably do some more testing over the next few days.",Ok I tested both NTSC and PAL versions of Pokemon Puzzle League and they work. I also tested a good number of others games and they work as well. This seems pretty good to me.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,357,2017-08-10T20:56:14Z,2017-08-21T02:53:54Z,2017-09-28T14:10:16Z,CLOSED,False,138,6,9,https://github.com/loganmc10,[WIP] Switch FGR to 32bit mode when jumping to an exception handler.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/357,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/357,"First of all, credit for this goes to @Gillou68310, he's the one that actually wrote this code.
You can read the original discussion about this problem here:
#145 (comment)
Basically, this is a fix for the ""Bone Displacement"" issue in DK64, as well as some flickering graphics in Factor5 games, see below:


I tested this with the save states that @Isotarge provided and it does indeed seem to fix the DK bone displacement issue. I also tested Rogue Squadron and Indiana Jones (with CountPerOp=2) and it fixes the odd graphics in those games.
I tested save states as well and they seem to be functioning normally.
Here is a 64-bit Windows build of mupen64plus+GLideN64 if anyone would like to test this on Windows:
mupen64plus-GLideN64-FGR-fix.zip
TODO:
I'm hoping @Gillou68310 can comment on this with his thoughts.
More work needs to be done to integrate this with the new dynarec.","First of all, credit for this goes to @Gillou68310, he's the one that actually wrote this code.
You can read the original discussion about this problem here:
#145 (comment)
Basically, this is a fix for the ""Bone Displacement"" issue in DK64, as well as some flickering graphics in Factor5 games, see below:


I tested this with the save states that @Isotarge provided and it does indeed seem to fix the DK bone displacement issue. I also tested Rogue Squadron and Indiana Jones (with CountPerOp=2) and it fixes the odd graphics in those games.
I tested save states as well and they seem to be functioning normally.
Here is a 64-bit Windows build of mupen64plus+GLideN64 if anyone would like to test this on Windows:
mupen64plus-GLideN64-FGR-fix.zip
TODO:
I'm hoping @Gillou68310 can comment on this with his thoughts.
More work needs to be done to integrate this with the new dynarec.",True,{'THUMBS_UP': ['https://github.com/AmbientMalice']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,357,2017-08-10T20:56:14Z,2017-08-21T02:53:54Z,2017-09-28T14:10:16Z,CLOSED,False,138,6,9,https://github.com/loganmc10,[WIP] Switch FGR to 32bit mode when jumping to an exception handler.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/357,https://github.com/AmbientMalice,2,https://github.com/mupen64plus/mupen64plus-core/pull/357#issuecomment-321962825,"First of all, credit for this goes to @Gillou68310, he's the one that actually wrote this code.
You can read the original discussion about this problem here:
#145 (comment)
Basically, this is a fix for the ""Bone Displacement"" issue in DK64, as well as some flickering graphics in Factor5 games, see below:


I tested this with the save states that @Isotarge provided and it does indeed seem to fix the DK bone displacement issue. I also tested Rogue Squadron and Indiana Jones (with CountPerOp=2) and it fixes the odd graphics in those games.
I tested save states as well and they seem to be functioning normally.
Here is a 64-bit Windows build of mupen64plus+GLideN64 if anyone would like to test this on Windows:
mupen64plus-GLideN64-FGR-fix.zip
TODO:
I'm hoping @Gillou68310 can comment on this with his thoughts.
More work needs to be done to integrate this with the new dynarec.","Being able to run some of these games at CF=2 would be a great help for low powered devices. Edit: That said, CF1 is definitely needed to fix stuttering and stalling as far as I can tell.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,357,2017-08-10T20:56:14Z,2017-08-21T02:53:54Z,2017-09-28T14:10:16Z,CLOSED,False,138,6,9,https://github.com/loganmc10,[WIP] Switch FGR to 32bit mode when jumping to an exception handler.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/357,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/357#issuecomment-323635046,"First of all, credit for this goes to @Gillou68310, he's the one that actually wrote this code.
You can read the original discussion about this problem here:
#145 (comment)
Basically, this is a fix for the ""Bone Displacement"" issue in DK64, as well as some flickering graphics in Factor5 games, see below:


I tested this with the save states that @Isotarge provided and it does indeed seem to fix the DK bone displacement issue. I also tested Rogue Squadron and Indiana Jones (with CountPerOp=2) and it fixes the odd graphics in those games.
I tested save states as well and they seem to be functioning normally.
Here is a 64-bit Windows build of mupen64plus+GLideN64 if anyone would like to test this on Windows:
mupen64plus-GLideN64-FGR-fix.zip
TODO:
I'm hoping @Gillou68310 can comment on this with his thoughts.
More work needs to be done to integrate this with the new dynarec.",See #368,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,358,2017-08-12T00:10:26Z,2017-08-13T00:18:40Z,2017-08-13T00:18:40Z,MERGED,True,6,4,1,https://github.com/AmbientMalice,Fix RevA (U) Rogue Squadron,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/358,https://github.com/AmbientMalice,1,https://github.com/mupen64plus/mupen64plus-core/pull/358,"Game needs CF=1. Will fix various issues, including low framerate.","Game needs CF=1. Will fix various issues, including low framerate.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,358,2017-08-12T00:10:26Z,2017-08-13T00:18:40Z,2017-08-13T00:18:40Z,MERGED,True,6,4,1,https://github.com/AmbientMalice,Fix RevA (U) Rogue Squadron,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/358,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/358#issuecomment-321949207,"Game needs CF=1. Will fix various issues, including low framerate.","Thanks, I didn't even know there was a Rev A, do you know the differences? (Just curious)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,358,2017-08-12T00:10:26Z,2017-08-13T00:18:40Z,2017-08-13T00:18:40Z,MERGED,True,6,4,1,https://github.com/AmbientMalice,Fix RevA (U) Rogue Squadron,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/358,https://github.com/AmbientMalice,3,https://github.com/mupen64plus/mupen64plus-core/pull/358#issuecomment-321949294,"Game needs CF=1. Will fix various issues, including low framerate.","I'm not sure about any under the hood modifications, but they did place the secret Naboo Starfighter in the hangar, instead of hiding it behind a cheat code. (They hid that in the original version using some extremely complex code obfuscation.)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,358,2017-08-12T00:10:26Z,2017-08-13T00:18:40Z,2017-08-13T00:18:40Z,MERGED,True,6,4,1,https://github.com/AmbientMalice,Fix RevA (U) Rogue Squadron,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/358,https://github.com/AmbientMalice,4,https://github.com/mupen64plus/mupen64plus-core/pull/358#issuecomment-322013280,"Game needs CF=1. Will fix various issues, including low framerate.",I did the same thing for the E version of Rogue Squadron.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,360,2017-08-12T15:23:57Z,2017-09-19T05:08:30Z,2017-10-05T08:21:33Z,MERGED,True,674,534,28,https://github.com/bsmiles32,Rewrite PIF emulation.,5,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/360,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/360,"Main changes in this partial rewrite are:

channel processing is done in 2 separate steps. First is the channel
setup done when 0x1 is written in the ""pif status byte"". The second step
is the effective channel processing which allow each channel device to
answer. This step is done just before DMA reads. This is in accordance
with Patent 6394905. (Fig5B - Pif Macro). This allowed to greatly
simplify pif channel processing (no more strange bytes to parse in pif
ram and no duplicated code for that).
""pif status byte"" is treated as a bitfield with each flag indicating
which action to take.
command processing interface has been reworked to separate the
transmitted data (Tx,TxBuf) from the the received data (Rx, RxBuf).
reworked the code to allow (later) to have custom pif channel process
callback. This should allow to implement ""raw"" processor to let an
external device (such as a Raphnet controller) do the channel
processing.
Validate pif commands
Fixed eeprom write command which missed the status byte.

I tested several games without noticing any regression, but deeper testing is always welcome. Also, as implied by the patent SI DMA read seems to take longer than SI DMA write because PIF/Channel communication is done just before the DMA. This might be why we had to use the DelaySI hack.
As is, this PR might break the Raphnet input plugin, so more work is needed before merging it.","Main changes in this partial rewrite are:

channel processing is done in 2 separate steps. First is the channel
setup done when 0x1 is written in the ""pif status byte"". The second step
is the effective channel processing which allow each channel device to
answer. This step is done just before DMA reads. This is in accordance
with Patent 6394905. (Fig5B - Pif Macro). This allowed to greatly
simplify pif channel processing (no more strange bytes to parse in pif
ram and no duplicated code for that).
""pif status byte"" is treated as a bitfield with each flag indicating
which action to take.
command processing interface has been reworked to separate the
transmitted data (Tx,TxBuf) from the the received data (Rx, RxBuf).
reworked the code to allow (later) to have custom pif channel process
callback. This should allow to implement ""raw"" processor to let an
external device (such as a Raphnet controller) do the channel
processing.
Validate pif commands
Fixed eeprom write command which missed the status byte.

I tested several games without noticing any regression, but deeper testing is always welcome. Also, as implied by the patent SI DMA read seems to take longer than SI DMA write because PIF/Channel communication is done just before the DMA. This might be why we had to use the DelaySI hack.
As is, this PR might break the Raphnet input plugin, so more work is needed before merging it.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,360,2017-08-12T15:23:57Z,2017-09-19T05:08:30Z,2017-10-05T08:21:33Z,MERGED,True,674,534,28,https://github.com/bsmiles32,Rewrite PIF emulation.,5,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/360,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/360#issuecomment-322000740,"Main changes in this partial rewrite are:

channel processing is done in 2 separate steps. First is the channel
setup done when 0x1 is written in the ""pif status byte"". The second step
is the effective channel processing which allow each channel device to
answer. This step is done just before DMA reads. This is in accordance
with Patent 6394905. (Fig5B - Pif Macro). This allowed to greatly
simplify pif channel processing (no more strange bytes to parse in pif
ram and no duplicated code for that).
""pif status byte"" is treated as a bitfield with each flag indicating
which action to take.
command processing interface has been reworked to separate the
transmitted data (Tx,TxBuf) from the the received data (Rx, RxBuf).
reworked the code to allow (later) to have custom pif channel process
callback. This should allow to implement ""raw"" processor to let an
external device (such as a Raphnet controller) do the channel
processing.
Validate pif commands
Fixed eeprom write command which missed the status byte.

I tested several games without noticing any regression, but deeper testing is always welcome. Also, as implied by the patent SI DMA read seems to take longer than SI DMA write because PIF/Channel communication is done just before the DMA. This might be why we had to use the DelaySI hack.
As is, this PR might break the Raphnet input plugin, so more work is needed before merging it.","When I boot Indiana Jones with this change I see:
Core Warning: Unexpected command format 21 fe 00

It still seems to work as normal. It's kind of a strange game. If CountPerOp=1 and CountPerScanline=1500 it won't boot at all (unless an existing good EEP save is there, then it will boot), but it boots at CountPerOp=1 and CountPerScanline=2200, and it freezes at the end of each level.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,360,2017-08-12T15:23:57Z,2017-09-19T05:08:30Z,2017-10-05T08:21:33Z,MERGED,True,674,534,28,https://github.com/bsmiles32,Rewrite PIF emulation.,5,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/360,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/360#issuecomment-322002174,"Main changes in this partial rewrite are:

channel processing is done in 2 separate steps. First is the channel
setup done when 0x1 is written in the ""pif status byte"". The second step
is the effective channel processing which allow each channel device to
answer. This step is done just before DMA reads. This is in accordance
with Patent 6394905. (Fig5B - Pif Macro). This allowed to greatly
simplify pif channel processing (no more strange bytes to parse in pif
ram and no duplicated code for that).
""pif status byte"" is treated as a bitfield with each flag indicating
which action to take.
command processing interface has been reworked to separate the
transmitted data (Tx,TxBuf) from the the received data (Rx, RxBuf).
reworked the code to allow (later) to have custom pif channel process
callback. This should allow to implement ""raw"" processor to let an
external device (such as a Raphnet controller) do the channel
processing.
Validate pif commands
Fixed eeprom write command which missed the status byte.

I tested several games without noticing any regression, but deeper testing is always welcome. Also, as implied by the patent SI DMA read seems to take longer than SI DMA write because PIF/Channel communication is done just before the DMA. This might be why we had to use the DelaySI hack.
As is, this PR might break the Raphnet input plugin, so more work is needed before merging it.","DMA read seems to take longer than SI DMA write because PIF/Channel communication is done just before the DMA. This might be why we had to use the DelaySI hack

I'm not sure I understand, are you saying the DelaySI hack shouldn't be needed after this PR? I tested Body Harvest and it still seems to require it to boot.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,360,2017-08-12T15:23:57Z,2017-09-19T05:08:30Z,2017-10-05T08:21:33Z,MERGED,True,674,534,28,https://github.com/bsmiles32,Rewrite PIF emulation.,5,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/360,https://github.com/bsmiles32,4,https://github.com/mupen64plus/mupen64plus-core/pull/360#issuecomment-322012676,"Main changes in this partial rewrite are:

channel processing is done in 2 separate steps. First is the channel
setup done when 0x1 is written in the ""pif status byte"". The second step
is the effective channel processing which allow each channel device to
answer. This step is done just before DMA reads. This is in accordance
with Patent 6394905. (Fig5B - Pif Macro). This allowed to greatly
simplify pif channel processing (no more strange bytes to parse in pif
ram and no duplicated code for that).
""pif status byte"" is treated as a bitfield with each flag indicating
which action to take.
command processing interface has been reworked to separate the
transmitted data (Tx,TxBuf) from the the received data (Rx, RxBuf).
reworked the code to allow (later) to have custom pif channel process
callback. This should allow to implement ""raw"" processor to let an
external device (such as a Raphnet controller) do the channel
processing.
Validate pif commands
Fixed eeprom write command which missed the status byte.

I tested several games without noticing any regression, but deeper testing is always welcome. Also, as implied by the patent SI DMA read seems to take longer than SI DMA write because PIF/Channel communication is done just before the DMA. This might be why we had to use the DelaySI hack.
As is, this PR might break the Raphnet input plugin, so more work is needed before merging it.","DelaySI is still needed, but after reading carefully the patent it seems that dma read take longer because it waits for pif/channel communication to finish before doing the read. I didn't test but maybe having different timings for dma read (longer) and for dma write (shorter) could replace the DelaySI hack.
Also thanks for reporting the issue with Indiana Jones, I will check that.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,360,2017-08-12T15:23:57Z,2017-09-19T05:08:30Z,2017-10-05T08:21:33Z,MERGED,True,674,534,28,https://github.com/bsmiles32,Rewrite PIF emulation.,5,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/360,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/360#issuecomment-322012740,"Main changes in this partial rewrite are:

channel processing is done in 2 separate steps. First is the channel
setup done when 0x1 is written in the ""pif status byte"". The second step
is the effective channel processing which allow each channel device to
answer. This step is done just before DMA reads. This is in accordance
with Patent 6394905. (Fig5B - Pif Macro). This allowed to greatly
simplify pif channel processing (no more strange bytes to parse in pif
ram and no duplicated code for that).
""pif status byte"" is treated as a bitfield with each flag indicating
which action to take.
command processing interface has been reworked to separate the
transmitted data (Tx,TxBuf) from the the received data (Rx, RxBuf).
reworked the code to allow (later) to have custom pif channel process
callback. This should allow to implement ""raw"" processor to let an
external device (such as a Raphnet controller) do the channel
processing.
Validate pif commands
Fixed eeprom write command which missed the status byte.

I tested several games without noticing any regression, but deeper testing is always welcome. Also, as implied by the patent SI DMA read seems to take longer than SI DMA write because PIF/Channel communication is done just before the DMA. This might be why we had to use the DelaySI hack.
As is, this PR might break the Raphnet input plugin, so more work is needed before merging it.","Just to be clear, I don't think the Indiana Jones issue was caused by this PR, there just wasn't any print out before, the game has always had issues.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,360,2017-08-12T15:23:57Z,2017-09-19T05:08:30Z,2017-10-05T08:21:33Z,MERGED,True,674,534,28,https://github.com/bsmiles32,Rewrite PIF emulation.,5,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/360,https://github.com/bsmiles32,6,https://github.com/mupen64plus/mupen64plus-core/pull/360#issuecomment-322109729,"Main changes in this partial rewrite are:

channel processing is done in 2 separate steps. First is the channel
setup done when 0x1 is written in the ""pif status byte"". The second step
is the effective channel processing which allow each channel device to
answer. This step is done just before DMA reads. This is in accordance
with Patent 6394905. (Fig5B - Pif Macro). This allowed to greatly
simplify pif channel processing (no more strange bytes to parse in pif
ram and no duplicated code for that).
""pif status byte"" is treated as a bitfield with each flag indicating
which action to take.
command processing interface has been reworked to separate the
transmitted data (Tx,TxBuf) from the the received data (Rx, RxBuf).
reworked the code to allow (later) to have custom pif channel process
callback. This should allow to implement ""raw"" processor to let an
external device (such as a Raphnet controller) do the channel
processing.
Validate pif commands
Fixed eeprom write command which missed the status byte.

I tested several games without noticing any regression, but deeper testing is always welcome. Also, as implied by the patent SI DMA read seems to take longer than SI DMA write because PIF/Channel communication is done just before the DMA. This might be why we had to use the DelaySI hack.
As is, this PR might break the Raphnet input plugin, so more work is needed before merging it.","Updated this PR with several new changes:

Updated the controller input backend to split pak detection from controller connection test.
Consolidated all input plugin compatibility code inside one module (eg. controller_input, rumble and pif processings functions).
Added PIF channel printing debug
When input plugin request RawData, we use the readController, controllerCommand functions instead of the built-in functions.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,360,2017-08-12T15:23:57Z,2017-09-19T05:08:30Z,2017-10-05T08:21:33Z,MERGED,True,674,534,28,https://github.com/bsmiles32,Rewrite PIF emulation.,5,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/360,https://github.com/bsmiles32,7,https://github.com/mupen64plus/mupen64plus-core/pull/360#issuecomment-322110722,"Main changes in this partial rewrite are:

channel processing is done in 2 separate steps. First is the channel
setup done when 0x1 is written in the ""pif status byte"". The second step
is the effective channel processing which allow each channel device to
answer. This step is done just before DMA reads. This is in accordance
with Patent 6394905. (Fig5B - Pif Macro). This allowed to greatly
simplify pif channel processing (no more strange bytes to parse in pif
ram and no duplicated code for that).
""pif status byte"" is treated as a bitfield with each flag indicating
which action to take.
command processing interface has been reworked to separate the
transmitted data (Tx,TxBuf) from the the received data (Rx, RxBuf).
reworked the code to allow (later) to have custom pif channel process
callback. This should allow to implement ""raw"" processor to let an
external device (such as a Raphnet controller) do the channel
processing.
Validate pif commands
Fixed eeprom write command which missed the status byte.

I tested several games without noticing any regression, but deeper testing is always welcome. Also, as implied by the patent SI DMA read seems to take longer than SI DMA write because PIF/Channel communication is done just before the DMA. This might be why we had to use the DelaySI hack.
As is, this PR might break the Raphnet input plugin, so more work is needed before merging it.","@loganmc10 Indiana Jones and Yoshi's Story have this strange 0x21 0xfe 0x00 command format Warning. From my little debugging, it seems that it's caused by a ""bogus"" CONT_PAK_READ request which has this extra 0x21 which screws PIF channels setup and cause the warning.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,360,2017-08-12T15:23:57Z,2017-09-19T05:08:30Z,2017-10-05T08:21:33Z,MERGED,True,674,534,28,https://github.com/bsmiles32,Rewrite PIF emulation.,5,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/360,https://github.com/bsmiles32,8,https://github.com/mupen64plus/mupen64plus-core/pull/360#issuecomment-322111006,"Main changes in this partial rewrite are:

channel processing is done in 2 separate steps. First is the channel
setup done when 0x1 is written in the ""pif status byte"". The second step
is the effective channel processing which allow each channel device to
answer. This step is done just before DMA reads. This is in accordance
with Patent 6394905. (Fig5B - Pif Macro). This allowed to greatly
simplify pif channel processing (no more strange bytes to parse in pif
ram and no duplicated code for that).
""pif status byte"" is treated as a bitfield with each flag indicating
which action to take.
command processing interface has been reworked to separate the
transmitted data (Tx,TxBuf) from the the received data (Rx, RxBuf).
reworked the code to allow (later) to have custom pif channel process
callback. This should allow to implement ""raw"" processor to let an
external device (such as a Raphnet controller) do the channel
processing.
Validate pif commands
Fixed eeprom write command which missed the status byte.

I tested several games without noticing any regression, but deeper testing is always welcome. Also, as implied by the patent SI DMA read seems to take longer than SI DMA write because PIF/Channel communication is done just before the DMA. This might be why we had to use the DelaySI hack.
As is, this PR might break the Raphnet input plugin, so more work is needed before merging it.","@raphnet In this PR I reworked how PIF emulation is done This has the potential to break existing plugins.
Could you take a look at this PR to see if breaks or not your plugin please ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,360,2017-08-12T15:23:57Z,2017-09-19T05:08:30Z,2017-10-05T08:21:33Z,MERGED,True,674,534,28,https://github.com/bsmiles32,Rewrite PIF emulation.,5,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/360,https://github.com/loganmc10,9,https://github.com/mupen64plus/mupen64plus-core/pull/360#issuecomment-322205965,"Main changes in this partial rewrite are:

channel processing is done in 2 separate steps. First is the channel
setup done when 0x1 is written in the ""pif status byte"". The second step
is the effective channel processing which allow each channel device to
answer. This step is done just before DMA reads. This is in accordance
with Patent 6394905. (Fig5B - Pif Macro). This allowed to greatly
simplify pif channel processing (no more strange bytes to parse in pif
ram and no duplicated code for that).
""pif status byte"" is treated as a bitfield with each flag indicating
which action to take.
command processing interface has been reworked to separate the
transmitted data (Tx,TxBuf) from the the received data (Rx, RxBuf).
reworked the code to allow (later) to have custom pif channel process
callback. This should allow to implement ""raw"" processor to let an
external device (such as a Raphnet controller) do the channel
processing.
Validate pif commands
Fixed eeprom write command which missed the status byte.

I tested several games without noticing any regression, but deeper testing is always welcome. Also, as implied by the patent SI DMA read seems to take longer than SI DMA write because PIF/Channel communication is done just before the DMA. This might be why we had to use the DelaySI hack.
As is, this PR might break the Raphnet input plugin, so more work is needed before merging it.","I tested input and saving in Indiana Jones and Yoshi's Story, they both still work fine, so nothing has changed, it's nice to at least get a printout now when it's doing something strange.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,360,2017-08-12T15:23:57Z,2017-09-19T05:08:30Z,2017-10-05T08:21:33Z,MERGED,True,674,534,28,https://github.com/bsmiles32,Rewrite PIF emulation.,5,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/360,https://github.com/raphnet,10,https://github.com/mupen64plus/mupen64plus-core/pull/360#issuecomment-322254192,"Main changes in this partial rewrite are:

channel processing is done in 2 separate steps. First is the channel
setup done when 0x1 is written in the ""pif status byte"". The second step
is the effective channel processing which allow each channel device to
answer. This step is done just before DMA reads. This is in accordance
with Patent 6394905. (Fig5B - Pif Macro). This allowed to greatly
simplify pif channel processing (no more strange bytes to parse in pif
ram and no duplicated code for that).
""pif status byte"" is treated as a bitfield with each flag indicating
which action to take.
command processing interface has been reworked to separate the
transmitted data (Tx,TxBuf) from the the received data (Rx, RxBuf).
reworked the code to allow (later) to have custom pif channel process
callback. This should allow to implement ""raw"" processor to let an
external device (such as a Raphnet controller) do the channel
processing.
Validate pif commands
Fixed eeprom write command which missed the status byte.

I tested several games without noticing any regression, but deeper testing is always welcome. Also, as implied by the patent SI DMA read seems to take longer than SI DMA write because PIF/Channel communication is done just before the DMA. This might be why we had to use the DelaySI hack.
As is, this PR might break the Raphnet input plugin, so more work is needed before merging it.","@bsmiles32 As far as I can tell, everything still works fine. Tested the rumble pak and controller pak using a single player and a multi-player adapter. (Games used: Perfect Dark, 007 - The world is not enough, Mario Kart 64)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,360,2017-08-12T15:23:57Z,2017-09-19T05:08:30Z,2017-10-05T08:21:33Z,MERGED,True,674,534,28,https://github.com/bsmiles32,Rewrite PIF emulation.,5,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/360,https://github.com/bsmiles32,11,https://github.com/mupen64plus/mupen64plus-core/pull/360#issuecomment-323552819,"Main changes in this partial rewrite are:

channel processing is done in 2 separate steps. First is the channel
setup done when 0x1 is written in the ""pif status byte"". The second step
is the effective channel processing which allow each channel device to
answer. This step is done just before DMA reads. This is in accordance
with Patent 6394905. (Fig5B - Pif Macro). This allowed to greatly
simplify pif channel processing (no more strange bytes to parse in pif
ram and no duplicated code for that).
""pif status byte"" is treated as a bitfield with each flag indicating
which action to take.
command processing interface has been reworked to separate the
transmitted data (Tx,TxBuf) from the the received data (Rx, RxBuf).
reworked the code to allow (later) to have custom pif channel process
callback. This should allow to implement ""raw"" processor to let an
external device (such as a Raphnet controller) do the channel
processing.
Validate pif commands
Fixed eeprom write command which missed the status byte.

I tested several games without noticing any regression, but deeper testing is always welcome. Also, as implied by the patent SI DMA read seems to take longer than SI DMA write because PIF/Channel communication is done just before the DMA. This might be why we had to use the DelaySI hack.
As is, this PR might break the Raphnet input plugin, so more work is needed before merging it.","Thanks both of you for testing this ! I think it is in a mergeable state, but I will let @richard42 decides if he wants it to be part of the coming release.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,360,2017-08-12T15:23:57Z,2017-09-19T05:08:30Z,2017-10-05T08:21:33Z,MERGED,True,674,534,28,https://github.com/bsmiles32,Rewrite PIF emulation.,5,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/360,https://github.com/loganmc10,12,https://github.com/mupen64plus/mupen64plus-core/pull/360#issuecomment-324657725,"Main changes in this partial rewrite are:

channel processing is done in 2 separate steps. First is the channel
setup done when 0x1 is written in the ""pif status byte"". The second step
is the effective channel processing which allow each channel device to
answer. This step is done just before DMA reads. This is in accordance
with Patent 6394905. (Fig5B - Pif Macro). This allowed to greatly
simplify pif channel processing (no more strange bytes to parse in pif
ram and no duplicated code for that).
""pif status byte"" is treated as a bitfield with each flag indicating
which action to take.
command processing interface has been reworked to separate the
transmitted data (Tx,TxBuf) from the the received data (Rx, RxBuf).
reworked the code to allow (later) to have custom pif channel process
callback. This should allow to implement ""raw"" processor to let an
external device (such as a Raphnet controller) do the channel
processing.
Validate pif commands
Fixed eeprom write command which missed the status byte.

I tested several games without noticing any regression, but deeper testing is always welcome. Also, as implied by the patent SI DMA read seems to take longer than SI DMA write because PIF/Channel communication is done just before the DMA. This might be why we had to use the DelaySI hack.
As is, this PR might break the Raphnet input plugin, so more work is needed before merging it.","@bsmiles32 thanks for your explanation of how the PIF is supposed to work. I believe I figured out a way to remove the DelaySI hack:
loganmc10@fd304b0
Basically we set DMA busy for a write, RD busy for a read, and then delay the 2nd half of the process until right before the interrupt is signaled. I tested a number of games, including Body Harvest (which currently requires DelaySI to boot) and Mischief Makers (which requires DelaySI to be off for the input to work), they both work with this new method.
By the way, it's unclear to me why an interrupt is triggered in this case:
https://github.com/loganmc10/mupen64plus-core/blob/fd304b064067edaf557d01bed3bb482b50b40c6c/src/device/si/pif.c#L373-L374
I removed it and tested a few games, I didn't see any issue. After my change, process_pif_ram is called at the end of the DMA event, so it doesn't really make sense to me to immediately call another interrupt.
The way it currently works, process_pif_ram is always called right before schedule_si_interrupt, so it seems like it would be redundant anyway.
So I didn't remove that interrupt scheduling, but I think it should be removed.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,360,2017-08-12T15:23:57Z,2017-09-19T05:08:30Z,2017-10-05T08:21:33Z,MERGED,True,674,534,28,https://github.com/bsmiles32,Rewrite PIF emulation.,5,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/360,https://github.com/loganmc10,13,https://github.com/mupen64plus/mupen64plus-core/pull/360#issuecomment-324661751,"Main changes in this partial rewrite are:

channel processing is done in 2 separate steps. First is the channel
setup done when 0x1 is written in the ""pif status byte"". The second step
is the effective channel processing which allow each channel device to
answer. This step is done just before DMA reads. This is in accordance
with Patent 6394905. (Fig5B - Pif Macro). This allowed to greatly
simplify pif channel processing (no more strange bytes to parse in pif
ram and no duplicated code for that).
""pif status byte"" is treated as a bitfield with each flag indicating
which action to take.
command processing interface has been reworked to separate the
transmitted data (Tx,TxBuf) from the the received data (Rx, RxBuf).
reworked the code to allow (later) to have custom pif channel process
callback. This should allow to implement ""raw"" processor to let an
external device (such as a Raphnet controller) do the channel
processing.
Validate pif commands
Fixed eeprom write command which missed the status byte.

I tested several games without noticing any regression, but deeper testing is always welcome. Also, as implied by the patent SI DMA read seems to take longer than SI DMA write because PIF/Channel communication is done just before the DMA. This might be why we had to use the DelaySI hack.
As is, this PR might break the Raphnet input plugin, so more work is needed before merging it.","@bsmiles32 I believe I found a bug in this PR. In Top Gear Rally, I get a ""Controller Pak not found"" message when the game boots. Doesn't happen in the current master. My DelaySI change doesn't make a difference either.
EDIT: I get the same thing in Bomberman 64, in ""Battle Mode"", it says ""Cannot access Controller Pak 1""",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,360,2017-08-12T15:23:57Z,2017-09-19T05:08:30Z,2017-10-05T08:21:33Z,MERGED,True,674,534,28,https://github.com/bsmiles32,Rewrite PIF emulation.,5,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/360,https://github.com/loganmc10,14,https://github.com/mupen64plus/mupen64plus-core/pull/360#issuecomment-325025381,"Main changes in this partial rewrite are:

channel processing is done in 2 separate steps. First is the channel
setup done when 0x1 is written in the ""pif status byte"". The second step
is the effective channel processing which allow each channel device to
answer. This step is done just before DMA reads. This is in accordance
with Patent 6394905. (Fig5B - Pif Macro). This allowed to greatly
simplify pif channel processing (no more strange bytes to parse in pif
ram and no duplicated code for that).
""pif status byte"" is treated as a bitfield with each flag indicating
which action to take.
command processing interface has been reworked to separate the
transmitted data (Tx,TxBuf) from the the received data (Rx, RxBuf).
reworked the code to allow (later) to have custom pif channel process
callback. This should allow to implement ""raw"" processor to let an
external device (such as a Raphnet controller) do the channel
processing.
Validate pif commands
Fixed eeprom write command which missed the status byte.

I tested several games without noticing any regression, but deeper testing is always welcome. Also, as implied by the patent SI DMA read seems to take longer than SI DMA write because PIF/Channel communication is done just before the DMA. This might be why we had to use the DelaySI hack.
As is, this PR might break the Raphnet input plugin, so more work is needed before merging it.","Also by the way, when starting Pokemon Puzzle League I now see:
Core Warning: PIF - channel reset - not implemented !
Core Warning: PIF - channel reset - not implemented !
Core Warning: PIF - channel reset - not implemented !
Core Warning: PIF - channel reset - not implemented !

Doesn't seem to cause any issues though.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,360,2017-08-12T15:23:57Z,2017-09-19T05:08:30Z,2017-10-05T08:21:33Z,MERGED,True,674,534,28,https://github.com/bsmiles32,Rewrite PIF emulation.,5,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/360,https://github.com/bsmiles32,15,https://github.com/mupen64plus/mupen64plus-core/pull/360#issuecomment-329641918,"Main changes in this partial rewrite are:

channel processing is done in 2 separate steps. First is the channel
setup done when 0x1 is written in the ""pif status byte"". The second step
is the effective channel processing which allow each channel device to
answer. This step is done just before DMA reads. This is in accordance
with Patent 6394905. (Fig5B - Pif Macro). This allowed to greatly
simplify pif channel processing (no more strange bytes to parse in pif
ram and no duplicated code for that).
""pif status byte"" is treated as a bitfield with each flag indicating
which action to take.
command processing interface has been reworked to separate the
transmitted data (Tx,TxBuf) from the the received data (Rx, RxBuf).
reworked the code to allow (later) to have custom pif channel process
callback. This should allow to implement ""raw"" processor to let an
external device (such as a Raphnet controller) do the channel
processing.
Validate pif commands
Fixed eeprom write command which missed the status byte.

I tested several games without noticing any regression, but deeper testing is always welcome. Also, as implied by the patent SI DMA read seems to take longer than SI DMA write because PIF/Channel communication is done just before the DMA. This might be why we had to use the DelaySI hack.
As is, this PR might break the Raphnet input plugin, so more work is needed before merging it.","@loganmc10 Thanks for testing this PR more thoroughly. I was able to reproduce the issues you mentionned in this PR, but couldn't with my other WIP branch https://github.com/bsmiles32/mupen64plus-core/tree/pif_and_other_things . So I guess fixing these won't be too difficult.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,360,2017-08-12T15:23:57Z,2017-09-19T05:08:30Z,2017-10-05T08:21:33Z,MERGED,True,674,534,28,https://github.com/bsmiles32,Rewrite PIF emulation.,5,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/360,https://github.com/bsmiles32,16,https://github.com/mupen64plus/mupen64plus-core/pull/360#issuecomment-329673138,"Main changes in this partial rewrite are:

channel processing is done in 2 separate steps. First is the channel
setup done when 0x1 is written in the ""pif status byte"". The second step
is the effective channel processing which allow each channel device to
answer. This step is done just before DMA reads. This is in accordance
with Patent 6394905. (Fig5B - Pif Macro). This allowed to greatly
simplify pif channel processing (no more strange bytes to parse in pif
ram and no duplicated code for that).
""pif status byte"" is treated as a bitfield with each flag indicating
which action to take.
command processing interface has been reworked to separate the
transmitted data (Tx,TxBuf) from the the received data (Rx, RxBuf).
reworked the code to allow (later) to have custom pif channel process
callback. This should allow to implement ""raw"" processor to let an
external device (such as a Raphnet controller) do the channel
processing.
Validate pif commands
Fixed eeprom write command which missed the status byte.

I tested several games without noticing any regression, but deeper testing is always welcome. Also, as implied by the patent SI DMA read seems to take longer than SI DMA write because PIF/Channel communication is done just before the DMA. This might be why we had to use the DelaySI hack.
As is, this PR might break the Raphnet input plugin, so more work is needed before merging it.","Updated against master
Implements the pif channel reset byte (should fix 0xfd in Pokemon Puzzle league)
Reduce the number of channels to 5 according to PIF pinouts
Add a ""hack"" to discard bogus pak access commands. This is what fixes the non pak detection in Bomberman 64 and Top Gear Rally. Note that @raphnet in his plugin also encountered this issue and did a similar command discarding (https://github.com/raphnet/mupen64plus-input-raphnetraw/blob/master/src/plugin_back.c#L402)

Please test and report so we can merge that and some more refactorings can be pushed :)",True,{'HOORAY': ['https://github.com/Narann']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,360,2017-08-12T15:23:57Z,2017-09-19T05:08:30Z,2017-10-05T08:21:33Z,MERGED,True,674,534,28,https://github.com/bsmiles32,Rewrite PIF emulation.,5,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/360,https://github.com/loganmc10,17,https://github.com/mupen64plus/mupen64plus-core/pull/360#issuecomment-329879149,"Main changes in this partial rewrite are:

channel processing is done in 2 separate steps. First is the channel
setup done when 0x1 is written in the ""pif status byte"". The second step
is the effective channel processing which allow each channel device to
answer. This step is done just before DMA reads. This is in accordance
with Patent 6394905. (Fig5B - Pif Macro). This allowed to greatly
simplify pif channel processing (no more strange bytes to parse in pif
ram and no duplicated code for that).
""pif status byte"" is treated as a bitfield with each flag indicating
which action to take.
command processing interface has been reworked to separate the
transmitted data (Tx,TxBuf) from the the received data (Rx, RxBuf).
reworked the code to allow (later) to have custom pif channel process
callback. This should allow to implement ""raw"" processor to let an
external device (such as a Raphnet controller) do the channel
processing.
Validate pif commands
Fixed eeprom write command which missed the status byte.

I tested several games without noticing any regression, but deeper testing is always welcome. Also, as implied by the patent SI DMA read seems to take longer than SI DMA write because PIF/Channel communication is done just before the DMA. This might be why we had to use the DelaySI hack.
As is, this PR might break the Raphnet input plugin, so more work is needed before merging it.","Looks good to me, I tested using a controller to make sure rumble still works as well.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,360,2017-08-12T15:23:57Z,2017-09-19T05:08:30Z,2017-10-05T08:21:33Z,MERGED,True,674,534,28,https://github.com/bsmiles32,Rewrite PIF emulation.,5,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/360,https://github.com/Narann,18,https://github.com/mupen64plus/mupen64plus-core/pull/360#issuecomment-330773845,"Main changes in this partial rewrite are:

channel processing is done in 2 separate steps. First is the channel
setup done when 0x1 is written in the ""pif status byte"". The second step
is the effective channel processing which allow each channel device to
answer. This step is done just before DMA reads. This is in accordance
with Patent 6394905. (Fig5B - Pif Macro). This allowed to greatly
simplify pif channel processing (no more strange bytes to parse in pif
ram and no duplicated code for that).
""pif status byte"" is treated as a bitfield with each flag indicating
which action to take.
command processing interface has been reworked to separate the
transmitted data (Tx,TxBuf) from the the received data (Rx, RxBuf).
reworked the code to allow (later) to have custom pif channel process
callback. This should allow to implement ""raw"" processor to let an
external device (such as a Raphnet controller) do the channel
processing.
Validate pif commands
Fixed eeprom write command which missed the status byte.

I tested several games without noticing any regression, but deeper testing is always welcome. Also, as implied by the patent SI DMA read seems to take longer than SI DMA write because PIF/Channel communication is done just before the DMA. This might be why we had to use the DelaySI hack.
As is, this PR might break the Raphnet input plugin, so more work is needed before merging it.","Coverity have found some memory overflow. @bsmiles32 do you have access to coverity?
I put it here anyway:
New defect(s) Reported-by: Coverity Scan
Showing 2 of 2 defect(s)


** CID 173760:  Memory - corruptions  (OVERRUN)
/src/device/si/pif.c: 251 in setup_channels_format()


________________________________________________________________________________________________________
*** CID 173760:  Memory - corruptions  (OVERRUN)
/src/device/si/pif.c: 251 in setup_channels_format()
245            default: /* setup channel */
246   
247                /* HACK?: some games sends bogus PIF commands while accessing controller paks
248                  * Yoshi Story, Top Gear Rally 2, Indiana Jones, ...
249                  * When encountering such commands, we skip this bogus byte.
250                  */
>>>    CID 173760:  Memory - corruptions  (OVERRUN)
>>>    Checking ""i + 1UL < PIF_RAM_SIZE"" implies that ""i"" is 63 on the false branch.
251                if ((i+1 < PIF_RAM_SIZE) && (pif->ram[i+1] == 0xfe)) {
252                    ++i;
253                }
254                else {
255                    i += setup_pif_channel(&pif->channels[k++], &pif->ram[i]);
256                }

** CID 173759:  Control flow issues  (MISSING_BREAK)
/src/device/si/game_controller.c: 180 in process_controller_command()


________________________________________________________________________________________________________
*** CID 173759:  Control flow issues  (MISSING_BREAK)
/src/device/si/game_controller.c: 180 in process_controller_command()
174        uint8_t cmd = tx_buf[0];
175   
176        switch (cmd)
177        {
178        case PIF_CMD_RESET:
179            standard_controller_reset(cont);
>>>    CID 173759:  Control flow issues  (MISSING_BREAK)
>>>    The above case falls through to this one.
180        case PIF_CMD_STATUS: {
181            PIF_CHECK_COMMAND_FORMAT(1, 3)
182   
183            /* set device type and status */
184            rx_buf[0] = (uint8_t)(PIF_PDT_GAME_CONTROLLER >> 0);
185            rx_buf[1] = (uint8_t)(PIF_PDT_GAME_CONTROLLER >> 8);",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,360,2017-08-12T15:23:57Z,2017-09-19T05:08:30Z,2017-10-05T08:21:33Z,MERGED,True,674,534,28,https://github.com/bsmiles32,Rewrite PIF emulation.,5,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/360,https://github.com/loganmc10,19,https://github.com/mupen64plus/mupen64plus-core/pull/360#issuecomment-330869426,"Main changes in this partial rewrite are:

channel processing is done in 2 separate steps. First is the channel
setup done when 0x1 is written in the ""pif status byte"". The second step
is the effective channel processing which allow each channel device to
answer. This step is done just before DMA reads. This is in accordance
with Patent 6394905. (Fig5B - Pif Macro). This allowed to greatly
simplify pif channel processing (no more strange bytes to parse in pif
ram and no duplicated code for that).
""pif status byte"" is treated as a bitfield with each flag indicating
which action to take.
command processing interface has been reworked to separate the
transmitted data (Tx,TxBuf) from the the received data (Rx, RxBuf).
reworked the code to allow (later) to have custom pif channel process
callback. This should allow to implement ""raw"" processor to let an
external device (such as a Raphnet controller) do the channel
processing.
Validate pif commands
Fixed eeprom write command which missed the status byte.

I tested several games without noticing any regression, but deeper testing is always welcome. Also, as implied by the patent SI DMA read seems to take longer than SI DMA write because PIF/Channel communication is done just before the DMA. This might be why we had to use the DelaySI hack.
As is, this PR might break the Raphnet input plugin, so more work is needed before merging it.","I'm having a hard time understanding what it's issue with the first thing is, but if the fallthrough in PIF_CMD_RESET is intentional, we probably just need to add a comment like this: snes9xgit/snes9x@d441856
That satisfies GCC, I assume it would satisfy Coverity as well, though I'm not sure",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,360,2017-08-12T15:23:57Z,2017-09-19T05:08:30Z,2017-10-05T08:21:33Z,MERGED,True,674,534,28,https://github.com/bsmiles32,Rewrite PIF emulation.,5,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/360,https://github.com/bsmiles32,20,https://github.com/mupen64plus/mupen64plus-core/pull/360#issuecomment-330956946,"Main changes in this partial rewrite are:

channel processing is done in 2 separate steps. First is the channel
setup done when 0x1 is written in the ""pif status byte"". The second step
is the effective channel processing which allow each channel device to
answer. This step is done just before DMA reads. This is in accordance
with Patent 6394905. (Fig5B - Pif Macro). This allowed to greatly
simplify pif channel processing (no more strange bytes to parse in pif
ram and no duplicated code for that).
""pif status byte"" is treated as a bitfield with each flag indicating
which action to take.
command processing interface has been reworked to separate the
transmitted data (Tx,TxBuf) from the the received data (Rx, RxBuf).
reworked the code to allow (later) to have custom pif channel process
callback. This should allow to implement ""raw"" processor to let an
external device (such as a Raphnet controller) do the channel
processing.
Validate pif commands
Fixed eeprom write command which missed the status byte.

I tested several games without noticing any regression, but deeper testing is always welcome. Also, as implied by the patent SI DMA read seems to take longer than SI DMA write because PIF/Channel communication is done just before the DMA. This might be why we had to use the DelaySI hack.
As is, this PR might break the Raphnet input plugin, so more work is needed before merging it.","The fall through for reset is intentional because the reset command also report device status.
The other warning I don't understand.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,360,2017-08-12T15:23:57Z,2017-09-19T05:08:30Z,2017-10-05T08:21:33Z,MERGED,True,674,534,28,https://github.com/bsmiles32,Rewrite PIF emulation.,5,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/360,https://github.com/richard42,21,https://github.com/mupen64plus/mupen64plus-core/pull/360#issuecomment-331061889,"Main changes in this partial rewrite are:

channel processing is done in 2 separate steps. First is the channel
setup done when 0x1 is written in the ""pif status byte"". The second step
is the effective channel processing which allow each channel device to
answer. This step is done just before DMA reads. This is in accordance
with Patent 6394905. (Fig5B - Pif Macro). This allowed to greatly
simplify pif channel processing (no more strange bytes to parse in pif
ram and no duplicated code for that).
""pif status byte"" is treated as a bitfield with each flag indicating
which action to take.
command processing interface has been reworked to separate the
transmitted data (Tx,TxBuf) from the the received data (Rx, RxBuf).
reworked the code to allow (later) to have custom pif channel process
callback. This should allow to implement ""raw"" processor to let an
external device (such as a Raphnet controller) do the channel
processing.
Validate pif commands
Fixed eeprom write command which missed the status byte.

I tested several games without noticing any regression, but deeper testing is always welcome. Also, as implied by the patent SI DMA read seems to take longer than SI DMA write because PIF/Channel communication is done just before the DMA. This might be why we had to use the DelaySI hack.
As is, this PR might break the Raphnet input plugin, so more work is needed before merging it.","okay I see from here that it's intentional. I think the first warning about memory corruption is incorrect. as long as the setup_pif_channel only reads 1 byte at most from the &pif->ram[i] pointer, it should be fine.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,360,2017-08-12T15:23:57Z,2017-09-19T05:08:30Z,2017-10-05T08:21:33Z,MERGED,True,674,534,28,https://github.com/bsmiles32,Rewrite PIF emulation.,5,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/360,https://github.com/fzurita,22,https://github.com/mupen64plus/mupen64plus-core/pull/360#issuecomment-331352690,"Main changes in this partial rewrite are:

channel processing is done in 2 separate steps. First is the channel
setup done when 0x1 is written in the ""pif status byte"". The second step
is the effective channel processing which allow each channel device to
answer. This step is done just before DMA reads. This is in accordance
with Patent 6394905. (Fig5B - Pif Macro). This allowed to greatly
simplify pif channel processing (no more strange bytes to parse in pif
ram and no duplicated code for that).
""pif status byte"" is treated as a bitfield with each flag indicating
which action to take.
command processing interface has been reworked to separate the
transmitted data (Tx,TxBuf) from the the received data (Rx, RxBuf).
reworked the code to allow (later) to have custom pif channel process
callback. This should allow to implement ""raw"" processor to let an
external device (such as a Raphnet controller) do the channel
processing.
Validate pif commands
Fixed eeprom write command which missed the status byte.

I tested several games without noticing any regression, but deeper testing is always welcome. Also, as implied by the patent SI DMA read seems to take longer than SI DMA write because PIF/Channel communication is done just before the DMA. This might be why we had to use the DelaySI hack.
As is, this PR might break the Raphnet input plugin, so more work is needed before merging it.",So I finally got around to testing this. It seems to have broken the Android input plugin. I need to figure out what's up...,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,360,2017-08-12T15:23:57Z,2017-09-19T05:08:30Z,2017-10-05T08:21:33Z,MERGED,True,674,534,28,https://github.com/bsmiles32,Rewrite PIF emulation.,5,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/360,https://github.com/fzurita,23,https://github.com/mupen64plus/mupen64plus-core/pull/360#issuecomment-331554036,"Main changes in this partial rewrite are:

channel processing is done in 2 separate steps. First is the channel
setup done when 0x1 is written in the ""pif status byte"". The second step
is the effective channel processing which allow each channel device to
answer. This step is done just before DMA reads. This is in accordance
with Patent 6394905. (Fig5B - Pif Macro). This allowed to greatly
simplify pif channel processing (no more strange bytes to parse in pif
ram and no duplicated code for that).
""pif status byte"" is treated as a bitfield with each flag indicating
which action to take.
command processing interface has been reworked to separate the
transmitted data (Tx,TxBuf) from the the received data (Rx, RxBuf).
reworked the code to allow (later) to have custom pif channel process
callback. This should allow to implement ""raw"" processor to let an
external device (such as a Raphnet controller) do the channel
processing.
Validate pif commands
Fixed eeprom write command which missed the status byte.

I tested several games without noticing any regression, but deeper testing is always welcome. Also, as implied by the patent SI DMA read seems to take longer than SI DMA write because PIF/Channel communication is done just before the DMA. This might be why we had to use the DelaySI hack.
As is, this PR might break the Raphnet input plugin, so more work is needed before merging it.","I'm trying to trace back why it's not working. It seems like setup_pif_channel in pif.c is never being called. I'll try to keep tracing back further.
Edit: Ok, I see the problem... si_end_of_dma_event with a flags of 1 only happens at game startup. So if you are loading a save state at startup, it flags of 1 never happens.
If you re-start the game and then load a save state, it works ok. I'll create an issue.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,362,2017-08-15T00:30:33Z,2017-08-19T22:25:04Z,2017-08-20T01:34:10Z,MERGED,True,1,0,1,https://github.com/loganmc10,Add setting for Mischief Makers J,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/362,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/362,I forgot about the Japanese version of this game.,I forgot about the Japanese version of this game.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,363,2017-08-15T00:38:38Z,2017-08-19T22:28:53Z,2017-09-21T06:01:13Z,MERGED,True,1,1,1,https://github.com/loganmc10,Round PI_WR_LEN_REG up to nearest even number,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/363,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/363,"This fixes AI Shogi 3 and other games.
Before:

After:

See:
https://github.com/project64/project64/blob/master/Source/Project64-core/N64System/Mips/Dma.cpp#L202-L203","This fixes AI Shogi 3 and other games.
Before:

After:

See:
https://github.com/project64/project64/blob/master/Source/Project64-core/N64System/Mips/Dma.cpp#L202-L203",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,364,2017-08-15T11:55:34Z,2017-08-19T23:01:45Z,2017-08-19T23:01:45Z,MERGED,True,2,2,1,https://github.com/fzurita,Get x86 new dynarec compiling again (when using PIC),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/364,https://github.com/fzurita,1,https://github.com/mupen64plus/mupen64plus-core/pull/364,"This allows the x86 new dynarec to compile again. I just switched the order of operations that the compiler was complain against and it allows it to build.
My x86 assembly skill is not strong at all, but you would think that the order of additions should not matter. Can anyone double check this and make sure that south park doesn't restart on its own anymore?
This is for this issue: #316","This allows the x86 new dynarec to compile again. I just switched the order of operations that the compiler was complain against and it allows it to build.
My x86 assembly skill is not strong at all, but you would think that the order of additions should not matter. Can anyone double check this and make sure that south park doesn't restart on its own anymore?
This is for this issue: #316",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,364,2017-08-15T11:55:34Z,2017-08-19T23:01:45Z,2017-08-19T23:01:45Z,MERGED,True,2,2,1,https://github.com/fzurita,Get x86 new dynarec compiling again (when using PIC),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/364,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/364#issuecomment-322475789,"This allows the x86 new dynarec to compile again. I just switched the order of operations that the compiler was complain against and it allows it to build.
My x86 assembly skill is not strong at all, but you would think that the order of additions should not matter. Can anyone double check this and make sure that south park doesn't restart on its own anymore?
This is for this issue: #316","I tested a few games in the new dynarec with this on Windows. No issues.
However, on PC it doesn't use PIC, so I can't say for sure how this would work on Android x86. I notice that the find_local_data() is different depending on the PIC setting",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,364,2017-08-15T11:55:34Z,2017-08-19T23:01:45Z,2017-08-19T23:01:45Z,MERGED,True,2,2,1,https://github.com/fzurita,Get x86 new dynarec compiling again (when using PIC),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/364,https://github.com/fzurita,3,https://github.com/mupen64plus/mupen64plus-core/pull/364#issuecomment-322482427,"This allows the x86 new dynarec to compile again. I just switched the order of operations that the compiler was complain against and it allows it to build.
My x86 assembly skill is not strong at all, but you would think that the order of additions should not matter. Can anyone double check this and make sure that south park doesn't restart on its own anymore?
This is for this issue: #316",I'll dig out my Nexus player later tonight to make sure there are no issues there. I would really like if @Gillou68310 could comment since he made the original change.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,364,2017-08-15T11:55:34Z,2017-08-19T23:01:45Z,2017-08-19T23:01:45Z,MERGED,True,2,2,1,https://github.com/fzurita,Get x86 new dynarec compiling again (when using PIC),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/364,https://github.com/fzurita,4,https://github.com/mupen64plus/mupen64plus-core/pull/364#issuecomment-322660253,"This allows the x86 new dynarec to compile again. I just switched the order of operations that the compiler was complain against and it allows it to build.
My x86 assembly skill is not strong at all, but you would think that the order of additions should not matter. Can anyone double check this and make sure that south park doesn't restart on its own anymore?
This is for this issue: #316","I tested, I didn't see any issue in Android X86, no random restarts. Although, all the colors are currently messed up with GLideN64, sounds like something broke somewhere in the video plugin. Edit: It's due to per pixel lighting.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,364,2017-08-15T11:55:34Z,2017-08-19T23:01:45Z,2017-08-19T23:01:45Z,MERGED,True,2,2,1,https://github.com/fzurita,Get x86 new dynarec compiling again (when using PIC),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/364,https://github.com/bsmiles32,5,https://github.com/mupen64plus/mupen64plus-core/pull/364#issuecomment-323552559,"This allows the x86 new dynarec to compile again. I just switched the order of operations that the compiler was complain against and it allows it to build.
My x86 assembly skill is not strong at all, but you would think that the order of additions should not matter. Can anyone double check this and make sure that south park doesn't restart on its own anymore?
This is for this issue: #316","Merging this as it fixes the compilation and is trivial to revert if anything. Still if @Gillou68310 wants to comment on it, be my guest :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,365,2017-08-17T15:55:39Z,2017-08-19T22:39:25Z,2017-08-20T01:34:05Z,MERGED,True,1,1,1,https://github.com/loganmc10,Fix order of operations for AI interrupt timing,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/365,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/365,"You'll notice this the most if you listen to the intro for Pokemon Puzzle League.
In the current master it is very choppy (I'm talking about the very first thing you hear, before you press start). You'll also notice there are some breaks in the audio while you watch the FMV intro after you push ""start"".
I listened to other games and they still sound good to me. This may fix other audio issues in games if they exist, but I'm not aware of any specific examples.","You'll notice this the most if you listen to the intro for Pokemon Puzzle League.
In the current master it is very choppy (I'm talking about the very first thing you hear, before you press start). You'll also notice there are some breaks in the audio while you watch the FMV intro after you push ""start"".
I listened to other games and they still sound good to me. This may fix other audio issues in games if they exist, but I'm not aware of any specific examples.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,367,2017-08-19T23:04:30Z,2017-08-19T23:04:55Z,2017-09-14T23:42:46Z,MERGED,True,3,3,2,https://github.com/bsmiles32,Fixing some warnings,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/367,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/367,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,368,2017-08-21T02:53:46Z,2017-09-14T11:27:33Z,2017-09-28T14:09:58Z,CLOSED,False,57,18,9,https://github.com/loganmc10,Disable exception handling if FR bit is set for some games,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/368,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/368,"I think this is a better solution compared to #357
If we were emulating the COUNT register properly, I don't think these issues would be happening. The previous solution was quite elaborate and applied to every game.
This still solves the bone displacement in DK, as well as the graphics in the Factor5 games, but it is much simpler and game specific.
I'll do some more testing in these games over the next few days. Hopefully somebody can figure out a better way to emulate the COUNT register, then maybe we could get rid of these many hacks.
Any comment from @Gillou68310 would be welcome as well.","I think this is a better solution compared to #357
If we were emulating the COUNT register properly, I don't think these issues would be happening. The previous solution was quite elaborate and applied to every game.
This still solves the bone displacement in DK, as well as the graphics in the Factor5 games, but it is much simpler and game specific.
I'll do some more testing in these games over the next few days. Hopefully somebody can figure out a better way to emulate the COUNT register, then maybe we could get rid of these many hacks.
Any comment from @Gillou68310 would be welcome as well.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,368,2017-08-21T02:53:46Z,2017-09-14T11:27:33Z,2017-09-28T14:09:58Z,CLOSED,False,57,18,9,https://github.com/loganmc10,Disable exception handling if FR bit is set for some games,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/368,https://github.com/Gillou68310,2,https://github.com/mupen64plus/mupen64plus-core/pull/368#issuecomment-323973524,"I think this is a better solution compared to #357
If we were emulating the COUNT register properly, I don't think these issues would be happening. The previous solution was quite elaborate and applied to every game.
This still solves the bone displacement in DK, as well as the graphics in the Factor5 games, but it is much simpler and game specific.
I'll do some more testing in these games over the next few days. Hopefully somebody can figure out a better way to emulate the COUNT register, then maybe we could get rid of these many hacks.
Any comment from @Gillou68310 would be welcome as well.","Is it necessary to be a game specific hack? Did you notice any regression with other games?
Another idea would be to delay the interrupt until the FR bit is unset, instead of skipping the exception.
This hack #357 is incomplete and should not be used.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,368,2017-08-21T02:53:46Z,2017-09-14T11:27:33Z,2017-09-28T14:09:58Z,CLOSED,False,57,18,9,https://github.com/loganmc10,Disable exception handling if FR bit is set for some games,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/368,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/368#issuecomment-324004512,"I think this is a better solution compared to #357
If we were emulating the COUNT register properly, I don't think these issues would be happening. The previous solution was quite elaborate and applied to every game.
This still solves the bone displacement in DK, as well as the graphics in the Factor5 games, but it is much simpler and game specific.
I'll do some more testing in these games over the next few days. Hopefully somebody can figure out a better way to emulate the COUNT register, then maybe we could get rid of these many hacks.
Any comment from @Gillou68310 would be welcome as well.","I didn't notice any regressions in these games. I made it a game specific hack because I don't see any documentation stating that this is how the N64 worked. It's hard to say whether this might cause regressions in other games or not, since it might take some obscure situation to trigger the regression. I thought ""better safe than sorry""",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,368,2017-08-21T02:53:46Z,2017-09-14T11:27:33Z,2017-09-28T14:09:58Z,CLOSED,False,57,18,9,https://github.com/loganmc10,Disable exception handling if FR bit is set for some games,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/368,https://github.com/Gillou68310,4,https://github.com/mupen64plus/mupen64plus-core/pull/368#issuecomment-324009488,"I think this is a better solution compared to #357
If we were emulating the COUNT register properly, I don't think these issues would be happening. The previous solution was quite elaborate and applied to every game.
This still solves the bone displacement in DK, as well as the graphics in the Factor5 games, but it is much simpler and game specific.
I'll do some more testing in these games over the next few days. Hopefully somebody can figure out a better way to emulate the COUNT register, then maybe we could get rid of these many hacks.
Any comment from @Gillou68310 would be welcome as well.","Ok for me ;-)
Still it would be interesting to test if delaying the interrupt is a possible solution too.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,368,2017-08-21T02:53:46Z,2017-09-14T11:27:33Z,2017-09-28T14:09:58Z,CLOSED,False,57,18,9,https://github.com/loganmc10,Disable exception handling if FR bit is set for some games,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/368,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/368#issuecomment-324499194,"I think this is a better solution compared to #357
If we were emulating the COUNT register properly, I don't think these issues would be happening. The previous solution was quite elaborate and applied to every game.
This still solves the bone displacement in DK, as well as the graphics in the Factor5 games, but it is much simpler and game specific.
I'll do some more testing in these games over the next few days. Hopefully somebody can figure out a better way to emulate the COUNT register, then maybe we could get rid of these many hacks.
Any comment from @Gillou68310 would be welcome as well.","I tried adding:
 if (cp0_regs[CP0_STATUS_REG] & CP0_STATUS_FR)
{
        uint32_t type = r4300->cp0.q.first->data.type;
        remove_interrupt_event(&r4300->cp0);
        add_interrupt_event(&r4300->cp0, type, 100);
        return;
}

Right before the switch statement in gen_interrupt. Rogue Squadron just locks up at boot. I might have done it wrong. Delaying the interrupt does seem like a decent solution, except that the interrupts might get out of order right? Like if we delay one, but not the others, then it seems to me that things would get out of order, unless there is a way to shift the whole interrupt queue. If there is I'm not aware of it.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,368,2017-08-21T02:53:46Z,2017-09-14T11:27:33Z,2017-09-28T14:09:58Z,CLOSED,False,57,18,9,https://github.com/loganmc10,Disable exception handling if FR bit is set for some games,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/368,https://github.com/Gillou68310,6,https://github.com/mupen64plus/mupen64plus-core/pull/368#issuecomment-324619688,"I think this is a better solution compared to #357
If we were emulating the COUNT register properly, I don't think these issues would be happening. The previous solution was quite elaborate and applied to every game.
This still solves the bone displacement in DK, as well as the graphics in the Factor5 games, but it is much simpler and game specific.
I'll do some more testing in these games over the next few days. Hopefully somebody can figure out a better way to emulate the COUNT register, then maybe we could get rid of these many hacks.
Any comment from @Gillou68310 would be welcome as well.","In order to shift the whole interrupt queue you can use the translate_event_queue function.
Anyway let's use your current implementation for now we can come back to this later.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,368,2017-08-21T02:53:46Z,2017-09-14T11:27:33Z,2017-09-28T14:09:58Z,CLOSED,False,57,18,9,https://github.com/loganmc10,Disable exception handling if FR bit is set for some games,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/368,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/368#issuecomment-328976770,"I think this is a better solution compared to #357
If we were emulating the COUNT register properly, I don't think these issues would be happening. The previous solution was quite elaborate and applied to every game.
This still solves the bone displacement in DK, as well as the graphics in the Factor5 games, but it is much simpler and game specific.
I'll do some more testing in these games over the next few days. Hopefully somebody can figure out a better way to emulate the COUNT register, then maybe we could get rid of these many hacks.
Any comment from @Gillou68310 would be welcome as well.",Ok I think this can be merged then @Narann,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,368,2017-08-21T02:53:46Z,2017-09-14T11:27:33Z,2017-09-28T14:09:58Z,CLOSED,False,57,18,9,https://github.com/loganmc10,Disable exception handling if FR bit is set for some games,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/368,https://github.com/theboy181,8,https://github.com/mupen64plus/mupen64plus-core/pull/368#issuecomment-329035359,"I think this is a better solution compared to #357
If we were emulating the COUNT register properly, I don't think these issues would be happening. The previous solution was quite elaborate and applied to every game.
This still solves the bone displacement in DK, as well as the graphics in the Factor5 games, but it is much simpler and game specific.
I'll do some more testing in these games over the next few days. Hopefully somebody can figure out a better way to emulate the COUNT register, then maybe we could get rid of these many hacks.
Any comment from @Gillou68310 would be welcome as well.",@loganmc10 How can I reproduce this bone displacement in latest PJ64 ?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,368,2017-08-21T02:53:46Z,2017-09-14T11:27:33Z,2017-09-28T14:09:58Z,CLOSED,False,57,18,9,https://github.com/loganmc10,Disable exception handling if FR bit is set for some games,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/368,https://github.com/loganmc10,9,https://github.com/mupen64plus/mupen64plus-core/pull/368#issuecomment-329036167,"I think this is a better solution compared to #357
If we were emulating the COUNT register properly, I don't think these issues would be happening. The previous solution was quite elaborate and applied to every game.
This still solves the bone displacement in DK, as well as the graphics in the Factor5 games, but it is much simpler and game specific.
I'll do some more testing in these games over the next few days. Hopefully somebody can figure out a better way to emulate the COUNT register, then maybe we could get rid of these many hacks.
Any comment from @Gillou68310 would be welcome as well.","project64/project64#791
The first post has a link to PJ64 save states that will reproduce the issue.
You also need to remove the cheat based fix in the RDB https://github.com/project64/project64/blob/master/Config/Project64.rdb#L1481
Then you should be able to reproduce it",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,368,2017-08-21T02:53:46Z,2017-09-14T11:27:33Z,2017-09-28T14:09:58Z,CLOSED,False,57,18,9,https://github.com/loganmc10,Disable exception handling if FR bit is set for some games,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/368,https://github.com/theboy181,10,https://github.com/mupen64plus/mupen64plus-core/pull/368#issuecomment-329037179,"I think this is a better solution compared to #357
If we were emulating the COUNT register properly, I don't think these issues would be happening. The previous solution was quite elaborate and applied to every game.
This still solves the bone displacement in DK, as well as the graphics in the Factor5 games, but it is much simpler and game specific.
I'll do some more testing in these games over the next few days. Hopefully somebody can figure out a better way to emulate the COUNT register, then maybe we could get rid of these many hacks.
Any comment from @Gillou68310 would be welcome as well.","I get some weird blue flashing and audio issue until I pause, but no bone issues.. I have and had the cheat code in the RDB disabled too. Can you test? This method doesn't appear to work for me.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,368,2017-08-21T02:53:46Z,2017-09-14T11:27:33Z,2017-09-28T14:09:58Z,CLOSED,False,57,18,9,https://github.com/loganmc10,Disable exception handling if FR bit is set for some games,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/368,https://github.com/loganmc10,11,https://github.com/mupen64plus/mupen64plus-core/pull/368#issuecomment-329037409,"I think this is a better solution compared to #357
If we were emulating the COUNT register properly, I don't think these issues would be happening. The previous solution was quite elaborate and applied to every game.
This still solves the bone displacement in DK, as well as the graphics in the Factor5 games, but it is much simpler and game specific.
I'll do some more testing in these games over the next few days. Hopefully somebody can figure out a better way to emulate the COUNT register, then maybe we could get rid of these many hacks.
Any comment from @Gillou68310 would be welcome as well.","One of the save states gave me the blue flashing, and the other gives the bone displacement as soon as you move. Actually I've only ever tried it in mupen64plus, the save states Isotarge provided are probably different for PJ64 and mupen64plus. I'll try PJ64 tomorrow. Did you try both save states?
EDIT: oh I see that Pj64 only has 1 save state, I guess they are different. The blue flashing screen is ""warping"" I believe ,and it is related to the bone displacement",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,368,2017-08-21T02:53:46Z,2017-09-14T11:27:33Z,2017-09-28T14:09:58Z,CLOSED,False,57,18,9,https://github.com/loganmc10,Disable exception handling if FR bit is set for some games,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/368,https://github.com/theboy181,12,https://github.com/mupen64plus/mupen64plus-core/pull/368#issuecomment-329038555,"I think this is a better solution compared to #357
If we were emulating the COUNT register properly, I don't think these issues would be happening. The previous solution was quite elaborate and applied to every game.
This still solves the bone displacement in DK, as well as the graphics in the Factor5 games, but it is much simpler and game specific.
I'll do some more testing in these games over the next few days. Hopefully somebody can figure out a better way to emulate the COUNT register, then maybe we could get rid of these many hacks.
Any comment from @Gillou68310 would be welcome as well.","I didn't see a second save state for PJ but the one link at the top does do a flashing blue screen and audio issue, but I assume that you would reproduce that from a save every time its loaded. I would like to test the bone displacement though.. where is the state?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,368,2017-08-21T02:53:46Z,2017-09-14T11:27:33Z,2017-09-28T14:09:58Z,CLOSED,False,57,18,9,https://github.com/loganmc10,Disable exception handling if FR bit is set for some games,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/368,https://github.com/loganmc10,13,https://github.com/mupen64plus/mupen64plus-core/pull/368#issuecomment-329039612,"I think this is a better solution compared to #357
If we were emulating the COUNT register properly, I don't think these issues would be happening. The previous solution was quite elaborate and applied to every game.
This still solves the bone displacement in DK, as well as the graphics in the Factor5 games, but it is much simpler and game specific.
I'll do some more testing in these games over the next few days. Hopefully somebody can figure out a better way to emulate the COUNT register, then maybe we could get rid of these many hacks.
Any comment from @Gillou68310 would be welcome as well.","Sorry yeah I guess PJ64 just has that 1 state. @Isotarge might be a better person to ask about reproducing it, all I know is what was posted on that thread. There is also a pretty detailed Google doc explaining the issue",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,368,2017-08-21T02:53:46Z,2017-09-14T11:27:33Z,2017-09-28T14:09:58Z,CLOSED,False,57,18,9,https://github.com/loganmc10,Disable exception handling if FR bit is set for some games,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/368,https://github.com/theboy181,14,https://github.com/mupen64plus/mupen64plus-core/pull/368#issuecomment-329057085,"I think this is a better solution compared to #357
If we were emulating the COUNT register properly, I don't think these issues would be happening. The previous solution was quite elaborate and applied to every game.
This still solves the bone displacement in DK, as well as the graphics in the Factor5 games, but it is much simpler and game specific.
I'll do some more testing in these games over the next few days. Hopefully somebody can figure out a better way to emulate the COUNT register, then maybe we could get rid of these many hacks.
Any comment from @Gillou68310 would be welcome as well.","Thanks for the help, anyway. I think that the bug was squashed in PJ couple of months ago. Hope I'm not wrong.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,368,2017-08-21T02:53:46Z,2017-09-14T11:27:33Z,2017-09-28T14:09:58Z,CLOSED,False,57,18,9,https://github.com/loganmc10,Disable exception handling if FR bit is set for some games,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/368,https://github.com/Narann,15,https://github.com/mupen64plus/mupen64plus-core/pull/368#issuecomment-329090923,"I think this is a better solution compared to #357
If we were emulating the COUNT register properly, I don't think these issues would be happening. The previous solution was quite elaborate and applied to every game.
This still solves the bone displacement in DK, as well as the graphics in the Factor5 games, but it is much simpler and game specific.
I'll do some more testing in these games over the next few days. Hopefully somebody can figure out a better way to emulate the COUNT register, then maybe we could get rid of these many hacks.
Any comment from @Gillou68310 would be welcome as well.","So, is it ok for merging? :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,368,2017-08-21T02:53:46Z,2017-09-14T11:27:33Z,2017-09-28T14:09:58Z,CLOSED,False,57,18,9,https://github.com/loganmc10,Disable exception handling if FR bit is set for some games,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/368,https://github.com/Gillou68310,16,https://github.com/mupen64plus/mupen64plus-core/pull/368#issuecomment-329094476,"I think this is a better solution compared to #357
If we were emulating the COUNT register properly, I don't think these issues would be happening. The previous solution was quite elaborate and applied to every game.
This still solves the bone displacement in DK, as well as the graphics in the Factor5 games, but it is much simpler and game specific.
I'll do some more testing in these games over the next few days. Hopefully somebody can figure out a better way to emulate the COUNT register, then maybe we could get rid of these many hacks.
Any comment from @Gillou68310 would be welcome as well.","Project64 has made some progress here, their latest builds do not seem to suffer from bone displacement issues, even without the RDRAM patch in the RDB. The commit responsible for fixing this issue is possibly project64/project64@c7f8957

Well I think we should consider backporting the fix from project64 to see if it fixes the issue for us.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,368,2017-08-21T02:53:46Z,2017-09-14T11:27:33Z,2017-09-28T14:09:58Z,CLOSED,False,57,18,9,https://github.com/loganmc10,Disable exception handling if FR bit is set for some games,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/368,https://github.com/Narann,17,https://github.com/mupen64plus/mupen64plus-core/pull/368#issuecomment-329100633,"I think this is a better solution compared to #357
If we were emulating the COUNT register properly, I don't think these issues would be happening. The previous solution was quite elaborate and applied to every game.
This still solves the bone displacement in DK, as well as the graphics in the Factor5 games, but it is much simpler and game specific.
I'll do some more testing in these games over the next few days. Hopefully somebody can figure out a better way to emulate the COUNT register, then maybe we could get rid of these many hacks.
Any comment from @Gillou68310 would be welcome as well.","PJ64 fix look nice, anyone would like to try it?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,368,2017-08-21T02:53:46Z,2017-09-14T11:27:33Z,2017-09-28T14:09:58Z,CLOSED,False,57,18,9,https://github.com/loganmc10,Disable exception handling if FR bit is set for some games,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/368,https://github.com/Gillou68310,18,https://github.com/mupen64plus/mupen64plus-core/pull/368#issuecomment-329110929,"I think this is a better solution compared to #357
If we were emulating the COUNT register properly, I don't think these issues would be happening. The previous solution was quite elaborate and applied to every game.
This still solves the bone displacement in DK, as well as the graphics in the Factor5 games, but it is much simpler and game specific.
I'll do some more testing in these games over the next few days. Hopefully somebody can figure out a better way to emulate the COUNT register, then maybe we could get rid of these many hacks.
Any comment from @Gillou68310 would be welcome as well.",I'll take a look,True,{'THUMBS_UP': ['https://github.com/Narann']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,368,2017-08-21T02:53:46Z,2017-09-14T11:27:33Z,2017-09-28T14:09:58Z,CLOSED,False,57,18,9,https://github.com/loganmc10,Disable exception handling if FR bit is set for some games,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/368,https://github.com/Gillou68310,19,https://github.com/mupen64plus/mupen64plus-core/pull/368#issuecomment-329210036,"I think this is a better solution compared to #357
If we were emulating the COUNT register properly, I don't think these issues would be happening. The previous solution was quite elaborate and applied to every game.
This still solves the bone displacement in DK, as well as the graphics in the Factor5 games, but it is much simpler and game specific.
I'll do some more testing in these games over the next few days. Hopefully somebody can figure out a better way to emulate the COUNT register, then maybe we could get rid of these many hacks.
Any comment from @Gillou68310 would be welcome as well.","Ok I backported the fix from project64:
Gillou68310@2cbd9be
@loganmc10 could you test it?
Don't forget to remove the Bone displacement fix cheat code before testing ;-)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,368,2017-08-21T02:53:46Z,2017-09-14T11:27:33Z,2017-09-28T14:09:58Z,CLOSED,False,57,18,9,https://github.com/loganmc10,Disable exception handling if FR bit is set for some games,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/368,https://github.com/loganmc10,20,https://github.com/mupen64plus/mupen64plus-core/pull/368#issuecomment-329215421,"I think this is a better solution compared to #357
If we were emulating the COUNT register properly, I don't think these issues would be happening. The previous solution was quite elaborate and applied to every game.
This still solves the bone displacement in DK, as well as the graphics in the Factor5 games, but it is much simpler and game specific.
I'll do some more testing in these games over the next few days. Hopefully somebody can figure out a better way to emulate the COUNT register, then maybe we could get rid of these many hacks.
Any comment from @Gillou68310 would be welcome as well.","Yes I tested DK with Isotarge's savestate, as well as Rogue Squadron and Indiana Jones, the issues are gone in all games, good work!",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,368,2017-08-21T02:53:46Z,2017-09-14T11:27:33Z,2017-09-28T14:09:58Z,CLOSED,False,57,18,9,https://github.com/loganmc10,Disable exception handling if FR bit is set for some games,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/368,https://github.com/Gillou68310,21,https://github.com/mupen64plus/mupen64plus-core/pull/368#issuecomment-329217148,"I think this is a better solution compared to #357
If we were emulating the COUNT register properly, I don't think these issues would be happening. The previous solution was quite elaborate and applied to every game.
This still solves the bone displacement in DK, as well as the graphics in the Factor5 games, but it is much simpler and game specific.
I'll do some more testing in these games over the next few days. Hopefully somebody can figure out a better way to emulate the COUNT register, then maybe we could get rid of these many hacks.
Any comment from @Gillou68310 would be welcome as well.",Cool :-),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,368,2017-08-21T02:53:46Z,2017-09-14T11:27:33Z,2017-09-28T14:09:58Z,CLOSED,False,57,18,9,https://github.com/loganmc10,Disable exception handling if FR bit is set for some games,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/368,https://github.com/loganmc10,22,https://github.com/mupen64plus/mupen64plus-core/pull/368#issuecomment-329347700,"I think this is a better solution compared to #357
If we were emulating the COUNT register properly, I don't think these issues would be happening. The previous solution was quite elaborate and applied to every game.
This still solves the bone displacement in DK, as well as the graphics in the Factor5 games, but it is much simpler and game specific.
I'll do some more testing in these games over the next few days. Hopefully somebody can figure out a better way to emulate the COUNT register, then maybe we could get rid of these many hacks.
Any comment from @Gillou68310 would be welcome as well.",@Gillou68310 I assume you plan to submit a PR for that? Can I close this?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,368,2017-08-21T02:53:46Z,2017-09-14T11:27:33Z,2017-09-28T14:09:58Z,CLOSED,False,57,18,9,https://github.com/loganmc10,Disable exception handling if FR bit is set for some games,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/368,https://github.com/Gillou68310,23,https://github.com/mupen64plus/mupen64plus-core/pull/368#issuecomment-329429509,"I think this is a better solution compared to #357
If we were emulating the COUNT register properly, I don't think these issues would be happening. The previous solution was quite elaborate and applied to every game.
This still solves the bone displacement in DK, as well as the graphics in the Factor5 games, but it is much simpler and game specific.
I'll do some more testing in these games over the next few days. Hopefully somebody can figure out a better way to emulate the COUNT register, then maybe we could get rid of these many hacks.
Any comment from @Gillou68310 would be welcome as well.","Sure
Here's the PR #390",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,368,2017-08-21T02:53:46Z,2017-09-14T11:27:33Z,2017-09-28T14:09:58Z,CLOSED,False,57,18,9,https://github.com/loganmc10,Disable exception handling if FR bit is set for some games,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/368,https://github.com/theboy181,24,https://github.com/mupen64plus/mupen64plus-core/pull/368#issuecomment-329673935,"I think this is a better solution compared to #357
If we were emulating the COUNT register properly, I don't think these issues would be happening. The previous solution was quite elaborate and applied to every game.
This still solves the bone displacement in DK, as well as the graphics in the Factor5 games, but it is much simpler and game specific.
I'll do some more testing in these games over the next few days. Hopefully somebody can figure out a better way to emulate the COUNT register, then maybe we could get rid of these many hacks.
Any comment from @Gillou68310 would be welcome as well.",Nice to see these type of bug fixes get across the scene so quickly.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,369,2017-08-21T03:25:44Z,2017-08-21T19:00:02Z,2017-09-28T14:10:14Z,CLOSED,False,2,0,1,https://github.com/loganmc10,CountPerScanline=2200 for WDC,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/369,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/369,"During a race in World Driver Championship, you hear ""garbage"" sometimes, like a random sound you shouldn't hear. Setting CountPerScanline=2200 eliminates this for me, although it would be nice is someone else could test.
The in-race clock still seems to be pretty accurate with CountPerScanline=2200, it doesn't run too fast, but again, if someone could verify that'd be nice","During a race in World Driver Championship, you hear ""garbage"" sometimes, like a random sound you shouldn't hear. Setting CountPerScanline=2200 eliminates this for me, although it would be nice is someone else could test.
The in-race clock still seems to be pretty accurate with CountPerScanline=2200, it doesn't run too fast, but again, if someone could verify that'd be nice",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,369,2017-08-21T03:25:44Z,2017-08-21T19:00:02Z,2017-09-28T14:10:14Z,CLOSED,False,2,0,1,https://github.com/loganmc10,CountPerScanline=2200 for WDC,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/369,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/369#issuecomment-323824000,"During a race in World Driver Championship, you hear ""garbage"" sometimes, like a random sound you shouldn't hear. Setting CountPerScanline=2200 eliminates this for me, although it would be nice is someone else could test.
The in-race clock still seems to be pretty accurate with CountPerScanline=2200, it doesn't run too fast, but again, if someone could verify that'd be nice",Actually I'm going to revisit this I think,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,370,2017-08-22T02:30:10Z,2017-09-13T09:02:43Z,2017-09-29T16:56:30Z,MERGED,True,12,38,8,https://github.com/loganmc10,Base count_per_scanline on N64 clockrate,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/370,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/370,"Right now we default to 1500, which is a pretty close guess.
It's still not great though, for instance, the European version of Pokemon Puzzle League still has audio stuttering, but the USA version is fine. Increasing the count_per_scanline to 1600 fixes the European version of the game.
This change moves away from this ""guesswork"" system, and calculates the count_per_scanline based on the vi clockrate.
It works pretty well, the audio now works in both the USA and European version of Pokemon Puzzle League. In Resident Evil 2, the audio and video now stay in sync (with CountPerOp=1), without any changes to the scanline setting.
More testing is welcome. I've been testing quite a few games and see no regressions so far.
EDIT: For the curious, in NTSC games, this generally increases the count_per_scanline setting to ~1545, for PAL games it's ~1590","Right now we default to 1500, which is a pretty close guess.
It's still not great though, for instance, the European version of Pokemon Puzzle League still has audio stuttering, but the USA version is fine. Increasing the count_per_scanline to 1600 fixes the European version of the game.
This change moves away from this ""guesswork"" system, and calculates the count_per_scanline based on the vi clockrate.
It works pretty well, the audio now works in both the USA and European version of Pokemon Puzzle League. In Resident Evil 2, the audio and video now stay in sync (with CountPerOp=1), without any changes to the scanline setting.
More testing is welcome. I've been testing quite a few games and see no regressions so far.
EDIT: For the curious, in NTSC games, this generally increases the count_per_scanline setting to ~1545, for PAL games it's ~1590",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,370,2017-08-22T02:30:10Z,2017-09-13T09:02:43Z,2017-09-29T16:56:30Z,MERGED,True,12,38,8,https://github.com/loganmc10,Base count_per_scanline on N64 clockrate,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/370,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/370#issuecomment-323920084,"Right now we default to 1500, which is a pretty close guess.
It's still not great though, for instance, the European version of Pokemon Puzzle League still has audio stuttering, but the USA version is fine. Increasing the count_per_scanline to 1600 fixes the European version of the game.
This change moves away from this ""guesswork"" system, and calculates the count_per_scanline based on the vi clockrate.
It works pretty well, the audio now works in both the USA and European version of Pokemon Puzzle League. In Resident Evil 2, the audio and video now stay in sync (with CountPerOp=1), without any changes to the scanline setting.
More testing is welcome. I've been testing quite a few games and see no regressions so far.
EDIT: For the curious, in NTSC games, this generally increases the count_per_scanline setting to ~1545, for PAL games it's ~1590","@AmbientMalice I tested this change with Indiana Jones and I was able to play through the first 2 levels (including the trading post). I'll probably try it again tomorrow to be sure, I've been burned by that game before when I thought I had it working.
It only boots with CountPerOp=2, so I'm not sure how that might affect the rest of the game, the 1st 2 levels seemed normal to me.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,370,2017-08-22T02:30:10Z,2017-09-13T09:02:43Z,2017-09-29T16:56:30Z,MERGED,True,12,38,8,https://github.com/loganmc10,Base count_per_scanline on N64 clockrate,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/370,https://github.com/AmbientMalice,3,https://github.com/mupen64plus/mupen64plus-core/pull/370#issuecomment-323955900,"Right now we default to 1500, which is a pretty close guess.
It's still not great though, for instance, the European version of Pokemon Puzzle League still has audio stuttering, but the USA version is fine. Increasing the count_per_scanline to 1600 fixes the European version of the game.
This change moves away from this ""guesswork"" system, and calculates the count_per_scanline based on the vi clockrate.
It works pretty well, the audio now works in both the USA and European version of Pokemon Puzzle League. In Resident Evil 2, the audio and video now stay in sync (with CountPerOp=1), without any changes to the scanline setting.
More testing is welcome. I've been testing quite a few games and see no regressions so far.
EDIT: For the curious, in NTSC games, this generally increases the count_per_scanline setting to ~1545, for PAL games it's ~1590","In my experience, =2 causes the game's physics to behave oddly. The game will temporarily freeze when Indy inflates the life raft in the third level, and the jeep will make a constant clunking noise and lurch around when you drive it.
Would you mind uploading a compiled build for me to test when I have time?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,370,2017-08-22T02:30:10Z,2017-09-13T09:02:43Z,2017-09-29T16:56:30Z,MERGED,True,12,38,8,https://github.com/loganmc10,Base count_per_scanline on N64 clockrate,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/370,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/370#issuecomment-324072814,"Right now we default to 1500, which is a pretty close guess.
It's still not great though, for instance, the European version of Pokemon Puzzle League still has audio stuttering, but the USA version is fine. Increasing the count_per_scanline to 1600 fixes the European version of the game.
This change moves away from this ""guesswork"" system, and calculates the count_per_scanline based on the vi clockrate.
It works pretty well, the audio now works in both the USA and European version of Pokemon Puzzle League. In Resident Evil 2, the audio and video now stay in sync (with CountPerOp=1), without any changes to the scanline setting.
More testing is welcome. I've been testing quite a few games and see no regressions so far.
EDIT: For the curious, in NTSC games, this generally increases the count_per_scanline setting to ~1545, for PAL games it's ~1590","It seems I spoke too soon again. I tested again on a different laptop today and I got through the 1st level, but it froze at the end of the second level. It must be some difference in what happens during the level or something. Very strange game...
Enabling DelaySI makes the first level work consistently for me, but breaks the 2nd level. Disabling DelaySI breaks the 1st level but allows me to complete the 2nd level. I wonder if shortening the DelaySI value would help. Anyway that is another problem for another day.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,370,2017-08-22T02:30:10Z,2017-09-13T09:02:43Z,2017-09-29T16:56:30Z,MERGED,True,12,38,8,https://github.com/loganmc10,Base count_per_scanline on N64 clockrate,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/370,None,5,https://github.com/mupen64plus/mupen64plus-core/pull/370#issuecomment-326116120,"Right now we default to 1500, which is a pretty close guess.
It's still not great though, for instance, the European version of Pokemon Puzzle League still has audio stuttering, but the USA version is fine. Increasing the count_per_scanline to 1600 fixes the European version of the game.
This change moves away from this ""guesswork"" system, and calculates the count_per_scanline based on the vi clockrate.
It works pretty well, the audio now works in both the USA and European version of Pokemon Puzzle League. In Resident Evil 2, the audio and video now stay in sync (with CountPerOp=1), without any changes to the scanline setting.
More testing is welcome. I've been testing quite a few games and see no regressions so far.
EDIT: For the curious, in NTSC games, this generally increases the count_per_scanline setting to ~1545, for PAL games it's ~1590",Have you tested timing dependant games like DK64?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,370,2017-08-22T02:30:10Z,2017-09-13T09:02:43Z,2017-09-29T16:56:30Z,MERGED,True,12,38,8,https://github.com/loganmc10,Base count_per_scanline on N64 clockrate,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/370,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/370#issuecomment-326118664,"Right now we default to 1500, which is a pretty close guess.
It's still not great though, for instance, the European version of Pokemon Puzzle League still has audio stuttering, but the USA version is fine. Increasing the count_per_scanline to 1600 fixes the European version of the game.
This change moves away from this ""guesswork"" system, and calculates the count_per_scanline based on the vi clockrate.
It works pretty well, the audio now works in both the USA and European version of Pokemon Puzzle League. In Resident Evil 2, the audio and video now stay in sync (with CountPerOp=1), without any changes to the scanline setting.
More testing is welcome. I've been testing quite a few games and see no regressions so far.
EDIT: For the curious, in NTSC games, this generally increases the count_per_scanline setting to ~1545, for PAL games it's ~1590","Yes, it's still the same, DK still misses the vines in the intro sequence. The song at the beginning still stays roughly in sync, but gets a bit worse towards the end. I assume more accurate emulation of the COUNT register will be needed to fix those issues.
The actual modification is rather small (1500 -> ~1545 in NTSC), but it's enough to fix some audio issues in a few games. Since the audio timing is dependent on the vi clock rate (https://github.com/mupen64plus/mupen64plus-core/blob/master/src/device/ai/ai_controller.c#L65) it makes sense to me to also use the vi clockrate here, instead of using the arbitrary 1500 number.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,370,2017-08-22T02:30:10Z,2017-09-13T09:02:43Z,2017-09-29T16:56:30Z,MERGED,True,12,38,8,https://github.com/loganmc10,Base count_per_scanline on N64 clockrate,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/370,None,7,https://github.com/mupen64plus/mupen64plus-core/pull/370#issuecomment-326127576,"Right now we default to 1500, which is a pretty close guess.
It's still not great though, for instance, the European version of Pokemon Puzzle League still has audio stuttering, but the USA version is fine. Increasing the count_per_scanline to 1600 fixes the European version of the game.
This change moves away from this ""guesswork"" system, and calculates the count_per_scanline based on the vi clockrate.
It works pretty well, the audio now works in both the USA and European version of Pokemon Puzzle League. In Resident Evil 2, the audio and video now stay in sync (with CountPerOp=1), without any changes to the scanline setting.
More testing is welcome. I've been testing quite a few games and see no regressions so far.
EDIT: For the curious, in NTSC games, this generally increases the count_per_scanline setting to ~1545, for PAL games it's ~1590",And COUNT register emulation would mean emulating cache behaviour so.......,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,370,2017-08-22T02:30:10Z,2017-09-13T09:02:43Z,2017-09-29T16:56:30Z,MERGED,True,12,38,8,https://github.com/loganmc10,Base count_per_scanline on N64 clockrate,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/370,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/370#issuecomment-328976971,"Right now we default to 1500, which is a pretty close guess.
It's still not great though, for instance, the European version of Pokemon Puzzle League still has audio stuttering, but the USA version is fine. Increasing the count_per_scanline to 1600 fixes the European version of the game.
This change moves away from this ""guesswork"" system, and calculates the count_per_scanline based on the vi clockrate.
It works pretty well, the audio now works in both the USA and European version of Pokemon Puzzle League. In Resident Evil 2, the audio and video now stay in sync (with CountPerOp=1), without any changes to the scanline setting.
More testing is welcome. I've been testing quite a few games and see no regressions so far.
EDIT: For the curious, in NTSC games, this generally increases the count_per_scanline setting to ~1545, for PAL games it's ~1590",I haven't come across any regressions in this change and I believe it can be merged @bsmiles32 @richard42 @Narann,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,370,2017-08-22T02:30:10Z,2017-09-13T09:02:43Z,2017-09-29T16:56:30Z,MERGED,True,12,38,8,https://github.com/loganmc10,Base count_per_scanline on N64 clockrate,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/370,https://github.com/loganmc10,9,https://github.com/mupen64plus/mupen64plus-core/pull/370#issuecomment-333180484,"Right now we default to 1500, which is a pretty close guess.
It's still not great though, for instance, the European version of Pokemon Puzzle League still has audio stuttering, but the USA version is fine. Increasing the count_per_scanline to 1600 fixes the European version of the game.
This change moves away from this ""guesswork"" system, and calculates the count_per_scanline based on the vi clockrate.
It works pretty well, the audio now works in both the USA and European version of Pokemon Puzzle League. In Resident Evil 2, the audio and video now stay in sync (with CountPerOp=1), without any changes to the scanline setting.
More testing is welcome. I've been testing quite a few games and see no regressions so far.
EDIT: For the curious, in NTSC games, this generally increases the count_per_scanline setting to ~1545, for PAL games it's ~1590",In case anyone is ever reading through this stuff in the future... This also happened to fix: gonetz/GLideN64#1549,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,371,2017-08-22T14:44:30Z,2017-09-13T12:56:38Z,2017-09-28T14:09:14Z,MERGED,True,34,44,9,https://github.com/loganmc10,Have emulator signal RSP interrupts again,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/371,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/371,"This partially reverts #307
@Gillou68310 brought to my attention that those changes might not be quite right. The main difference here is that we unset TASKDONE/HALT/BROKE at the end of the RSP task, and set them when the interrupt is triggered. This should prevent the ""doubling up"" of RSP tasks that caused us issues before.
I tested Top Gear Rally 2, which used to freeze when an overlapping SP interrupt was called, it still seems fine. I also tested other ""troublesome"" games like Pokemon Snap, Kirby, World Driver Championship, they all seem to work well, but I'm hoping for some testing on this.
This also allows us to remove the ""audio signal"" hack that was added.","This partially reverts #307
@Gillou68310 brought to my attention that those changes might not be quite right. The main difference here is that we unset TASKDONE/HALT/BROKE at the end of the RSP task, and set them when the interrupt is triggered. This should prevent the ""doubling up"" of RSP tasks that caused us issues before.
I tested Top Gear Rally 2, which used to freeze when an overlapping SP interrupt was called, it still seems fine. I also tested other ""troublesome"" games like Pokemon Snap, Kirby, World Driver Championship, they all seem to work well, but I'm hoping for some testing on this.
This also allows us to remove the ""audio signal"" hack that was added.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,371,2017-08-22T14:44:30Z,2017-09-13T12:56:38Z,2017-09-28T14:09:14Z,MERGED,True,34,44,9,https://github.com/loganmc10,Have emulator signal RSP interrupts again,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/371,https://github.com/Gillou68310,2,https://github.com/mupen64plus/mupen64plus-core/pull/371#issuecomment-324053298,"This partially reverts #307
@Gillou68310 brought to my attention that those changes might not be quite right. The main difference here is that we unset TASKDONE/HALT/BROKE at the end of the RSP task, and set them when the interrupt is triggered. This should prevent the ""doubling up"" of RSP tasks that caused us issues before.
I tested Top Gear Rally 2, which used to freeze when an overlapping SP interrupt was called, it still seems fine. I also tested other ""troublesome"" games like Pokemon Snap, Kirby, World Driver Championship, they all seem to work well, but I'm hoping for some testing on this.
This also allows us to remove the ""audio signal"" hack that was added.","When returning from an audio task we were also previously clearing the SP_STATUS_YIELDED flag, probably because an audio task can't be yielded.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,371,2017-08-22T14:44:30Z,2017-09-13T12:56:38Z,2017-09-28T14:09:14Z,MERGED,True,34,44,9,https://github.com/loganmc10,Have emulator signal RSP interrupts again,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/371,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/371#issuecomment-324054779,"This partially reverts #307
@Gillou68310 brought to my attention that those changes might not be quite right. The main difference here is that we unset TASKDONE/HALT/BROKE at the end of the RSP task, and set them when the interrupt is triggered. This should prevent the ""doubling up"" of RSP tasks that caused us issues before.
I tested Top Gear Rally 2, which used to freeze when an overlapping SP interrupt was called, it still seems fine. I also tested other ""troublesome"" games like Pokemon Snap, Kirby, World Driver Championship, they all seem to work well, but I'm hoping for some testing on this.
This also allows us to remove the ""audio signal"" hack that was added.","I saw that, if an audio task can't be yielded, then wouldn't the SP_STATUS_YIELDED flag never be set to begin with? As long as there isn't some bug in the RSP plugin, I would think it isn't necessary to clear it. In PR #307 that was removed, and I haven't seen or heard any issues to do with that.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,371,2017-08-22T14:44:30Z,2017-09-13T12:56:38Z,2017-09-28T14:09:14Z,MERGED,True,34,44,9,https://github.com/loganmc10,Have emulator signal RSP interrupts again,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/371,https://github.com/Gillou68310,4,https://github.com/mupen64plus/mupen64plus-core/pull/371#issuecomment-324058211,"This partially reverts #307
@Gillou68310 brought to my attention that those changes might not be quite right. The main difference here is that we unset TASKDONE/HALT/BROKE at the end of the RSP task, and set them when the interrupt is triggered. This should prevent the ""doubling up"" of RSP tasks that caused us issues before.
I tested Top Gear Rally 2, which used to freeze when an overlapping SP interrupt was called, it still seems fine. I also tested other ""troublesome"" games like Pokemon Snap, Kirby, World Driver Championship, they all seem to work well, but I'm hoping for some testing on this.
This also allows us to remove the ""audio signal"" hack that was added.",Let's remove it!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,371,2017-08-22T14:44:30Z,2017-09-13T12:56:38Z,2017-09-28T14:09:14Z,MERGED,True,34,44,9,https://github.com/loganmc10,Have emulator signal RSP interrupts again,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/371,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/371#issuecomment-325027696,"This partially reverts #307
@Gillou68310 brought to my attention that those changes might not be quite right. The main difference here is that we unset TASKDONE/HALT/BROKE at the end of the RSP task, and set them when the interrupt is triggered. This should prevent the ""doubling up"" of RSP tasks that caused us issues before.
I tested Top Gear Rally 2, which used to freeze when an overlapping SP interrupt was called, it still seems fine. I also tested other ""troublesome"" games like Pokemon Snap, Kirby, World Driver Championship, they all seem to work well, but I'm hoping for some testing on this.
This also allows us to remove the ""audio signal"" hack that was added.","Hold off on this for now, @Gillou68310 I just experienced
Core Warning: two events of type 0x100 in interrupt queue
Core Warning: two events of type 0x80 in interrupt queue

In Perfect Dark while the N64 logo is spinning, and then game froze. This is the same problem we had before. Interestingly, it also freezes in the same spot using LLE. I could only get it to do it once, but it does happen more frequently in LLE (it happens in LLE with or without this PR). I need to look into this a bit more.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,371,2017-08-22T14:44:30Z,2017-09-13T12:56:38Z,2017-09-28T14:09:14Z,MERGED,True,34,44,9,https://github.com/loganmc10,Have emulator signal RSP interrupts again,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/371,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/371#issuecomment-325041021,"This partially reverts #307
@Gillou68310 brought to my attention that those changes might not be quite right. The main difference here is that we unset TASKDONE/HALT/BROKE at the end of the RSP task, and set them when the interrupt is triggered. This should prevent the ""doubling up"" of RSP tasks that caused us issues before.
I tested Top Gear Rally 2, which used to freeze when an overlapping SP interrupt was called, it still seems fine. I also tested other ""troublesome"" games like Pokemon Snap, Kirby, World Driver Championship, they all seem to work well, but I'm hoping for some testing on this.
This also allows us to remove the ""audio signal"" hack that was added.","Ok I fixed that problem by doing this:
8bbbde9
I tested Blast Corps and DK64 in LLE, which are both games that go berserk without this DP freeze hack in place, and they both still work. Perfect Dark works again in HLE, but still not LLE (it never has, the DP freeze hack is to blame, disabling it makes Perfect Dark work in LLE).
So I think this is good to merge. That whole DP freeze thing is an unfortunate hack since the RSP and CPU don't run in parallel in the emulator, but it does seem to work for everything except Perfect Dark LLE",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,371,2017-08-22T14:44:30Z,2017-09-13T12:56:38Z,2017-09-28T14:09:14Z,MERGED,True,34,44,9,https://github.com/loganmc10,Have emulator signal RSP interrupts again,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/371,https://github.com/AmbientMalice,7,https://github.com/mupen64plus/mupen64plus-core/pull/371#issuecomment-325065273,"This partially reverts #307
@Gillou68310 brought to my attention that those changes might not be quite right. The main difference here is that we unset TASKDONE/HALT/BROKE at the end of the RSP task, and set them when the interrupt is triggered. This should prevent the ""doubling up"" of RSP tasks that caused us issues before.
I tested Top Gear Rally 2, which used to freeze when an overlapping SP interrupt was called, it still seems fine. I also tested other ""troublesome"" games like Pokemon Snap, Kirby, World Driver Championship, they all seem to work well, but I'm hoping for some testing on this.
This also allows us to remove the ""audio signal"" hack that was added.",@loganmc10 You should probably disable the DP freeze hack for Perfect Dark like libretro has done.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,371,2017-08-22T14:44:30Z,2017-09-13T12:56:38Z,2017-09-28T14:09:14Z,MERGED,True,34,44,9,https://github.com/loganmc10,Have emulator signal RSP interrupts again,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/371,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/371#issuecomment-325076258,"This partially reverts #307
@Gillou68310 brought to my attention that those changes might not be quite right. The main difference here is that we unset TASKDONE/HALT/BROKE at the end of the RSP task, and set them when the interrupt is triggered. This should prevent the ""doubling up"" of RSP tasks that caused us issues before.
I tested Top Gear Rally 2, which used to freeze when an overlapping SP interrupt was called, it still seems fine. I also tested other ""troublesome"" games like Pokemon Snap, Kirby, World Driver Championship, they all seem to work well, but I'm hoping for some testing on this.
This also allows us to remove the ""audio signal"" hack that was added.","I'm really trying to get rid of game specific hacks. We know the cause of that problem and it's very easy to reproduce, so it's a prime candidate for a proper fix. I'm worried that adding a game specific hack would remove all motivation to find a proper fix, and that game emulates very well in HLE, so that is a pretty good workaround for now.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,371,2017-08-22T14:44:30Z,2017-09-13T12:56:38Z,2017-09-28T14:09:14Z,MERGED,True,34,44,9,https://github.com/loganmc10,Have emulator signal RSP interrupts again,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/371,https://github.com/loganmc10,9,https://github.com/mupen64plus/mupen64plus-core/pull/371#issuecomment-326005314,"This partially reverts #307
@Gillou68310 brought to my attention that those changes might not be quite right. The main difference here is that we unset TASKDONE/HALT/BROKE at the end of the RSP task, and set them when the interrupt is triggered. This should prevent the ""doubling up"" of RSP tasks that caused us issues before.
I tested Top Gear Rally 2, which used to freeze when an overlapping SP interrupt was called, it still seems fine. I also tested other ""troublesome"" games like Pokemon Snap, Kirby, World Driver Championship, they all seem to work well, but I'm hoping for some testing on this.
This also allows us to remove the ""audio signal"" hack that was added.","Ok I pushed a generic fix for Perfect Dark in LLE, I tested the first level in HLE and LLE, got all the way through and into the 2nd level (I think it used to freeze when you hit ""Accept"" at the end of the level, happened in PJ64 too, but I haven't experienced that in a while)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,371,2017-08-22T14:44:30Z,2017-09-13T12:56:38Z,2017-09-28T14:09:14Z,MERGED,True,34,44,9,https://github.com/loganmc10,Have emulator signal RSP interrupts again,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/371,https://github.com/Gillou68310,10,https://github.com/mupen64plus/mupen64plus-core/pull/371#issuecomment-326233282,"This partially reverts #307
@Gillou68310 brought to my attention that those changes might not be quite right. The main difference here is that we unset TASKDONE/HALT/BROKE at the end of the RSP task, and set them when the interrupt is triggered. This should prevent the ""doubling up"" of RSP tasks that caused us issues before.
I tested Top Gear Rally 2, which used to freeze when an overlapping SP interrupt was called, it still seems fine. I also tested other ""troublesome"" games like Pokemon Snap, Kirby, World Driver Championship, they all seem to work well, but I'm hoping for some testing on this.
This also allows us to remove the ""audio signal"" hack that was added.","Hold off on this for now, @Gillou68310 I just experienced
Core Warning: two events of type 0x100 in interrupt queue
Core Warning: two events of type 0x80 in interrupt queue
In Perfect Dark while the N64 logo is spinning, and then game froze. This is the same problem we had before. Interestingly, it also freezes in the same spot using LLE. I could only get it to do it once, but it does happen more frequently in LLE (it happens in LLE with or without this PR). I need to look into this a bit more.

@loganmc10 could you try reducing the SP interrupt delay to see if it helps with this issue?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,371,2017-08-22T14:44:30Z,2017-09-13T12:56:38Z,2017-09-28T14:09:14Z,MERGED,True,34,44,9,https://github.com/loganmc10,Have emulator signal RSP interrupts again,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/371,https://github.com/loganmc10,11,https://github.com/mupen64plus/mupen64plus-core/pull/371#issuecomment-326295657,"This partially reverts #307
@Gillou68310 brought to my attention that those changes might not be quite right. The main difference here is that we unset TASKDONE/HALT/BROKE at the end of the RSP task, and set them when the interrupt is triggered. This should prevent the ""doubling up"" of RSP tasks that caused us issues before.
I tested Top Gear Rally 2, which used to freeze when an overlapping SP interrupt was called, it still seems fine. I also tested other ""troublesome"" games like Pokemon Snap, Kirby, World Driver Championship, they all seem to work well, but I'm hoping for some testing on this.
This also allows us to remove the ""audio signal"" hack that was added.","I fixed it with this commit: 49f9d38
Reducing the interrupt timer might fix it, but I don't really like counting on that. There could be other games that have the same issue but need an even shorter timer, or the 3rd level in Perfect Dark, etc... I'd rather have a ""bullet proof"" fix",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,371,2017-08-22T14:44:30Z,2017-09-13T12:56:38Z,2017-09-28T14:09:14Z,MERGED,True,34,44,9,https://github.com/loganmc10,Have emulator signal RSP interrupts again,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/371,https://github.com/loganmc10,12,https://github.com/mupen64plus/mupen64plus-core/pull/371#issuecomment-328977108,"This partially reverts #307
@Gillou68310 brought to my attention that those changes might not be quite right. The main difference here is that we unset TASKDONE/HALT/BROKE at the end of the RSP task, and set them when the interrupt is triggered. This should prevent the ""doubling up"" of RSP tasks that caused us issues before.
I tested Top Gear Rally 2, which used to freeze when an overlapping SP interrupt was called, it still seems fine. I also tested other ""troublesome"" games like Pokemon Snap, Kirby, World Driver Championship, they all seem to work well, but I'm hoping for some testing on this.
This also allows us to remove the ""audio signal"" hack that was added.",This has also been tested quite a bit and can be merged I believe @Narann @bsmiles32 @richard42,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,371,2017-08-22T14:44:30Z,2017-09-13T12:56:38Z,2017-09-28T14:09:14Z,MERGED,True,34,44,9,https://github.com/loganmc10,Have emulator signal RSP interrupts again,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/371,https://github.com/Narann,13,https://github.com/mupen64plus/mupen64plus-core/pull/371#issuecomment-329105168,"This partially reverts #307
@Gillou68310 brought to my attention that those changes might not be quite right. The main difference here is that we unset TASKDONE/HALT/BROKE at the end of the RSP task, and set them when the interrupt is triggered. This should prevent the ""doubling up"" of RSP tasks that caused us issues before.
I tested Top Gear Rally 2, which used to freeze when an overlapping SP interrupt was called, it still seems fine. I also tested other ""troublesome"" games like Pokemon Snap, Kirby, World Driver Championship, they all seem to work well, but I'm hoping for some testing on this.
This also allows us to remove the ""audio signal"" hack that was added.",Merge conflict after merging #370,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,371,2017-08-22T14:44:30Z,2017-09-13T12:56:38Z,2017-09-28T14:09:14Z,MERGED,True,34,44,9,https://github.com/loganmc10,Have emulator signal RSP interrupts again,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/371,https://github.com/loganmc10,14,https://github.com/mupen64plus/mupen64plus-core/pull/371#issuecomment-329147681,"This partially reverts #307
@Gillou68310 brought to my attention that those changes might not be quite right. The main difference here is that we unset TASKDONE/HALT/BROKE at the end of the RSP task, and set them when the interrupt is triggered. This should prevent the ""doubling up"" of RSP tasks that caused us issues before.
I tested Top Gear Rally 2, which used to freeze when an overlapping SP interrupt was called, it still seems fine. I also tested other ""troublesome"" games like Pokemon Snap, Kirby, World Driver Championship, they all seem to work well, but I'm hoping for some testing on this.
This also allows us to remove the ""audio signal"" hack that was added.",Merge conflict has been resolved,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,373,2017-08-23T21:47:28Z,2017-09-12T20:50:54Z,2017-09-28T14:10:05Z,MERGED,True,4,7,4,https://github.com/loganmc10,Remove Rat Attack hack,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/373,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/373,"I think it was a mistake for me to submit this hack earlier. It's not good to add an extra if statement every time virtual_to_physical_address is called just so this game can (sort of) work.
It seems like some kind of strange timing issue, so hopefully as we get more accurate timing this problem will sort itself out.","I think it was a mistake for me to submit this hack earlier. It's not good to add an extra if statement every time virtual_to_physical_address is called just so this game can (sort of) work.
It seems like some kind of strange timing issue, so hopefully as we get more accurate timing this problem will sort itself out.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,373,2017-08-23T21:47:28Z,2017-09-12T20:50:54Z,2017-09-28T14:10:05Z,MERGED,True,4,7,4,https://github.com/loganmc10,Remove Rat Attack hack,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/373,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/373#issuecomment-328977326,"I think it was a mistake for me to submit this hack earlier. It's not good to add an extra if statement every time virtual_to_physical_address is called just so this game can (sort of) work.
It seems like some kind of strange timing issue, so hopefully as we get more accurate timing this problem will sort itself out.","This will ""break"" Rat Attack, although it never worked 100% with this hack. I think removing this is a good idea and hopefully with better timing in the future this game will start to work. It can be merged",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,373,2017-08-23T21:47:28Z,2017-09-12T20:50:54Z,2017-09-28T14:10:05Z,MERGED,True,4,7,4,https://github.com/loganmc10,Remove Rat Attack hack,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/373,https://github.com/Gillou68310,3,https://github.com/mupen64plus/mupen64plus-core/pull/373#issuecomment-329196797,"I think it was a mistake for me to submit this hack earlier. It's not good to add an extra if statement every time virtual_to_physical_address is called just so this game can (sort of) work.
It seems like some kind of strange timing issue, so hopefully as we get more accurate timing this problem will sort itself out.",@loganmc10 you forgot to remove the hack from the new dynarec,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,373,2017-08-23T21:47:28Z,2017-09-12T20:50:54Z,2017-09-28T14:10:05Z,MERGED,True,4,7,4,https://github.com/loganmc10,Remove Rat Attack hack,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/373,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/373#issuecomment-329200872,"I think it was a mistake for me to submit this hack earlier. It's not good to add an extra if statement every time virtual_to_physical_address is called just so this game can (sort of) work.
It seems like some kind of strange timing issue, so hopefully as we get more accurate timing this problem will sort itself out.",Whoops sorry #387 @Narann,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,375,2017-08-25T16:21:44Z,2017-09-14T14:56:38Z,2021-11-28T00:20:48Z,MERGED,True,20,35,1,https://github.com/loganmc10,Fix duplicate saving in Paper Mario,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/375,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/375,"This fixes #154
Right now, if the PI controller gets a strange request, we basically just ignore it and hope for better luck next time.
What this change does: If the rom address is too large, or if the rom address is good, but the (rom_address + length) would put us outside the ROM's size, then we copy what fits, and fill the rest with 0's.
I'll do some more testing in the next day or two to make sure this doesn't cause any regressions in other games.","This fixes #154
Right now, if the PI controller gets a strange request, we basically just ignore it and hope for better luck next time.
What this change does: If the rom address is too large, or if the rom address is good, but the (rom_address + length) would put us outside the ROM's size, then we copy what fits, and fill the rest with 0's.
I'll do some more testing in the next day or two to make sure this doesn't cause any regressions in other games.",True,{'THUMBS_UP': ['https://github.com/Oggom']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,375,2017-08-25T16:21:44Z,2017-09-14T14:56:38Z,2021-11-28T00:20:48Z,MERGED,True,20,35,1,https://github.com/loganmc10,Fix duplicate saving in Paper Mario,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/375,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/375#issuecomment-328977453,"This fixes #154
Right now, if the PI controller gets a strange request, we basically just ignore it and hope for better luck next time.
What this change does: If the rom address is too large, or if the rom address is good, but the (rom_address + length) would put us outside the ROM's size, then we copy what fits, and fill the rest with 0's.
I'll do some more testing in the next day or two to make sure this doesn't cause any regressions in other games.",My testing of this PR hasn't revealed any issues with any other games,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,375,2017-08-25T16:21:44Z,2017-09-14T14:56:38Z,2021-11-28T00:20:48Z,MERGED,True,20,35,1,https://github.com/loganmc10,Fix duplicate saving in Paper Mario,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/375,https://github.com/Narann,3,https://github.com/mupen64plus/mupen64plus-core/pull/375#issuecomment-328997266,"This fixes #154
Right now, if the PI controller gets a strange request, we basically just ignore it and hope for better luck next time.
What this change does: If the rom address is too large, or if the rom address is good, but the (rom_address + length) would put us outside the ROM's size, then we copy what fits, and fill the rest with 0's.
I'll do some more testing in the next day or two to make sure this doesn't cause any regressions in other games.","Good job @loganmc10 !
This is not a tiny change, I would wait for @bsmiles32 and @Gillou68310 to check this before merge.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,375,2017-08-25T16:21:44Z,2017-09-14T14:56:38Z,2021-11-28T00:20:48Z,MERGED,True,20,35,1,https://github.com/loganmc10,Fix duplicate saving in Paper Mario,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/375,https://github.com/bsmiles32,4,https://github.com/mupen64plus/mupen64plus-core/pull/375#issuecomment-329508698,"This fixes #154
Right now, if the PI controller gets a strange request, we basically just ignore it and hope for better luck next time.
What this change does: If the rom address is too large, or if the rom address is good, but the (rom_address + length) would put us outside the ROM's size, then we copy what fits, and fill the rest with 0's.
I'll do some more testing in the next day or two to make sure this doesn't cause any regressions in other games.","Not sure what is the real behavior on the console, but your changes seems ok. I tested with Paper Mario, did not notice anything strange, but also I wasn't able to reproduce the issue before, so I will just trust you that it indeed fixes the saving issue.
Merging this. Good work !",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,375,2017-08-25T16:21:44Z,2017-09-14T14:56:38Z,2021-11-28T00:20:48Z,MERGED,True,20,35,1,https://github.com/loganmc10,Fix duplicate saving in Paper Mario,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/375,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/375#issuecomment-329509121,"This fixes #154
Right now, if the PI controller gets a strange request, we basically just ignore it and hope for better luck next time.
What this change does: If the rom address is too large, or if the rom address is good, but the (rom_address + length) would put us outside the ROM's size, then we copy what fits, and fill the rest with 0's.
I'll do some more testing in the next day or two to make sure this doesn't cause any regressions in other games.","@bsmiles32 somebody in the libretro thread reported that it doesn't happen in the PAL version, I'm assuming you were probably testing that version.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,375,2017-08-25T16:21:44Z,2017-09-14T14:56:38Z,2021-11-28T00:20:48Z,MERGED,True,20,35,1,https://github.com/loganmc10,Fix duplicate saving in Paper Mario,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/375,https://github.com/bsmiles32,6,https://github.com/mupen64plus/mupen64plus-core/pull/375#issuecomment-329520783,"This fixes #154
Right now, if the PI controller gets a strange request, we basically just ignore it and hope for better luck next time.
What this change does: If the rom address is too large, or if the rom address is good, but the (rom_address + length) would put us outside the ROM's size, then we copy what fits, and fill the rest with 0's.
I'll do some more testing in the next day or two to make sure this doesn't cause any regressions in other games.",Indeed :),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,375,2017-08-25T16:21:44Z,2017-09-14T14:56:38Z,2021-11-28T00:20:48Z,MERGED,True,20,35,1,https://github.com/loganmc10,Fix duplicate saving in Paper Mario,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/375,https://github.com/Fad1000,7,https://github.com/mupen64plus/mupen64plus-core/pull/375#issuecomment-980811674,"This fixes #154
Right now, if the PI controller gets a strange request, we basically just ignore it and hope for better luck next time.
What this change does: If the rom address is too large, or if the rom address is good, but the (rom_address + length) would put us outside the ROM's size, then we copy what fits, and fill the rest with 0's.
I'll do some more testing in the next day or two to make sure this doesn't cause any regressions in other games.","This fixes #154
Right now, if the PI controller gets a strange request, we basically just ignore it and hope for better luck next time.
What this change does: If the rom address is too large, or if the rom address is good, but the (rom_address + length) would put us outside the ROM's size, then we copy what fits, and fill the rest with 0's.
I'll do some more testing in the next day or two to make sure this doesn't cause any regressions in other games.

What am I supposed to do? #",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,376,2017-08-29T03:57:56Z,2017-11-02T14:29:22Z,2017-11-02T14:29:22Z,CLOSED,False,63,60,2,https://github.com/loganmc10,[WIP] Fix FBInfo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/376,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/376,"This makes the FBInfo API work as well as it does with Mupen64. It's still not perfect (doesn't work with Banjo-Kazooie or Pokemon Snap, but neither does Mupen64).
I believe there are some writes (maybe reads) in the PI controller that need to be tracked using pre_framebuffer_write/read, but I can't get it working quite right. It seems to work in 1964 using GLideN64, at least the puzzle transition in Banjo does. The camera in Pokemon Snap doesn't seem to work in 1964 so I can't see if the red dot is there.
I'll keep working on this to see if I can get Pokemon Snap and Banjo working
TODO:

Get it working with new dynarec
Waiting for GLideN64 to fix FBInfo on it's side, so this can be properly tested
Potentially need to add some pre_framebuffer_write/read to PI DMA
Would like to have a way to communicate to the graphics plugin that FBInfo has been fixed. My idea is to write a 1 to fb->infos[0].addr before the first call to gfx.fBGetFrameBufferInfo this can be a signal to the GFX plugin, a sort of ""version number"", telling it that the FBInfo implementation has changed/is working.","This makes the FBInfo API work as well as it does with Mupen64. It's still not perfect (doesn't work with Banjo-Kazooie or Pokemon Snap, but neither does Mupen64).
I believe there are some writes (maybe reads) in the PI controller that need to be tracked using pre_framebuffer_write/read, but I can't get it working quite right. It seems to work in 1964 using GLideN64, at least the puzzle transition in Banjo does. The camera in Pokemon Snap doesn't seem to work in 1964 so I can't see if the red dot is there.
I'll keep working on this to see if I can get Pokemon Snap and Banjo working
TODO:

Get it working with new dynarec
Waiting for GLideN64 to fix FBInfo on it's side, so this can be properly tested
Potentially need to add some pre_framebuffer_write/read to PI DMA
Would like to have a way to communicate to the graphics plugin that FBInfo has been fixed. My idea is to write a 1 to fb->infos[0].addr before the first call to gfx.fBGetFrameBufferInfo this can be a signal to the GFX plugin, a sort of ""version number"", telling it that the FBInfo implementation has changed/is working.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,376,2017-08-29T03:57:56Z,2017-11-02T14:29:22Z,2017-11-02T14:29:22Z,CLOSED,False,63,60,2,https://github.com/loganmc10,[WIP] Fix FBInfo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/376,https://github.com/AmbientMalice,2,https://github.com/mupen64plus/mupen64plus-core/pull/376#issuecomment-325594147,"This makes the FBInfo API work as well as it does with Mupen64. It's still not perfect (doesn't work with Banjo-Kazooie or Pokemon Snap, but neither does Mupen64).
I believe there are some writes (maybe reads) in the PI controller that need to be tracked using pre_framebuffer_write/read, but I can't get it working quite right. It seems to work in 1964 using GLideN64, at least the puzzle transition in Banjo does. The camera in Pokemon Snap doesn't seem to work in 1964 so I can't see if the red dot is there.
I'll keep working on this to see if I can get Pokemon Snap and Banjo working
TODO:

Get it working with new dynarec
Waiting for GLideN64 to fix FBInfo on it's side, so this can be properly tested
Potentially need to add some pre_framebuffer_write/read to PI DMA
Would like to have a way to communicate to the graphics plugin that FBInfo has been fixed. My idea is to write a 1 to fb->infos[0].addr before the first call to gfx.fBGetFrameBufferInfo this can be a signal to the GFX plugin, a sort of ""version number"", telling it that the FBInfo implementation has changed/is working.",It would be ideal if the stability issue in Pokemon Snap could be fixed because that's one of the use cases where this feature would be invaluable.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,376,2017-08-29T03:57:56Z,2017-11-02T14:29:22Z,2017-11-02T14:29:22Z,CLOSED,False,63,60,2,https://github.com/loganmc10,[WIP] Fix FBInfo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/376,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/376#issuecomment-325717892,"This makes the FBInfo API work as well as it does with Mupen64. It's still not perfect (doesn't work with Banjo-Kazooie or Pokemon Snap, but neither does Mupen64).
I believe there are some writes (maybe reads) in the PI controller that need to be tracked using pre_framebuffer_write/read, but I can't get it working quite right. It seems to work in 1964 using GLideN64, at least the puzzle transition in Banjo does. The camera in Pokemon Snap doesn't seem to work in 1964 so I can't see if the red dot is there.
I'll keep working on this to see if I can get Pokemon Snap and Banjo working
TODO:

Get it working with new dynarec
Waiting for GLideN64 to fix FBInfo on it's side, so this can be properly tested
Potentially need to add some pre_framebuffer_write/read to PI DMA
Would like to have a way to communicate to the graphics plugin that FBInfo has been fixed. My idea is to write a 1 to fb->infos[0].addr before the first call to gfx.fBGetFrameBufferInfo this can be a signal to the GFX plugin, a sort of ""version number"", telling it that the FBInfo implementation has changed/is working.","Ok I figured out the issue. I moved unprotect/protect framebuffers to when VI_ORIGIN_REG is read, 1964 seems to do it when VI_ORIGIN_REG is written, but that didn't work for me:
https://github.com/LegendOfDragoon/1964-X/blob/7374fb0e5f175ecc2f2acfa089d0814bc7d99ae1/src/core/R4300i.cpp#L3474-L3485
Besides that, the only issue was the ""dirty page"" tracking, FBRead's should be ignored if the same 4K block has already been read. That system was broken, so I re-wrote it.
I tested various games, Banjo, Mario Kart, Dr Mario, they all look good now in GLideN64.
Could use some more testing, in GLideN64 you set ""DisableFBInfo"" to false to use this.
The red dot in Pokemon Snap is still missing. It only appears if CopyColorfromRDRAM is enabled, but then the screen flickers. Pokemon Snap doesn't work in 1964, and it freezes in Mupen64 when using FBInfo, so there is no other case to test against to see if it would work, so I assume it's working as it should now",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,376,2017-08-29T03:57:56Z,2017-11-02T14:29:22Z,2017-11-02T14:29:22Z,CLOSED,False,63,60,2,https://github.com/loganmc10,[WIP] Fix FBInfo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/376,https://github.com/fzurita,4,https://github.com/mupen64plus/mupen64plus-core/pull/376#issuecomment-325727646,"This makes the FBInfo API work as well as it does with Mupen64. It's still not perfect (doesn't work with Banjo-Kazooie or Pokemon Snap, but neither does Mupen64).
I believe there are some writes (maybe reads) in the PI controller that need to be tracked using pre_framebuffer_write/read, but I can't get it working quite right. It seems to work in 1964 using GLideN64, at least the puzzle transition in Banjo does. The camera in Pokemon Snap doesn't seem to work in 1964 so I can't see if the red dot is there.
I'll keep working on this to see if I can get Pokemon Snap and Banjo working
TODO:

Get it working with new dynarec
Waiting for GLideN64 to fix FBInfo on it's side, so this can be properly tested
Potentially need to add some pre_framebuffer_write/read to PI DMA
Would like to have a way to communicate to the graphics plugin that FBInfo has been fixed. My idea is to write a 1 to fb->infos[0].addr before the first call to gfx.fBGetFrameBufferInfo this can be a signal to the GFX plugin, a sort of ""version number"", telling it that the FBInfo implementation has changed/is working.","Cool, nice work. Is this working with the new ARM dynarec? From my inspection of the code a while back, it seemed like it completely bypassed the mechanism that would allow FBInfo to work.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,376,2017-08-29T03:57:56Z,2017-11-02T14:29:22Z,2017-11-02T14:29:22Z,CLOSED,False,63,60,2,https://github.com/loganmc10,[WIP] Fix FBInfo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/376,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/376#issuecomment-325730692,"This makes the FBInfo API work as well as it does with Mupen64. It's still not perfect (doesn't work with Banjo-Kazooie or Pokemon Snap, but neither does Mupen64).
I believe there are some writes (maybe reads) in the PI controller that need to be tracked using pre_framebuffer_write/read, but I can't get it working quite right. It seems to work in 1964 using GLideN64, at least the puzzle transition in Banjo does. The camera in Pokemon Snap doesn't seem to work in 1964 so I can't see if the red dot is there.
I'll keep working on this to see if I can get Pokemon Snap and Banjo working
TODO:

Get it working with new dynarec
Waiting for GLideN64 to fix FBInfo on it's side, so this can be properly tested
Potentially need to add some pre_framebuffer_write/read to PI DMA
Would like to have a way to communicate to the graphics plugin that FBInfo has been fixed. My idea is to write a 1 to fb->infos[0].addr before the first call to gfx.fBGetFrameBufferInfo this can be a signal to the GFX plugin, a sort of ""version number"", telling it that the FBInfo implementation has changed/is working.","lol I just realized that all my change did was completely disable FBInfo, so I need to keep digging... To be honest I don't really see the benefit of this API. It doesn't actually increase compatibility, or allow previously un-rendered effects to render.
It's just a speed thing, to try and notify the graphics plugin which parts of which framebuffers have been modified by the CPU. I haven't seen any real concrete evidence that it provides a noticeable speed boost. I'm starting to think we should just remove it, GLideN64 can render all these effects without the help of this API.
The only real benefit I could possibly see is that it could reduce the amount of data copied over via glReadPixels, since it can just read a chunk of the framebuffer instead of the whole thing, but even that is disabled by default:

Read color buffer by chunks. When enabled, plugin follows FBInfo specification: ""Notify the dll that the frame buffer memory is beening read at the given address. ... DLL should copy 4KB block content back to RDRAM frame buffer."" Plugin will read only chunks of data, explicitly requested by emulator. It may reduce overheads if only few 4KB chunks have to be read. If CPU wants to modify whole buffer, read by chunks will be much slower. Since CPU usually needs the whole color buffer, that option is off by default.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,376,2017-08-29T03:57:56Z,2017-11-02T14:29:22Z,2017-11-02T14:29:22Z,CLOSED,False,63,60,2,https://github.com/loganmc10,[WIP] Fix FBInfo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/376,https://github.com/fzurita,6,https://github.com/mupen64plus/mupen64plus-core/pull/376#issuecomment-325731447,"This makes the FBInfo API work as well as it does with Mupen64. It's still not perfect (doesn't work with Banjo-Kazooie or Pokemon Snap, but neither does Mupen64).
I believe there are some writes (maybe reads) in the PI controller that need to be tracked using pre_framebuffer_write/read, but I can't get it working quite right. It seems to work in 1964 using GLideN64, at least the puzzle transition in Banjo does. The camera in Pokemon Snap doesn't seem to work in 1964 so I can't see if the red dot is there.
I'll keep working on this to see if I can get Pokemon Snap and Banjo working
TODO:

Get it working with new dynarec
Waiting for GLideN64 to fix FBInfo on it's side, so this can be properly tested
Potentially need to add some pre_framebuffer_write/read to PI DMA
Would like to have a way to communicate to the graphics plugin that FBInfo has been fixed. My idea is to write a 1 to fb->infos[0].addr before the first call to gfx.fBGetFrameBufferInfo this can be a signal to the GFX plugin, a sort of ""version number"", telling it that the FBInfo implementation has changed/is working.",This API is good for cases where async copies to RDRAM break certain game effects. Synchronous copies to RDRAM cause a very large slow down.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,376,2017-08-29T03:57:56Z,2017-11-02T14:29:22Z,2017-11-02T14:29:22Z,CLOSED,False,63,60,2,https://github.com/loganmc10,[WIP] Fix FBInfo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/376,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/376#issuecomment-325733412,"This makes the FBInfo API work as well as it does with Mupen64. It's still not perfect (doesn't work with Banjo-Kazooie or Pokemon Snap, but neither does Mupen64).
I believe there are some writes (maybe reads) in the PI controller that need to be tracked using pre_framebuffer_write/read, but I can't get it working quite right. It seems to work in 1964 using GLideN64, at least the puzzle transition in Banjo does. The camera in Pokemon Snap doesn't seem to work in 1964 so I can't see if the red dot is there.
I'll keep working on this to see if I can get Pokemon Snap and Banjo working
TODO:

Get it working with new dynarec
Waiting for GLideN64 to fix FBInfo on it's side, so this can be properly tested
Potentially need to add some pre_framebuffer_write/read to PI DMA
Would like to have a way to communicate to the graphics plugin that FBInfo has been fixed. My idea is to write a 1 to fb->infos[0].addr before the first call to gfx.fBGetFrameBufferInfo this can be a signal to the GFX plugin, a sort of ""version number"", telling it that the FBInfo implementation has changed/is working.","But how does this API make a difference? The API just uses synchronous copies to copy the data, whether it's a chunk, or the whole thing (which is the default).
I guess I got the Mario Kart screen working, so I can test the difference in speed there, but I don't really see how it could make things faster",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,376,2017-08-29T03:57:56Z,2017-11-02T14:29:22Z,2017-11-02T14:29:22Z,CLOSED,False,63,60,2,https://github.com/loganmc10,[WIP] Fix FBInfo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/376,https://github.com/fzurita,8,https://github.com/mupen64plus/mupen64plus-core/pull/376#issuecomment-325734293,"This makes the FBInfo API work as well as it does with Mupen64. It's still not perfect (doesn't work with Banjo-Kazooie or Pokemon Snap, but neither does Mupen64).
I believe there are some writes (maybe reads) in the PI controller that need to be tracked using pre_framebuffer_write/read, but I can't get it working quite right. It seems to work in 1964 using GLideN64, at least the puzzle transition in Banjo does. The camera in Pokemon Snap doesn't seem to work in 1964 so I can't see if the red dot is there.
I'll keep working on this to see if I can get Pokemon Snap and Banjo working
TODO:

Get it working with new dynarec
Waiting for GLideN64 to fix FBInfo on it's side, so this can be properly tested
Potentially need to add some pre_framebuffer_write/read to PI DMA
Would like to have a way to communicate to the graphics plugin that FBInfo has been fixed. My idea is to write a 1 to fb->infos[0].addr before the first call to gfx.fBGetFrameBufferInfo this can be a signal to the GFX plugin, a sort of ""version number"", telling it that the FBInfo implementation has changed/is working.",It makes things faster because it will only make the video plugin do a glReadPixels when the data is actually needed and not every frame.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,376,2017-08-29T03:57:56Z,2017-11-02T14:29:22Z,2017-11-02T14:29:22Z,CLOSED,False,63,60,2,https://github.com/loganmc10,[WIP] Fix FBInfo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/376,https://github.com/loganmc10,9,https://github.com/mupen64plus/mupen64plus-core/pull/376#issuecomment-325744258,"This makes the FBInfo API work as well as it does with Mupen64. It's still not perfect (doesn't work with Banjo-Kazooie or Pokemon Snap, but neither does Mupen64).
I believe there are some writes (maybe reads) in the PI controller that need to be tracked using pre_framebuffer_write/read, but I can't get it working quite right. It seems to work in 1964 using GLideN64, at least the puzzle transition in Banjo does. The camera in Pokemon Snap doesn't seem to work in 1964 so I can't see if the red dot is there.
I'll keep working on this to see if I can get Pokemon Snap and Banjo working
TODO:

Get it working with new dynarec
Waiting for GLideN64 to fix FBInfo on it's side, so this can be properly tested
Potentially need to add some pre_framebuffer_write/read to PI DMA
Would like to have a way to communicate to the graphics plugin that FBInfo has been fixed. My idea is to write a 1 to fb->infos[0].addr before the first call to gfx.fBGetFrameBufferInfo this can be a signal to the GFX plugin, a sort of ""version number"", telling it that the FBInfo implementation has changed/is working.","Well I feel really stupid/not so stupid. I've been testing 1964, since I heard that's the only emulator that supports this, but I didn't realize that FBInfo is disabled by default on the emulator side. When I enable ""Frame Buffer R/W"", then I have the exact same issue in Banjo and Pokemon Snap that I've been having here.
So as of right now I don't think there are any issues with this implementation, it seems like FBInfo in GLideN64 is broken or something",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,376,2017-08-29T03:57:56Z,2017-11-02T14:29:22Z,2017-11-02T14:29:22Z,CLOSED,False,63,60,2,https://github.com/loganmc10,[WIP] Fix FBInfo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/376,https://github.com/loganmc10,10,https://github.com/mupen64plus/mupen64plus-core/pull/376#issuecomment-325798278,"This makes the FBInfo API work as well as it does with Mupen64. It's still not perfect (doesn't work with Banjo-Kazooie or Pokemon Snap, but neither does Mupen64).
I believe there are some writes (maybe reads) in the PI controller that need to be tracked using pre_framebuffer_write/read, but I can't get it working quite right. It seems to work in 1964 using GLideN64, at least the puzzle transition in Banjo does. The camera in Pokemon Snap doesn't seem to work in 1964 so I can't see if the red dot is there.
I'll keep working on this to see if I can get Pokemon Snap and Banjo working
TODO:

Get it working with new dynarec
Waiting for GLideN64 to fix FBInfo on it's side, so this can be properly tested
Potentially need to add some pre_framebuffer_write/read to PI DMA
Would like to have a way to communicate to the graphics plugin that FBInfo has been fixed. My idea is to write a 1 to fb->infos[0].addr before the first call to gfx.fBGetFrameBufferInfo this can be a signal to the GFX plugin, a sort of ""version number"", telling it that the FBInfo implementation has changed/is working.","It makes things faster because it will only make the video plugin do a glReadPixels when the data is actually needed and not every frame.

Thanks for explaining, hopefully it can get sorted out in the GLideN64 side.
As for your question about the new dynarec, no it probably won't work right now. It probably won't require much to make it work, I'll just have to wrap some alternate code inside ifdef NEW_DYNAREC that uses read_rdram_new/write_rdram_new instead of the regular one. Once it's fixed on GLideN64's side and I can actually test and make sure everything is working I'll do that part.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,376,2017-08-29T03:57:56Z,2017-11-02T14:29:22Z,2017-11-02T14:29:22Z,CLOSED,False,63,60,2,https://github.com/loganmc10,[WIP] Fix FBInfo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/376,https://github.com/AmbientMalice,11,https://github.com/mupen64plus/mupen64plus-core/pull/376#issuecomment-325815198,"This makes the FBInfo API work as well as it does with Mupen64. It's still not perfect (doesn't work with Banjo-Kazooie or Pokemon Snap, but neither does Mupen64).
I believe there are some writes (maybe reads) in the PI controller that need to be tracked using pre_framebuffer_write/read, but I can't get it working quite right. It seems to work in 1964 using GLideN64, at least the puzzle transition in Banjo does. The camera in Pokemon Snap doesn't seem to work in 1964 so I can't see if the red dot is there.
I'll keep working on this to see if I can get Pokemon Snap and Banjo working
TODO:

Get it working with new dynarec
Waiting for GLideN64 to fix FBInfo on it's side, so this can be properly tested
Potentially need to add some pre_framebuffer_write/read to PI DMA
Would like to have a way to communicate to the graphics plugin that FBInfo has been fixed. My idea is to write a 1 to fb->infos[0].addr before the first call to gfx.fBGetFrameBufferInfo this can be a signal to the GFX plugin, a sort of ""version number"", telling it that the FBInfo implementation has changed/is working.",@loganmc10 Be aware that vanilla 1964 has a broken implementation that slows to a crawl in games like Mario Kart.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,376,2017-08-29T03:57:56Z,2017-11-02T14:29:22Z,2017-11-02T14:29:22Z,CLOSED,False,63,60,2,https://github.com/loganmc10,[WIP] Fix FBInfo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/376,https://github.com/loganmc10,12,https://github.com/mupen64plus/mupen64plus-core/pull/376#issuecomment-325817070,"This makes the FBInfo API work as well as it does with Mupen64. It's still not perfect (doesn't work with Banjo-Kazooie or Pokemon Snap, but neither does Mupen64).
I believe there are some writes (maybe reads) in the PI controller that need to be tracked using pre_framebuffer_write/read, but I can't get it working quite right. It seems to work in 1964 using GLideN64, at least the puzzle transition in Banjo does. The camera in Pokemon Snap doesn't seem to work in 1964 so I can't see if the red dot is there.
I'll keep working on this to see if I can get Pokemon Snap and Banjo working
TODO:

Get it working with new dynarec
Waiting for GLideN64 to fix FBInfo on it's side, so this can be properly tested
Potentially need to add some pre_framebuffer_write/read to PI DMA
Would like to have a way to communicate to the graphics plugin that FBInfo has been fixed. My idea is to write a 1 to fb->infos[0].addr before the first call to gfx.fBGetFrameBufferInfo this can be a signal to the GFX plugin, a sort of ""version number"", telling it that the FBInfo implementation has changed/is working.","Yeah that shouldn't happen here. I've got it so it doesn't do duplicate reads, that is the part that was missing in 1964 (that is also the part that is currently broken in mupen64plus, the duplicate read tracking is broken, and it skips all the reads).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,376,2017-08-29T03:57:56Z,2017-11-02T14:29:22Z,2017-11-02T14:29:22Z,CLOSED,False,63,60,2,https://github.com/loganmc10,[WIP] Fix FBInfo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/376,https://github.com/AmbientMalice,13,https://github.com/mupen64plus/mupen64plus-core/pull/376#issuecomment-325817347,"This makes the FBInfo API work as well as it does with Mupen64. It's still not perfect (doesn't work with Banjo-Kazooie or Pokemon Snap, but neither does Mupen64).
I believe there are some writes (maybe reads) in the PI controller that need to be tracked using pre_framebuffer_write/read, but I can't get it working quite right. It seems to work in 1964 using GLideN64, at least the puzzle transition in Banjo does. The camera in Pokemon Snap doesn't seem to work in 1964 so I can't see if the red dot is there.
I'll keep working on this to see if I can get Pokemon Snap and Banjo working
TODO:

Get it working with new dynarec
Waiting for GLideN64 to fix FBInfo on it's side, so this can be properly tested
Potentially need to add some pre_framebuffer_write/read to PI DMA
Would like to have a way to communicate to the graphics plugin that FBInfo has been fixed. My idea is to write a 1 to fb->infos[0].addr before the first call to gfx.fBGetFrameBufferInfo this can be a signal to the GFX plugin, a sort of ""version number"", telling it that the FBInfo implementation has changed/is working.","To be honest I don't really see the benefit of this API. It doesn't actually increase compatibility, or allow previously un-rendered effects to render.

It allows the plugin to render above native resolution while rendering CPU framebuffer effects. This is an extremely problematic behavior in games like Jet Force Gemini, and of course Pokemon Snap. You just want to read the red pixels from the centre of the screen. You don't want to copy the entire framebuffer and paste it on the screen.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,376,2017-08-29T03:57:56Z,2017-11-02T14:29:22Z,2017-11-02T14:29:22Z,CLOSED,False,63,60,2,https://github.com/loganmc10,[WIP] Fix FBInfo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/376,None,14,https://github.com/mupen64plus/mupen64plus-core/pull/376#issuecomment-336817073,"This makes the FBInfo API work as well as it does with Mupen64. It's still not perfect (doesn't work with Banjo-Kazooie or Pokemon Snap, but neither does Mupen64).
I believe there are some writes (maybe reads) in the PI controller that need to be tracked using pre_framebuffer_write/read, but I can't get it working quite right. It seems to work in 1964 using GLideN64, at least the puzzle transition in Banjo does. The camera in Pokemon Snap doesn't seem to work in 1964 so I can't see if the red dot is there.
I'll keep working on this to see if I can get Pokemon Snap and Banjo working
TODO:

Get it working with new dynarec
Waiting for GLideN64 to fix FBInfo on it's side, so this can be properly tested
Potentially need to add some pre_framebuffer_write/read to PI DMA
Would like to have a way to communicate to the graphics plugin that FBInfo has been fixed. My idea is to write a 1 to fb->infos[0].addr before the first call to gfx.fBGetFrameBufferInfo this can be a signal to the GFX plugin, a sort of ""version number"", telling it that the FBInfo implementation has changed/is working.","which would be expensive, especially at 1080p and above.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,376,2017-08-29T03:57:56Z,2017-11-02T14:29:22Z,2017-11-02T14:29:22Z,CLOSED,False,63,60,2,https://github.com/loganmc10,[WIP] Fix FBInfo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/376,https://github.com/AmbientMalice,15,https://github.com/mupen64plus/mupen64plus-core/pull/376#issuecomment-340623888,"This makes the FBInfo API work as well as it does with Mupen64. It's still not perfect (doesn't work with Banjo-Kazooie or Pokemon Snap, but neither does Mupen64).
I believe there are some writes (maybe reads) in the PI controller that need to be tracked using pre_framebuffer_write/read, but I can't get it working quite right. It seems to work in 1964 using GLideN64, at least the puzzle transition in Banjo does. The camera in Pokemon Snap doesn't seem to work in 1964 so I can't see if the red dot is there.
I'll keep working on this to see if I can get Pokemon Snap and Banjo working
TODO:

Get it working with new dynarec
Waiting for GLideN64 to fix FBInfo on it's side, so this can be properly tested
Potentially need to add some pre_framebuffer_write/read to PI DMA
Would like to have a way to communicate to the graphics plugin that FBInfo has been fixed. My idea is to write a 1 to fb->infos[0].addr before the first call to gfx.fBGetFrameBufferInfo this can be a signal to the GFX plugin, a sort of ""version number"", telling it that the FBInfo implementation has changed/is working.",Would it be possible to get a build with this enabled for testing? I'd like to see how things are working with GLideN64 now.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,376,2017-08-29T03:57:56Z,2017-11-02T14:29:22Z,2017-11-02T14:29:22Z,CLOSED,False,63,60,2,https://github.com/loganmc10,[WIP] Fix FBInfo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/376,https://github.com/loganmc10,16,https://github.com/mupen64plus/mupen64plus-core/pull/376#issuecomment-340767121,"This makes the FBInfo API work as well as it does with Mupen64. It's still not perfect (doesn't work with Banjo-Kazooie or Pokemon Snap, but neither does Mupen64).
I believe there are some writes (maybe reads) in the PI controller that need to be tracked using pre_framebuffer_write/read, but I can't get it working quite right. It seems to work in 1964 using GLideN64, at least the puzzle transition in Banjo does. The camera in Pokemon Snap doesn't seem to work in 1964 so I can't see if the red dot is there.
I'll keep working on this to see if I can get Pokemon Snap and Banjo working
TODO:

Get it working with new dynarec
Waiting for GLideN64 to fix FBInfo on it's side, so this can be properly tested
Potentially need to add some pre_framebuffer_write/read to PI DMA
Would like to have a way to communicate to the graphics plugin that FBInfo has been fixed. My idea is to write a 1 to fb->infos[0].addr before the first call to gfx.fBGetFrameBufferInfo this can be a signal to the GFX plugin, a sort of ""version number"", telling it that the FBInfo implementation has changed/is working.","@AmbientMalice gonetz posted a zilmar-spec build here: gonetz/GLideN64@58636fc#commitcomment-25299034
the mupen64plus implementation isn't really ready for testing yet. The Banjo puzzle transition still doesn't work, and Mario Kart crashes, both issues that 1964 doesn't have. Now that we have a better implementation in GLideN64, I'm going to work on improving the mupen64plus side of things",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,376,2017-08-29T03:57:56Z,2017-11-02T14:29:22Z,2017-11-02T14:29:22Z,CLOSED,False,63,60,2,https://github.com/loganmc10,[WIP] Fix FBInfo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/376,https://github.com/loganmc10,17,https://github.com/mupen64plus/mupen64plus-core/pull/376#issuecomment-341439075,"This makes the FBInfo API work as well as it does with Mupen64. It's still not perfect (doesn't work with Banjo-Kazooie or Pokemon Snap, but neither does Mupen64).
I believe there are some writes (maybe reads) in the PI controller that need to be tracked using pre_framebuffer_write/read, but I can't get it working quite right. It seems to work in 1964 using GLideN64, at least the puzzle transition in Banjo does. The camera in Pokemon Snap doesn't seem to work in 1964 so I can't see if the red dot is there.
I'll keep working on this to see if I can get Pokemon Snap and Banjo working
TODO:

Get it working with new dynarec
Waiting for GLideN64 to fix FBInfo on it's side, so this can be properly tested
Potentially need to add some pre_framebuffer_write/read to PI DMA
Would like to have a way to communicate to the graphics plugin that FBInfo has been fixed. My idea is to write a 1 to fb->infos[0].addr before the first call to gfx.fBGetFrameBufferInfo this can be a signal to the GFX plugin, a sort of ""version number"", telling it that the FBInfo implementation has changed/is working.","I've messed around with this quite a bit, looking at 1964's implementation. I can't get the puzzle transition in Banjo Kazooie to work properly.
I'm pretty much out of ideas so I'm going to close this. Someone else can give another stab at it in a different PR if desired. The implementation in GLideN64 still has some issues, Mario 64 freezes right at the intro for instance, so there are other issues as well. I think some PR recently also broke FBInfo with the dynarec, it only seems to work with the interpreter now (crashes with dynarec for me)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,380,2017-09-01T01:37:23Z,2017-09-12T07:45:01Z,2017-09-12T07:45:01Z,CLOSED,False,1,1,1,https://github.com/BanzaiMan,Add missing dependencies,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/380,https://github.com/BanzaiMan,1,https://github.com/mupen64plus/mupen64plus-core/pull/380,Resolves #377.,Resolves #377.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,380,2017-09-01T01:37:23Z,2017-09-12T07:45:01Z,2017-09-12T07:45:01Z,CLOSED,False,1,1,1,https://github.com/BanzaiMan,Add missing dependencies,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/380,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/380#issuecomment-326466106,Resolves #377.,"I don't know why it doesn't install the dependencies automatically, but it does seem to fix it since the Travis build succeeded, thanks",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,380,2017-09-01T01:37:23Z,2017-09-12T07:45:01Z,2017-09-12T07:45:01Z,CLOSED,False,1,1,1,https://github.com/BanzaiMan,Add missing dependencies,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/380,None,3,https://github.com/mupen64plus/mupen64plus-core/pull/380#issuecomment-326503277,Resolves #377.,It is a rather bad idea to install stuff which are dependencies for packages that are required by packages used by mupen64plus - BUT NOT actual dependencies for mupen64plus-core,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,380,2017-09-01T01:37:23Z,2017-09-12T07:45:01Z,2017-09-12T07:45:01Z,CLOSED,False,1,1,1,https://github.com/BanzaiMan,Add missing dependencies,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/380,None,4,https://github.com/mupen64plus/mupen64plus-core/pull/380#issuecomment-326509260,Resolves #377.,Please reject this pull request. #381 shows that apt-get on their servers is broken and currently makes problems. Adding these packages is not required to work around this problem.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,381,2017-09-01T07:18:57Z,2017-09-12T07:40:48Z,2017-09-12T07:40:48Z,MERGED,True,14,3,1,None,Let travis handle the package installation directly,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/381,None,1,https://github.com/mupen64plus/mupen64plus-core/pull/381,"The before_install  currently fails on Travis CI with:
The following packages have unmet dependencies:
 libsdl2-dev : Depends: libegl1-mesa-dev
               Depends: libgles2-mesa-dev
E: Unable to correct problems, you have held broken packages.

This can currently only be solved by using the apt addon to install packages.","The before_install  currently fails on Travis CI with:
The following packages have unmet dependencies:
 libsdl2-dev : Depends: libegl1-mesa-dev
               Depends: libgles2-mesa-dev
E: Unable to correct problems, you have held broken packages.

This can currently only be solved by using the apt addon to install packages.",True,{'THUMBS_UP': ['https://github.com/loganmc10']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,382,2017-09-01T07:33:24Z,2017-09-12T07:43:14Z,2017-09-12T07:43:14Z,MERGED,True,15,4,1,None,Use faster container based Travis CI,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/382,None,1,https://github.com/mupen64plus/mupen64plus-core/pull/382,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/Gillou68310,1,https://github.com/mupen64plus/mupen64plus-core/pull/383,#288,#288,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-327258235,#288,"Just tested this (including the WDC fix). WDC/Stunt Racer and Indiana Jones are working now, however Smash Bros no longer boots.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/Gillou68310,3,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-327273588,#288,Thanks could you check which one of the 2 commits broke smash bros? I guess it would be the first one. Did you test on arm or x86?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-327276525,#288,"I do that in a bit, I tested x86 (windows)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/Gillou68310,5,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-327413825,#288,Ok my fix for Indi on x86 is wrong. I can't force the shift value to be allocated to ECX because it's likely to break the register mapping when in a delay slot. I need to find another workaround!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/Gillou68310,6,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-327414187,#288,However my fix for ARM should be ok!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/Gillou68310,7,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-327893866,#288,"@loganmc10 I updated my fixes, could you check again for regressions?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-327897909,#288,"Smash Bros works now. Pokemon Puzzle League and both Banjo games now fail at the assert(0) in MULTDIV. Pokemon Puzzle League used to fail at a different assert (#304), but I believe the Banjo games used to work.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/Gillou68310,9,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-327910055,#288,Oups sorry I forgot to remove it. You can safely remove it if you want to do more tests ;-),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/loganmc10,10,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-327912552,#288,"Ok yeah removing that assert allows those 3 games to work normally.
I just ran across an issue in Conkers though:
Assertion failed!
File: ../../src/device/r4300/new_dynarec/x86/assem_x86.c, Line 777

Expression: rm<8

Doesn't happen in the current master, this is with x86",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/Gillou68310,11,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-327913158,#288,Thanks I'll investigate the issue!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/Gillou68310,12,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-328049789,#288,@loganmc10 I updated the fix for WDC. It should fix the issue in CBFD.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/loganmc10,13,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-328120395,#288,"Yep looks good to me now. I did all my testing on x86, not arm",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/fzurita,14,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-328416286,#288,"Ok, sorry for the delay. I just tried Indiana Jones with ARM Android, it's not crashing where it used to crash any more. I also tried several other games as sanity checks with no issue.
This looks good to me,",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/Gillou68310,15,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-328578885,#288,"Thanks for testing!
I just pushed a fix for Glover BTW ;-)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/loganmc10,16,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-328585243,#288,Does that fix perhaps also fix #304? I notice it modifies the assert that is failing in that issue,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/Gillou68310,17,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-328610830,#288,I didn't check but last time I invatigated this issue I think the problem was elsewhere. I need to double check!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/fzurita,18,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-328614478,#288,"Nice work, I'll try to test it soon.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/fzurita,19,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-329042268,#288,I can confirm that the glover fix works correctly. I did some sanity checks with a few common games and nothing seems to break.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/Narann,20,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-329089788,#288,@fzurita could you rebase on master so the TravisCI doesn't bug anymore.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/Gillou68310,21,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-329099548,#288,Done,True,{'HEART': ['https://github.com/Narann']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/Narann,22,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-329101718,#288,"It's passing the build. Is this ready for merge? As it's not that much, I would have loved to have @bsmiles32 view on this.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/Gillou68310,23,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-329104136,#288,"Nope it's not ready yet, I'm still working on the following issues:
#286 #304 #305
Also the fix for Glover might change because it accidentally fix #304 while it's not the root cause of the issue.
#385 will be for another PR",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/loganmc10,24,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-333182929,#288,"I would suggest perhaps merging this PR, and then submitting a new PR for the future fixes. The current fixes have been tested and we know they fix these games.
EDIT:
Oh I didn't notice this line:

Also the fix for Glover might change because it accidentally fix #304 while it's not the root cause of the issue.

I suppose that's why you are holding off",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/Gillou68310,25,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-333210811,#288,The fix for glover is not mergeable yet but the fix for WDC and indi could definitely be merged. Since I'm busy with other things right now I think it's a good idea to merge the 2 first commits until I come back to this!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/Narann,26,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-333227442,#288,@Gillou68310 You should have merge permission. Haven't you?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/Gillou68310,27,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-333474652,#288,Ok I pushed the fix for WDC and indi!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/fzurita,28,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-458138644,#288,Can this be merged now that you fixed Pokemon Puzzle league?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/Gillou68310,29,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-458139294,#288,I will double check that issue first,True,{'THUMBS_UP': ['https://github.com/gjimenezf']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,383,2017-09-01T15:25:32Z,2020-02-21T09:33:42Z,2021-07-15T08:42:31Z,CLOSED,False,12,6,1,https://github.com/Gillou68310,New dynarec fixes [WIP],1,[],https://github.com/mupen64plus/mupen64plus-core/pull/383,https://github.com/gjimenezf,30,https://github.com/mupen64plus/mupen64plus-core/pull/383#issuecomment-462597104,#288,Ready to close?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,386,2017-09-12T14:20:49Z,2017-09-13T18:03:22Z,2017-09-28T14:09:10Z,MERGED,True,1201,73,7,https://github.com/loganmc10,Switch from adler32 to xxHash,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/386,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/386,"You can see some performance benchmarks here (conducted in Java):
https://jpountz.github.io/lz4-java/1.3.0/xxhash-benchmark/
And you and read a bit more about xxHash here:
http://cyan4973.github.io/xxHash/
This should provide a performance improvement in the cached interpreter and dynarecs. xxHash is significantly faster than adler32, while still providing an accurate hash.","You can see some performance benchmarks here (conducted in Java):
https://jpountz.github.io/lz4-java/1.3.0/xxhash-benchmark/
And you and read a bit more about xxHash here:
http://cyan4973.github.io/xxHash/
This should provide a performance improvement in the cached interpreter and dynarecs. xxHash is significantly faster than adler32, while still providing an accurate hash.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,386,2017-09-12T14:20:49Z,2017-09-13T18:03:22Z,2017-09-28T14:09:10Z,MERGED,True,1201,73,7,https://github.com/loganmc10,Switch from adler32 to xxHash,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/386,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/386#issuecomment-328979496,"You can see some performance benchmarks here (conducted in Java):
https://jpountz.github.io/lz4-java/1.3.0/xxhash-benchmark/
And you and read a bit more about xxHash here:
http://cyan4973.github.io/xxHash/
This should provide a performance improvement in the cached interpreter and dynarecs. xxHash is significantly faster than adler32, while still providing an accurate hash.","Thanks. It could have been useful to bench real core situation.
As I'm not an expert in hash function I would love @bsmiles32 or @Gillou68310 to review this.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,386,2017-09-12T14:20:49Z,2017-09-13T18:03:22Z,2017-09-28T14:09:10Z,MERGED,True,1201,73,7,https://github.com/loganmc10,Switch from adler32 to xxHash,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/386,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/386#issuecomment-328980310,"You can see some performance benchmarks here (conducted in Java):
https://jpountz.github.io/lz4-java/1.3.0/xxhash-benchmark/
And you and read a bit more about xxHash here:
http://cyan4973.github.io/xxHash/
This should provide a performance improvement in the cached interpreter and dynarecs. xxHash is significantly faster than adler32, while still providing an accurate hash.","Yes when I get some time over the next few days I'll probably try to provide some benchmarks. I'm also not an expert, but I assume measuring how much time is spent in the TLBWrite function over a set number of frames would provide a pretty good benchmark for comparison.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,386,2017-09-12T14:20:49Z,2017-09-13T18:03:22Z,2017-09-28T14:09:10Z,MERGED,True,1201,73,7,https://github.com/loganmc10,Switch from adler32 to xxHash,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/386,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/386#issuecomment-329238390,"You can see some performance benchmarks here (conducted in Java):
https://jpountz.github.io/lz4-java/1.3.0/xxhash-benchmark/
And you and read a bit more about xxHash here:
http://cyan4973.github.io/xxHash/
This should provide a performance improvement in the cached interpreter and dynarecs. xxHash is significantly faster than adler32, while still providing an accurate hash.","Ok I tested this on Conker's Bad Fur Day. I let TLBWrite execute 10,000 times. I did it 12 times, throwing out the top and bottom values, and then averaged the remaining 10 values:
xxHash: TLBWrite executed for a total of 0.034939159 seconds on average (so those 10,000 executions took 0.034939159 seconds total)
adler32: TLBWrite executed for a total of 0.067649399 seconds on average.
So yes, as expected this change roughly doubles the speed of the TLBWrite function.",True,{'HOORAY': ['https://github.com/Narann']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,386,2017-09-12T14:20:49Z,2017-09-13T18:03:22Z,2017-09-28T14:09:10Z,MERGED,True,1201,73,7,https://github.com/loganmc10,Switch from adler32 to xxHash,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/386,https://github.com/Narann,5,https://github.com/mupen64plus/mupen64plus-core/pull/386#issuecomment-329249318,"You can see some performance benchmarks here (conducted in Java):
https://jpountz.github.io/lz4-java/1.3.0/xxhash-benchmark/
And you and read a bit more about xxHash here:
http://cyan4973.github.io/xxHash/
This should provide a performance improvement in the cached interpreter and dynarecs. xxHash is significantly faster than adler32, while still providing an accurate hash.",Here we go!!!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,387,2017-09-13T15:15:59Z,2017-09-13T15:51:18Z,2017-09-28T14:09:12Z,MERGED,True,0,2,1,https://github.com/loganmc10,Remove Rat Attack hack for new_dynarec,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/387,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/387,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,388,2017-09-13T22:01:01Z,2017-09-14T15:34:27Z,2017-09-28T14:09:03Z,MERGED,True,31,61,9,https://github.com/loganmc10,Remove DelaySI hack/option,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/388,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/388,"Right now we have the SI interrupt delayed in the majority of cases. The only case I know of where DelaySI needs to be off is Mischief Makers (input doesn't work with it enabled). However, I assume if 1 game has issues, others may as well.
The SI DMA has 2 parts: the DMA itself, and the PIF processing. This PR breaks those 2 steps up (right now they both happen at the beginning of the DMA). So for a DMA write, it does the DMA at the beginning of the DMA, and the PIF processing at the end. For a DMA read, it does the PIF processing at the beginning and the DMA at the end. You get the idea.
This removes the need to disable DelaySI for Mischief Makers. Therefore, I assume this is a more accurate way to represent the DMA, and we can remove the DelaySI option altogether.
I've tested a good number of games with this change and I've seen no regressions, however more testing is obviously welcome.","Right now we have the SI interrupt delayed in the majority of cases. The only case I know of where DelaySI needs to be off is Mischief Makers (input doesn't work with it enabled). However, I assume if 1 game has issues, others may as well.
The SI DMA has 2 parts: the DMA itself, and the PIF processing. This PR breaks those 2 steps up (right now they both happen at the beginning of the DMA). So for a DMA write, it does the DMA at the beginning of the DMA, and the PIF processing at the end. For a DMA read, it does the PIF processing at the beginning and the DMA at the end. You get the idea.
This removes the need to disable DelaySI for Mischief Makers. Therefore, I assume this is a more accurate way to represent the DMA, and we can remove the DelaySI option altogether.
I've tested a good number of games with this change and I've seen no regressions, however more testing is obviously welcome.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,388,2017-09-13T22:01:01Z,2017-09-14T15:34:27Z,2017-09-28T14:09:03Z,MERGED,True,31,61,9,https://github.com/loganmc10,Remove DelaySI hack/option,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/388,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/388#issuecomment-329509623,"Right now we have the SI interrupt delayed in the majority of cases. The only case I know of where DelaySI needs to be off is Mischief Makers (input doesn't work with it enabled). However, I assume if 1 game has issues, others may as well.
The SI DMA has 2 parts: the DMA itself, and the PIF processing. This PR breaks those 2 steps up (right now they both happen at the beginning of the DMA). So for a DMA write, it does the DMA at the beginning of the DMA, and the PIF processing at the end. For a DMA read, it does the PIF processing at the beginning and the DMA at the end. You get the idea.
This removes the need to disable DelaySI for Mischief Makers. Therefore, I assume this is a more accurate way to represent the DMA, and we can remove the DelaySI option altogether.
I've tested a good number of games with this change and I've seen no regressions, however more testing is obviously welcome.","By the way, it'd probably be better if #360 was merged before this. I don't mind rebasing this, I'm just putting it here now for review",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,388,2017-09-13T22:01:01Z,2017-09-14T15:34:27Z,2017-09-28T14:09:03Z,MERGED,True,31,61,9,https://github.com/loganmc10,Remove DelaySI hack/option,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/388,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/388#issuecomment-329516351,"Right now we have the SI interrupt delayed in the majority of cases. The only case I know of where DelaySI needs to be off is Mischief Makers (input doesn't work with it enabled). However, I assume if 1 game has issues, others may as well.
The SI DMA has 2 parts: the DMA itself, and the PIF processing. This PR breaks those 2 steps up (right now they both happen at the beginning of the DMA). So for a DMA write, it does the DMA at the beginning of the DMA, and the PIF processing at the end. For a DMA read, it does the PIF processing at the beginning and the DMA at the end. You get the idea.
This removes the need to disable DelaySI for Mischief Makers. Therefore, I assume this is a more accurate way to represent the DMA, and we can remove the DelaySI option altogether.
I've tested a good number of games with this change and I've seen no regressions, however more testing is obviously welcome.","Looks ok to me. I also tested some games with it and saw no regressions (Mischief Maker, Diddy Kong Racing, Blast Corp, Banjo-Tooie).
If you can fix the trailing space and look if also setting the DMA_BUSY for dma_si_read is okay (tested this myself but you can double check) then I'm ok to get this merged.
Good work on removing these hacks !",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,388,2017-09-13T22:01:01Z,2017-09-14T15:34:27Z,2017-09-28T14:09:03Z,MERGED,True,31,61,9,https://github.com/loganmc10,Remove DelaySI hack/option,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/388,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/388#issuecomment-329517331,"Right now we have the SI interrupt delayed in the majority of cases. The only case I know of where DelaySI needs to be off is Mischief Makers (input doesn't work with it enabled). However, I assume if 1 game has issues, others may as well.
The SI DMA has 2 parts: the DMA itself, and the PIF processing. This PR breaks those 2 steps up (right now they both happen at the beginning of the DMA). So for a DMA write, it does the DMA at the beginning of the DMA, and the PIF processing at the end. For a DMA read, it does the PIF processing at the beginning and the DMA at the end. You get the idea.
This removes the need to disable DelaySI for Mischief Makers. Therefore, I assume this is a more accurate way to represent the DMA, and we can remove the DelaySI option altogether.
I've tested a good number of games with this change and I've seen no regressions, however more testing is obviously welcome.","setting the DMA_BUSY for dma_si_read is okay (tested this myself but you can double check)

I thought it broke the input in Mischief Makers, but maybe I'm remembering just setting DMA_BUSY, and not RD_BUSY and DMA_BUSY, in any event, I don't think it should be set (#388 (comment))",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,388,2017-09-13T22:01:01Z,2017-09-14T15:34:27Z,2017-09-28T14:09:03Z,MERGED,True,31,61,9,https://github.com/loganmc10,Remove DelaySI hack/option,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/388,https://github.com/bsmiles32,5,https://github.com/mupen64plus/mupen64plus-core/pull/388#issuecomment-329520494,"Right now we have the SI interrupt delayed in the majority of cases. The only case I know of where DelaySI needs to be off is Mischief Makers (input doesn't work with it enabled). However, I assume if 1 game has issues, others may as well.
The SI DMA has 2 parts: the DMA itself, and the PIF processing. This PR breaks those 2 steps up (right now they both happen at the beginning of the DMA). So for a DMA write, it does the DMA at the beginning of the DMA, and the PIF processing at the end. For a DMA read, it does the PIF processing at the beginning and the DMA at the end. You get the idea.
This removes the need to disable DelaySI for Mischief Makers. Therefore, I assume this is a more accurate way to represent the DMA, and we can remove the DelaySI option altogether.
I've tested a good number of games with this change and I've seen no regressions, however more testing is obviously welcome.","@loganmc10 Thanks for the explanation. Then I'm okay with the PR. Merging this.

Also, I'm indeed very busy atm, that's why PR accumulates. Don't desperate, I'll review everything when I get the chance (and usually you do very good work so it's ok). I also saw your mail on the mailing list, I'll try to answer it when I can !
@Narann thanks for merging some other PR recently, as I wasn't available to do it !",True,{'HEART': ['https://github.com/Narann']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,390,2017-09-14T09:37:17Z,2017-09-14T15:47:47Z,2017-09-15T18:19:15Z,MERGED,True,26,103,6,https://github.com/Gillou68310,Fix set_fpr_pointers,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/390,https://github.com/Gillou68310,1,https://github.com/mupen64plus/mupen64plus-core/pull/390,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,390,2017-09-14T09:37:17Z,2017-09-14T15:47:47Z,2017-09-15T18:19:15Z,MERGED,True,26,103,6,https://github.com/Gillou68310,Fix set_fpr_pointers,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/390,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/390#issuecomment-329493793,,"As part of this PR, I would also remove CountPerOp=1 for Rogue Squadron and Battle for Naboo. It was added as a workaround for this problem, but the games perform better with the default CountPerOp, and I'm not aware of any other issues when using the default",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,390,2017-09-14T09:37:17Z,2017-09-14T15:47:47Z,2017-09-15T18:19:15Z,MERGED,True,26,103,6,https://github.com/Gillou68310,Fix set_fpr_pointers,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/390,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/390#issuecomment-329518115,,Quickly tested and looked okay to me.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,390,2017-09-14T09:37:17Z,2017-09-14T15:47:47Z,2017-09-15T18:19:15Z,MERGED,True,26,103,6,https://github.com/Gillou68310,Fix set_fpr_pointers,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/390,https://github.com/Gillou68310,4,https://github.com/mupen64plus/mupen64plus-core/pull/390#issuecomment-329523069,,"As part of this PR, I would also remove CountPerOp=1 for Rogue Squadron and Battle for Naboo. It was added as a workaround for this problem, but the games perform better with the default CountPerOp, and I'm not aware of any other issues when using the default

Done",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,390,2017-09-14T09:37:17Z,2017-09-14T15:47:47Z,2017-09-15T18:19:15Z,MERGED,True,26,103,6,https://github.com/Gillou68310,Fix set_fpr_pointers,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/390,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/390#issuecomment-329544971,,"@AmbientMalice I know I've said this so many times, but after this latest group of PR's, I believe the Trading Post in Indiana Jones is really fixed. I played through the first 2 levels twice with a fresh config each time. The game still needs CountPerOp=2 to boot, so I'm curious if that causes any issues, I know you mentioned it has in the past with some physics stuff.
Anyway if you ever get a chance can you try the latest at https://m64p.github.io ? I know you have an interest in this game which is why I bring it up. If you do test I would delete any .eep saves you might have for the game beforehand, although I'm not 100% if it would make a difference.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,390,2017-09-14T09:37:17Z,2017-09-14T15:47:47Z,2017-09-15T18:19:15Z,MERGED,True,26,103,6,https://github.com/Gillou68310,Fix set_fpr_pointers,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/390,https://github.com/AmbientMalice,6,https://github.com/mupen64plus/mupen64plus-core/pull/390#issuecomment-329608549,,I'll give it a try this weekend.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,390,2017-09-14T09:37:17Z,2017-09-14T15:47:47Z,2017-09-15T18:19:15Z,MERGED,True,26,103,6,https://github.com/Gillou68310,Fix set_fpr_pointers,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/390,https://github.com/AmbientMalice,7,https://github.com/mupen64plus/mupen64plus-core/pull/390#issuecomment-329723304,,"@loganmc10 Indiana Jones appears to be working near-perfectly now. (Demanding as heck on multi-threaded Angrylion's.) The raft no longer freezes the game momentarily on CF=2, but I haven't tested the jeep. I'm up to the third mission with no freezes. The third mission could be a fly in the ointment, and I probably should finish it -- but all signs seem positive.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,390,2017-09-14T09:37:17Z,2017-09-14T15:47:47Z,2017-09-15T18:19:15Z,MERGED,True,26,103,6,https://github.com/Gillou68310,Fix set_fpr_pointers,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/390,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/390#issuecomment-329860918,,"Awesome that's really encouraging to hear! I'll be curious to hear about the 3rd level/Jeep, I've never gotten that far in my testing",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,393,2017-09-14T18:39:13Z,2017-09-14T19:25:20Z,2017-09-28T14:09:02Z,MERGED,True,3,3,1,https://github.com/loganmc10,Fix description of some core config variables,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/393,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/393,"This PR is to address #374
See:

  
    
      mupen64plus-core/src/main/main.c
    
    
        Lines 140 to 146
      in
      5c386fd
    
  
  
    

        
          
           if (!configpath || (strlen(configpath) == 0)) { 
        

        
          
               snprintf(path, 1024, ""%ssave%c"", ConfigGetUserDataPath(), OSAL_DIR_SEPARATORS[0]); 
        

        
          
               path[1023] = 0; 
        

        
          
           } else { 
        

        
          
               snprintf(path, 1024, ""%s%c"", configpath, OSAL_DIR_SEPARATORS[0]); 
        

        
          
               path[1023] = 0; 
        

        
          
           } 
        
    
  


It's actually using UserDataPath, not UserConfigPath as the default (these happen to be the same if the frontend/user hasn't specified something different for UserConfigPath, but if they have, then they are different. They are always different on Linux)","This PR is to address #374
See:

  
    
      mupen64plus-core/src/main/main.c
    
    
        Lines 140 to 146
      in
      5c386fd
    
  
  
    

        
          
           if (!configpath || (strlen(configpath) == 0)) { 
        

        
          
               snprintf(path, 1024, ""%ssave%c"", ConfigGetUserDataPath(), OSAL_DIR_SEPARATORS[0]); 
        

        
          
               path[1023] = 0; 
        

        
          
           } else { 
        

        
          
               snprintf(path, 1024, ""%s%c"", configpath, OSAL_DIR_SEPARATORS[0]); 
        

        
          
               path[1023] = 0; 
        

        
          
           } 
        
    
  


It's actually using UserDataPath, not UserConfigPath as the default (these happen to be the same if the frontend/user hasn't specified something different for UserConfigPath, but if they have, then they are different. They are always different on Linux)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,394,2017-09-14T21:21:36Z,2017-09-14T21:36:45Z,2017-09-28T14:09:00Z,MERGED,True,1,0,1,https://github.com/loganmc10,CountPerOp=1 for Yakouchuu II - Satsujin Kouro,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/394,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/394,See #392,See #392,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,399,2017-09-18T17:37:28Z,2017-09-21T05:40:09Z,2017-09-28T14:08:55Z,MERGED,True,1,1,1,https://github.com/loganmc10,Fix screenshots for games with colon in the title,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/399,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/399,Fix for #398,Fix for #398,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,400,2017-09-20T04:42:47Z,2017-09-20T05:25:28Z,2017-09-28T14:08:52Z,CLOSED,False,1,1,1,https://github.com/loganmc10,Correct error in PI dma for loop,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/400,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/400,"Spotted by @richard42
#375 (comment)","Spotted by @richard42
#375 (comment)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,400,2017-09-20T04:42:47Z,2017-09-20T05:25:28Z,2017-09-28T14:08:52Z,CLOSED,False,1,1,1,https://github.com/loganmc10,Correct error in PI dma for loop,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/400,https://github.com/richard42,2,https://github.com/mupen64plus/mupen64plus-core/pull/400#issuecomment-330748685,"Spotted by @richard42
#375 (comment)","oops, didn't see this. I just pushed the same change.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,401,2017-09-20T07:59:31Z,2017-09-21T06:17:56Z,2017-09-21T10:35:30Z,MERGED,True,3,0,1,https://github.com/Narann,Add travisCI and coverity badges,1,['continuous integration'],https://github.com/mupen64plus/mupen64plus-core/pull/401,https://github.com/Narann,1,https://github.com/mupen64plus/mupen64plus-core/pull/401,"I added TravisCI and Coverity badges. As I don't know if this has already been discussed before, feel free to refuse this PR if you think it's a bad idea.","I added TravisCI and Coverity badges. As I don't know if this has already been discussed before, feel free to refuse this PR if you think it's a bad idea.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,403,2017-09-21T15:52:16Z,2017-09-21T22:33:50Z,2017-09-28T14:08:33Z,MERGED,True,1,0,1,https://github.com/loganmc10,Fix save size for Custom Robo V2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/403,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/403,Fixes #402,Fixes #402,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,403,2017-09-21T15:52:16Z,2017-09-21T22:33:50Z,2017-09-28T14:08:33Z,MERGED,True,1,0,1,https://github.com/loganmc10,Fix save size for Custom Robo V2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/403,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/403#issuecomment-331300446,Fixes #402,"Merged, but @loganmc10, could you point your source for save size? :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,403,2017-09-21T15:52:16Z,2017-09-21T22:33:50Z,2017-09-28T14:08:33Z,MERGED,True,1,0,1,https://github.com/loganmc10,Fix save size for Custom Robo V2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/403,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/403#issuecomment-331315976,Fixes #402,"Sure, like I mentioned, I realized that the issue was with eeprom saving. So I looked at the PJ64 RDB to see if they have any special settings for this game, and I saw that they have 16KB eeprom set. I tested that out and it fixed all the issues, and here we are!",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,403,2017-09-21T15:52:16Z,2017-09-21T22:33:50Z,2017-09-28T14:08:33Z,MERGED,True,1,0,1,https://github.com/loganmc10,Fix save size for Custom Robo V2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/403,https://github.com/Narann,4,https://github.com/mupen64plus/mupen64plus-core/pull/403#issuecomment-331366201,Fixes #402,I was expecting a wonderful list of all N64 games save sizes. ;D,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,404,2017-09-22T16:06:19Z,2017-09-23T00:09:35Z,2017-09-28T14:08:30Z,MERGED,True,8,0,1,https://github.com/loganmc10,Add entry for 007 - Goldfinger,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/404,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/404,"You can read about it here:
http://goldeneyevault.com/viewfile.php?id=349
Performs better with CountPerOp=1","You can read about it here:
http://goldeneyevault.com/viewfile.php?id=349
Performs better with CountPerOp=1",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,404,2017-09-22T16:06:19Z,2017-09-23T00:09:35Z,2017-09-28T14:08:30Z,MERGED,True,8,0,1,https://github.com/loganmc10,Add entry for 007 - Goldfinger,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/404,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/404#issuecomment-331489923,"You can read about it here:
http://goldeneyevault.com/viewfile.php?id=349
Performs better with CountPerOp=1",Perhaps @AmbientMalice could verify the MD5 I got for the game? A56B15FAF24389DD375E7AFB03A7D3C1,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,404,2017-09-22T16:06:19Z,2017-09-23T00:09:35Z,2017-09-28T14:08:30Z,MERGED,True,8,0,1,https://github.com/loganmc10,Add entry for 007 - Goldfinger,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/404,https://github.com/AmbientMalice,3,https://github.com/mupen64plus/mupen64plus-core/pull/404#issuecomment-331581370,"You can read about it here:
http://goldeneyevault.com/viewfile.php?id=349
Performs better with CountPerOp=1",MD5 looks good.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,406,2017-09-25T10:53:12Z,2017-09-28T06:03:52Z,2017-10-05T08:21:19Z,MERGED,True,288,28,9,https://github.com/bsmiles32,Bump savestate format to 1.2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/406,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/406,"Recent development omitted to save several emulated device state
variables. We remedy this by appending them at the end of the savestate
file. When loading older savestate files (<1.2 or pj64) we adopt a best-effort
approach to set the missing state to a reasonnable state. But it may
cause some instability.","Recent development omitted to save several emulated device state
variables. We remedy this by appending them at the end of the savestate
file. When loading older savestate files (<1.2 or pj64) we adopt a best-effort
approach to set the missing state to a reasonnable state. But it may
cause some instability.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,406,2017-09-25T10:53:12Z,2017-09-28T06:03:52Z,2017-10-05T08:21:19Z,MERGED,True,288,28,9,https://github.com/bsmiles32,Bump savestate format to 1.2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/406,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/406#issuecomment-331846438,"Recent development omitted to save several emulated device state
variables. We remedy this by appending them at the end of the savestate
file. When loading older savestate files (<1.2 or pj64) we adopt a best-effort
approach to set the missing state to a reasonnable state. But it may
cause some instability.",Should fix #405. I also tested with WDC and it seems much better.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,406,2017-09-25T10:53:12Z,2017-09-28T06:03:52Z,2017-10-05T08:21:19Z,MERGED,True,288,28,9,https://github.com/bsmiles32,Bump savestate format to 1.2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/406,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/406#issuecomment-331888919,"Recent development omitted to save several emulated device state
variables. We remedy this by appending them at the end of the savestate
file. When loading older savestate files (<1.2 or pj64) we adopt a best-effort
approach to set the missing state to a reasonnable state. But it may
cause some instability.","I tested loading older save states and it works again. Looks good
I don't think we should store the fb stuff in the save state. fb->infos is supposed to be populated by the graphics plugin, I think if we re-populate it from the save state, the gfx plugin might not expect that.
Also, fb->once is used to disable dp->r4300->recomp.fast_memory. If we load the value of fb->once from the save state, we'll probably miss changing dp->r4300->recomp.fast_memory",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,406,2017-09-25T10:53:12Z,2017-09-28T06:03:52Z,2017-10-05T08:21:19Z,MERGED,True,288,28,9,https://github.com/bsmiles32,Bump savestate format to 1.2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/406,https://github.com/richard42,4,https://github.com/mupen64plus/mupen64plus-core/pull/406#issuecomment-332064569,"Recent development omitted to save several emulated device state
variables. We remedy this by appending them at the end of the savestate
file. When loading older savestate files (<1.2 or pj64) we adopt a best-effort
approach to set the missing state to a reasonnable state. But it may
cause some instability.","It looks good to me, except I would recommend using a different data type for serializing the time_t values:
https://stackoverflow.com/questions/13957254/c-c-safest-way-to-send-time-t-over-socket
Cast them to uint32_t or int64_t",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,406,2017-09-25T10:53:12Z,2017-09-28T06:03:52Z,2017-10-05T08:21:19Z,MERGED,True,288,28,9,https://github.com/bsmiles32,Bump savestate format to 1.2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/406,https://github.com/fzurita,5,https://github.com/mupen64plus/mupen64plus-core/pull/406#issuecomment-332389191,"Recent development omitted to save several emulated device state
variables. We remedy this by appending them at the end of the savestate
file. When loading older savestate files (<1.2 or pj64) we adopt a best-effort
approach to set the missing state to a reasonnable state. But it may
cause some instability.",It seems to have fixed the save state issues in mupen64plus-ae,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,406,2017-09-25T10:53:12Z,2017-09-28T06:03:52Z,2017-10-05T08:21:19Z,MERGED,True,288,28,9,https://github.com/bsmiles32,Bump savestate format to 1.2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/406,https://github.com/bsmiles32,6,https://github.com/mupen64plus/mupen64plus-core/pull/406#issuecomment-332648855,"Recent development omitted to save several emulated device state
variables. We remedy this by appending them at the end of the savestate
file. When loading older savestate files (<1.2 or pj64) we adopt a best-effort
approach to set the missing state to a reasonnable state. But it may
cause some instability.","@loganmc10 You're probably right about the fb state, so I removed that from this PR
@richard42 Now, I (de)serialize time_t variables as int64_t values to avoid the vagueness of specification o the time_t type.
Also I did 2 small fixes :

After re-initializing the pif channels, I need to call the input-plugin controllerCommand(-1,NULL) to notify that pif processing has ended
There was some extra for loops for channels re-initialization which were a left-over from other tries at fixing the problem.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,406,2017-09-25T10:53:12Z,2017-09-28T06:03:52Z,2017-10-05T08:21:19Z,MERGED,True,288,28,9,https://github.com/bsmiles32,Bump savestate format to 1.2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/406,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/406#issuecomment-332652017,"Recent development omitted to save several emulated device state
variables. We remedy this by appending them at the end of the savestate
file. When loading older savestate files (<1.2 or pj64) we adopt a best-effort
approach to set the missing state to a reasonnable state. But it may
cause some instability.","You've still got:
/* reset fb state */
    memset(&g_dev.dp.fb, 0, sizeof(g_dev.dp.fb));
    g_dev.dp.fb.once = 1;

in savestates.c in 2 spots that I see.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,406,2017-09-25T10:53:12Z,2017-09-28T06:03:52Z,2017-10-05T08:21:19Z,MERGED,True,288,28,9,https://github.com/bsmiles32,Bump savestate format to 1.2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/406,https://github.com/bsmiles32,8,https://github.com/mupen64plus/mupen64plus-core/pull/406#issuecomment-332658179,"Recent development omitted to save several emulated device state
variables. We remedy this by appending them at the end of the savestate
file. When loading older savestate files (<1.2 or pj64) we adopt a best-effort
approach to set the missing state to a reasonnable state. But it may
cause some instability.","I thought that, resetting the fb state would allow the video plugin to start from a state that it knows how to deals with (eg same as poweron). Otherwise, if I don't put anything, fb state will be uninitialized which seems worse to me. Did I miss something here ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,406,2017-09-25T10:53:12Z,2017-09-28T06:03:52Z,2017-10-05T08:21:19Z,MERGED,True,288,28,9,https://github.com/bsmiles32,Bump savestate format to 1.2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/406,https://github.com/loganmc10,9,https://github.com/mupen64plus/mupen64plus-core/pull/406#issuecomment-332667421,"Recent development omitted to save several emulated device state
variables. We remedy this by appending them at the end of the savestate
file. When loading older savestate files (<1.2 or pj64) we adopt a best-effort
approach to set the missing state to a reasonnable state. But it may
cause some instability.","No you are right, I've never looked at how the save states worked very closely. For some reason I assumed that poweron() would execute again, but it doesn't seem that way. It's good like it is now",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,406,2017-09-25T10:53:12Z,2017-09-28T06:03:52Z,2017-10-05T08:21:19Z,MERGED,True,288,28,9,https://github.com/bsmiles32,Bump savestate format to 1.2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/406,https://github.com/bsmiles32,10,https://github.com/mupen64plus/mupen64plus-core/pull/406#issuecomment-332669686,"Recent development omitted to save several emulated device state
variables. We remedy this by appending them at the end of the savestate
file. When loading older savestate files (<1.2 or pj64) we adopt a best-effort
approach to set the missing state to a reasonnable state. But it may
cause some instability.",Good. I guess it is mergeable now !,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,407,2017-09-25T18:37:38Z,2017-09-25T21:28:33Z,2017-09-28T14:08:28Z,MERGED,True,19,0,1,https://github.com/loganmc10,Add AppVeyor config,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/407,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/407,"AppVeyor is like Travis for Windows.
This will do 2 things for us: it will automatically test the Windows/MSVC builds, just like Travis does for the Unix builds.
It will also test the x86 new dynarec for us, hopefully this will allow us to catch any compile-time errors to the new dynarec.
Someone is going to need to configure the GitHub repo to integrate with AppVeyor, I assume @Narann might know how to do this.","AppVeyor is like Travis for Windows.
This will do 2 things for us: it will automatically test the Windows/MSVC builds, just like Travis does for the Unix builds.
It will also test the x86 new dynarec for us, hopefully this will allow us to catch any compile-time errors to the new dynarec.
Someone is going to need to configure the GitHub repo to integrate with AppVeyor, I assume @Narann might know how to do this.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,407,2017-09-25T18:37:38Z,2017-09-25T21:28:33Z,2017-09-28T14:08:28Z,MERGED,True,19,0,1,https://github.com/loganmc10,Add AppVeyor config,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/407,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/407#issuecomment-331996534,"AppVeyor is like Travis for Windows.
This will do 2 things for us: it will automatically test the Windows/MSVC builds, just like Travis does for the Unix builds.
It will also test the x86 new dynarec for us, hopefully this will allow us to catch any compile-time errors to the new dynarec.
Someone is going to need to configure the GitHub repo to integrate with AppVeyor, I assume @Narann might know how to do this.","Anyone have opinion about integrating AppVeyor? Looks like it's not a ""Github App"". @bsmiles32 @Gillou68310 @richard42 ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,407,2017-09-25T18:37:38Z,2017-09-25T21:28:33Z,2017-09-28T14:08:28Z,MERGED,True,19,0,1,https://github.com/loganmc10,Add AppVeyor config,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/407,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/407#issuecomment-331997268,"AppVeyor is like Travis for Windows.
This will do 2 things for us: it will automatically test the Windows/MSVC builds, just like Travis does for the Unix builds.
It will also test the x86 new dynarec for us, hopefully this will allow us to catch any compile-time errors to the new dynarec.
Someone is going to need to configure the GitHub repo to integrate with AppVeyor, I assume @Narann might know how to do this.","It does integrate with GitHub, if you look at the buildbot-type-thing I do for m64p.github.io, you can see:
https://github.com/m64p/mupen64plus-GLideN64/commits/master
If you hover over the green check marks, you'll see that it does Travis and AppVeyor. It will pass or fail PR's just like Travis does. However, in the settings for that repo it does show up under ""Webhooks"" instead of ""Integrations and Services"". I think you have to set it up from the AppVeyor website instead of from the GitHub website
EDIT: https://github.com/marketplace/appveyor",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,407,2017-09-25T18:37:38Z,2017-09-25T21:28:33Z,2017-09-28T14:08:28Z,MERGED,True,19,0,1,https://github.com/loganmc10,Add AppVeyor config,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/407,https://github.com/Gillou68310,4,https://github.com/mupen64plus/mupen64plus-core/pull/407#issuecomment-331998620,"AppVeyor is like Travis for Windows.
This will do 2 things for us: it will automatically test the Windows/MSVC builds, just like Travis does for the Unix builds.
It will also test the x86 new dynarec for us, hopefully this will allow us to catch any compile-time errors to the new dynarec.
Someone is going to need to configure the GitHub repo to integrate with AppVeyor, I assume @Narann might know how to do this.",It looks good to me!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,407,2017-09-25T18:37:38Z,2017-09-25T21:28:33Z,2017-09-28T14:08:28Z,MERGED,True,19,0,1,https://github.com/loganmc10,Add AppVeyor config,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/407,https://github.com/bsmiles32,5,https://github.com/mupen64plus/mupen64plus-core/pull/407#issuecomment-332012238,"AppVeyor is like Travis for Windows.
This will do 2 things for us: it will automatically test the Windows/MSVC builds, just like Travis does for the Unix builds.
It will also test the x86 new dynarec for us, hopefully this will allow us to catch any compile-time errors to the new dynarec.
Someone is going to need to configure the GitHub repo to integrate with AppVeyor, I assume @Narann might know how to do this.","I for one would be very pleased when this gets merged, as I'm one of the worst offender when it comes to break Windows builds. Hope this will helps me avoid these issues in the future.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,407,2017-09-25T18:37:38Z,2017-09-25T21:28:33Z,2017-09-28T14:08:28Z,MERGED,True,19,0,1,https://github.com/loganmc10,Add AppVeyor config,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/407,https://github.com/Narann,6,https://github.com/mupen64plus/mupen64plus-core/pull/407#issuecomment-332019086,"AppVeyor is like Travis for Windows.
This will do 2 things for us: it will automatically test the Windows/MSVC builds, just like Travis does for the Unix builds.
It will also test the x86 new dynarec for us, hopefully this will allow us to catch any compile-time errors to the new dynarec.
Someone is going to need to configure the GitHub repo to integrate with AppVeyor, I assume @Narann might know how to do this.",I'm preparing the stuff right now. It looks seriously intrusive but that's why I asked after all! :),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,410,2017-09-27T14:12:43Z,2017-09-27T20:45:54Z,2017-09-28T14:08:26Z,MERGED,True,3,0,1,https://github.com/loganmc10,Fix slowdowns in Mischief Makers,1,['bug'],https://github.com/mupen64plus/mupen64plus-core/pull/410,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/410,Fixes #409,Fixes #409,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,410,2017-09-27T14:12:43Z,2017-09-27T20:45:54Z,2017-09-28T14:08:26Z,MERGED,True,3,0,1,https://github.com/loganmc10,Fix slowdowns in Mischief Makers,1,['bug'],https://github.com/mupen64plus/mupen64plus-core/pull/410,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/410#issuecomment-332537502,Fixes #409,"Hey by the way it looks like the AppVeyor checks are working, thanks @Narann !",True,{'HOORAY': ['https://github.com/Narann']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,410,2017-09-27T14:12:43Z,2017-09-27T20:45:54Z,2017-09-28T14:08:26Z,MERGED,True,3,0,1,https://github.com/loganmc10,Fix slowdowns in Mischief Makers,1,['bug'],https://github.com/mupen64plus/mupen64plus-core/pull/410,https://github.com/Narann,3,https://github.com/mupen64plus/mupen64plus-core/pull/410#issuecomment-332573082,Fixes #409,I realize we put CountPerOp=1 for many games recently. Is this really the solution?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,410,2017-09-27T14:12:43Z,2017-09-27T20:45:54Z,2017-09-28T14:08:26Z,MERGED,True,3,0,1,https://github.com/loganmc10,Fix slowdowns in Mischief Makers,1,['bug'],https://github.com/mupen64plus/mupen64plus-core/pull/410,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/410#issuecomment-332574596,Fixes #409,"It's definitely the worst thing about the emulator currently (accuracy wise). Every N64 emulator I know of (except CEN64) uses this hack (1964, Project64, mupen64, mupen64plus). By default it increments the COUNT register by 2 for every operation, but that's not how it worked on the N64.
I've never seen any solid proposal on how to fix this problem without going ""all in"" like CEN64 does.
But to answer your question, yes, it fixes some games, breaks others. BattleTanx needs CountPerOp=3 to even boot. Resident Evil needs CountPerOp=1 for the voices to work. Rogue Squadron needs CountPerOp=1 to prevent sound crackling during the opening Star Wars scroll, but it causes the CPU usage to go up, so we leave it at 2.
The list goes on and on, almost every game is likely affected in some way. If someone could come up with a better way to emulate the COUNT register without killing the performance it would be a massive step forward for N64 emulation",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/411,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.",True,{'HOORAY': ['https://github.com/Narann']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-332793997,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","Thanks @bsmiles32, looks like we have a fail with appveyor. Do you have access to the build log?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-332829078,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","@Narann Yep, I saw the build logs and I was just me not updating the msvc project files properly.... Should be fixed with the new commits. Thank you (@Narann and @loganmc10 ) very much for having setup this AppVeyor thing, me likes it very much !!!",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-332845139,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","I'll test this out in a bit, but it looks like the docs still need to be updated to include M64CMD_SET_GB_CART_LOADER
Also, main.c currently has an implementation of the loader functions. Was that just for testing?  There is a null version but it's ifdef'ed out",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/bsmiles32,5,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-332847099,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","but it looks like the docs still need to be updated to include M64CMD_SET_GB_CART_LOADER

Yep

Also, main.c currently has an implementation of the loader functions. Was that just for testing? There is a null version but it's ifdef'ed out

Yep, it was just to ease testing, but shouldn't be part of the final merge. Still for local quick testing, it's more convenient than the hard-coded gb roms that were previously inside the source :)
Also, I will update the rom db a bit to allow proper pak compatibility.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-332860532,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","Ok I got around to testing it (with Pokemon Stadium). Seems like it's working properly. What games actually support Pak switching? Pokemon Stadium does not it seems.
One thing: it seems like some variables might not be re-initializing properly? If I open Pokemon Stadium to this point:

And then Pak switch, I get this:

Which I'm sure is normal, the game says not to do that. However, if I then restart the game, I get that same ""Transfer Pak is not set properly"" message. If I restart it a third time, then it's back to normal. I'm testing this in my GUI, so ""CoreStartup"" isn't being called between games, it's just executing M64CMD_STOP and then M64CMD_EXECUTE to stop/start the game.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-332861585,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","Sorry, one other question, I haven't looked through the code extremely close. Does this support changing the GB cart mid-game? Like is there a way to simulate removing the Transfer Pak, changing the GB cart, and then re-inserting the Transfer Pak? Or even just switching the GB cart with the Transfer Pak still inserted, did any games do this?
As long as init_ram/init_rom are called each time the Transfer Pak is inserted then I assume it would work, but is there a way to simulate removing/reinserting the transfer pak?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/bsmiles32,8,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-332863227,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","What games actually support Pak switching?

Perfect Dark
For Pokemon Stadium, I got the same message when switching paks in-game. I had to reset the console for it work normal. But I'll have to investigate your unitialized variable issue.

Sorry, one other question, I haven't looked through the code extremely close. Does this support changing the GB cart mid-game? Like is there a way to simulate removing the Transfer Pak, changing the GB cart, and then re-inserting the Transfer Pak?
As long as init_ram/init_rom are called each time the Transfer Pak is inserted then I assume it would work, but is there a way to simulate removing/reinserting the transfer pak?

This is still not implemented. I would have to re-purpose the ""rumble switch"" button for that I guess. But yeah, that would be cool to have :) Especially for pokemon.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/loganmc10,9,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-332864036,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","It seems like the ""Mempak"" settings in the INI file might be redundant, wouldn't it make more sense to check if the SaveType is ""Controller Pak"" and then just add the Transferpak entry for the games that support it?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/bsmiles32,10,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-332864600,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","It seems like the ""Mempak"" settings in the INI file might be redundant, wouldn't it make more sense to check if the SaveType is ""Controller Pak"" and then just add the Transferpak entry for the games that support it?

The Mempak seems redundant at first, but some games support both in cartridge save and Mempak (eg Perfect Dark). See http://s9.zetaboards.com/Nintendo_64_Forever/topic/7041206/1/ for a good list.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/loganmc10,11,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-332866940,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","Couldn't we just change SaveType into an array of 5 chars (the number of different save types) and change the INI parser to support commas? like SaveType=Eeprom 16KB, Controller Pack
I know it would make the code a little more complex but it would make the INI file a little easier to understand",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/bsmiles32,12,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-332868811,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","I'm open to suggestions as for the db format, I just went with what seemed the easiest for me without much thinking. I'll push what I have or now, and when the format is settled I will try to continue the tedious work :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/bsmiles32,13,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-333626809,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","@loganmc10 GB cart switching is implemented now. When press the ""Rumble Switch"" button, the GB cart loading procedure is triggered. I might have forgotten to disable that with games incompatible with the tpak, but yeah, I can add that later if needed.
If you keep the PR as is, you can edit the mupen64plus.cfg file while the game is running, and then press the ""Rumble Switch"" button to make the core load the new gb cart.
I tested with Perfect Dark (because it's the game that supports all paks, and allow to change between them en live, no need to reboot). I also tested with Pokemon Stadium, but this one requires a reset after changing the pak/GB cart. I also tried with Pokemon Stadium 2, but it requires a reset when changing paks/GB carts and we have some bugs preventing proper reset.
Enjoy !
Edit : I also remove the dependence on SDL_GetTicks(), and used a simple counter instead.
About the db format, should we extend the SaveType to accept several types (comma separated ?) or should SaveType be reserved for the CartSaveType (Flash,SRAM,Eeprom 4k, Eeprom 16k) and just add a MemPak=Yes for the games that accepts the mempak. This would match other paks style : rumblepak, transferpak and maybe in the future the bio sensor pak :)
For more context, I may try in a more or less distant future to put more stuff in the rom db, especially cart types such as what do we map at 0x08000000 (none, flash, sram or something else), or what joybus device si connected inside the cart (none, eeprom, rtc, ....). That will allow for a more declarative style, and avoid the auto-detect flash/sram heuristic that we have now or avoid having both eeprom and rtc initialized (when none, or only one is effectively used). Also this would pave the way for more exotic N64 accessories/carts...
I might also add in the db if the game expects|is compatible with a VRU or a train controller, ...
@richard42 Any thoughts ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/loganmc10,14,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-333629909,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","About the db format, should we extend the SaveType to accept several types (comma separated ?) or should SaveType be reserved for the CartSaveType (Flash,SRAM,Eeprom 4k, Eeprom 16k) and just add a MemPak=Yes for the games that accepts the mempak. This would match other paks style : rumblepak, transferpak and maybe in the future the bio sensor pak :)

I'm fine with whatever, just having ""SaveType=None"" and ""MemPak=Yes"" seemed a little confusing, renaming SaveType to CartSaveType makes more sense.
I still have the issue in Pokemon Stadium where the """"Transfer Pak is not set properly"" message will persist between games. It displays it if I open the ROM a second time, but not the third time. I'll try and see why that might be.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/loganmc10,15,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-333633941,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","@bsmiles32 I notice in the logs it prints out:
Core: Removing pak from controller 0

The second time I start the game, so it looks like it calls main_switch_pak() or something",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/bsmiles32,16,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-333709639,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","Went through the full rom dataset to add/adjust mempak/rumble/transferpak entries. USA and Europe sets should be almost good (except for mistakes on my side as it is a tiring process). Japanese set is much harder for me because I don't understand Japanese, so I can't know what's compatible.
For now, only paks marked as compatible are switchable with the pak switch button, but as the db is still a bit WIP, it might be better to allow all kind of paks until we are more confident with the db ? Or keep it that way and have user report when they encounter a problem ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/bsmiles32,17,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-333786476,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.",@loganmc10 Can you test if my latest commit fixes your stop/execute initialization issue ? I think it was due to the usage of initialized static variables inside function which are initialized only once and not at emulation start.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/bsmiles32,18,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-333850749,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","Ok, now this PR should be complete. Documentation has been updated, API version bumped, some minor refactorings, and gb cart change button disabled when the game is not compatible with the transferpak.
Some more testing is welcome.
NOTE : the gb_cart_loader functions have been slightly changed compared to the initial plan (better names, simpler prototype).
After this gets merged, maybe we should change the names of the Mempak Switch and Rumble switch buttons to a more appropriate name such as ""Pak switch"" and ""GB cart change"" buttons in the input plugin ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/tony971,19,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-333865030,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.",Will this feature have compatibility with libretro .srm-style saves? Or just the traditional .sav files?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/bsmiles32,20,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-333867839,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.",Don't know much about the libretro srm format sorry. The core just expects a file with the RAM content. This also mean that for now RTC data that some GB emu adds at the end of sav files is not supported.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/loganmc10,21,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-333882033,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","@bsmiles32 now in Pokemon Stadium I get a ""Saved file not found"" message. If I revert the last commit, then it works as normal, here is what is in the log file:
Core: GB Loader ROM: C:\Games\N64\pokered\pokered.gb - zu
Core: GB cart type (13) mbc3 RAM BATT
Core: Providing default RAM content
Core: GB Loader RAM: C:\Games\N64\pokered\pokered.sav - zu
Core: Using a 32768 bytes GB RAM
Core: Game controller 0 (Standard controller) has a Transfer pak plugged in

Also, shouldn't all the stuff inside the #if 1 go away before this is merged? The issue with stopping/restarting does seem to be fixed in the latest commit BTW",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/bsmiles32,22,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-333973527,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","@loganmc10 The empty save issue is due to having a save file of different size from what the game expects. Here pokemon should have a 32k save, but I assume you had a <32k save. I reverted to the old way and be more forgiving about size mismatches.
I've also disabled the testing code in this PR, but will leave it in there until the ui-console is updated to provide this functionality.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/loganmc10,23,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-333980600,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.",Ok looks good to me! Everything is working as expected,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/tony971,24,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-334003436,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","Don't know much about the libretro srm format sorry. The core just expects a file with the RAM content.

From what I can tell, the .srm file format is just a raw save ram dump. In the case of  game boy saves, the files should contain the same data, but with different file sizes.
https://forums.libretro.com/t/srm-to-sav-incompatibilities/1075
https://forums.libretro.com/t/solved-save-game-compatibility-help/932
Edit: found a better forum link.
https://forums.libretro.com/t/can-i-convert-my-gameboy-color-saves-to-a-format-usable-on-another-emulator/2212/4",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/bsmiles32,25,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-334007051,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","Now that GB CART LOADER functions have been added to the ui-console, I've removed the testing code from this PR.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/bsmiles32,26,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-334442300,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.",Updated against master.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/richard42,27,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-334619040,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","After this is merged, do we need to remove the ""Rumble Pak"" switch from all of the InputAutoConfig.ini sections, and the corresponding input plugin code?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/bsmiles32,28,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-334677617,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","No. The rumble switch button has been repurposed to change GB cart. So after merging we could rename both mempak and rumblepak switch buttons to ""Pak switch"" and ""GB cart switch"". And remove Pak switching code from input plugin.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/bsmiles32,29,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-334902897,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","I was thinking we could generalize in the future the GB cart loader interface to more kind of content not necessarily GB related. For instance PIF Boot ROM, 64DD Disks, cart ROM, flash, SRAM or Eeprom, .... If so we should rename it to a more generic name such as : ""frontend loader"" and rename the current functions to load_gb_rom, load_gb_ram, or something like that. What do you think ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/tony971,30,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-334939200,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","""Accessory loader"" sounds more obvious, but I may be misunderstanding the intention.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/richard42,31,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-335033649,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","Regarding generalizing the interface and re-using for other purposes; this is kind of a weird API in that the front-end registers a callback which then gets executed when the core needs to load the GB data. For other data loading needs, we have different mechanisms. The ROM is loaded with an explicit core command (""pushed"" by the front-end). EEPROM/SRAM save data is (de)serialized from files by the core itself. Do you think there are any other data types for which it makes sense to use a callback architecture like this, as opposed to something more conventional?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/bsmiles32,32,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-335796117,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","My first candidate for extending this loading API are the 64dd disks because they can be swapped in-game just like the gb carts or the {mem,rumble,transfer}paks. But as you point out the frontend could also be ""pushing"" them to the core instead of having the core ""pull"" them. For the GB cart having it this way allows to centralize the GB cart parsing/loading procedure inside the core and not split it across multiple frontends. But for 64dd disks, this may or may not be the best.
Then after thinking about the 64dd disks, I thought, why not use this mechanism for all other cases. That's why I proposed it for other types of saved content (sram, flash, eeprom, mempaks), PIF Boot ROM [not yet supported], and even cart rom. I know some of them are already handled internally by the core, but this forces ""fixed"" names for the saved content decided by the core, not the user. It is not a very big deal, but I think it would have been a nice thing to have.
All in all, it was more a ""what if"" type of question to see what others were thinking, not a definite proposition. I would rather see that PR merged sooner and re-examine when needed how we want to extend the API.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/richard42,33,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-336013044,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","I don't really like this callback type mechanism for loading everything, due to the extra complexity. I can see that it's useful for the GB carts, so that's okay, and it may make sense for the DD disks as well. But I would avoid using it for other things if possible. I understand your point about having filenames fixed by the core, but this can also be an advantage as it allows different front-ends to use the same savestates.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/bsmiles32,34,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-336596882,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.","Renamed GB cart loader to a more generic name : media loader. That way, we can extend this mecanism to 64dd disks in the future without keeping a confusing name.
PR mupen64plus/mupen64plus-ui-console#41 has also been updated accordingly.
@richard42 Any other blocking issue before merging this ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,411,2017-09-28T09:51:08Z,2017-10-14T01:30:30Z,2017-11-02T01:53:33Z,MERGED,True,3156,1933,68,https://github.com/bsmiles32,More si refactorings,27,[],https://github.com/mupen64plus/mupen64plus-core/pull/411,https://github.com/richard42,35,https://github.com/mupen64plus/mupen64plus-core/pull/411#issuecomment-336599770,"Main items of this work are :

input backend API now only consists of 1 function - to get the input state. Pak detection and Controller connection test are handled internally by the core.
Preliminary N64 Mouse support
Extraction of controllers and paks from si into their own subdirectories
Extraction of a cart subdirectory (with eeprom and af_rtc for now, other pi devices will also go there)
Separation of backends interface from their mutable state
Implement pak switching logic by reusing the ""Mempak switch"" button
Use the internal rom db to know which paks are compatible with a game, and only switch theses
Preliminary implementation of gb cart loader core command (for the Core-side). see #337 for anterior discussion.

Please test and report issues.",now it has conflicts with your memory refactoring changes. I think you can merge this (and ui-console PR #41) after this is fixed.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,415,2017-10-01T18:56:21Z,2017-10-15T03:06:40Z,2017-11-09T15:50:18Z,MERGED,True,37,7,9,https://github.com/loganmc10,Randomize PI/SI interrupt timing,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/415,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/415,"This is to address #361
This is ready, but I put the WIP tag because it should get some testing. Right now I've only done very limited testing.
2 easy tests for this: The intro to Smash Bros and Star Wars Ep I Racer. The master hand should pull a random character out of the box, right now it always pulls out Mario. The Ep I Racer intro should either be Anakin or Subulba, right now it's always Subulba.
I added a core option to enable/disable randomizing the interrupt timing. Disabling it will be needed for some scenarios like regression testing, netplay, and possibly TAS runs. I think enabling it by default would be good, since it's more similar to how the N64 operated, assuming there aren't any regressions.","This is to address #361
This is ready, but I put the WIP tag because it should get some testing. Right now I've only done very limited testing.
2 easy tests for this: The intro to Smash Bros and Star Wars Ep I Racer. The master hand should pull a random character out of the box, right now it always pulls out Mario. The Ep I Racer intro should either be Anakin or Subulba, right now it's always Subulba.
I added a core option to enable/disable randomizing the interrupt timing. Disabling it will be needed for some scenarios like regression testing, netplay, and possibly TAS runs. I think enabling it by default would be good, since it's more similar to how the N64 operated, assuming there aren't any regressions.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,415,2017-10-01T18:56:21Z,2017-10-15T03:06:40Z,2017-11-09T15:50:18Z,MERGED,True,37,7,9,https://github.com/loganmc10,Randomize PI/SI interrupt timing,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/415,https://github.com/AmbientMalice,2,https://github.com/mupen64plus/mupen64plus-core/pull/415#issuecomment-333415740,"This is to address #361
This is ready, but I put the WIP tag because it should get some testing. Right now I've only done very limited testing.
2 easy tests for this: The intro to Smash Bros and Star Wars Ep I Racer. The master hand should pull a random character out of the box, right now it always pulls out Mario. The Ep I Racer intro should either be Anakin or Subulba, right now it's always Subulba.
I added a core option to enable/disable randomizing the interrupt timing. Disabling it will be needed for some scenarios like regression testing, netplay, and possibly TAS runs. I think enabling it by default would be good, since it's more similar to how the N64 operated, assuming there aren't any regressions.",Someone who's familiar with Mario Kart 64's correct behavior can hopefully comment on whether this fixes the wrong items being given to the player repeatedly.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,415,2017-10-01T18:56:21Z,2017-10-15T03:06:40Z,2017-11-09T15:50:18Z,MERGED,True,37,7,9,https://github.com/loganmc10,Randomize PI/SI interrupt timing,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/415,https://github.com/theboy181,3,https://github.com/mupen64plus/mupen64plus-core/pull/415#issuecomment-333418800,"This is to address #361
This is ready, but I put the WIP tag because it should get some testing. Right now I've only done very limited testing.
2 easy tests for this: The intro to Smash Bros and Star Wars Ep I Racer. The master hand should pull a random character out of the box, right now it always pulls out Mario. The Ep I Racer intro should either be Anakin or Subulba, right now it's always Subulba.
I added a core option to enable/disable randomizing the interrupt timing. Disabling it will be needed for some scenarios like regression testing, netplay, and possibly TAS runs. I think enabling it by default would be good, since it's more similar to how the N64 operated, assuming there aren't any regressions.",You have a PR forPJ64 handy? like to test too.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,415,2017-10-01T18:56:21Z,2017-10-15T03:06:40Z,2017-11-09T15:50:18Z,MERGED,True,37,7,9,https://github.com/loganmc10,Randomize PI/SI interrupt timing,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/415,https://github.com/AmbientMalice,4,https://github.com/mupen64plus/mupen64plus-core/pull/415#issuecomment-333420948,"This is to address #361
This is ready, but I put the WIP tag because it should get some testing. Right now I've only done very limited testing.
2 easy tests for this: The intro to Smash Bros and Star Wars Ep I Racer. The master hand should pull a random character out of the box, right now it always pulls out Mario. The Ep I Racer intro should either be Anakin or Subulba, right now it's always Subulba.
I added a core option to enable/disable randomizing the interrupt timing. Disabling it will be needed for some scenarios like regression testing, netplay, and possibly TAS runs. I think enabling it by default would be good, since it's more similar to how the N64 operated, assuming there aren't any regressions.","You have a PR forPJ64 handy? like to test too.

Project 64 works slightly differently current. If you turn off Fixed Audio Timing in PJ64, most RNG stuff should work okay. PJ64 needs a new audio plugin, for a start. Zilmar does seem to be working on something.
That said, this hack could probably apply to PJ64. It's probably a better solution than whatever PJ64 is currently accidentally exploiting.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,415,2017-10-01T18:56:21Z,2017-10-15T03:06:40Z,2017-11-09T15:50:18Z,MERGED,True,37,7,9,https://github.com/loganmc10,Randomize PI/SI interrupt timing,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/415,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/415#issuecomment-333639762,"This is to address #361
This is ready, but I put the WIP tag because it should get some testing. Right now I've only done very limited testing.
2 easy tests for this: The intro to Smash Bros and Star Wars Ep I Racer. The master hand should pull a random character out of the box, right now it always pulls out Mario. The Ep I Racer intro should either be Anakin or Subulba, right now it's always Subulba.
I added a core option to enable/disable randomizing the interrupt timing. Disabling it will be needed for some scenarios like regression testing, netplay, and possibly TAS runs. I think enabling it by default would be good, since it's more similar to how the N64 operated, assuming there aren't any regressions.","OK I've had a chance to test this a bit more. I don't see any regressions. I also tested the first level of Indiana Jones twice, since that was a game that always locked up at the end in the past, it worked both times.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,415,2017-10-01T18:56:21Z,2017-10-15T03:06:40Z,2017-11-09T15:50:18Z,MERGED,True,37,7,9,https://github.com/loganmc10,Randomize PI/SI interrupt timing,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/415,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/415#issuecomment-333641925,"This is to address #361
This is ready, but I put the WIP tag because it should get some testing. Right now I've only done very limited testing.
2 easy tests for this: The intro to Smash Bros and Star Wars Ep I Racer. The master hand should pull a random character out of the box, right now it always pulls out Mario. The Ep I Racer intro should either be Anakin or Subulba, right now it's always Subulba.
I added a core option to enable/disable randomizing the interrupt timing. Disabling it will be needed for some scenarios like regression testing, netplay, and possibly TAS runs. I think enabling it by default would be good, since it's more similar to how the N64 operated, assuming there aren't any regressions.","Here is a 64-bit Windows build if anyone would like to test:
mupen64plus-GLideN64-rng.zip",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,415,2017-10-01T18:56:21Z,2017-10-15T03:06:40Z,2017-11-09T15:50:18Z,MERGED,True,37,7,9,https://github.com/loganmc10,Randomize PI/SI interrupt timing,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/415,https://github.com/AmbientMalice,7,https://github.com/mupen64plus/mupen64plus-core/pull/415#issuecomment-333779451,"This is to address #361
This is ready, but I put the WIP tag because it should get some testing. Right now I've only done very limited testing.
2 easy tests for this: The intro to Smash Bros and Star Wars Ep I Racer. The master hand should pull a random character out of the box, right now it always pulls out Mario. The Ep I Racer intro should either be Anakin or Subulba, right now it's always Subulba.
I added a core option to enable/disable randomizing the interrupt timing. Disabling it will be needed for some scenarios like regression testing, netplay, and possibly TAS runs. I think enabling it by default would be good, since it's more similar to how the N64 operated, assuming there aren't any regressions.",Haven't noticed any regressions. Tested a few games including Mischief Makers.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,415,2017-10-01T18:56:21Z,2017-10-15T03:06:40Z,2017-11-09T15:50:18Z,MERGED,True,37,7,9,https://github.com/loganmc10,Randomize PI/SI interrupt timing,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/415,https://github.com/bsmiles32,8,https://github.com/mupen64plus/mupen64plus-core/pull/415#issuecomment-333855557,"This is to address #361
This is ready, but I put the WIP tag because it should get some testing. Right now I've only done very limited testing.
2 easy tests for this: The intro to Smash Bros and Star Wars Ep I Racer. The master hand should pull a random character out of the box, right now it always pulls out Mario. The Ep I Racer intro should either be Anakin or Subulba, right now it's always Subulba.
I added a core option to enable/disable randomizing the interrupt timing. Disabling it will be needed for some scenarios like regression testing, netplay, and possibly TAS runs. I think enabling it by default would be good, since it's more similar to how the N64 operated, assuming there aren't any regressions.","Found a regression : Conker Bad Fur Day will freeze during the intro with these changes. I remember it to be very sensitive to PI timings, so maybe the % 0x1000 is too big for this game.
Edit: I tried reducing to % 0x40 and can get Conker to boot, Star Wars Racer to have both Anakin and Subulba, and got various characters from Smash Bros (maybe not all, but most).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,415,2017-10-01T18:56:21Z,2017-10-15T03:06:40Z,2017-11-09T15:50:18Z,MERGED,True,37,7,9,https://github.com/loganmc10,Randomize PI/SI interrupt timing,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/415,https://github.com/loganmc10,9,https://github.com/mupen64plus/mupen64plus-core/pull/415#issuecomment-333875853,"This is to address #361
This is ready, but I put the WIP tag because it should get some testing. Right now I've only done very limited testing.
2 easy tests for this: The intro to Smash Bros and Star Wars Ep I Racer. The master hand should pull a random character out of the box, right now it always pulls out Mario. The Ep I Racer intro should either be Anakin or Subulba, right now it's always Subulba.
I added a core option to enable/disable randomizing the interrupt timing. Disabling it will be needed for some scenarios like regression testing, netplay, and possibly TAS runs. I think enabling it by default would be good, since it's more similar to how the N64 operated, assuming there aren't any regressions.","during the intro

What part of the intro? Like when the N64/Rare logo is showing? or after the game starts?
I'd like to try and reproduce it and see if there is some way to make it a little more robust, 0x1000 is probably bigger than necessary, but along with lowering the value I'd like to see if I can figure out what is causing the freeze in the first place.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,415,2017-10-01T18:56:21Z,2017-10-15T03:06:40Z,2017-11-09T15:50:18Z,MERGED,True,37,7,9,https://github.com/loganmc10,Randomize PI/SI interrupt timing,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/415,https://github.com/bsmiles32,10,https://github.com/mupen64plus/mupen64plus-core/pull/415#issuecomment-333889286,"This is to address #361
This is ready, but I put the WIP tag because it should get some testing. Right now I've only done very limited testing.
2 easy tests for this: The intro to Smash Bros and Star Wars Ep I Racer. The master hand should pull a random character out of the box, right now it always pulls out Mario. The Ep I Racer intro should either be Anakin or Subulba, right now it's always Subulba.
I added a core option to enable/disable randomizing the interrupt timing. Disabling it will be needed for some scenarios like regression testing, netplay, and possibly TAS runs. I think enabling it by default would be good, since it's more similar to how the N64 operated, assuming there aren't any regressions.","Freezes when Conker cuts the N64 logo.
The freezing is related to PI timings. I remember having a similar issue in an unpublished PI refactoring branch where I changed the PI timing to be constant instead of proportional to the length of the DMA.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,415,2017-10-01T18:56:21Z,2017-10-15T03:06:40Z,2017-11-09T15:50:18Z,MERGED,True,37,7,9,https://github.com/loganmc10,Randomize PI/SI interrupt timing,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/415,https://github.com/loganmc10,11,https://github.com/mupen64plus/mupen64plus-core/pull/415#issuecomment-334034090,"This is to address #361
This is ready, but I put the WIP tag because it should get some testing. Right now I've only done very limited testing.
2 easy tests for this: The intro to Smash Bros and Star Wars Ep I Racer. The master hand should pull a random character out of the box, right now it always pulls out Mario. The Ep I Racer intro should either be Anakin or Subulba, right now it's always Subulba.
I added a core option to enable/disable randomizing the interrupt timing. Disabling it will be needed for some scenarios like regression testing, netplay, and possibly TAS runs. I think enabling it by default would be good, since it's more similar to how the N64 operated, assuming there aren't any regressions.","Ok I thought I had a potential fix but it turned out to be a dead end. I've modified the range to 0x40, it does seem to provide just as good randomness as 0x1000",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,415,2017-10-01T18:56:21Z,2017-10-15T03:06:40Z,2017-11-09T15:50:18Z,MERGED,True,37,7,9,https://github.com/loganmc10,Randomize PI/SI interrupt timing,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/415,https://github.com/loganmc10,12,https://github.com/mupen64plus/mupen64plus-core/pull/415#issuecomment-336667497,"This is to address #361
This is ready, but I put the WIP tag because it should get some testing. Right now I've only done very limited testing.
2 easy tests for this: The intro to Smash Bros and Star Wars Ep I Racer. The master hand should pull a random character out of the box, right now it always pulls out Mario. The Ep I Racer intro should either be Anakin or Subulba, right now it's always Subulba.
I added a core option to enable/disable randomizing the interrupt timing. Disabling it will be needed for some scenarios like regression testing, netplay, and possibly TAS runs. I think enabling it by default would be good, since it's more similar to how the N64 operated, assuming there aren't any regressions.",I haven't noticed any regressions since decreasing the variance to 0x40/64. I think this can probably be merged,True,"{'THUMBS_UP': ['https://github.com/AmbientMalice', 'https://github.com/rlabrecque']}"
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,417,2017-10-01T22:45:26Z,2017-10-02T05:16:48Z,2017-11-09T15:50:33Z,MERGED,True,65,4,1,https://github.com/loganmc10,Fix rounding in interpreter,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/417,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/417,"Adapted from project64/project64@c3d89e8
Fixes (tested using PeterLemon's test ROM):
#416","Adapted from project64/project64@c3d89e8
Fixes (tested using PeterLemon's test ROM):
#416",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,419,2017-10-03T21:44:36Z,2017-10-04T02:20:42Z,2017-10-04T02:20:42Z,CLOSED,False,39,16,4,https://github.com/loganmc10,Better flags and timing for PI/SI interrupts,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/419,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/419,"I've actually been working on this and researching this for a while now, but I never found a case of it helping until @bsmiles32 comment in my other PR (#415 (comment)), where Conker's would freeze if the PI timing was off (adding 0x1000 to the PI interrupt delay causes the game to freeze at the N64 logo)
The PI and SI have 2 kinds of data transfers: IO and DMA. It had always been a little unclear to me what the difference is but now I understand. A DMA is a DMA, initiated by a write to the read/write register of the PI/SI. IO is when there is a write/read to the memory space of the ROM or PIF.
With this PR, the DMA's only set the DMA_BUSY flag, not the IO_BUSY flag. I never actually set the IO_BUSY flag, I just trigger an interrupt immediately after an IO read/write.
The SI processing still needs to be done at the end of the DMA, not the beginning (or else Mischief Makers input won't work). I had to add a ""si_type"" field to keep track of what kind of processing to do at the end of the DMA. I added it to the end of the current savestate revision. I'm hoping to ""sneak it in"" there since it's only been a couple days since it was last bumped...
EDIT: I forgot where I was going with all this! This change makes Conker's more tolerant to PI timing changes (adding 0x1000 doesn't freeze the game anymore), and it's hopefully a generally more accurate way of emulating the DMA/IO interrupts","I've actually been working on this and researching this for a while now, but I never found a case of it helping until @bsmiles32 comment in my other PR (#415 (comment)), where Conker's would freeze if the PI timing was off (adding 0x1000 to the PI interrupt delay causes the game to freeze at the N64 logo)
The PI and SI have 2 kinds of data transfers: IO and DMA. It had always been a little unclear to me what the difference is but now I understand. A DMA is a DMA, initiated by a write to the read/write register of the PI/SI. IO is when there is a write/read to the memory space of the ROM or PIF.
With this PR, the DMA's only set the DMA_BUSY flag, not the IO_BUSY flag. I never actually set the IO_BUSY flag, I just trigger an interrupt immediately after an IO read/write.
The SI processing still needs to be done at the end of the DMA, not the beginning (or else Mischief Makers input won't work). I had to add a ""si_type"" field to keep track of what kind of processing to do at the end of the DMA. I added it to the end of the current savestate revision. I'm hoping to ""sneak it in"" there since it's only been a couple days since it was last bumped...
EDIT: I forgot where I was going with all this! This change makes Conker's more tolerant to PI timing changes (adding 0x1000 doesn't freeze the game anymore), and it's hopefully a generally more accurate way of emulating the DMA/IO interrupts",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,419,2017-10-03T21:44:36Z,2017-10-04T02:20:42Z,2017-10-04T02:20:42Z,CLOSED,False,39,16,4,https://github.com/loganmc10,Better flags and timing for PI/SI interrupts,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/419,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/419#issuecomment-333998612,"I've actually been working on this and researching this for a while now, but I never found a case of it helping until @bsmiles32 comment in my other PR (#415 (comment)), where Conker's would freeze if the PI timing was off (adding 0x1000 to the PI interrupt delay causes the game to freeze at the N64 logo)
The PI and SI have 2 kinds of data transfers: IO and DMA. It had always been a little unclear to me what the difference is but now I understand. A DMA is a DMA, initiated by a write to the read/write register of the PI/SI. IO is when there is a write/read to the memory space of the ROM or PIF.
With this PR, the DMA's only set the DMA_BUSY flag, not the IO_BUSY flag. I never actually set the IO_BUSY flag, I just trigger an interrupt immediately after an IO read/write.
The SI processing still needs to be done at the end of the DMA, not the beginning (or else Mischief Makers input won't work). I had to add a ""si_type"" field to keep track of what kind of processing to do at the end of the DMA. I added it to the end of the current savestate revision. I'm hoping to ""sneak it in"" there since it's only been a couple days since it was last bumped...
EDIT: I forgot where I was going with all this! This change makes Conker's more tolerant to PI timing changes (adding 0x1000 doesn't freeze the game anymore), and it's hopefully a generally more accurate way of emulating the DMA/IO interrupts","Hm Bugs Life doesn't boot with this change, I'll have to do a bit more research",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,419,2017-10-03T21:44:36Z,2017-10-04T02:20:42Z,2017-10-04T02:20:42Z,CLOSED,False,39,16,4,https://github.com/loganmc10,Better flags and timing for PI/SI interrupts,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/419,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/419#issuecomment-334032458,"I've actually been working on this and researching this for a while now, but I never found a case of it helping until @bsmiles32 comment in my other PR (#415 (comment)), where Conker's would freeze if the PI timing was off (adding 0x1000 to the PI interrupt delay causes the game to freeze at the N64 logo)
The PI and SI have 2 kinds of data transfers: IO and DMA. It had always been a little unclear to me what the difference is but now I understand. A DMA is a DMA, initiated by a write to the read/write register of the PI/SI. IO is when there is a write/read to the memory space of the ROM or PIF.
With this PR, the DMA's only set the DMA_BUSY flag, not the IO_BUSY flag. I never actually set the IO_BUSY flag, I just trigger an interrupt immediately after an IO read/write.
The SI processing still needs to be done at the end of the DMA, not the beginning (or else Mischief Makers input won't work). I had to add a ""si_type"" field to keep track of what kind of processing to do at the end of the DMA. I added it to the end of the current savestate revision. I'm hoping to ""sneak it in"" there since it's only been a couple days since it was last bumped...
EDIT: I forgot where I was going with all this! This change makes Conker's more tolerant to PI timing changes (adding 0x1000 doesn't freeze the game anymore), and it's hopefully a generally more accurate way of emulating the DMA/IO interrupts",I'm going to re-open this as a different PR in a bit,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,420,2017-10-04T02:24:46Z,2017-10-21T00:08:10Z,2017-11-09T15:49:59Z,MERGED,True,84,95,12,https://github.com/loganmc10,Don't use IO_BUSY flags for DMA,6,[],https://github.com/mupen64plus/mupen64plus-core/pull/420,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/420,"The IO/RD_BUSY flags are not meant for DMA's. Only the DMA_BUSY flag should be set during a DMA.
In order to accomplish this I had to add an si_type field, I added it to the end of the current savestate version.
I tested this with the usual suspects like Mischief Makers and everything still seems to work normally.
There may not be any real difference with this PR, since most games probably just check if IO_BUSY | DMA_BUSY, but the DMA_BUSY flag is the only flags that should be set for a DMA","The IO/RD_BUSY flags are not meant for DMA's. Only the DMA_BUSY flag should be set during a DMA.
In order to accomplish this I had to add an si_type field, I added it to the end of the current savestate version.
I tested this with the usual suspects like Mischief Makers and everything still seems to work normally.
There may not be any real difference with this PR, since most games probably just check if IO_BUSY | DMA_BUSY, but the DMA_BUSY flag is the only flags that should be set for a DMA",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,420,2017-10-04T02:24:46Z,2017-10-21T00:08:10Z,2017-11-09T15:49:59Z,MERGED,True,84,95,12,https://github.com/loganmc10,Don't use IO_BUSY flags for DMA,6,[],https://github.com/mupen64plus/mupen64plus-core/pull/420,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/420#issuecomment-336667412,"The IO/RD_BUSY flags are not meant for DMA's. Only the DMA_BUSY flag should be set during a DMA.
In order to accomplish this I had to add an si_type field, I added it to the end of the current savestate version.
I tested this with the usual suspects like Mischief Makers and everything still seems to work normally.
There may not be any real difference with this PR, since most games probably just check if IO_BUSY | DMA_BUSY, but the DMA_BUSY flag is the only flags that should be set for a DMA","Any comment on this?
Basically the DMA_BUSY flag should be used for DMA requests processed via the PI/SI controller, the IO_BUSY flag is used for direct CPU writes, like when the CPU read/writes to the PIF/cart_rom via their memory address instead of via DMA, this is why these 2 different flags exist, I misunderstood their purpose in the past.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,420,2017-10-04T02:24:46Z,2017-10-21T00:08:10Z,2017-11-09T15:49:59Z,MERGED,True,84,95,12,https://github.com/loganmc10,Don't use IO_BUSY flags for DMA,6,[],https://github.com/mupen64plus/mupen64plus-core/pull/420,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/420#issuecomment-338032336,"The IO/RD_BUSY flags are not meant for DMA's. Only the DMA_BUSY flag should be set during a DMA.
In order to accomplish this I had to add an si_type field, I added it to the end of the current savestate version.
I tested this with the usual suspects like Mischief Makers and everything still seems to work normally.
There may not be any real difference with this PR, since most games probably just check if IO_BUSY | DMA_BUSY, but the DMA_BUSY flag is the only flags that should be set for a DMA","This has been rebased against master. I also added a commit to make the PI DMA lengths consistent (1dfecd4). I tested a number of SRAM and Flash RAM games without issue. The DMA alignment requirements are the same regardless of the address register, so it makes sense that they should all behave the same in this regard",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,420,2017-10-04T02:24:46Z,2017-10-21T00:08:10Z,2017-11-09T15:49:59Z,MERGED,True,84,95,12,https://github.com/loganmc10,Don't use IO_BUSY flags for DMA,6,[],https://github.com/mupen64plus/mupen64plus-core/pull/420,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/420#issuecomment-338099616,"The IO/RD_BUSY flags are not meant for DMA's. Only the DMA_BUSY flag should be set during a DMA.
In order to accomplish this I had to add an si_type field, I added it to the end of the current savestate version.
I tested this with the usual suspects like Mischief Makers and everything still seems to work normally.
There may not be any real difference with this PR, since most games probably just check if IO_BUSY | DMA_BUSY, but the DMA_BUSY flag is the only flags that should be set for a DMA","Thanks for the edits, looks good to me",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,420,2017-10-04T02:24:46Z,2017-10-21T00:08:10Z,2017-11-09T15:49:59Z,MERGED,True,84,95,12,https://github.com/loganmc10,Don't use IO_BUSY flags for DMA,6,[],https://github.com/mupen64plus/mupen64plus-core/pull/420,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/420#issuecomment-338099827,"The IO/RD_BUSY flags are not meant for DMA's. Only the DMA_BUSY flag should be set during a DMA.
In order to accomplish this I had to add an si_type field, I added it to the end of the current savestate version.
I tested this with the usual suspects like Mischief Makers and everything still seems to work normally.
There may not be any real difference with this PR, since most games probably just check if IO_BUSY | DMA_BUSY, but the DMA_BUSY flag is the only flags that should be set for a DMA","By the way, from what I read the word alignment is actually enforced (the last 2 bits are stripped from the address). I don't know if there are any games that run into that though",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,420,2017-10-04T02:24:46Z,2017-10-21T00:08:10Z,2017-11-09T15:49:59Z,MERGED,True,84,95,12,https://github.com/loganmc10,Don't use IO_BUSY flags for DMA,6,[],https://github.com/mupen64plus/mupen64plus-core/pull/420,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/420#issuecomment-338107900,"The IO/RD_BUSY flags are not meant for DMA's. Only the DMA_BUSY flag should be set during a DMA.
In order to accomplish this I had to add an si_type field, I added it to the end of the current savestate version.
I tested this with the usual suspects like Mischief Makers and everything still seems to work normally.
There may not be any real difference with this PR, since most games probably just check if IO_BUSY | DMA_BUSY, but the DMA_BUSY flag is the only flags that should be set for a DMA","@bsmiles32 I made that change to force word alignment (e415e75), I believe this is how the N64 actually did it, I'm not sure if any games actually write non-aligned addresses, but I believe this is how they would be handled",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,421,2017-10-04T04:40:45Z,2017-10-04T05:42:29Z,2017-10-05T08:21:16Z,MERGED,True,20,7,3,https://github.com/bsmiles32,CIC and Densha de Go Translation Patch,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/421,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/421,"Some small additions while I was trying the Densha de Go Translation Patch [1].
Still I can't get to the main screen. Will need some further investigation.
[1] http://www.shootersforever.com/forums_message_boards/viewtopic.php?t=7174","Some small additions while I was trying the Densha de Go Translation Patch [1].
Still I can't get to the main screen. Will need some further investigation.
[1] http://www.shootersforever.com/forums_message_boards/viewtopic.php?t=7174",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,422,2017-10-04T15:29:56Z,2017-10-05T02:59:32Z,2017-10-05T08:21:12Z,MERGED,True,52,0,1,https://github.com/bsmiles32,Stubbing some 64dd conversion roms into database.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/422,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/422,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,423,2017-10-04T16:44:26Z,2017-10-05T03:05:39Z,2017-10-05T03:37:22Z,MERGED,True,16,3,4,https://github.com/loganmc10,Add SP_STATUS_REG and RDRAM_SIZE to gfx_info,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/423,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/423,"It has become apparent that in order to tackle some of the remaining GFX ucodes, the GFX plugins will need access to SP_STATUS_REG (see mupen64plus/mupen64plus-rsp-hle#51 (comment))
This should allow that, I also added RDRAM_SIZE, since right now most GFX plugins use some kind of hack to try and determine that value.
@richard42","It has become apparent that in order to tackle some of the remaining GFX ucodes, the GFX plugins will need access to SP_STATUS_REG (see mupen64plus/mupen64plus-rsp-hle#51 (comment))
This should allow that, I also added RDRAM_SIZE, since right now most GFX plugins use some kind of hack to try and determine that value.
@richard42",True,{'THUMBS_UP': ['https://github.com/ObiKKa']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,424,2017-10-05T12:26:33Z,2017-10-05T23:26:25Z,2017-11-02T01:53:44Z,MERGED,True,3,4,1,https://github.com/bsmiles32,SDL_Delay is only called just before input polling.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/424,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/424,"This should help reduce the input lag as suggested by wareya in issue #164
Be sure to test with AUDIO_SYNC = False in audio plugin so that SDL_Delay is only called right before input_polling.
@wareya can you test if it makes a difference for you ?","This should help reduce the input lag as suggested by wareya in issue #164
Be sure to test with AUDIO_SYNC = False in audio plugin so that SDL_Delay is only called right before input_polling.
@wareya can you test if it makes a difference for you ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,424,2017-10-05T12:26:33Z,2017-10-05T23:26:25Z,2017-11-02T01:53:44Z,MERGED,True,3,4,1,https://github.com/bsmiles32,SDL_Delay is only called just before input polling.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/424,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/424#issuecomment-334548933,"This should help reduce the input lag as suggested by wareya in issue #164
Be sure to test with AUDIO_SYNC = False in audio plugin so that SDL_Delay is only called right before input_polling.
@wareya can you test if it makes a difference for you ?",I wonder if it would be beneficial to call it right before the delay and also right after?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,424,2017-10-05T12:26:33Z,2017-10-05T23:26:25Z,2017-11-02T01:53:44Z,MERGED,True,3,4,1,https://github.com/bsmiles32,SDL_Delay is only called just before input polling.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/424,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/424#issuecomment-334563128,"This should help reduce the input lag as suggested by wareya in issue #164
Be sure to test with AUDIO_SYNC = False in audio plugin so that SDL_Delay is only called right before input_polling.
@wareya can you test if it makes a difference for you ?","All that main_check_inputs does is run SDL_PumpEvents (polls input devices). I believe that calling it before and after would be the same as just calling it after. input-sdl executes SDL_JoystickUpdate() inside the GetKeys() function anyway, so the joystick is polled for input when GetKeys happens.
It would be more important to make sure that GetKeys is called at the proper time.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,424,2017-10-05T12:26:33Z,2017-10-05T23:26:25Z,2017-11-02T01:53:44Z,MERGED,True,3,4,1,https://github.com/bsmiles32,SDL_Delay is only called just before input polling.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/424,https://github.com/wareya,4,https://github.com/mupen64plus/mupen64plus-core/pull/424#issuecomment-334579714,"This should help reduce the input lag as suggested by wareya in issue #164
Be sure to test with AUDIO_SYNC = False in audio plugin so that SDL_Delay is only called right before input_polling.
@wareya can you test if it makes a difference for you ?","@wareya can you test if it makes a difference for you ?

I would test it, but I don't have a mupen64plus environment set up right now. Sorry about that. The code looks right, though!",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,425,2017-10-05T12:39:35Z,2017-10-05T23:27:01Z,2017-11-09T15:50:32Z,MERGED,True,4,0,1,https://github.com/loganmc10,Add note about SP_STATUS_REG,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/425,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/425,"I just wanted to add a short note about the expected usage of the SP_STATUS_REG register by the RSP and GFX plugins.
Right now, after the RSP plugin calls ProcessDList(), it sets HALT | BROKE | TASKDONE. I am proposing that the RSP plugin sets those bits before calling ProcessDList(), and then the GFX plugin can unset them if it needs.
This will maintain backwards compatibility with current GFX plugins, while still allowing future GFX plugins to modify SP_STATUS_REG if needed","I just wanted to add a short note about the expected usage of the SP_STATUS_REG register by the RSP and GFX plugins.
Right now, after the RSP plugin calls ProcessDList(), it sets HALT | BROKE | TASKDONE. I am proposing that the RSP plugin sets those bits before calling ProcessDList(), and then the GFX plugin can unset them if it needs.
This will maintain backwards compatibility with current GFX plugins, while still allowing future GFX plugins to modify SP_STATUS_REG if needed",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,427,2017-10-06T21:50:04Z,2017-10-07T02:19:22Z,2017-11-09T15:50:31Z,MERGED,True,5,43,1,https://github.com/loganmc10,Do a proper open bus read,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/427,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/427,"Fixes #418
Castlevania tries to read from ""Cartridge Domain 1 Address 3"" (http://en64.shoutwiki.com/wiki/N64_Memory#Memory_Map_Overview)
I have no idea what that address space is for. I seem to recall Paper Mario tried to access it as well via PI DMA when I was working on fixing duplicate saving in that game. Nothing I read gives me any hints as to what it might be for.
Anyway, when the N64 tries to read from unmapped memory, it's an ""open bus"" and it shouldn't just return 0. It returns some strange mash-up of the address.
Interestingly, the intro in the E version is different from the U version in Castlevania (the guy takes a different path and fights different enemies). I guess they were programmed differently, which might explain why this didn't happen in the E version","Fixes #418
Castlevania tries to read from ""Cartridge Domain 1 Address 3"" (http://en64.shoutwiki.com/wiki/N64_Memory#Memory_Map_Overview)
I have no idea what that address space is for. I seem to recall Paper Mario tried to access it as well via PI DMA when I was working on fixing duplicate saving in that game. Nothing I read gives me any hints as to what it might be for.
Anyway, when the N64 tries to read from unmapped memory, it's an ""open bus"" and it shouldn't just return 0. It returns some strange mash-up of the address.
Interestingly, the intro in the E version is different from the U version in Castlevania (the guy takes a different path and fights different enemies). I guess they were programmed differently, which might explain why this didn't happen in the E version",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,427,2017-10-06T21:50:04Z,2017-10-07T02:19:22Z,2017-11-09T15:50:31Z,MERGED,True,5,43,1,https://github.com/loganmc10,Do a proper open bus read,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/427,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/427#issuecomment-334879961,"Fixes #418
Castlevania tries to read from ""Cartridge Domain 1 Address 3"" (http://en64.shoutwiki.com/wiki/N64_Memory#Memory_Map_Overview)
I have no idea what that address space is for. I seem to recall Paper Mario tried to access it as well via PI DMA when I was working on fixing duplicate saving in that game. Nothing I read gives me any hints as to what it might be for.
Anyway, when the N64 tries to read from unmapped memory, it's an ""open bus"" and it shouldn't just return 0. It returns some strange mash-up of the address.
Interestingly, the intro in the E version is different from the U version in Castlevania (the guy takes a different path and fights different enemies). I guess they were programmed differently, which might explain why this didn't happen in the E version","Just because I find this interesting, from Wikipedia:

The PAL version of the game features voice acting for Dracula's servant in the Castle Wall and Castle Keep levels; the North American version did not include the voice work for the latter level.

The PAL version was released 4 months after the North American version. It seems like it probably received a bit more polish and perhaps this bogus read was a bug that was the result of a rushed release...
EDIT:
Also just of interest: Like I mentioned, Paper Mario does this too, but via the PI controller. The duplicate saving issue was only present in the NA and JP version of Paper Mario, not the PAL version (libretro/parallel-n64#63 (comment))",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,427,2017-10-06T21:50:04Z,2017-10-07T02:19:22Z,2017-11-09T15:50:31Z,MERGED,True,5,43,1,https://github.com/loganmc10,Do a proper open bus read,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/427,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/427#issuecomment-334894014,"Fixes #418
Castlevania tries to read from ""Cartridge Domain 1 Address 3"" (http://en64.shoutwiki.com/wiki/N64_Memory#Memory_Map_Overview)
I have no idea what that address space is for. I seem to recall Paper Mario tried to access it as well via PI DMA when I was working on fixing duplicate saving in that game. Nothing I read gives me any hints as to what it might be for.
Anyway, when the N64 tries to read from unmapped memory, it's an ""open bus"" and it shouldn't just return 0. It returns some strange mash-up of the address.
Interestingly, the intro in the E version is different from the U version in Castlevania (the guy takes a different path and fights different enemies). I guess they were programmed differently, which might explain why this didn't happen in the E version",I added a commit to do the same for the 64DD registers. F-Zero still works with this method (testing the U ROM). This may help other games like the English translations of Densha de Go! @bsmiles32 (https://krikzz.com/forum/index.php?topic=6362.msg49577#msg49577),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,427,2017-10-06T21:50:04Z,2017-10-07T02:19:22Z,2017-11-09T15:50:31Z,MERGED,True,5,43,1,https://github.com/loganmc10,Do a proper open bus read,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/427,https://github.com/bsmiles32,4,https://github.com/mupen64plus/mupen64plus-core/pull/427#issuecomment-334903089,"Fixes #418
Castlevania tries to read from ""Cartridge Domain 1 Address 3"" (http://en64.shoutwiki.com/wiki/N64_Memory#Memory_Map_Overview)
I have no idea what that address space is for. I seem to recall Paper Mario tried to access it as well via PI DMA when I was working on fixing duplicate saving in that game. Nothing I read gives me any hints as to what it might be for.
Anyway, when the N64 tries to read from unmapped memory, it's an ""open bus"" and it shouldn't just return 0. It returns some strange mash-up of the address.
Interestingly, the intro in the E version is different from the U version in Castlevania (the guy takes a different path and fights different enemies). I guess they were programmed differently, which might explain why this didn't happen in the E version","Cannot test at the moment, but looks good. Nice reads also. Thank you very much !",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,428,2017-10-07T07:44:12Z,2017-10-07T14:34:42Z,2017-10-07T15:03:57Z,MERGED,True,6,5,1,https://github.com/psyke83,Raspberry Pi: use new vendor library names,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/428,https://github.com/psyke83,1,https://github.com/mupen64plus/mupen64plus-core/pull/428,Needed for new firmwares on Raspbian stretch/ SDL 2.0.6. Also working with recent jessie firmwares.,Needed for new firmwares on Raspbian stretch/ SDL 2.0.6. Also working with recent jessie firmwares.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,428,2017-10-07T07:44:12Z,2017-10-07T14:34:42Z,2017-10-07T15:03:57Z,MERGED,True,6,5,1,https://github.com/psyke83,Raspberry Pi: use new vendor library names,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/428,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/428#issuecomment-334939546,Needed for new firmwares on Raspbian stretch/ SDL 2.0.6. Also working with recent jessie firmwares.,"Thanks,
Please provide more context. I guess the open source OpenGL driver is now provided with Debian right?
So, with this PR, you want to keep old driver.
My question  is: Why not use the open source drivers ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,428,2017-10-07T07:44:12Z,2017-10-07T14:34:42Z,2017-10-07T15:03:57Z,MERGED,True,6,5,1,https://github.com/psyke83,Raspberry Pi: use new vendor library names,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/428,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/428#issuecomment-334939956,Needed for new firmwares on Raspbian stretch/ SDL 2.0.6. Also working with recent jessie firmwares.,"The closed source driver is what comes enabled by default, the user needs to manually enable the open source driver. To use the open source driver they could just compile without setting VC=1",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,428,2017-10-07T07:44:12Z,2017-10-07T14:34:42Z,2017-10-07T15:03:57Z,MERGED,True,6,5,1,https://github.com/psyke83,Raspberry Pi: use new vendor library names,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/428,https://github.com/psyke83,4,https://github.com/mupen64plus/mupen64plus-core/pull/428#issuecomment-334941286,Needed for new firmwares on Raspbian stretch/ SDL 2.0.6. Also working with recent jessie firmwares.,"Along with what Logan said, the Foundation wanted to distinguish the vendor libraries from Mesa with the rename. They provided both names as a temporary measure since September of last year, but stopped doing so in recent firmware.
The open VC4 driver is not yet a full drop in replacement due to the lack of hardware accelerated video decoding and other incompatibility issues that are only partially solved by the intermediate fake kms Device Tree overlay of the driver.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,430,2017-10-10T13:53:47Z,2017-10-10T23:48:37Z,2017-11-09T15:50:20Z,MERGED,True,16,16,1,https://github.com/loganmc10,Fix a few indentation warnings,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/430,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/430,"Fixes these warnings:
../../src/osal/files_win32.c: In function 'osal_mkdirp':
../../src/osal/files_win32.c:86:5: warning: this 'if' clause does not guard... [-Wmisleading-indentation]
     if (mypath == NULL)
     ^~
../../src/osal/files_win32.c:90:2: note: ...this statement, but the latter is misleadingly indented as if it were guarded by the 'if'
  lastchar = mypath + strlen(mypath) - 1;
  ^~~~~~~~
../../src/osal/files_win32.c: In function 'osal_get_user_configpath':
../../src/osal/files_win32.c:161:13: warning: variable 'hr' set but not used [-Wunused-but-set-variable]
     HRESULT hr = SHGetSpecialFolderLocation(NULL, CSIDL_APPDATA, &pidl);


Also there was some inconsistency betweening tabbing/4 spaces, I got rid of the tabs","Fixes these warnings:
../../src/osal/files_win32.c: In function 'osal_mkdirp':
../../src/osal/files_win32.c:86:5: warning: this 'if' clause does not guard... [-Wmisleading-indentation]
     if (mypath == NULL)
     ^~
../../src/osal/files_win32.c:90:2: note: ...this statement, but the latter is misleadingly indented as if it were guarded by the 'if'
  lastchar = mypath + strlen(mypath) - 1;
  ^~~~~~~~
../../src/osal/files_win32.c: In function 'osal_get_user_configpath':
../../src/osal/files_win32.c:161:13: warning: variable 'hr' set but not used [-Wunused-but-set-variable]
     HRESULT hr = SHGetSpecialFolderLocation(NULL, CSIDL_APPDATA, &pidl);


Also there was some inconsistency betweening tabbing/4 spaces, I got rid of the tabs",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,431,2017-10-11T15:58:23Z,2018-03-10T13:47:41Z,2020-04-27T19:40:30Z,CLOSED,False,25,32,5,https://github.com/loganmc10,Update to Visual Studio 2015/SDL2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/431,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/431,I have PR's for the other repo's incoming as well. This updates the build to VS2015 and SDL2.0.6 for Windows,I have PR's for the other repo's incoming as well. This updates the build to VS2015 and SDL2.0.6 for Windows,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,431,2017-10-11T15:58:23Z,2018-03-10T13:47:41Z,2020-04-27T19:40:30Z,CLOSED,False,25,32,5,https://github.com/loganmc10,Update to Visual Studio 2015/SDL2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/431,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/431#issuecomment-335883434,I have PR's for the other repo's incoming as well. This updates the build to VS2015 and SDL2.0.6 for Windows,How about having multiple projects for different msvc versions?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,431,2017-10-11T15:58:23Z,2018-03-10T13:47:41Z,2020-04-27T19:40:30Z,CLOSED,False,25,32,5,https://github.com/loganmc10,Update to Visual Studio 2015/SDL2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/431,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/431#issuecomment-335890211,I have PR's for the other repo's incoming as well. This updates the build to VS2015 and SDL2.0.6 for Windows,"I think it becomes a bit of a pain maintaining all those files. They are already a bit of an afterthought for most the devs lol
I don't see any real barrier to just supporting VS2015, it's free to download and it's not even the most recent version. Actually getting your hands on VS2013 is a bit harder in my experience. I have VS2017 and it seems to support VS2015 projects without issue, but I don't know how to get it to compile VS2013 projects",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,431,2017-10-11T15:58:23Z,2018-03-10T13:47:41Z,2020-04-27T19:40:30Z,CLOSED,False,25,32,5,https://github.com/loganmc10,Update to Visual Studio 2015/SDL2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/431,https://github.com/fzurita,4,https://github.com/mupen64plus/mupen64plus-core/pull/431#issuecomment-335903628,I have PR's for the other repo's incoming as well. This updates the build to VS2015 and SDL2.0.6 for Windows,"Yeah, you bring up good points.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,431,2017-10-11T15:58:23Z,2018-03-10T13:47:41Z,2020-04-27T19:40:30Z,CLOSED,False,25,32,5,https://github.com/loganmc10,Update to Visual Studio 2015/SDL2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/431,https://github.com/bsmiles32,5,https://github.com/mupen64plus/mupen64plus-core/pull/431#issuecomment-335966405,I have PR's for the other repo's incoming as well. This updates the build to VS2015 and SDL2.0.6 for Windows,"They are already a bit of an afterthought for most the devs lol

Sorry for that... The thing is, maintaining both Makefile and MSVC solution is kind of a pain for me as I have no access to a windows dev machine, so updating the MSVC file is always in ""blind"" mode when I don't completely forget about it. Having a single file to maintain would be far easier. Maybe looking at CMake or meson could help in this regard ? Yet, what we have now kind of works and migrating to another solution would be more work than editing once in a while the msvc file... so meh",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,431,2017-10-11T15:58:23Z,2018-03-10T13:47:41Z,2020-04-27T19:40:30Z,CLOSED,False,25,32,5,https://github.com/loganmc10,Update to Visual Studio 2015/SDL2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/431,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/431#issuecomment-336002756,I have PR's for the other repo's incoming as well. This updates the build to VS2015 and SDL2.0.6 for Windows,"Oh I didn't mean just you. I also pretty much exclusively work in Linux, I just test things in Windows from time to time, but still usually with MinGW/Makefile. I'm still not 100% sure how to change stuff in these files via Visual Studio without it changing 5 other things I didn't want",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,431,2017-10-11T15:58:23Z,2018-03-10T13:47:41Z,2020-04-27T19:40:30Z,CLOSED,False,25,32,5,https://github.com/loganmc10,Update to Visual Studio 2015/SDL2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/431,https://github.com/fzurita,7,https://github.com/mupen64plus/mupen64plus-core/pull/431#issuecomment-336007854,I have PR's for the other repo's incoming as well. This updates the build to VS2015 and SDL2.0.6 for Windows,"Do you mean that we have to add more to "".gitignore""?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,431,2017-10-11T15:58:23Z,2018-03-10T13:47:41Z,2020-04-27T19:40:30Z,CLOSED,False,25,32,5,https://github.com/loganmc10,Update to Visual Studio 2015/SDL2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/431,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/431#issuecomment-336009108,I have PR's for the other repo's incoming as well. This updates the build to VS2015 and SDL2.0.6 for Windows,"No like it changes all kinds of version numbers and things in the vcxproj file when I try to add a .c file to it, I end up just adding it in a text editor. I'm probably just hopelessly stubborn.. I'm sure there must be a way",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,431,2017-10-11T15:58:23Z,2018-03-10T13:47:41Z,2020-04-27T19:40:30Z,CLOSED,False,25,32,5,https://github.com/loganmc10,Update to Visual Studio 2015/SDL2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/431,https://github.com/richard42,9,https://github.com/mupen64plus/mupen64plus-core/pull/431#issuecomment-336013277,I have PR's for the other repo's incoming as well. This updates the build to VS2015 and SDL2.0.6 for Windows,"Thanks for this; switching to VS2015 is good, it's probably about time. But I'll wait until you have PRs for all the modules including rice and glide64mk2 and then merge them all at the same time. I don't want to have them out of sync with each other.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,431,2017-10-11T15:58:23Z,2018-03-10T13:47:41Z,2020-04-27T19:40:30Z,CLOSED,False,25,32,5,https://github.com/loganmc10,Update to Visual Studio 2015/SDL2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/431,https://github.com/loganmc10,10,https://github.com/mupen64plus/mupen64plus-core/pull/431#issuecomment-336162432,I have PR's for the other repo's incoming as well. This updates the build to VS2015 and SDL2.0.6 for Windows,"Good point, neither video-rice or video-glide64mk2 will compile using SDL2 right now though (mupen64plus/mupen64plus-video-glide64mk2#90 (comment))",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,431,2017-10-11T15:58:23Z,2018-03-10T13:47:41Z,2020-04-27T19:40:30Z,CLOSED,False,25,32,5,https://github.com/loganmc10,Update to Visual Studio 2015/SDL2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/431,https://github.com/richard42,11,https://github.com/mupen64plus/mupen64plus-core/pull/431#issuecomment-336309072,I have PR's for the other repo's incoming as well. This updates the build to VS2015 and SDL2.0.6 for Windows,Apparently the SDL2 headers for opengl have been modified in a way which is inconvenient for us. I hate having to use GLEW; our previous solution was about as good as it could be.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,431,2017-10-11T15:58:23Z,2018-03-10T13:47:41Z,2020-04-27T19:40:30Z,CLOSED,False,25,32,5,https://github.com/loganmc10,Update to Visual Studio 2015/SDL2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/431,https://github.com/rlabrecque,12,https://github.com/mupen64plus/mupen64plus-core/pull/431#issuecomment-336552063,I have PR's for the other repo's incoming as well. This updates the build to VS2015 and SDL2.0.6 for Windows,Is there any reason to support SDL1 at all anymore? Why ever #ifdef SDL2?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,431,2017-10-11T15:58:23Z,2018-03-10T13:47:41Z,2020-04-27T19:40:30Z,CLOSED,False,25,32,5,https://github.com/loganmc10,Update to Visual Studio 2015/SDL2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/431,https://github.com/richard42,13,https://github.com/mupen64plus/mupen64plus-core/pull/431#issuecomment-336599616,I have PR's for the other repo's incoming as well. This updates the build to VS2015 and SDL2.0.6 for Windows,"the last release of SDL1 was 4 years ago, so it's probably safe to remove support for it in the near future.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,431,2017-10-11T15:58:23Z,2018-03-10T13:47:41Z,2020-04-27T19:40:30Z,CLOSED,False,25,32,5,https://github.com/loganmc10,Update to Visual Studio 2015/SDL2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/431,https://github.com/loganmc10,14,https://github.com/mupen64plus/mupen64plus-core/pull/431#issuecomment-336599875,I have PR's for the other repo's incoming as well. This updates the build to VS2015 and SDL2.0.6 for Windows,"Yeah as far as I can tell Glide64mk2, rice, and audio-sdl are all incompatible with SDL2 on Windows, once that is all corrected then SDL1 could go",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,431,2017-10-11T15:58:23Z,2018-03-10T13:47:41Z,2020-04-27T19:40:30Z,CLOSED,False,25,32,5,https://github.com/loganmc10,Update to Visual Studio 2015/SDL2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/431,https://github.com/Papermanzero,15,https://github.com/mupen64plus/mupen64plus-core/pull/431#issuecomment-355822400,I have PR's for the other repo's incoming as well. This updates the build to VS2015 and SDL2.0.6 for Windows,Is it possible to add the rumble feature on windows with SDL2?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,436,2017-10-14T07:46:21Z,2017-10-19T20:23:56Z,2017-11-02T01:53:26Z,MERGED,True,601,377,21,https://github.com/bsmiles32,PI refactorings,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/436,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/436,"Main focus of this PR is to move some dma logic inside each dma'ble component (flashram, sram, cart_rom) to make pi_controller more agnostic to the type of component it accesses. I also moved these components inside the cart subsytem.","Main focus of this PR is to move some dma logic inside each dma'ble component (flashram, sram, cart_rom) to make pi_controller more agnostic to the type of component it accesses. I also moved these components inside the cart subsytem.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,436,2017-10-14T07:46:21Z,2017-10-19T20:23:56Z,2017-11-02T01:53:26Z,MERGED,True,601,377,21,https://github.com/bsmiles32,PI refactorings,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/436,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/436#issuecomment-336635175,"Main focus of this PR is to move some dma logic inside each dma'ble component (flashram, sram, cart_rom) to make pi_controller more agnostic to the type of component it accesses. I also moved these components inside the cart subsytem.","A couple notes just from reading:
You can probably use length = (length & UINT32_C(0x00fffffe)) + 2; in all cases. I just did it only for cart_rom since there was a case where it was required (AI Shogi 3), but it probably could/should be used in all cases.
From a git perspective, this conflicts in a pretty major way with both #415 and #420. It would be nice if they could be reviewed and either merged first, or incorporated into this PR",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,436,2017-10-14T07:46:21Z,2017-10-19T20:23:56Z,2017-11-02T01:53:26Z,MERGED,True,601,377,21,https://github.com/bsmiles32,PI refactorings,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/436,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/436#issuecomment-336637257,"Main focus of this PR is to move some dma logic inside each dma'ble component (flashram, sram, cart_rom) to make pi_controller more agnostic to the type of component it accesses. I also moved these components inside the cart subsytem.","I tried not to change any behaviour in this PR even if I could have done some changes like you suggested. This is on purpose. Changing behaviour can be tricky and I thought it would be more appropriate in a later PR. But yeah there is a lot of potential to gather common behaviour at the pi_controller level.
I'm fine with any order for the merges, I can rebase this PR if needed. Just, I will be away for the whole week, so I won't be able to do anything in the coming days.",True,{'THUMBS_UP': ['https://github.com/rlabrecque']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,436,2017-10-14T07:46:21Z,2017-10-19T20:23:56Z,2017-11-02T01:53:26Z,MERGED,True,601,377,21,https://github.com/bsmiles32,PI refactorings,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/436,https://github.com/bsmiles32,4,https://github.com/mupen64plus/mupen64plus-core/pull/436#issuecomment-336715406,"Main focus of this PR is to move some dma logic inside each dma'ble component (flashram, sram, cart_rom) to make pi_controller more agnostic to the type of component it accesses. I also moved these components inside the cart subsytem.",Rebased against master.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,436,2017-10-14T07:46:21Z,2017-10-19T20:23:56Z,2017-11-02T01:53:26Z,MERGED,True,601,377,21,https://github.com/bsmiles32,PI refactorings,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/436,https://github.com/richard42,5,https://github.com/mupen64plus/mupen64plus-core/pull/436#issuecomment-336725575,"Main focus of this PR is to move some dma logic inside each dma'ble component (flashram, sram, cart_rom) to make pi_controller more agnostic to the type of component it accesses. I also moved these components inside the cart subsytem.","bsmiles32, you can merge this when you get back next week.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,436,2017-10-14T07:46:21Z,2017-10-19T20:23:56Z,2017-11-02T01:53:26Z,MERGED,True,601,377,21,https://github.com/bsmiles32,PI refactorings,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/436,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/436#issuecomment-337640520,"Main focus of this PR is to move some dma logic inside each dma'ble component (flashram, sram, cart_rom) to make pi_controller more agnostic to the type of component it accesses. I also moved these components inside the cart subsytem.","I finally got around to testing this, Paper Mario (U) crashes, here is the backtrace:
0x00007fffbfbf279d in flashram_command (flashram=0x7fffc0f8f7d8 <g_dev+17834712>, command=3523215360) at ../../src/device/cart/flashram.c:40
40	    uint8_t* mem = flashram->istorage->data(flashram->storage);
(gdb) backtrace
#0  0x00007fffbfbf279d in flashram_command (flashram=0x7fffc0f8f7d8 <g_dev+17834712>, command=3523215360) at ../../src/device/cart/flashram.c:40
#1  0x00007fffbfbf2adc in write_flashram_command (opaque=0x7fffc0f8f7d8 <g_dev+17834712>, address=134283264, value=3523215360, mask=4294967295) at ../../src/device/cart/flashram.c:136
#2  0x00007fffbfbf1b93 in write_cart_dom2 (opaque=0x7fffc0f8f760 <g_dev+17834592>, address=134283264, value=3523215360, mask=4294967295) at ../../src/device/cart/cart.c:165
#3  0x00007fffbfc1b455 in mem_write32 (handler=0x7fffc0f9b9b0 <g_dev+17884336>, address=134283264, value=3523215360, mask=4294967295) at ../../src/device/memory/memory.h:106
#4  0x00007fffbfc1bd3c in r4300_write_aligned_word (r4300=0x7fffbfe8d500 <g_dev>, address=134283264, value=3523215360, mask=4294967295) at ../../src/device/r4300/r4300_core.c:398
#5  0x00007fffbfc0d87b in SW (r4300=0x7fffbfe8d500 <g_dev>, op=2890268672) at ../../src/device/r4300/mips_instructions.def:333
#6  0x00007fffbfc1b14d in InterpretOpcode (r4300=0x7fffbfe8d500 <g_dev>) at ../../src/device/r4300/pure_interp.c:687
#7  0x00007fffbfc1b363 in run_pure_interpreter (r4300=0x7fffbfe8d500 <g_dev>) at ../../src/device/r4300/pure_interp.c:736
#8  0x00007fffbfc1b8ae in run_r4300 (r4300=0x7fffbfe8d500 <g_dev>) at ../../src/device/r4300/r4300_core.c:157
#9  0x00007fffbfbf4c4c in run_device (dev=0x7fffbfe8d500 <g_dev>) at ../../src/device/device.c:223
#10 0x00007fffbfc2a7aa in main_run () at ../../src/main/main.c:1323

I believe Paper Mario writes some goofy value to CART_ADDR_REG. It might be using the wrong handler or something. This is why Paper Mario had those duplicate saving issues for so long",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,436,2017-10-14T07:46:21Z,2017-10-19T20:23:56Z,2017-11-02T01:53:26Z,MERGED,True,601,377,21,https://github.com/bsmiles32,PI refactorings,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/436,https://github.com/bsmiles32,7,https://github.com/mupen64plus/mupen64plus-core/pull/436#issuecomment-337892394,"Main focus of this PR is to move some dma logic inside each dma'ble component (flashram, sram, cart_rom) to make pi_controller more agnostic to the type of component it accesses. I also moved these components inside the cart subsytem.","Rebased against master and fixed the crash in Paper Mario.
@loganmc10 : The crash was due to wrong ""opaque"" object passed to cart_dom2 mmio handlers (and was not specific to Paper Mario, but all flashram games... whoops !). Thanks for reporting this.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,436,2017-10-14T07:46:21Z,2017-10-19T20:23:56Z,2017-11-02T01:53:26Z,MERGED,True,601,377,21,https://github.com/bsmiles32,PI refactorings,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/436,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/436#issuecomment-337924032,"Main focus of this PR is to move some dma logic inside each dma'ble component (flashram, sram, cart_rom) to make pi_controller more agnostic to the type of component it accesses. I also moved these components inside the cart subsytem.","The crashing is fixed, but the duplicate saving in Paper Mario is back. You can test this using the U rom by:
Making a save game, then close the game and reopen it, you'll see that your save game now occupies all 4 slots.
Just for reference here is the PR that originally fixed it: #375",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,436,2017-10-14T07:46:21Z,2017-10-19T20:23:56Z,2017-11-02T01:53:26Z,MERGED,True,601,377,21,https://github.com/bsmiles32,PI refactorings,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/436,https://github.com/loganmc10,9,https://github.com/mupen64plus/mupen64plus-core/pull/436#issuecomment-338013885,"Main focus of this PR is to move some dma logic inside each dma'ble component (flashram, sram, cart_rom) to make pi_controller more agnostic to the type of component it accesses. I also moved these components inside the cart subsytem.","I don't think using cart_rom_dma_read/cart_rom_dma_write is the correct approach. Since the whole thing lies outside the ROM's address space, it just writes all 0's in this case.
It's more like a ""DMA open bus"" situation. Writing all 0's seems to work instead of the address shifting thing that is used for CPU reads from invalid memory addresses. I can't remember if I actually tried handling it like the other open bus situation, or if I just tried all 0's. All 0's is what we do now anyway",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,436,2017-10-14T07:46:21Z,2017-10-19T20:23:56Z,2017-11-02T01:53:26Z,MERGED,True,601,377,21,https://github.com/bsmiles32,PI refactorings,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/436,https://github.com/loganmc10,10,https://github.com/mupen64plus/mupen64plus-core/pull/436#issuecomment-338014133,"Main focus of this PR is to move some dma logic inside each dma'ble component (flashram, sram, cart_rom) to make pi_controller more agnostic to the type of component it accesses. I also moved these components inside the cart subsytem.","But now that I remember, you are just trying to mimic what we currently do, so then yes, cart_rom_dma_read/cart_rom_dma_write would be accurate to what we are currently doing",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,436,2017-10-14T07:46:21Z,2017-10-19T20:23:56Z,2017-11-02T01:53:26Z,MERGED,True,601,377,21,https://github.com/bsmiles32,PI refactorings,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/436,https://github.com/bsmiles32,11,https://github.com/mupen64plus/mupen64plus-core/pull/436#issuecomment-338017835,"Main focus of this PR is to move some dma logic inside each dma'ble component (flashram, sram, cart_rom) to make pi_controller more agnostic to the type of component it accesses. I also moved these components inside the cart subsytem.","Exactly, for this PR I want same behavior. but after this is merged, we can try more accurate behavior. Things that come to mind is indeed the open bus behavior, and ideally doing the effective dma copy inside pi controller instead of in each devices. Also, maybe we could derive the dma timings from the pi_bsd_domX_zzz_regs. Also, having the cart decide what's mapped in addr2 space (rom, SRAM, flash). Same for addr1 with DD.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,436,2017-10-14T07:46:21Z,2017-10-19T20:23:56Z,2017-11-02T01:53:26Z,MERGED,True,601,377,21,https://github.com/bsmiles32,PI refactorings,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/436,https://github.com/loganmc10,12,https://github.com/mupen64plus/mupen64plus-core/pull/436#issuecomment-338020793,"Main focus of this PR is to move some dma logic inside each dma'ble component (flashram, sram, cart_rom) to make pi_controller more agnostic to the type of component it accesses. I also moved these components inside the cart subsytem.","Looks good to me, I believe I've tested a game with every type of save, no issues anymore",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,436,2017-10-14T07:46:21Z,2017-10-19T20:23:56Z,2017-11-02T01:53:26Z,MERGED,True,601,377,21,https://github.com/bsmiles32,PI refactorings,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/436,https://github.com/bsmiles32,13,https://github.com/mupen64plus/mupen64plus-core/pull/436#issuecomment-338025876,"Main focus of this PR is to move some dma logic inside each dma'ble component (flashram, sram, cart_rom) to make pi_controller more agnostic to the type of component it accesses. I also moved these components inside the cart subsytem.","Great ! If you're okay, I'll merge this right away :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,436,2017-10-14T07:46:21Z,2017-10-19T20:23:56Z,2017-11-02T01:53:26Z,MERGED,True,601,377,21,https://github.com/bsmiles32,PI refactorings,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/436,https://github.com/loganmc10,14,https://github.com/mupen64plus/mupen64plus-core/pull/436#issuecomment-338026053,"Main focus of this PR is to move some dma logic inside each dma'ble component (flashram, sram, cart_rom) to make pi_controller more agnostic to the type of component it accesses. I also moved these components inside the cart subsytem.",yeah fine with me,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,437,2017-10-14T18:55:17Z,2017-10-15T03:07:38Z,2017-10-15T15:52:02Z,MERGED,True,672,162,1,None,ROM database update,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/437,None,1,https://github.com/mupen64plus/mupen64plus-core/pull/437,"This should make the database on par with PJ64 😄. The main changes are GoodN64 additions, and I checked/added all Mempak/Rumble/Transferpak entries for Japan.
I also tested/confirmed some cart save types, and added CountPerOp=1 to the games below. I tested them with the latest M64P GUI build.
Goemon games: Fixes slowdowns during some cutscenes.
Pokemon Snap: project64/project64#1393, same with M64P
Wonder Project J2: project64/project64#1238, same with M64P","This should make the database on par with PJ64 😄. The main changes are GoodN64 additions, and I checked/added all Mempak/Rumble/Transferpak entries for Japan.
I also tested/confirmed some cart save types, and added CountPerOp=1 to the games below. I tested them with the latest M64P GUI build.
Goemon games: Fixes slowdowns during some cutscenes.
Pokemon Snap: project64/project64#1393, same with M64P
Wonder Project J2: project64/project64#1238, same with M64P",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,437,2017-10-14T18:55:17Z,2017-10-15T03:07:38Z,2017-10-15T15:52:02Z,MERGED,True,672,162,1,None,ROM database update,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/437,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/437#issuecomment-336665848,"This should make the database on par with PJ64 😄. The main changes are GoodN64 additions, and I checked/added all Mempak/Rumble/Transferpak entries for Japan.
I also tested/confirmed some cart save types, and added CountPerOp=1 to the games below. I tested them with the latest M64P GUI build.
Goemon games: Fixes slowdowns during some cutscenes.
Pokemon Snap: project64/project64#1393, same with M64P
Wonder Project J2: project64/project64#1238, same with M64P","Wow this seems like a massive effort, did you use some kind of tool?
I noticed Transferpak was removed from the Japanese version of Perfect Dark and Mickey's Speedway, do they not support it?
Also I noticed at least 1 MD5 changed (E version of Indiana Jones), can someone confirm that? I don't think I have a copy",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,437,2017-10-14T18:55:17Z,2017-10-15T03:07:38Z,2017-10-15T15:52:02Z,MERGED,True,672,162,1,None,ROM database update,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/437,None,3,https://github.com/mupen64plus/mupen64plus-core/pull/437#issuecomment-336666736,"This should make the database on par with PJ64 😄. The main changes are GoodN64 additions, and I checked/added all Mempak/Rumble/Transferpak entries for Japan.
I also tested/confirmed some cart save types, and added CountPerOp=1 to the games below. I tested them with the latest M64P GUI build.
Goemon games: Fixes slowdowns during some cutscenes.
Pokemon Snap: project64/project64#1393, same with M64P
Wonder Project J2: project64/project64#1238, same with M64P","Yes, it took me a few days 😓. I didn't use a tool, I just compared ROMs against PJ64's rdb, and added the ones that matched with GoodN64 V327.
Those two (J) games do not support the Transferpak, due to the GB games not being released in Japan.
The previous Indiana Jones (E) hash was little-endian. I noticed it when I was renaming it.",True,{'HOORAY': ['https://github.com/loganmc10']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,437,2017-10-14T18:55:17Z,2017-10-15T03:07:38Z,2017-10-15T15:52:02Z,MERGED,True,672,162,1,None,ROM database update,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/437,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/437#issuecomment-336666868,"This should make the database on par with PJ64 😄. The main changes are GoodN64 additions, and I checked/added all Mempak/Rumble/Transferpak entries for Japan.
I also tested/confirmed some cart save types, and added CountPerOp=1 to the games below. I tested them with the latest M64P GUI build.
Goemon games: Fixes slowdowns during some cutscenes.
Pokemon Snap: project64/project64#1393, same with M64P
Wonder Project J2: project64/project64#1238, same with M64P","Thanks, like I said, massive effort and very tedious, good work",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,437,2017-10-14T18:55:17Z,2017-10-15T03:07:38Z,2017-10-15T15:52:02Z,MERGED,True,672,162,1,None,ROM database update,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/437,None,5,https://github.com/mupen64plus/mupen64plus-core/pull/437#issuecomment-336667298,"This should make the database on par with PJ64 😄. The main changes are GoodN64 additions, and I checked/added all Mempak/Rumble/Transferpak entries for Japan.
I also tested/confirmed some cart save types, and added CountPerOp=1 to the games below. I tested them with the latest M64P GUI build.
Goemon games: Fixes slowdowns during some cutscenes.
Pokemon Snap: project64/project64#1393, same with M64P
Wonder Project J2: project64/project64#1238, same with M64P","No problem :). There are still tons of missing GoodN64 roms, but I only added the non-bad/hack ones that I noticed were missing. We'd need a tool to add those, if they are wanted for the database. Though copying the game settings would be tricky.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,439,2017-10-15T14:08:41Z,2017-10-15T17:01:10Z,2017-11-02T01:53:30Z,MERGED,True,19,5,1,https://github.com/bsmiles32,Fix crash when loading savestate.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/439,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/439,"savestate loading code was trying to poweron rumble pak on a
non-initialized rumble pak.
Now we check that the game is rumble pak compatible (therefore it has
been initialized) before calling the poweron function.
A similar issue was also present for transferpak.","savestate loading code was trying to poweron rumble pak on a
non-initialized rumble pak.
Now we check that the game is rumble pak compatible (therefore it has
been initialized) before calling the poweron function.
A similar issue was also present for transferpak.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,439,2017-10-15T14:08:41Z,2017-10-15T17:01:10Z,2017-11-02T01:53:30Z,MERGED,True,19,5,1,https://github.com/bsmiles32,Fix crash when loading savestate.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/439,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/439#issuecomment-336715108,"savestate loading code was trying to poweron rumble pak on a
non-initialized rumble pak.
Now we check that the game is rumble pak compatible (therefore it has
been initialized) before calling the poweron function.
A similar issue was also present for transferpak.",I just tested this. It does seem to fix the crashing when loading save states.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,440,2017-10-17T01:06:39Z,2017-10-17T01:38:32Z,2017-10-19T00:03:04Z,MERGED,True,25,32,1,None,Mempak/Rumble fixes,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/440,None,1,https://github.com/mupen64plus/mupen64plus-core/pull/440,"I noticed that I missed a few games in #437, so here are the corrections. I also fixed a wrong CRC value that I had copied from PJ64's rdb. I double checked my additions and it was the only wrong CRC.","I noticed that I missed a few games in #437, so here are the corrections. I also fixed a wrong CRC value that I had copied from PJ64's rdb. I double checked my additions and it was the only wrong CRC.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,443,2017-10-18T20:49:26Z,2017-10-19T01:19:04Z,2017-11-09T15:50:02Z,MERGED,True,0,3,1,https://github.com/loganmc10,Remove CountPerOp=1 for Ep I Racer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/443,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/443,"Some PR over the summer has fixed the audio in this game with CountPerOp=2, it used to not work (#272)
The CPU usage in this game is a lot higher with CountPerOp=1, so since there are no more issues with CountPerOp=2, it should be the default again. Hopefully this means I can finally play it on my tablet at full speed!","Some PR over the summer has fixed the audio in this game with CountPerOp=2, it used to not work (#272)
The CPU usage in this game is a lot higher with CountPerOp=1, so since there are no more issues with CountPerOp=2, it should be the default again. Hopefully this means I can finally play it on my tablet at full speed!",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,443,2017-10-18T20:49:26Z,2017-10-19T01:19:04Z,2017-11-09T15:50:02Z,MERGED,True,0,3,1,https://github.com/loganmc10,Remove CountPerOp=1 for Ep I Racer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/443,https://github.com/AmbientMalice,2,https://github.com/mupen64plus/mupen64plus-core/pull/443#issuecomment-337739555,"Some PR over the summer has fixed the audio in this game with CountPerOp=2, it used to not work (#272)
The CPU usage in this game is a lot higher with CountPerOp=1, so since there are no more issues with CountPerOp=2, it should be the default again. Hopefully this means I can finally play it on my tablet at full speed!","From memory, Episode 1 Racer has a pretty atrocious framerate with 2. It's one of the reasons the game has CF=1 on PJ64. The game had framerate issues on real N64 hardware, and that's kind of a problem for a fast paced racing game.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,443,2017-10-18T20:49:26Z,2017-10-19T01:19:04Z,2017-11-09T15:50:02Z,MERGED,True,0,3,1,https://github.com/loganmc10,Remove CountPerOp=1 for Ep I Racer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/443,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/443#issuecomment-337742087,"Some PR over the summer has fixed the audio in this game with CountPerOp=2, it used to not work (#272)
The CPU usage in this game is a lot higher with CountPerOp=1, so since there are no more issues with CountPerOp=2, it should be the default again. Hopefully this means I can finally play it on my tablet at full speed!","I played through a race on Tatooine and it seemed quite smooth, normal/playable to me at least. This is easy to test though, the CountPerOp settings can be overridden for any game.
The difference in CPU usage is pretty dramatic. On my Windows laptop it shows the CPU usage at 24-25% during a race (4 logical processors so that is almost maxed out). With CountPerOp=2 the CPU usage is around 15%",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,443,2017-10-18T20:49:26Z,2017-10-19T01:19:04Z,2017-11-09T15:50:02Z,MERGED,True,0,3,1,https://github.com/loganmc10,Remove CountPerOp=1 for Ep I Racer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/443,https://github.com/AmbientMalice,4,https://github.com/mupen64plus/mupen64plus-core/pull/443#issuecomment-338351176,"Some PR over the summer has fixed the audio in this game with CountPerOp=2, it used to not work (#272)
The CPU usage in this game is a lot higher with CountPerOp=1, so since there are no more issues with CountPerOp=2, it should be the default again. Hopefully this means I can finally play it on my tablet at full speed!","The difference in CPU usage is pretty dramatic. On my Windows laptop it shows the CPU usage at 24-25% during a race (4 logical processors so that is almost maxed out). With CountPerOp=2 the CPU usage is around 15%

The game runs at 30fps with frequent dips with CPO 2. It runs at 60-70fps at CPO 1. It doesn't appear to have to proper frame limiter. There's no right answer to this, but 60fps is inherently better than 30fps with constant dipping. The problem is, of course, that running the game at 60fps is inherently more demanding. Same as running Rogue Squadron at 60fps with a hack.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,443,2017-10-18T20:49:26Z,2017-10-19T01:19:04Z,2017-11-09T15:50:02Z,MERGED,True,0,3,1,https://github.com/loganmc10,Remove CountPerOp=1 for Ep I Racer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/443,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/443#issuecomment-338352346,"Some PR over the summer has fixed the audio in this game with CountPerOp=2, it used to not work (#272)
The CPU usage in this game is a lot higher with CountPerOp=1, so since there are no more issues with CountPerOp=2, it should be the default again. Hopefully this means I can finally play it on my tablet at full speed!","Well the right answer is what it ran at on a real N64, what was the framerate there?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,443,2017-10-18T20:49:26Z,2017-10-19T01:19:04Z,2017-11-09T15:50:02Z,MERGED,True,0,3,1,https://github.com/loganmc10,Remove CountPerOp=1 for Ep I Racer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/443,https://github.com/AmbientMalice,6,https://github.com/mupen64plus/mupen64plus-core/pull/443#issuecomment-338353230,"Some PR over the summer has fixed the audio in this game with CountPerOp=2, it used to not work (#272)
The CPU usage in this game is a lot higher with CountPerOp=1, so since there are no more issues with CountPerOp=2, it should be the default again. Hopefully this means I can finally play it on my tablet at full speed!","Well the right answer is what it ran at on a real N64, what was the framerate there?

Under 30 FPS pretty much constantly. It's one of the reasons the PC version is preferred, because the N64 version is hard to control -- almost brokenly so in high resolution mode -- and the Dreamcast version is locked at 30fps. (Yet ironically the N64 version does run at 60fps if overclocked.)
I think the fundamental problem is there's no simple user facing overclocking function. The game running atrociously is kinda accurate to hardware, but I wouldn't wish that experience on anyone. However, accuracy should ideally be the default. This problem will only get worse as N64 emulators improve in accuracy. Running games at a higher framerate has been a luxury afforded by a sloppy approach to emulator timings.
I'm still not sure what the right approach with games like Perfect Dark is. The game runs at 17fps on a regular basis on mupen64plus. That's absolutely horrible. But raising CountPerOp to 1 causes some minor bugs in addition to a massive framerate boost. The former is more accurate, but the latter is a much more enjoyable way to play the game.
One possible solution would be an option users tick to automatically override the CPO setting for certain games. These games could have canoverlock=true in the RDB, and if the player has gamespecificoverclock=true enabled, those games are automatically given inaccurate, but faster timing.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,443,2017-10-18T20:49:26Z,2017-10-19T01:19:04Z,2017-11-09T15:50:02Z,MERGED,True,0,3,1,https://github.com/loganmc10,Remove CountPerOp=1 for Ep I Racer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/443,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/443#issuecomment-338360072,"Some PR over the summer has fixed the audio in this game with CountPerOp=2, it used to not work (#272)
The CPU usage in this game is a lot higher with CountPerOp=1, so since there are no more issues with CountPerOp=2, it should be the default again. Hopefully this means I can finally play it on my tablet at full speed!","Yeah I definitely think the default should be how an N64 would run it. It probably wouldn't hurt to have an overclocking option. I haven't really looked at what PJ64 did to accomplish that. Setting CountPerOp=1 sort of accomplishes that, but I'm sure there is a better way. Then people could just enable or disable overclocking via the config as they see fit",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,444,2017-10-18T21:24:09Z,2017-10-19T03:42:53Z,2018-01-14T11:15:15Z,MERGED,True,17,23,4,https://github.com/loganmc10,Re-work the way VI interrupts are timed,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/444,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/444,"A VI interrupt should happen when VI_CURRENT_REG = VI_V_INTR_REG. VI_CURRENT_REG basically has no meaning unless VI_V_SYNC_REG is set. Therefore no interrupt should be triggered until VI_V_SYNC_REG is set.
So, this removes the more hackish method we currently use of just kicking off the VI's when the game starts, and replaces it with this method:
The first VI is triggered when VI_V_SYNC_REG has a nonzero value written to it.
Benefits:

Indiana Jones used to not boot with CountPerOp=1 (if no save file existed), now it does
Both BattleTanx (U) games needed CountPerOp=3 to boot, now they don't

I think this shows that this is probably a more accurate way to kick off the VI's. I tested a few games, including the usual suspects like Pokemon Puzzle League and didn't see any regressions.","A VI interrupt should happen when VI_CURRENT_REG = VI_V_INTR_REG. VI_CURRENT_REG basically has no meaning unless VI_V_SYNC_REG is set. Therefore no interrupt should be triggered until VI_V_SYNC_REG is set.
So, this removes the more hackish method we currently use of just kicking off the VI's when the game starts, and replaces it with this method:
The first VI is triggered when VI_V_SYNC_REG has a nonzero value written to it.
Benefits:

Indiana Jones used to not boot with CountPerOp=1 (if no save file existed), now it does
Both BattleTanx (U) games needed CountPerOp=3 to boot, now they don't

I think this shows that this is probably a more accurate way to kick off the VI's. I tested a few games, including the usual suspects like Pokemon Puzzle League and didn't see any regressions.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,444,2017-10-18T21:24:09Z,2017-10-19T03:42:53Z,2018-01-14T11:15:15Z,MERGED,True,17,23,4,https://github.com/loganmc10,Re-work the way VI interrupts are timed,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/444,https://github.com/Gillou68310,2,https://github.com/mupen64plus/mupen64plus-core/pull/444#issuecomment-338369330,"A VI interrupt should happen when VI_CURRENT_REG = VI_V_INTR_REG. VI_CURRENT_REG basically has no meaning unless VI_V_SYNC_REG is set. Therefore no interrupt should be triggered until VI_V_SYNC_REG is set.
So, this removes the more hackish method we currently use of just kicking off the VI's when the game starts, and replaces it with this method:
The first VI is triggered when VI_V_SYNC_REG has a nonzero value written to it.
Benefits:

Indiana Jones used to not boot with CountPerOp=1 (if no save file existed), now it does
Both BattleTanx (U) games needed CountPerOp=3 to boot, now they don't

I think this shows that this is probably a more accurate way to kick off the VI's. I tested a few games, including the usual suspects like Pokemon Puzzle League and didn't see any regressions.",@loganmc10 this seems to have introduced a large delay at startup.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,444,2017-10-18T21:24:09Z,2017-10-19T03:42:53Z,2018-01-14T11:15:15Z,MERGED,True,17,23,4,https://github.com/loganmc10,Re-work the way VI interrupts are timed,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/444,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/444#issuecomment-338386748,"A VI interrupt should happen when VI_CURRENT_REG = VI_V_INTR_REG. VI_CURRENT_REG basically has no meaning unless VI_V_SYNC_REG is set. Therefore no interrupt should be triggered until VI_V_SYNC_REG is set.
So, this removes the more hackish method we currently use of just kicking off the VI's when the game starts, and replaces it with this method:
The first VI is triggered when VI_V_SYNC_REG has a nonzero value written to it.
Benefits:

Indiana Jones used to not boot with CountPerOp=1 (if no save file existed), now it does
Both BattleTanx (U) games needed CountPerOp=3 to boot, now they don't

I think this shows that this is probably a more accurate way to kick off the VI's. I tested a few games, including the usual suspects like Pokemon Puzzle League and didn't see any regressions.","I noticed that Super Mario seemed to take a bit longer for the image to appear, I didn't notice any other games, do you have an example?
I'm open to suggestions, a long delay isn't necessarily an indication of an issue, the console might have had the same delay. I believe this is a more accurate way of kicking off the VI's but I could be wrong",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,444,2017-10-18T21:24:09Z,2017-10-19T03:42:53Z,2018-01-14T11:15:15Z,MERGED,True,17,23,4,https://github.com/loganmc10,Re-work the way VI interrupts are timed,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/444,https://github.com/Gillou68310,4,https://github.com/mupen64plus/mupen64plus-core/pull/444#issuecomment-338386984,"A VI interrupt should happen when VI_CURRENT_REG = VI_V_INTR_REG. VI_CURRENT_REG basically has no meaning unless VI_V_SYNC_REG is set. Therefore no interrupt should be triggered until VI_V_SYNC_REG is set.
So, this removes the more hackish method we currently use of just kicking off the VI's when the game starts, and replaces it with this method:
The first VI is triggered when VI_V_SYNC_REG has a nonzero value written to it.
Benefits:

Indiana Jones used to not boot with CountPerOp=1 (if no save file existed), now it does
Both BattleTanx (U) games needed CountPerOp=3 to boot, now they don't

I think this shows that this is probably a more accurate way to kick off the VI's. I tested a few games, including the usual suspects like Pokemon Puzzle League and didn't see any regressions.","Well, almost every game I tested have this delay, turok 2 is an another example.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,444,2017-10-18T21:24:09Z,2017-10-19T03:42:53Z,2018-01-14T11:15:15Z,MERGED,True,17,23,4,https://github.com/loganmc10,Re-work the way VI interrupts are timed,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/444,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/444#issuecomment-338388163,"A VI interrupt should happen when VI_CURRENT_REG = VI_V_INTR_REG. VI_CURRENT_REG basically has no meaning unless VI_V_SYNC_REG is set. Therefore no interrupt should be triggered until VI_V_SYNC_REG is set.
So, this removes the more hackish method we currently use of just kicking off the VI's when the game starts, and replaces it with this method:
The first VI is triggered when VI_V_SYNC_REG has a nonzero value written to it.
Benefits:

Indiana Jones used to not boot with CountPerOp=1 (if no save file existed), now it does
Both BattleTanx (U) games needed CountPerOp=3 to boot, now they don't

I think this shows that this is probably a more accurate way to kick off the VI's. I tested a few games, including the usual suspects like Pokemon Puzzle League and didn't see any regressions.","Fair enough, still, I think someone would need to measure a real console, from the time they hit the power switch to when the image appears. Time without an image on the screen is still potentially legitimate time.
The way we were doing it before was definitely hacky, like I mentioned, I believe this is the right way to trigger the first VI, but I could be wrong. I don't have a real N64 to test unfortunately",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,444,2017-10-18T21:24:09Z,2017-10-19T03:42:53Z,2018-01-14T11:15:15Z,MERGED,True,17,23,4,https://github.com/loganmc10,Re-work the way VI interrupts are timed,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/444,https://github.com/Gillou68310,6,https://github.com/mupen64plus/mupen64plus-core/pull/444#issuecomment-338390405,"A VI interrupt should happen when VI_CURRENT_REG = VI_V_INTR_REG. VI_CURRENT_REG basically has no meaning unless VI_V_SYNC_REG is set. Therefore no interrupt should be triggered until VI_V_SYNC_REG is set.
So, this removes the more hackish method we currently use of just kicking off the VI's when the game starts, and replaces it with this method:
The first VI is triggered when VI_V_SYNC_REG has a nonzero value written to it.
Benefits:

Indiana Jones used to not boot with CountPerOp=1 (if no save file existed), now it does
Both BattleTanx (U) games needed CountPerOp=3 to boot, now they don't

I think this shows that this is probably a more accurate way to kick off the VI's. I tested a few games, including the usual suspects like Pokemon Puzzle League and didn't see any regressions.",How is this done in other emu? PJ64 for example?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,444,2017-10-18T21:24:09Z,2017-10-19T03:42:53Z,2018-01-14T11:15:15Z,MERGED,True,17,23,4,https://github.com/loganmc10,Re-work the way VI interrupts are timed,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/444,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/444#issuecomment-338390721,"A VI interrupt should happen when VI_CURRENT_REG = VI_V_INTR_REG. VI_CURRENT_REG basically has no meaning unless VI_V_SYNC_REG is set. Therefore no interrupt should be triggered until VI_V_SYNC_REG is set.
So, this removes the more hackish method we currently use of just kicking off the VI's when the game starts, and replaces it with this method:
The first VI is triggered when VI_V_SYNC_REG has a nonzero value written to it.
Benefits:

Indiana Jones used to not boot with CountPerOp=1 (if no save file existed), now it does
Both BattleTanx (U) games needed CountPerOp=3 to boot, now they don't

I think this shows that this is probably a more accurate way to kick off the VI's. I tested a few games, including the usual suspects like Pokemon Puzzle League and didn't see any regressions.","The same way as we did it before, they just kick off the VI's when the game starts with some delay like 5000 (I can't remember the exact value).
They suffer from the same issues with Battle Tanx and Indiana Jones, where you need a specific Counter Factor for those games to boot",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,444,2017-10-18T21:24:09Z,2017-10-19T03:42:53Z,2018-01-14T11:15:15Z,MERGED,True,17,23,4,https://github.com/loganmc10,Re-work the way VI interrupts are timed,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/444,https://github.com/Gillou68310,8,https://github.com/mupen64plus/mupen64plus-core/pull/444#issuecomment-338393241,"A VI interrupt should happen when VI_CURRENT_REG = VI_V_INTR_REG. VI_CURRENT_REG basically has no meaning unless VI_V_SYNC_REG is set. Therefore no interrupt should be triggered until VI_V_SYNC_REG is set.
So, this removes the more hackish method we currently use of just kicking off the VI's when the game starts, and replaces it with this method:
The first VI is triggered when VI_V_SYNC_REG has a nonzero value written to it.
Benefits:

Indiana Jones used to not boot with CountPerOp=1 (if no save file existed), now it does
Both BattleTanx (U) games needed CountPerOp=3 to boot, now they don't

I think this shows that this is probably a more accurate way to kick off the VI's. I tested a few games, including the usual suspects like Pokemon Puzzle League and didn't see any regressions.",Also it would be interesting to understand why the core takes so much time before writing to VI_V_SYNC_REG,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,444,2017-10-18T21:24:09Z,2017-10-19T03:42:53Z,2018-01-14T11:15:15Z,MERGED,True,17,23,4,https://github.com/loganmc10,Re-work the way VI interrupts are timed,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/444,https://github.com/Gillou68310,9,https://github.com/mupen64plus/mupen64plus-core/pull/444#issuecomment-351971403,"A VI interrupt should happen when VI_CURRENT_REG = VI_V_INTR_REG. VI_CURRENT_REG basically has no meaning unless VI_V_SYNC_REG is set. Therefore no interrupt should be triggered until VI_V_SYNC_REG is set.
So, this removes the more hackish method we currently use of just kicking off the VI's when the game starts, and replaces it with this method:
The first VI is triggered when VI_V_SYNC_REG has a nonzero value written to it.
Benefits:

Indiana Jones used to not boot with CountPerOp=1 (if no save file existed), now it does
Both BattleTanx (U) games needed CountPerOp=3 to boot, now they don't

I think this shows that this is probably a more accurate way to kick off the VI's. I tested a few games, including the usual suspects like Pokemon Puzzle League and didn't see any regressions.","@loganmc10 @richard42 @bsmiles32 we really need to find a workaround for the startup delay. This is probably not a big deal for users but during my debugging sessions I'm spending most of my time waiting for the game to start.
Maybe we can add a config parameter to allow using the old hacky (but fast) way.
What do you think?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,444,2017-10-18T21:24:09Z,2017-10-19T03:42:53Z,2018-01-14T11:15:15Z,MERGED,True,17,23,4,https://github.com/loganmc10,Re-work the way VI interrupts are timed,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/444,https://github.com/loganmc10,10,https://github.com/mupen64plus/mupen64plus-core/pull/444#issuecomment-352001830,"A VI interrupt should happen when VI_CURRENT_REG = VI_V_INTR_REG. VI_CURRENT_REG basically has no meaning unless VI_V_SYNC_REG is set. Therefore no interrupt should be triggered until VI_V_SYNC_REG is set.
So, this removes the more hackish method we currently use of just kicking off the VI's when the game starts, and replaces it with this method:
The first VI is triggered when VI_V_SYNC_REG has a nonzero value written to it.
Benefits:

Indiana Jones used to not boot with CountPerOp=1 (if no save file existed), now it does
Both BattleTanx (U) games needed CountPerOp=3 to boot, now they don't

I think this shows that this is probably a more accurate way to kick off the VI's. I tested a few games, including the usual suspects like Pokemon Puzzle League and didn't see any regressions.","Is it really that long for you? I don't really notice it.
Anyway, I thought this was a pretty good change, it allows battletanx to boot without needing CountPerOp=3 for instance.
A VI interrupt is supposed to happen when VI_CURRENT_REG = VI_INTR_REG. so an interrupt shouldn't happen until the registers are set in such a way that that is possible. That's what this PR was trying to address.
I think the goal should be to emulate the N64 as accurately as possible. I don't have a physical n64 anymore, but I suspect it has similar startup delays. The problem with the old hacky way is that we've now gotten rid of the CountPerOp settings for battletanx (and I think at least 1 other game), so those games will no longer boot using the old method",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,444,2017-10-18T21:24:09Z,2017-10-19T03:42:53Z,2018-01-14T11:15:15Z,MERGED,True,17,23,4,https://github.com/loganmc10,Re-work the way VI interrupts are timed,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/444,https://github.com/loganmc10,11,https://github.com/mupen64plus/mupen64plus-core/pull/444#issuecomment-352003941,"A VI interrupt should happen when VI_CURRENT_REG = VI_V_INTR_REG. VI_CURRENT_REG basically has no meaning unless VI_V_SYNC_REG is set. Therefore no interrupt should be triggered until VI_V_SYNC_REG is set.
So, this removes the more hackish method we currently use of just kicking off the VI's when the game starts, and replaces it with this method:
The first VI is triggered when VI_V_SYNC_REG has a nonzero value written to it.
Benefits:

Indiana Jones used to not boot with CountPerOp=1 (if no save file existed), now it does
Both BattleTanx (U) games needed CountPerOp=3 to boot, now they don't

I think this shows that this is probably a more accurate way to kick off the VI's. I tested a few games, including the usual suspects like Pokemon Puzzle League and didn't see any regressions.","By the way, are you sure it's all related to this commit? If you use GLideN64, it recently started compiling all the shaders at boot, instead of on-the-fly, it also generates textures used for noise emulation at boot. So it probably has much longer startup times compared to other GFX plugins, and that would have increased lately",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,444,2017-10-18T21:24:09Z,2017-10-19T03:42:53Z,2018-01-14T11:15:15Z,MERGED,True,17,23,4,https://github.com/loganmc10,Re-work the way VI interrupts are timed,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/444,https://github.com/Gillou68310,12,https://github.com/mupen64plus/mupen64plus-core/pull/444#issuecomment-352012812,"A VI interrupt should happen when VI_CURRENT_REG = VI_V_INTR_REG. VI_CURRENT_REG basically has no meaning unless VI_V_SYNC_REG is set. Therefore no interrupt should be triggered until VI_V_SYNC_REG is set.
So, this removes the more hackish method we currently use of just kicking off the VI's when the game starts, and replaces it with this method:
The first VI is triggered when VI_V_SYNC_REG has a nonzero value written to it.
Benefits:

Indiana Jones used to not boot with CountPerOp=1 (if no save file existed), now it does
Both BattleTanx (U) games needed CountPerOp=3 to boot, now they don't

I think this shows that this is probably a more accurate way to kick off the VI's. I tested a few games, including the usual suspects like Pokemon Puzzle League and didn't see any regressions.","Is it really that long for you? I don't really notice it.

When reverting this commit I went from 10 sec waiting to instant boot in WDC. I just tested again so I'm pretty sure it's not related to any other plugin update ;-)
Also I'm not talking about reverting this commit because I agree with what it addresses. I would rather try to find a non intrusive workaround in order to bypass the startup delay.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,444,2017-10-18T21:24:09Z,2017-10-19T03:42:53Z,2018-01-14T11:15:15Z,MERGED,True,17,23,4,https://github.com/loganmc10,Re-work the way VI interrupts are timed,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/444,https://github.com/Gillou68310,13,https://github.com/mupen64plus/mupen64plus-core/pull/444#issuecomment-352017479,"A VI interrupt should happen when VI_CURRENT_REG = VI_V_INTR_REG. VI_CURRENT_REG basically has no meaning unless VI_V_SYNC_REG is set. Therefore no interrupt should be triggered until VI_V_SYNC_REG is set.
So, this removes the more hackish method we currently use of just kicking off the VI's when the game starts, and replaces it with this method:
The first VI is triggered when VI_V_SYNC_REG has a nonzero value written to it.
Benefits:

Indiana Jones used to not boot with CountPerOp=1 (if no save file existed), now it does
Both BattleTanx (U) games needed CountPerOp=3 to boot, now they don't

I think this shows that this is probably a more accurate way to kick off the VI's. I tested a few games, including the usual suspects like Pokemon Puzzle League and didn't see any regressions.",,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,444,2017-10-18T21:24:09Z,2017-10-19T03:42:53Z,2018-01-14T11:15:15Z,MERGED,True,17,23,4,https://github.com/loganmc10,Re-work the way VI interrupts are timed,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/444,https://github.com/loganmc10,14,https://github.com/mupen64plus/mupen64plus-core/pull/444#issuecomment-352028205,"A VI interrupt should happen when VI_CURRENT_REG = VI_V_INTR_REG. VI_CURRENT_REG basically has no meaning unless VI_V_SYNC_REG is set. Therefore no interrupt should be triggered until VI_V_SYNC_REG is set.
So, this removes the more hackish method we currently use of just kicking off the VI's when the game starts, and replaces it with this method:
The first VI is triggered when VI_V_SYNC_REG has a nonzero value written to it.
Benefits:

Indiana Jones used to not boot with CountPerOp=1 (if no save file existed), now it does
Both BattleTanx (U) games needed CountPerOp=3 to boot, now they don't

I think this shows that this is probably a more accurate way to kick off the VI's. I tested a few games, including the usual suspects like Pokemon Puzzle League and didn't see any regressions.","I guess it's probably different in a release build, on my PC when using GLideN64, WDC launches in just under 5 seconds after I click ""go"" (using mupen64plus-gui). If I use Angrylion Plus, the game launches in just under 2 seconds.
Just re-adding add_interrupt_event_count(&dev->r4300.cp0, VI_INT, 5000); to the end of poweron_device() would probably speed up the boot (mimic the old behavior).
I don't think it's really needed for end users. you you could probably wrap it like:
#ifdef FAST_BOOT
add_interrupt_event_count(&dev->r4300.cp0, VI_INT, 5000);
#endif

at the end of poweron_device(), something like that, and then just define FAST_BOOT when you are debugging/working? I think that would be a bit cleaner than adding a config parameter.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,444,2017-10-18T21:24:09Z,2017-10-19T03:42:53Z,2018-01-14T11:15:15Z,MERGED,True,17,23,4,https://github.com/loganmc10,Re-work the way VI interrupts are timed,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/444,https://github.com/Gillou68310,15,https://github.com/mupen64plus/mupen64plus-core/pull/444#issuecomment-352463949,"A VI interrupt should happen when VI_CURRENT_REG = VI_V_INTR_REG. VI_CURRENT_REG basically has no meaning unless VI_V_SYNC_REG is set. Therefore no interrupt should be triggered until VI_V_SYNC_REG is set.
So, this removes the more hackish method we currently use of just kicking off the VI's when the game starts, and replaces it with this method:
The first VI is triggered when VI_V_SYNC_REG has a nonzero value written to it.
Benefits:

Indiana Jones used to not boot with CountPerOp=1 (if no save file existed), now it does
Both BattleTanx (U) games needed CountPerOp=3 to boot, now they don't

I think this shows that this is probably a more accurate way to kick off the VI's. I tested a few games, including the usual suspects like Pokemon Puzzle League and didn't see any regressions.","Ok I made some debugging and the core is looping forever into the same procedure (doing the same thing over and over) until cp0_regs[CP0_COUNT_REG] > UINT32_C(0x10000000) (see special_int_handler)
Reducing the value will reduce the startup delay but I have no idea what this is used for.
@richard42 @bsmiles32 do you have any information about the special interrupt?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,444,2017-10-18T21:24:09Z,2017-10-19T03:42:53Z,2018-01-14T11:15:15Z,MERGED,True,17,23,4,https://github.com/loganmc10,Re-work the way VI interrupts are timed,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/444,https://github.com/fzurita,16,https://github.com/mupen64plus/mupen64plus-core/pull/444#issuecomment-352582113,"A VI interrupt should happen when VI_CURRENT_REG = VI_V_INTR_REG. VI_CURRENT_REG basically has no meaning unless VI_V_SYNC_REG is set. Therefore no interrupt should be triggered until VI_V_SYNC_REG is set.
So, this removes the more hackish method we currently use of just kicking off the VI's when the game starts, and replaces it with this method:
The first VI is triggered when VI_V_SYNC_REG has a nonzero value written to it.
Benefits:

Indiana Jones used to not boot with CountPerOp=1 (if no save file existed), now it does
Both BattleTanx (U) games needed CountPerOp=3 to boot, now they don't

I think this shows that this is probably a more accurate way to kick off the VI's. I tested a few games, including the usual suspects like Pokemon Puzzle League and didn't see any regressions.","This is an interesting one. On one device, I have a 20-30 second delay when starting CBFD, on another device, the delay doesn't exist. If I disable FB emulation on GLideN64, the delay goes away (maybe 5 seconds). I'm not sure why one device is affected and the other is not.
I wonder if it's the same issue.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,444,2017-10-18T21:24:09Z,2017-10-19T03:42:53Z,2018-01-14T11:15:15Z,MERGED,True,17,23,4,https://github.com/loganmc10,Re-work the way VI interrupts are timed,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/444,https://github.com/bsmiles32,17,https://github.com/mupen64plus/mupen64plus-core/pull/444#issuecomment-357446452,"A VI interrupt should happen when VI_CURRENT_REG = VI_V_INTR_REG. VI_CURRENT_REG basically has no meaning unless VI_V_SYNC_REG is set. Therefore no interrupt should be triggered until VI_V_SYNC_REG is set.
So, this removes the more hackish method we currently use of just kicking off the VI's when the game starts, and replaces it with this method:
The first VI is triggered when VI_V_SYNC_REG has a nonzero value written to it.
Benefits:

Indiana Jones used to not boot with CountPerOp=1 (if no save file existed), now it does
Both BattleTanx (U) games needed CountPerOp=3 to boot, now they don't

I think this shows that this is probably a more accurate way to kick off the VI's. I tested a few games, including the usual suspects like Pokemon Puzzle League and didn't see any regressions.","@Gillou68310 : Interrupt/event scheduling is quite complex and I don't fully understand it. With that said, it works more or less like that :

we maintain some kind of priority queue ordered (more or less) by their timestamp (""count"" in the code). This priority queue is implemented with a single linked-list (whose node are allocated via a pool of reusable nodes). An extra field ""cp0_next_interrupt"" contains the first upcoming interrupt/event timestamp, so we know if we need to execute some interrupt handler (eg if CP0_COUNT_REG >= cp0_next_interrupt).
event/interrupt timestamps (eg ""count"") is 32-bit unsigned and can overflow, so a scheme was devised (when 64-bit registers were not common) to handle gracefully this wrap-around. This is done thanks to the ""SPECIAL_INT"" event.
This SPECIAL_INT event is always triggered when CP0_COUNT_REG wraps around, eg reaches 0 (more or less, because we don't check at every cycles if CP0_COUNT_REG >= cp0_next_interrupt). When it is triggered, it sets ""special_done"" to 1. There is a test to not do anything if CP0_COUNT is above a certain threshold, but I don't understand why it exists.
This ""special_done"" variable changes how new events (which have an overflowed counter) are prioritized when they are inserted into the priority queue (see before_event function).
The before_event function is what keeps the priority queue ordered (however it seems that not all the ordering details are encapsulated inside this very function, some ordering details such as the special handling of special events are also inside the add_interrupt_event_count).
This function is a bit convoluted because it compares events relative to the current CP0_COUNT_REG to see if event timestamps have overflowed or not.

All in all, the interrupt/event scheduling code is quite difficult to reason about because :

it has been implemented with uint32_t timestamps that can overflow
such overflow handling logic has diffused in several places of the code (not just the ordering function)
so reasoning about this code is very hard to say the least.

I can see 2 ways to proceed from here :

do away with uint32_t timestamps, and use uint64_t so that overflows are not a problem anymore
or keep uint32_t timestamps and try to refactor this code so that we have a clear priorty queue code, with a well defined ordering function. But even then I can't guarantee that it would be bug-free.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,444,2017-10-18T21:24:09Z,2017-10-19T03:42:53Z,2018-01-14T11:15:15Z,MERGED,True,17,23,4,https://github.com/loganmc10,Re-work the way VI interrupts are timed,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/444,https://github.com/loganmc10,18,https://github.com/mupen64plus/mupen64plus-core/pull/444#issuecomment-357447979,"A VI interrupt should happen when VI_CURRENT_REG = VI_V_INTR_REG. VI_CURRENT_REG basically has no meaning unless VI_V_SYNC_REG is set. Therefore no interrupt should be triggered until VI_V_SYNC_REG is set.
So, this removes the more hackish method we currently use of just kicking off the VI's when the game starts, and replaces it with this method:
The first VI is triggered when VI_V_SYNC_REG has a nonzero value written to it.
Benefits:

Indiana Jones used to not boot with CountPerOp=1 (if no save file existed), now it does
Both BattleTanx (U) games needed CountPerOp=3 to boot, now they don't

I think this shows that this is probably a more accurate way to kick off the VI's. I tested a few games, including the usual suspects like Pokemon Puzzle League and didn't see any regressions.","Maybe I misunderstand what you're talking about, but isn't the COUNT register wraparound a feature of the R4300? My understanding is that it is a 32 bit register and the r4300 would reset it to 0 when it overflowed",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,444,2017-10-18T21:24:09Z,2017-10-19T03:42:53Z,2018-01-14T11:15:15Z,MERGED,True,17,23,4,https://github.com/loganmc10,Re-work the way VI interrupts are timed,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/444,https://github.com/bsmiles32,19,https://github.com/mupen64plus/mupen64plus-core/pull/444#issuecomment-357449487,"A VI interrupt should happen when VI_CURRENT_REG = VI_V_INTR_REG. VI_CURRENT_REG basically has no meaning unless VI_V_SYNC_REG is set. Therefore no interrupt should be triggered until VI_V_SYNC_REG is set.
So, this removes the more hackish method we currently use of just kicking off the VI's when the game starts, and replaces it with this method:
The first VI is triggered when VI_V_SYNC_REG has a nonzero value written to it.
Benefits:

Indiana Jones used to not boot with CountPerOp=1 (if no save file existed), now it does
Both BattleTanx (U) games needed CountPerOp=3 to boot, now they don't

I think this shows that this is probably a more accurate way to kick off the VI's. I tested a few games, including the usual suspects like Pokemon Puzzle League and didn't see any regressions.","@loganmc10 COUNT register is indeed a 32-bit overflowing register. The problem is how to compare events taking into account this overflowing. If we go the 64-bit route, we make COUNT being the lowest 32-bit of the global 64-bit cycle counts, and make events also 64-bit so that ordering them becomes trivial and there would be no need for the wrap-around logic + special_int.
Edit : however, that would break retro-compatibility with current savestates... Or maybe we can  add an extra epoch field or something to take compensate the migration to 64-bit",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,444,2017-10-18T21:24:09Z,2017-10-19T03:42:53Z,2018-01-14T11:15:15Z,MERGED,True,17,23,4,https://github.com/loganmc10,Re-work the way VI interrupts are timed,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/444,https://github.com/Gillou68310,20,https://github.com/mupen64plus/mupen64plus-core/pull/444#issuecomment-357504367,"A VI interrupt should happen when VI_CURRENT_REG = VI_V_INTR_REG. VI_CURRENT_REG basically has no meaning unless VI_V_SYNC_REG is set. Therefore no interrupt should be triggered until VI_V_SYNC_REG is set.
So, this removes the more hackish method we currently use of just kicking off the VI's when the game starts, and replaces it with this method:
The first VI is triggered when VI_V_SYNC_REG has a nonzero value written to it.
Benefits:

Indiana Jones used to not boot with CountPerOp=1 (if no save file existed), now it does
Both BattleTanx (U) games needed CountPerOp=3 to boot, now they don't

I think this shows that this is probably a more accurate way to kick off the VI's. I tested a few games, including the usual suspects like Pokemon Puzzle League and didn't see any regressions.","@bsmiles32 thanks for the detailed explanation! ""SPECIAL_INT"" is probably not a good name BTW, ""OVERFLOW_INT"" would be more appropriate IMO.

There is a test to not do anything if CP0_COUNT is above a certain threshold, but I don't understand why it exists.

Yep this is a mystery.

do away with uint32_t timestamps, and use uint64_t so that overflows are not a problem anymore

I like the idea of using a 64bit value for the count, it will definitely simplify the code. Also at 93.75MHz it will take approximately 6239 years to overflow the 64bit value. I think we are good here :-)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/446,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/LuigiBlood,2,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-337954032,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","The implementation that works the best is on Project64. That said all implementations are based on what MAME already did, thanks to @Happy-yppaH. I only added save and swapping support on Project64, added support on parallel-n64 but I think the implementation is awful and hacky because I don't really like mupen64plus' codebase. MAME's codebase tends to be simple so you can check it out and try to understand it if you want.
From what I understand, it's doing something at C2 correction data (DMA write is CART -> RAM, right?)
Make sure C2 data is all 00s at all times.
It's doing 64DD IPL region check (0609FF00), 0xC3 = Japan, 0x04 = USA. It freezes when the check fails. So it seemed to have passed.
However for 060004BC, I'm not sure why it checks the IPL3 of the 64DD IPL...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-340091519,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","Rebased against master, updated msvc files, did some more editing and now I can get a bit further...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/LuigiBlood,4,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-340094408,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129",That sounds good to me.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/bsmiles32,5,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-340096294,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129",@LuigiBlood Any idea what I should look into now ? Or games I can test ?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/LuigiBlood,6,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-340113467,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","To be honest just about any game in the 64DD library are pushing the GFX plugins and I think are worth taking a look at. Sim City 64 is the one that pushes them harder.
Mario Artist suite is worth a try to add disk swapping support and such. You could also check saving support that way.
Also on parallel-n64, Japan Pro Golf Tour 64 is not playable. I assume it's also the case of mupen64plus.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/bsmiles32,7,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-341280372,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129",Rebased against master.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/bsmiles32,8,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-343611135,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129",Rebased against master,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/bsmiles32,9,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-345443925,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129",Rebased against master,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/LuigiBlood,10,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-345444878,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","/* XXX: add convert back function */
Can be found here:
https://github.com/LuigiBlood/ddconvert_back
https://github.com/project64/project64/blob/master/Source/Project64-core/N64System/N64DiskClass.cpp#L449",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/bsmiles32,11,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-345445033,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","Thanks ! I will indeed need to look into that for good save support. Also I need to do proper savestates, disk swapping, ...
I move slow in this PR, but I think after the next release, I'll be able to have it in shape and ready :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/LuigiBlood,12,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-345445469,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","About M64CMD_SET_MEDIA_LOADER, Mario Artist might be a good way to test since you can load the game + GameBoy Camera (Japanese) ROM and RAM to take photos from.
I implemented GB Camera mapper a while back (I remember it was a mix of previous mappers I think?)
https://github.com/project64/project64/blob/master/Source/nragev20/GBCart.cpp#L1059
If you wanna go crazy, implement Camera support for it lol
When I tried to deal with the Capture Cartridge, I simply don't understand how the image format is like.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/bsmiles32,13,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-345445885,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","Didn't know there was already an implementation. Will put it on my todo list.
Or if you want to work on it, be my guest :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/LuigiBlood,14,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-345446089,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","I guess it could easily be done by myself. When I'll have some time to spend I could try to see.
I definitely remember just copy pasting code and change a little bit of it and got away with it.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/bsmiles32,15,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-347705855,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","Rebased against master.
Added convert back function.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/bsmiles32,16,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-348810693,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129",Rebased against master,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/bsmiles32,17,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-352600434,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129",Rebased against master,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/LuigiBlood,18,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-352601668,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","if (w == 0xe848d316 || w == 0x2263ee56) {
    DebugMessage(M64MSG_WARNING, ""Loading a saved disk "");
}

What does this mean, actually?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/bsmiles32,19,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-352604226,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","I guess it is 64 disk magic constant check like
https://github.com/project64/project64/blob/def0550dede289f7702c5613b69f796e7ff68ac8/Source/Project64-core/N64System/N64DiskClass.cpp#L116-L121",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/LuigiBlood,20,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-352674346,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","Actually that magic number is the disk region. e848d316 is Japanese, 2263ee56 is US (unreleased but we have the US IPL so why not)
That's why I rely on it for detection but when I think about it I think I should like, rely on other offsets as well.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/Narann,21,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-352677037,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","Actually that magic number is the disk region. e848d316 is Japanese, 2263ee56 is US (unreleased but we have the US IPL so why not)

A perfect candidate for some constants here. :D",True,{'THUMBS_UP': ['https://github.com/rlabrecque']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/bsmiles32,22,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-357455432,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129",Updated against master.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/bsmiles32,23,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-377731926,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","Rebased against master. Added savestate support, SDK and MAME dump format support, preliminary save support (but disabled because of severe slowdown).
SM64DD: works OK
DKDJ: seems to boot (hear music, brief ""loading"" message), but can't get in game
DKIJ: dito
DKKJ: dito
DMBJ: seems OK - emit warnings in menu screen with JCMD warning 23 01 14 (not DD related)
DMGJ: seems OK
DMPJ: goes to menu, but can't do much
DMTJ: seems OK
DPGJ: goes up to press start screen, then freezes
DRDJ: goes to press start screen, but doesn't react to any presses
DSCJ: boots, goes in-game, but many missing graphics
EFZJ: boots, but complains about missing F-ZEROX cart, even if it is plugged :(
@richard42 Even if support is really basic, maybe we could get this (and the ui-console part) merged so that our users can enjoy it. (And I wouldn't have to keep rebasing every now and then...). What do you think ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/LuigiBlood,24,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-377732410,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","DMPJ: Cursor is invisible? Plugin's fault. Must enable ""Render frame buffer as texture"" or something like that. Otherwise it should work okay.
DPGJ: That's what I got on parallel-n64.
DRDJ: That's normal it wants the modem pak.
DSCJ: Is a pain to emulate
EFZJ: You should boot F-Zero X cart. Cart takes priority over IPL.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/bsmiles32,25,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-377943361,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","@LuigiBlood Very helpful thanks ! Indeed when I force FZ to boot on the cartridge things start to work. With the dynarec, it works fine. With the pure interpreter and cached interpreter I get some strange issue where it doesn't get past the 64DD loading part. Very strange (and not reassuring...).
For this test, I forced booting on the cart for FZ (in device.c and plugin.c), but proper implementation would be ""if DD disk only, boot on DD, otherwise use cart ROM"". The problem is that this DD disk only case is not possible currently as ui/core loading sequence requires a ROM.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/LuigiBlood,26,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-377950540,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","That's pretty much how it should work, yeah. That's where it gets complicated.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/bsmiles32,27,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-378377747,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","Implemented in a hackish way the boot device selection: we boot on cart unless 64DD is plugged and the plugged cartridge is not a combo game (eg cart+disk). Be sure to plug a Japanese cart otherwise 64DD region checks will fail. With that F-Zero now works on dynarec (but some bugs prevent it to work on pure,cached interpreter).
I guess, we're now at almost parity with libretro/cen64/MAME 64DD wise. There are still some core bugs that needs to be ironed out. Then I'll look at disk swapping and saving, which will bring us closer to PJ64 level of support.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/fzurita,28,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-382373634,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129",@bsmiles32 how does this deal with game specific settings when it's always the IPL ROM being loaded?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/bsmiles32,29,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-382520777,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","@fzurita The IPL ROM is inside the disk drive itself, not the cartridge, nor the disk. It is used as a boot menu and store some hard-coded assets. In the core we use it's presence as a test for enabling DD emulation. Beside the disk drive itself, the user can insert a disk (in the console-ui you use the --dd-disk argument), which is the effective program that is run (when no cartridge is concurrently inserted).
Note: there is currently a limitation in the console-ui that requires a cartridge ROM even if strictly speaking, none is mandated in this case.
Some disk games are also meant to be played with a matching cartridge (eg F-Zero-X) to have the full experience, in this case, the console boots on the cartridge, which can then use use the disk at will.
The heuristic we use to notify the GFX plugin of what game is played is here:
https://github.com/bsmiles32/mupen64plus-core/blob/740406ff156ce2b8867f7c416996404e2f0981bb/src/plugin/plugin.c#L233
Clearly, it is not perfect [disks cannot be discriminated], but given that there is no ""header"" in the 64DD disk, we don't have much choice.
Maybe we could, change the API to pass a truly unique game identifier (like SHA-256) so that plugins know what game is loaded, and there what settings to apply. Or embed in the core some ""fake headers"" for the disk games (based on their cartridge port) to make the GFX plugin happy. Given that there are only a few disk-only games, hard-coding them may still be acceptable.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/fzurita,30,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-382522021,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","My question was going to lead to that, so you answered some of the quetions I had. What about loading appropriate settings for a disk from mupen64plus.ini?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/bsmiles32,31,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-382523306,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","I think the MD5 computation for identification in mupen64plus.ini is still based on the cartridge ROM [1], so for now, it is not possible to load game-specific parameters for disks.
[1] https://github.com/bsmiles32/mupen64plus-core/blob/740406ff156ce2b8867f7c416996404e2f0981bb/src/main/rom.c#L154",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/bsmiles32,32,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-382523777,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","But you can cheat and insert a ""compatible"" cartridge ROM (japanese, otherwise some regional check can fail)...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/fzurita,33,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-382524283,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","What about this? For 64DD cartridges, we could combine the IPL+disk or ROM+disk together to come up with one big md5?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/LuigiBlood,34,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-382524684,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129",If you do the big MD5 just mind that there are portions you just cannot do any checksums on because it's different on each disk.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/fzurita,35,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-382526302,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129",One big MD5 still doesn't fix the ROM header issue. I guess a ROM header could be faked out by the core based on the combined MD5.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/fzurita,36,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-382526921,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","@LuigiBlood is there such thing as a ""pristine"" disk image where nothing has been written yet? It would be nice if an emulator could direct any writes to a separate file that indexes into the pristine disk image, so that the pristine disk image is never modified.
Edit: I'm thinking this could be like a patch file, but for binary.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/bsmiles32,37,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-382527483,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","Since there is not really any choice when combining a cart and a disk, I don't think a big MD5 brings much. However, generating a ""fake"" header based on a hash of the ""read-only part"" of the disk, could work.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/LuigiBlood,38,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-382539350,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129",@fzurita I did exactly that on Project64. But I didn't say it's not possible to do a MD5. Depending on Disk Type you can actually make it work. Just ignore System Area (different dates on each disk) and RAM area (save data).,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/loganmc10,39,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-383958904,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","I think this should be merged soon, it can always be improved upon later, it's all pretty self contained so it's not going to cause issues with other games, lets not make @bsmiles32 keep rebasing this until the end of time.",True,"{'THUMBS_UP': ['https://github.com/fzurita', 'https://github.com/LuigiBlood']}"
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/fzurita,40,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-387036290,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129",@richard42 can this be merged? I would love to add support to Mupen64plus AE.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/LuigiBlood,41,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-387049687,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129",I'm literally just waiting for this to be merged so I can work on the promised Game Boy Camera Transfer Pak support.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/Narann,42,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-387074216,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129",I think @bsmiles32 has the permissions to merge. Do you wait for anyone's approval first ?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/loganmc10,43,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-388076715,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","This PR caused a new issue in Coverity:
*** CID 278587:  Null pointer dereferences  (FORWARD_NULL)
/src/device/dd/dd_controller.c: 425 in read_dd_regs()
419         switch(reg)
420         {
421         case DD_ASIC_CMD_STATUS: {
422                 /* clear BM interrupt when reading gap */
423                 if ((dd->regs[DD_ASIC_CMD_STATUS] & DD_STATUS_BM_INT) && (dd->regs[DD_ASIC_CUR_SECTOR] > SECTORS_PER_BLOCK)) {
424                     clear_dd_interrupt(dd, DD_STATUS_BM_INT);
>>>     CID 278587:  Null pointer dereferences  (FORWARD_NULL)
>>>     Passing ""dd"" to ""dd_update_bm"", which dereferences null ""dd->idisk"".
425                     dd_update_bm(dd);
426                 }
427             } break;
428         }
429     }
430",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/richard42,44,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-388245227,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","I saw this also, but disregarded it. If dd is NULL it will crash at line 423 anyway, so who cares about crashing inside the dd_update_bm() function on line 425?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/bsmiles32,45,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-388392475,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","@LuigiBlood I've been working on GB cam support with promising results while waiting for this to be merged :

It still needs some cleaning, but I should PR soonish :)",True,{'HEART': ['https://github.com/Narann']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/LuigiBlood,46,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-388395434,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129",I wanted to do it once you were done with DD but I guess you did it yourself instead :P,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,446,2017-10-19T13:46:47Z,2018-05-08T04:23:50Z,2021-02-01T11:21:54Z,MERGED,True,1501,36,21,https://github.com/bsmiles32,[WIP] Add support for 64 Disk Drive.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/446,https://github.com/hissingshark,47,https://github.com/mupen64plus/mupen64plus-core/pull/446#issuecomment-401593586,"Not ready for merging nor public consumption yet, and will certainly need several iterations to be done (read: I will rebase and force push often !).
I'm trying to finally add 64DD support. I've based my work on the parallel code, cen64 and looked a bit at pj64 source also (edit : what/where is the canonical/latest implementation ?). I've also updated the code to match the latest core paradigms.
But in the process I might have mixed up some lines between all these. So it doesn't really work : DD IPL boots and try to load a disk, but get stuck with a black screen.
The last DD MMIO/DMA logs show the following.
Core: DD DMA write dram=0033f450  cart=05000000 length=000003a0
Core: DD REG: 05000540 -> 00030000
Core: DD ROM: 0609FF00 -> c3dbfe61
Core: DD ROM: 060004BC -> 3c0ba600

@LuigiBlood : Any idea where I can look to debug this ?
NDD file and DD IPL ROM paths are hardcoded inside the source (./NUD-EFZJ-JPN.ndd and ./64ddipl.bin). Proper support for disk and ipl loading will come later.
Issue : #129","Hi, it's the first time this year I've rebuilt from master and I'm getting a segfault, which I've bisected back to commit e302bc2 ""Add support for 64 Disk Drive"".  Not opened a separate issue as this still seems to be a work in progress.
Mario Kart shows the spinning logo at the start but segfaults just before the start screen.
Super Smash Bros segfaults during the intro animation.
I'm on armv8, Amlogic S905x (Mali 450 GPU).  GLES2.  And I was using the mupen64plus-video-n64 plugin.
Anything I can provide to assist debugging?
EDIT - sorry this has been merged so better I open an issue.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,448,2017-10-20T21:04:04Z,2017-10-21T00:02:07Z,2017-10-22T00:01:27Z,MERGED,True,35,19,1,None,Fix some Save Type entries,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/448,None,1,https://github.com/mupen64plus/mupen64plus-core/pull/448,"This fixes some incorrect SaveType=None entries. I also added types for a few other games. I tested the game saving to make sure these changes are accurate.
I also removed Transferpak=Yes from Transformers - Beast Wars Transmetal (U), only the (J) game supports it.
Note: Hybrid Heaven (E)(U), Top Gear Rally (U), and Transformers - Beast Wars Transmetal (U) don't use cart saving.","This fixes some incorrect SaveType=None entries. I also added types for a few other games. I tested the game saving to make sure these changes are accurate.
I also removed Transferpak=Yes from Transformers - Beast Wars Transmetal (U), only the (J) game supports it.
Note: Hybrid Heaven (E)(U), Top Gear Rally (U), and Transformers - Beast Wars Transmetal (U) don't use cart saving.",True,{'THUMBS_UP': ['https://github.com/loganmc10']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,449,2017-10-21T05:14:53Z,2017-11-01T17:55:37Z,2017-11-01T17:58:54Z,MERGED,True,72,16,6,https://github.com/fzurita,Allow switching controller paks using CONTROLS.plugin API,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/449,https://github.com/fzurita,1,https://github.com/mupen64plus/mupen64plus-core/pull/449,"Allow switching controller paks using CONTROLS.Plugin API. Instead of reading the Plugin parameter once at startup, it will constantly be read, like old behavior.
Also, if an invalid pak is selected for a game, it will use ""None"" instead of the first available. This is more similar to older behavior.
This addresses #445","Allow switching controller paks using CONTROLS.Plugin API. Instead of reading the Plugin parameter once at startup, it will constantly be read, like old behavior.
Also, if an invalid pak is selected for a game, it will use ""None"" instead of the first available. This is more similar to older behavior.
This addresses #445",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,449,2017-10-21T05:14:53Z,2017-11-01T17:55:37Z,2017-11-01T17:58:54Z,MERGED,True,72,16,6,https://github.com/fzurita,Allow switching controller paks using CONTROLS.plugin API,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/449,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/449#issuecomment-338365181,"Allow switching controller paks using CONTROLS.Plugin API. Instead of reading the Plugin parameter once at startup, it will constantly be read, like old behavior.
Also, if an invalid pak is selected for a game, it will use ""None"" instead of the first available. This is more similar to older behavior.
This addresses #445","If possible, I would appreciate some testing of the ""Next Pak"" button. I did not test that functionality since my setup (Android with mupen64plus-ae) doesn't make that easy to test.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,449,2017-10-21T05:14:53Z,2017-11-01T17:55:37Z,2017-11-01T17:58:54Z,MERGED,True,72,16,6,https://github.com/fzurita,Allow switching controller paks using CONTROLS.plugin API,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/449,https://github.com/fzurita,3,https://github.com/mupen64plus/mupen64plus-core/pull/449#issuecomment-338475807,"Allow switching controller paks using CONTROLS.Plugin API. Instead of reading the Plugin parameter once at startup, it will constantly be read, like old behavior.
Also, if an invalid pak is selected for a game, it will use ""None"" instead of the first available. This is more similar to older behavior.
This addresses #445",@bsmiles32 what do you think about this?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,449,2017-10-21T05:14:53Z,2017-11-01T17:55:37Z,2017-11-01T17:58:54Z,MERGED,True,72,16,6,https://github.com/fzurita,Allow switching controller paks using CONTROLS.plugin API,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/449,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/449#issuecomment-338506415,"Allow switching controller paks using CONTROLS.Plugin API. Instead of reading the Plugin parameter once at startup, it will constantly be read, like old behavior.
Also, if an invalid pak is selected for a game, it will use ""None"" instead of the first available. This is more similar to older behavior.
This addresses #445","I haven't gotten a chance to test this yet, but this:
static int switchToNextPak[4] = {0};
static int switchToSpecificPak[4] = {0};

Is probably not a good way to initialize the variables if you're counting on that setting them to 0. Remember that the core can technically stop and start multiple ROMs without ever being unloaded",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,449,2017-10-21T05:14:53Z,2017-11-01T17:55:37Z,2017-11-01T17:58:54Z,MERGED,True,72,16,6,https://github.com/fzurita,Allow switching controller paks using CONTROLS.plugin API,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/449,https://github.com/fzurita,5,https://github.com/mupen64plus/mupen64plus-core/pull/449#issuecomment-338507069,"Allow switching controller paks using CONTROLS.Plugin API. Instead of reading the Plugin parameter once at startup, it will constantly be read, like old behavior.
Also, if an invalid pak is selected for a game, it will use ""None"" instead of the first available. This is more similar to older behavior.
This addresses #445","I'm thinking that should be fine. The individual members of those arrays get set back to zero after paks are done switching.
If you start changing paks and then before paks are done changing, the game is switched, then things may get weird. You would start the second game with the second available Pak instead of the first. But I think that would be ok.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,449,2017-10-21T05:14:53Z,2017-11-01T17:55:37Z,2017-11-01T17:58:54Z,MERGED,True,72,16,6,https://github.com/fzurita,Allow switching controller paks using CONTROLS.plugin API,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/449,https://github.com/fzurita,6,https://github.com/mupen64plus/mupen64plus-core/pull/449#issuecomment-340648092,"Allow switching controller paks using CONTROLS.Plugin API. Instead of reading the Plugin parameter once at startup, it will constantly be read, like old behavior.
Also, if an invalid pak is selected for a game, it will use ""None"" instead of the first available. This is more similar to older behavior.
This addresses #445","@bsmiles32 any chance of merging this? Without it, the Android input plugin doesn't work correctly.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,449,2017-10-21T05:14:53Z,2017-11-01T17:55:37Z,2017-11-01T17:58:54Z,MERGED,True,72,16,6,https://github.com/fzurita,Allow switching controller paks using CONTROLS.plugin API,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/449,https://github.com/bsmiles32,7,https://github.com/mupen64plus/mupen64plus-core/pull/449#issuecomment-340686197,"Allow switching controller paks using CONTROLS.Plugin API. Instead of reading the Plugin parameter once at startup, it will constantly be read, like old behavior.
Also, if an invalid pak is selected for a game, it will use ""None"" instead of the first available. This is more similar to older behavior.
This addresses #445","@fzurita Sorry it took me so long to review your PR. See fzurita#1 for comments and fixes. Can you test if selecting the pak type from menu still works as intended on your end ?
Also, I'm a bit hesitant here (not your PR, just overall design I ended up with) because, now we have 2 ways to handle pak switching and I don't like that. I originally put that ""pak cycling"" logic inside the core for convenience (core knows about which paks are compatible for a given game) but doing so I resorted to the hacky, input-sdl specific, PAK_SWITCH_BUTTON to trigger the pak switch. I feel like fixing these hacks would be easier if/when we get rid of input plugins and integrate them inside the core.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,449,2017-10-21T05:14:53Z,2017-11-01T17:55:37Z,2017-11-01T17:58:54Z,MERGED,True,72,16,6,https://github.com/fzurita,Allow switching controller paks using CONTROLS.plugin API,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/449,https://github.com/fzurita,8,https://github.com/mupen64plus/mupen64plus-core/pull/449#issuecomment-340731617,"Allow switching controller paks using CONTROLS.Plugin API. Instead of reading the Plugin parameter once at startup, it will constantly be read, like old behavior.
Also, if an invalid pak is selected for a game, it will use ""None"" instead of the first available. This is more similar to older behavior.
This addresses #445",Thanks for rewriting my fix :). I'll check if it works correctly still with the Android input plugin.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,449,2017-10-21T05:14:53Z,2017-11-01T17:55:37Z,2017-11-01T17:58:54Z,MERGED,True,72,16,6,https://github.com/fzurita,Allow switching controller paks using CONTROLS.plugin API,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/449,https://github.com/fzurita,9,https://github.com/mupen64plus/mupen64plus-core/pull/449#issuecomment-340823708,"Allow switching controller paks using CONTROLS.Plugin API. Instead of reading the Plugin parameter once at startup, it will constantly be read, like old behavior.
Also, if an invalid pak is selected for a game, it will use ""None"" instead of the first available. This is more similar to older behavior.
This addresses #445","@bsmiles32 you changes work correctly on my device. I updated the pull request with your changes.
One less hacky way of doing this maybe be to have  the special button press change CONTROLS.plugin instead of changing the selected Pak directly. That way, there is only one method of doing things.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,449,2017-10-21T05:14:53Z,2017-11-01T17:55:37Z,2017-11-01T17:58:54Z,MERGED,True,72,16,6,https://github.com/fzurita,Allow switching controller paks using CONTROLS.plugin API,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/449,https://github.com/fzurita,10,https://github.com/mupen64plus/mupen64plus-core/pull/449#issuecomment-341117716,"Allow switching controller paks using CONTROLS.Plugin API. Instead of reading the Plugin parameter once at startup, it will constantly be read, like old behavior.
Also, if an invalid pak is selected for a game, it will use ""None"" instead of the first available. This is more similar to older behavior.
This addresses #445",@bsmiles32 are we ok with merging this after your changes? Or would you rather come up with a less hacky solution?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,449,2017-10-21T05:14:53Z,2017-11-01T17:55:37Z,2017-11-01T17:58:54Z,MERGED,True,72,16,6,https://github.com/fzurita,Allow switching controller paks using CONTROLS.plugin API,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/449,https://github.com/bsmiles32,11,https://github.com/mupen64plus/mupen64plus-core/pull/449#issuecomment-341188030,"Allow switching controller paks using CONTROLS.Plugin API. Instead of reading the Plugin parameter once at startup, it will constantly be read, like old behavior.
Also, if an invalid pak is selected for a game, it will use ""None"" instead of the first available. This is more similar to older behavior.
This addresses #445","@fzurita Merging this now, because it fixes a bug. Properly addressing this can come later as it is not a user-facing issue.
Also, changing the Controls[i].Plugin from the core might not be a so good idea. If you change that from the core, the input plugin can get ""confused"" that one of its variable changed ""magically""...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,450,2017-10-21T08:04:10Z,2017-10-21T20:07:14Z,2017-10-31T09:46:59Z,MERGED,True,178,176,7,https://github.com/Gillou68310,Fix issues listed in #385,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/450,https://github.com/Gillou68310,1,https://github.com/mupen64plus/mupen64plus-core/pull/450,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,450,2017-10-21T08:04:10Z,2017-10-21T20:07:14Z,2017-10-31T09:46:59Z,MERGED,True,178,176,7,https://github.com/Gillou68310,Fix issues listed in #385,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/450,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/450#issuecomment-338386873,,You've got a build failure in AppVeyor,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,450,2017-10-21T08:04:10Z,2017-10-21T20:07:14Z,2017-10-31T09:46:59Z,MERGED,True,178,176,7,https://github.com/Gillou68310,Fix issues listed in #385,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/450,https://github.com/Gillou68310,3,https://github.com/mupen64plus/mupen64plus-core/pull/450#issuecomment-338387095,,Yeah I saw but I don't understand how it's related to my commits.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,450,2017-10-21T08:04:10Z,2017-10-21T20:07:14Z,2017-10-31T09:46:59Z,MERGED,True,178,176,7,https://github.com/Gillou68310,Fix issues listed in #385,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/450,https://github.com/Gillou68310,4,https://github.com/mupen64plus/mupen64plus-core/pull/450#issuecomment-338388164,,I just check on my computer and it build just fine for x64,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,450,2017-10-21T08:04:10Z,2017-10-21T20:07:14Z,2017-10-31T09:46:59Z,MERGED,True,178,176,7,https://github.com/Gillou68310,Fix issues listed in #385,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/450,https://github.com/fzurita,5,https://github.com/mupen64plus/mupen64plus-core/pull/450#issuecomment-338390628,,"This is the error:
Performing Custom Build Tools
  C:\projects\mupen64plus-core\src\device\r4300\x86_64\dyna_start.asm:21: fatal: unable to open include file `asm_defines_nasm.h'

Sounds unrelated to anything you did",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,450,2017-10-21T08:04:10Z,2017-10-21T20:07:14Z,2017-10-31T09:46:59Z,MERGED,True,178,176,7,https://github.com/Gillou68310,Fix issues listed in #385,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/450,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/450#issuecomment-338390797,,"Yeah it probably just crapped out, I can restart Travis builds but I don't think I have permission to restart AppVeyor builds",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,450,2017-10-21T08:04:10Z,2017-10-21T20:07:14Z,2017-10-31T09:46:59Z,MERGED,True,178,176,7,https://github.com/Gillou68310,Fix issues listed in #385,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/450,https://github.com/fzurita,7,https://github.com/mupen64plus/mupen64plus-core/pull/450#issuecomment-338393467,,All games are booting now except for dance dance revolution. Dance dance revolution was booting until recently.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,450,2017-10-21T08:04:10Z,2017-10-21T20:07:14Z,2017-10-31T09:46:59Z,MERGED,True,178,176,7,https://github.com/Gillou68310,Fix issues listed in #385,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/450,https://github.com/Gillou68310,8,https://github.com/mupen64plus/mupen64plus-core/pull/450#issuecomment-338393721,,Thanks for testing! Could you bisect which commit broke dance dance revolution?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,450,2017-10-21T08:04:10Z,2017-10-21T20:07:14Z,2017-10-31T09:46:59Z,MERGED,True,178,176,7,https://github.com/Gillou68310,Fix issues listed in #385,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/450,https://github.com/fzurita,9,https://github.com/mupen64plus/mupen64plus-core/pull/450#issuecomment-338393934,,"Yeah, I can check.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,450,2017-10-21T08:04:10Z,2017-10-21T20:07:14Z,2017-10-31T09:46:59Z,MERGED,True,178,176,7,https://github.com/Gillou68310,Fix issues listed in #385,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/450,https://github.com/Gillou68310,10,https://github.com/mupen64plus/mupen64plus-core/pull/450#issuecomment-338394052,,Thanks ;-),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,450,2017-10-21T08:04:10Z,2017-10-21T20:07:14Z,2017-10-31T09:46:59Z,MERGED,True,178,176,7,https://github.com/Gillou68310,Fix issues listed in #385,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/450,https://github.com/fzurita,11,https://github.com/mupen64plus/mupen64plus-core/pull/450#issuecomment-338402550,,"For reference, the DDR game does boot with interpreter and the old dynarec.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,450,2017-10-21T08:04:10Z,2017-10-21T20:07:14Z,2017-10-31T09:46:59Z,MERGED,True,178,176,7,https://github.com/Gillou68310,Fix issues listed in #385,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/450,https://github.com/fzurita,12,https://github.com/mupen64plus/mupen64plus-core/pull/450#issuecomment-338409249,,It was the rework of TLB exceptions that broke the Dance Dance Revolution game in the new dynarec.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,450,2017-10-21T08:04:10Z,2017-10-21T20:07:14Z,2017-10-31T09:46:59Z,MERGED,True,178,176,7,https://github.com/Gillou68310,Fix issues listed in #385,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/450,https://github.com/fzurita,13,https://github.com/mupen64plus/mupen64plus-core/pull/450#issuecomment-338415438,,It looks like South Park 64 is also broken. This pull request doesn't fix it.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,450,2017-10-21T08:04:10Z,2017-10-21T20:07:14Z,2017-10-31T09:46:59Z,MERGED,True,178,176,7,https://github.com/Gillou68310,Fix issues listed in #385,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/450,https://github.com/fzurita,14,https://github.com/mupen64plus/mupen64plus-core/pull/450#issuecomment-338433963,,"@richard42 was it too early to merge this? This did fix a few of the mentioned games, but it broke others.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,450,2017-10-21T08:04:10Z,2017-10-21T20:07:14Z,2017-10-31T09:46:59Z,MERGED,True,178,176,7,https://github.com/Gillou68310,Fix issues listed in #385,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/450,https://github.com/richard42,15,https://github.com/mupen64plus/mupen64plus-core/pull/450#issuecomment-338438593,,oops. did this one break DDR? I was under the impression that this didn't fix everything but didn't break anything either.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,450,2017-10-21T08:04:10Z,2017-10-21T20:07:14Z,2017-10-31T09:46:59Z,MERGED,True,178,176,7,https://github.com/Gillou68310,Fix issues listed in #385,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/450,https://github.com/fzurita,16,https://github.com/mupen64plus/mupen64plus-core/pull/450#issuecomment-338442690,,See the commentary in #385.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,450,2017-10-21T08:04:10Z,2017-10-21T20:07:14Z,2017-10-31T09:46:59Z,MERGED,True,178,176,7,https://github.com/Gillou68310,Fix issues listed in #385,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/450,https://github.com/richard42,17,https://github.com/mupen64plus/mupen64plus-core/pull/450#issuecomment-338491497,,"Well it looks like this PR fixed the new dynarec problems for most of the games that were broken by recent changes, except DDR and South Park. But it caused a crash in Banjo Kazooie? Let's just open a new issue and keep moving forward.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,451,2017-10-21T11:10:23Z,2017-10-21T20:08:40Z,2017-10-21T20:08:40Z,MERGED,True,5,0,1,https://github.com/AmbientMalice,Enable CountPerOp=1 for Battletanx 2 & Army Men,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/451,https://github.com/AmbientMalice,1,https://github.com/mupen64plus/mupen64plus-core/pull/451,"This is a bit of a tricky situation. Basically the game always had CountPerOp=3 for compatibility issues. It's now CPO=2, the default, since #444
The problem is that with CPO=2, the game chugs along noticably in some missions. It was even worse before, mind you. In the third mission, in the train yard, there are extended gameplay sequences where it runs at 20fps.
I did some digging, and this YT footage of the game of real N64 hardware looks like a steady 30fps, stepping through frame by frame.
https://youtu.be/nALPY_BZgPA?t=6m35s
Also, reviews for the game praised its smooth framerate.
http://ign.com/articles/1999/10/14/battletanx-global-assault-3
I didn't change the CF for the first game because I don't have any proof that game isn't running right. If I find some, I'll make a PR. I do notice it chugs like crazy on the emulator when you use a nuke weapon, but I don't have real N64 footage of that to compare.
Additionally, I looked up some footage of Army Men: Sarge's Heroes running on a real N64.
https://www.youtube.com/watch?v=jV017qWimq0
With mupen64plus on CPO=2, the game often runs at 20fps. Bear in mind Battletanx and Army Men are from the same developer and clearly use the same engine. With CPO=1, the game floats between 30 and 60fps. Presumably the game is capped at 60fps. Since the real N64 footage shows the game running smoothly, this is more reflective of how the game should run.","This is a bit of a tricky situation. Basically the game always had CountPerOp=3 for compatibility issues. It's now CPO=2, the default, since #444
The problem is that with CPO=2, the game chugs along noticably in some missions. It was even worse before, mind you. In the third mission, in the train yard, there are extended gameplay sequences where it runs at 20fps.
I did some digging, and this YT footage of the game of real N64 hardware looks like a steady 30fps, stepping through frame by frame.
https://youtu.be/nALPY_BZgPA?t=6m35s
Also, reviews for the game praised its smooth framerate.
http://ign.com/articles/1999/10/14/battletanx-global-assault-3
I didn't change the CF for the first game because I don't have any proof that game isn't running right. If I find some, I'll make a PR. I do notice it chugs like crazy on the emulator when you use a nuke weapon, but I don't have real N64 footage of that to compare.
Additionally, I looked up some footage of Army Men: Sarge's Heroes running on a real N64.
https://www.youtube.com/watch?v=jV017qWimq0
With mupen64plus on CPO=2, the game often runs at 20fps. Bear in mind Battletanx and Army Men are from the same developer and clearly use the same engine. With CPO=1, the game floats between 30 and 60fps. Presumably the game is capped at 60fps. Since the real N64 footage shows the game running smoothly, this is more reflective of how the game should run.",True,{'THUMBS_UP': ['https://github.com/loganmc10']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,453,2017-10-23T15:28:19Z,2017-10-31T00:20:38Z,2017-11-09T15:49:48Z,MERGED,True,77,45,1,https://github.com/loganmc10,Do SI DMA in 2 stages,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/453,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/453,"Fixes #452
When I submitted #420 I thought I could simplify the code by just doing the whole DMA transaction right before the interrupt. Mischief Makers still worked so I assumed it was good.
However that change broke the input in Turok. This PR basically reverts back to the old behaviour of doing the SI DMA in 2 stages, however it still uses the DMA_BUSY flags instead of the RD_BUSY flag like it did before.
Tested a few games including Mischief Makers and Turok with no issues
Hoping for a review from @bsmiles32 before merger since he looked over the last PR and has some familiarity with that change.","Fixes #452
When I submitted #420 I thought I could simplify the code by just doing the whole DMA transaction right before the interrupt. Mischief Makers still worked so I assumed it was good.
However that change broke the input in Turok. This PR basically reverts back to the old behaviour of doing the SI DMA in 2 stages, however it still uses the DMA_BUSY flags instead of the RD_BUSY flag like it did before.
Tested a few games including Mischief Makers and Turok with no issues
Hoping for a review from @bsmiles32 before merger since he looked over the last PR and has some familiarity with that change.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,454,2017-10-24T12:24:29Z,2017-10-24T23:35:48Z,2017-11-09T15:49:58Z,MERGED,True,3,0,1,https://github.com/loganmc10,CountPerOp=1 for Gauntlet Legends,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/454,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/454,"Allows for better performance when using GLideN64. Still needs a fairly quick CPU, but the audio is really bad when using GLideN64 HLE with CountPerOp=2","Allows for better performance when using GLideN64. Still needs a fairly quick CPU, but the audio is really bad when using GLideN64 HLE with CountPerOp=2",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,454,2017-10-24T12:24:29Z,2017-10-24T23:35:48Z,2017-11-09T15:49:58Z,MERGED,True,3,0,1,https://github.com/loganmc10,CountPerOp=1 for Gauntlet Legends,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/454,https://github.com/AmbientMalice,2,https://github.com/mupen64plus/mupen64plus-core/pull/454#issuecomment-339013890,"Allows for better performance when using GLideN64. Still needs a fairly quick CPU, but the audio is really bad when using GLideN64 HLE with CountPerOp=2",Does this cause negative side effects with Angrylion's beside being more demanding? I haven't had time to test.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,454,2017-10-24T12:24:29Z,2017-10-24T23:35:48Z,2017-11-09T15:49:58Z,MERGED,True,3,0,1,https://github.com/loganmc10,CountPerOp=1 for Gauntlet Legends,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/454,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/454#issuecomment-339018010,"Allows for better performance when using GLideN64. Still needs a fairly quick CPU, but the audio is really bad when using GLideN64 HLE with CountPerOp=2","I get nowhere near full speed using angrylion, and mupen64plus has no fps counter using angrylion so it's hard to say what is working faster. It would be good for someone to test, I'm not exactly sure why it seems to perform so much better using 1, using the flickery version in glide64mk2 it seems ok at 2",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,455,2017-10-25T00:46:58Z,2017-10-27T22:02:53Z,2017-10-27T23:50:57Z,MERGED,True,90,24,1,None,Complete (U) save types + Add four games,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/455,None,1,https://github.com/mupen64plus/mupen64plus-core/pull/455,"The retail (U) save types should be accurate now :). I checked the board pics found here: http://s9.zetaboards.com/Nintendo_64_Forever/topic/7464768/1/
Note: I couldn't find a pic for Monster Truck Madness 64
I tested the ones I changed to confirm the save type.","The retail (U) save types should be accurate now :). I checked the board pics found here: http://s9.zetaboards.com/Nintendo_64_Forever/topic/7464768/1/
Note: I couldn't find a pic for Monster Truck Madness 64
I tested the ones I changed to confirm the save type.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,455,2017-10-25T00:46:58Z,2017-10-27T22:02:53Z,2017-10-27T23:50:57Z,MERGED,True,90,24,1,None,Complete (U) save types + Add four games,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/455,https://github.com/AmbientMalice,2,https://github.com/mupen64plus/mupen64plus-core/pull/455#issuecomment-339209203,"The retail (U) save types should be accurate now :). I checked the board pics found here: http://s9.zetaboards.com/Nintendo_64_Forever/topic/7464768/1/
Note: I couldn't find a pic for Monster Truck Madness 64
I tested the ones I changed to confirm the save type.","mupen64plus uses the entry RefMD5= to reduce duplication. If different variations of the game use the same settings, refer them to the MD5 hash of the ""master"" version.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,455,2017-10-25T00:46:58Z,2017-10-27T22:02:53Z,2017-10-27T23:50:57Z,MERGED,True,90,24,1,None,Complete (U) save types + Add four games,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/455,None,3,https://github.com/mupen64plus/mupen64plus-core/pull/455#issuecomment-339212116,"The retail (U) save types should be accurate now :). I checked the board pics found here: http://s9.zetaboards.com/Nintendo_64_Forever/topic/7464768/1/
Note: I couldn't find a pic for Monster Truck Madness 64
I tested the ones I changed to confirm the save type.","I thought it was only for alternate dumps of the same version? I can change it if it's better that way.
Most rom V1.1/etc have the full settings currently.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,455,2017-10-25T00:46:58Z,2017-10-27T22:02:53Z,2017-10-27T23:50:57Z,MERGED,True,90,24,1,None,Complete (U) save types + Add four games,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/455,https://github.com/AmbientMalice,4,https://github.com/mupen64plus/mupen64plus-core/pull/455#issuecomment-339213542,"The retail (U) save types should be accurate now :). I checked the board pics found here: http://s9.zetaboards.com/Nintendo_64_Forever/topic/7464768/1/
Note: I couldn't find a pic for Monster Truck Madness 64
I tested the ones I changed to confirm the save type.","For example, Rogue Squadron has this:
[47CAC4E2A6309458342F21A9018FFBF0]
GoodName=Star Wars - Rogue Squadron (U) (M3) (V1.0) [!]
CRC=66A24BEC 2EADD94F
Players=1
SaveType=Eeprom 4KB
Rumble=Yes
GoodName=Star Wars - Rogue Squadron (U) (M3) (V1.1) [!]
CRC=C7F30CFA ECB0FA36
RefMD5=47CAC4E2A6309458342F21A9018FFBF0",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,455,2017-10-25T00:46:58Z,2017-10-27T22:02:53Z,2017-10-27T23:50:57Z,MERGED,True,90,24,1,None,Complete (U) save types + Add four games,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/455,None,5,https://github.com/mupen64plus/mupen64plus-core/pull/455#issuecomment-339517853,"The retail (U) save types should be accurate now :). I checked the board pics found here: http://s9.zetaboards.com/Nintendo_64_Forever/topic/7464768/1/
Note: I couldn't find a pic for Monster Truck Madness 64
I tested the ones I changed to confirm the save type.",I added another save fix and made the four V1.1 games use the RefMD5 settings format.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,455,2017-10-25T00:46:58Z,2017-10-27T22:02:53Z,2017-10-27T23:50:57Z,MERGED,True,90,24,1,None,Complete (U) save types + Add four games,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/455,https://github.com/bsmiles32,6,https://github.com/mupen64plus/mupen64plus-core/pull/455#issuecomment-340109133,"The retail (U) save types should be accurate now :). I checked the board pics found here: http://s9.zetaboards.com/Nintendo_64_Forever/topic/7464768/1/
Note: I couldn't find a pic for Monster Truck Madness 64
I tested the ones I changed to confirm the save type.","@Enker Thanks for your work on the mupen64plus ini file. This is tedious work and we greatly appreciate your contributions.
RefMD5 indeed allow to inherit keys/values from a parent entry. This is typically used for several dumps of the ""same"" rom. However there is no clear rule (that I know of) which say what should inherit from what: should a rom revision inherit from the original version ? should a rom released in a different region inherit from another and which one (U/E/J/???)... I don't know. Maybe @richard42 knows more about that ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,455,2017-10-25T00:46:58Z,2017-10-27T22:02:53Z,2017-10-27T23:50:57Z,MERGED,True,90,24,1,None,Complete (U) save types + Add four games,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/455,None,7,https://github.com/mupen64plus/mupen64plus-core/pull/455#issuecomment-340122625,"The retail (U) save types should be accurate now :). I checked the board pics found here: http://s9.zetaboards.com/Nintendo_64_Forever/topic/7464768/1/
Note: I couldn't find a pic for Monster Truck Madness 64
I tested the ones I changed to confirm the save type.","@bsmiles32 No problem :). I'm glad I could help improve the emulator's compatibility.
Yeah, it would be nice to have a description of how RefMD5 should be used. It's currently almost exclusively used for roms with the same region+version.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,457,2017-10-25T16:45:05Z,2017-10-31T00:21:00Z,2017-11-09T15:49:52Z,MERGED,True,60,27,6,https://github.com/loganmc10,Add support for SRAM cpu read/write,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/457,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/457,"This will fix #456 once #455 is merged.
The auto-detection scheme we use to detect SRAM/flashram doesn't seem to work with Waialae Country Club.
This change will take the value in ROM_SETTINGS if it can, but still try to fallback to the auto-detection scheme if ROM_SETTINGS doesn't specify the type.
This PR adds support for reading/writing to sram via read_cart_dom2/write_cart_dom2, Waialae Country Club does this.
Finally, it gets rid of read_cart_dom2_dummy/write_cart_dom2_dummy, and maps the whole DOM2 address space to read_cart_dom2/write_cart_dom2. I'm not sure why the dummy functions are there, perhaps someone knows the back story?
So far I've tested Paper Mario and Waialae Country Club, I'll do some more testing. I'm hoping @bsmiles32 can comment on this since you seem to be pretty familiar with the memory mapping and just refactored this code","This will fix #456 once #455 is merged.
The auto-detection scheme we use to detect SRAM/flashram doesn't seem to work with Waialae Country Club.
This change will take the value in ROM_SETTINGS if it can, but still try to fallback to the auto-detection scheme if ROM_SETTINGS doesn't specify the type.
This PR adds support for reading/writing to sram via read_cart_dom2/write_cart_dom2, Waialae Country Club does this.
Finally, it gets rid of read_cart_dom2_dummy/write_cart_dom2_dummy, and maps the whole DOM2 address space to read_cart_dom2/write_cart_dom2. I'm not sure why the dummy functions are there, perhaps someone knows the back story?
So far I've tested Paper Mario and Waialae Country Club, I'll do some more testing. I'm hoping @bsmiles32 can comment on this since you seem to be pretty familiar with the memory mapping and just refactored this code",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,457,2017-10-25T16:45:05Z,2017-10-31T00:21:00Z,2017-11-09T15:49:52Z,MERGED,True,60,27,6,https://github.com/loganmc10,Add support for SRAM cpu read/write,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/457,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/457#issuecomment-339433081,"This will fix #456 once #455 is merged.
The auto-detection scheme we use to detect SRAM/flashram doesn't seem to work with Waialae Country Club.
This change will take the value in ROM_SETTINGS if it can, but still try to fallback to the auto-detection scheme if ROM_SETTINGS doesn't specify the type.
This PR adds support for reading/writing to sram via read_cart_dom2/write_cart_dom2, Waialae Country Club does this.
Finally, it gets rid of read_cart_dom2_dummy/write_cart_dom2_dummy, and maps the whole DOM2 address space to read_cart_dom2/write_cart_dom2. I'm not sure why the dummy functions are there, perhaps someone knows the back story?
So far I've tested Paper Mario and Waialae Country Club, I'll do some more testing. I'm hoping @bsmiles32 can comment on this since you seem to be pretty familiar with the memory mapping and just refactored this code","Ok I've tested quite a few games now, the only thing I notice is now in quite a few Flash RAM games (noticed it in Jet Force Gemini, Pokemon Snap, Pokemon Stadium) I get a bunch of these messages:
Core Warning: unknown flashram command: 0

I added this commit: 1264b54 to just ignore those writes, I guess this was taken care of by the ""dummy write"" before.
Project64 handles this situation by treating it the same as 0xf0000000 (FLASHRAM_MODE_READ) project64/project64#1039, but I didn't see any reason why they chose that, since our current method isn't causing any issues that I know of, I figured we might as well keep the same behavior as before",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,457,2017-10-25T16:45:05Z,2017-10-31T00:21:00Z,2017-11-09T15:49:52Z,MERGED,True,60,27,6,https://github.com/loganmc10,Add support for SRAM cpu read/write,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/457,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/457#issuecomment-339478600,"This will fix #456 once #455 is merged.
The auto-detection scheme we use to detect SRAM/flashram doesn't seem to work with Waialae Country Club.
This change will take the value in ROM_SETTINGS if it can, but still try to fallback to the auto-detection scheme if ROM_SETTINGS doesn't specify the type.
This PR adds support for reading/writing to sram via read_cart_dom2/write_cart_dom2, Waialae Country Club does this.
Finally, it gets rid of read_cart_dom2_dummy/write_cart_dom2_dummy, and maps the whole DOM2 address space to read_cart_dom2/write_cart_dom2. I'm not sure why the dummy functions are there, perhaps someone knows the back story?
So far I've tested Paper Mario and Waialae Country Club, I'll do some more testing. I'm hoping @bsmiles32 can comment on this since you seem to be pretty familiar with the memory mapping and just refactored this code","I added another commit to initialize the sram to 0xff (the same that is done for eeprom and flashram), see #456 (comment)
I tested a number of sram games like Ocarina of Time, Mario Golf, Resident Evil 2. I didn't go too far into these games though. More testing on this is always welcome.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,457,2017-10-25T16:45:05Z,2017-10-31T00:21:00Z,2017-11-09T15:49:52Z,MERGED,True,60,27,6,https://github.com/loganmc10,Add support for SRAM cpu read/write,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/457,https://github.com/AmbientMalice,4,https://github.com/mupen64plus/mupen64plus-core/pull/457#issuecomment-339482317,"This will fix #456 once #455 is merged.
The auto-detection scheme we use to detect SRAM/flashram doesn't seem to work with Waialae Country Club.
This change will take the value in ROM_SETTINGS if it can, but still try to fallback to the auto-detection scheme if ROM_SETTINGS doesn't specify the type.
This PR adds support for reading/writing to sram via read_cart_dom2/write_cart_dom2, Waialae Country Club does this.
Finally, it gets rid of read_cart_dom2_dummy/write_cart_dom2_dummy, and maps the whole DOM2 address space to read_cart_dom2/write_cart_dom2. I'm not sure why the dummy functions are there, perhaps someone knows the back story?
So far I've tested Paper Mario and Waialae Country Club, I'll do some more testing. I'm hoping @bsmiles32 can comment on this since you seem to be pretty familiar with the memory mapping and just refactored this code","I'd recommend testing Fushigi no Dungeon, since it writes to flash ram literally every time you take a step.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,457,2017-10-25T16:45:05Z,2017-10-31T00:21:00Z,2017-11-09T15:49:52Z,MERGED,True,60,27,6,https://github.com/loganmc10,Add support for SRAM cpu read/write,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/457,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/457#issuecomment-339485006,"This will fix #456 once #455 is merged.
The auto-detection scheme we use to detect SRAM/flashram doesn't seem to work with Waialae Country Club.
This change will take the value in ROM_SETTINGS if it can, but still try to fallback to the auto-detection scheme if ROM_SETTINGS doesn't specify the type.
This PR adds support for reading/writing to sram via read_cart_dom2/write_cart_dom2, Waialae Country Club does this.
Finally, it gets rid of read_cart_dom2_dummy/write_cart_dom2_dummy, and maps the whole DOM2 address space to read_cart_dom2/write_cart_dom2. I'm not sure why the dummy functions are there, perhaps someone knows the back story?
So far I've tested Paper Mario and Waialae Country Club, I'll do some more testing. I'm hoping @bsmiles32 can comment on this since you seem to be pretty familiar with the memory mapping and just refactored this code","Yeah it seems to work fine, I started a game and reloaded it without issue.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,457,2017-10-25T16:45:05Z,2017-10-31T00:21:00Z,2017-11-09T15:49:52Z,MERGED,True,60,27,6,https://github.com/loganmc10,Add support for SRAM cpu read/write,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/457,https://github.com/bsmiles32,6,https://github.com/mupen64plus/mupen64plus-core/pull/457#issuecomment-340110866,"This will fix #456 once #455 is merged.
The auto-detection scheme we use to detect SRAM/flashram doesn't seem to work with Waialae Country Club.
This change will take the value in ROM_SETTINGS if it can, but still try to fallback to the auto-detection scheme if ROM_SETTINGS doesn't specify the type.
This PR adds support for reading/writing to sram via read_cart_dom2/write_cart_dom2, Waialae Country Club does this.
Finally, it gets rid of read_cart_dom2_dummy/write_cart_dom2_dummy, and maps the whole DOM2 address space to read_cart_dom2/write_cart_dom2. I'm not sure why the dummy functions are there, perhaps someone knows the back story?
So far I've tested Paper Mario and Waialae Country Club, I'll do some more testing. I'm hoping @bsmiles32 can comment on this since you seem to be pretty familiar with the memory mapping and just refactored this code",Looks good to me except for the masked_write in write_sram. Good work !,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,457,2017-10-25T16:45:05Z,2017-10-31T00:21:00Z,2017-11-09T15:49:52Z,MERGED,True,60,27,6,https://github.com/loganmc10,Add support for SRAM cpu read/write,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/457,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/457#issuecomment-340619691,"This will fix #456 once #455 is merged.
The auto-detection scheme we use to detect SRAM/flashram doesn't seem to work with Waialae Country Club.
This change will take the value in ROM_SETTINGS if it can, but still try to fallback to the auto-detection scheme if ROM_SETTINGS doesn't specify the type.
This PR adds support for reading/writing to sram via read_cart_dom2/write_cart_dom2, Waialae Country Club does this.
Finally, it gets rid of read_cart_dom2_dummy/write_cart_dom2_dummy, and maps the whole DOM2 address space to read_cart_dom2/write_cart_dom2. I'm not sure why the dummy functions are there, perhaps someone knows the back story?
So far I've tested Paper Mario and Waialae Country Club, I'll do some more testing. I'm hoping @bsmiles32 can comment on this since you seem to be pretty familiar with the memory mapping and just refactored this code",Updated to use masked_write,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,459,2017-10-27T21:13:29Z,2017-11-02T05:22:28Z,2021-02-01T11:21:41Z,MERGED,True,84,46,8,https://github.com/bsmiles32,Fix reset,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/459,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/459,@Gillou68310 noticed that reset has been broken since remove_memd PR and bisected it at PIF Boot ROM rewrite. But a deeper analysis revealed several point of regressions (at least 3) and general weakness of the reset implementation. I'm not sure this PR fixes all regressions related to reset as I can still trigger some cascade of warnings at times. But I haven't been able to exactly track down why it is like that and what broke it.,@Gillou68310 noticed that reset has been broken since remove_memd PR and bisected it at PIF Boot ROM rewrite. But a deeper analysis revealed several point of regressions (at least 3) and general weakness of the reset implementation. I'm not sure this PR fixes all regressions related to reset as I can still trigger some cascade of warnings at times. But I haven't been able to exactly track down why it is like that and what broke it.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,459,2017-10-27T21:13:29Z,2017-11-02T05:22:28Z,2021-02-01T11:21:41Z,MERGED,True,84,46,8,https://github.com/bsmiles32,Fix reset,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/459,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/459#issuecomment-340194374,@Gillou68310 noticed that reset has been broken since remove_memd PR and bisected it at PIF Boot ROM rewrite. But a deeper analysis revealed several point of regressions (at least 3) and general weakness of the reset implementation. I'm not sure this PR fixes all regressions related to reset as I can still trigger some cascade of warnings at times. But I haven't been able to exactly track down why it is like that and what broke it.,"Ok I tested this out a bit, hard reset seems to work reliably, although if I do a hard reset, the core will freeze when shutting down and print a bunch of these messages: Core Warning: Instruction pointer is 0 at dyna_stop()
I still can't really get soft reset to work reliably (tested Super Mario 64), I think I got it to work once, but usually I'll just get a bunch of Core Warning: Unaligned dword read messages",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,460,2017-10-27T23:43:10Z,2017-11-10T01:38:53Z,2018-02-03T12:04:33Z,MERGED,True,38,12,8,https://github.com/bsmiles32,Add support for different flashram types.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/460,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/460,"Default to MX29L1100 as it is the most common one and is what pj64 uses.
I don't understand Japanese, but it looked like Derby Stallion could save stuff so it is a potential fix for #458
Will need some more testing with other flashram games though before being merged.","Default to MX29L1100 as it is the most common one and is what pj64 uses.
I don't understand Japanese, but it looked like Derby Stallion could save stuff so it is a potential fix for #458
Will need some more testing with other flashram games though before being merged.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,460,2017-10-27T23:43:10Z,2017-11-10T01:38:53Z,2018-02-03T12:04:33Z,MERGED,True,38,12,8,https://github.com/bsmiles32,Add support for different flashram types.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/460,None,2,https://github.com/mupen64plus/mupen64plus-core/pull/460#issuecomment-340212309,"Default to MX29L1100 as it is the most common one and is what pj64 uses.
I don't understand Japanese, but it looked like Derby Stallion could save stuff so it is a potential fix for #458
Will need some more testing with other flashram games though before being merged.","I found two games that don't use the MX29L1100 flashram chip.
(U) board pics: http://s9.zetaboards.com/Nintendo_64_Forever/topic/7464768/1/
A few (E) board pics are here: http://n64.icequake.net/mirror/tcsr2001.tripod.com/
Jet Force Gemini (E) = 29L1101KC-15B0
WWF No Mercy (U) (V1.0) = MN63F81MPN, V1.1 is unknown
EDIT: I found a useful post about flashram types here: http://forum.retrode.org/index.php/topic,154.msg2506.html#msg2506
I guess WWF No Mercy V1.0 will be fine with the default flashram chip.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,460,2017-10-27T23:43:10Z,2017-11-10T01:38:53Z,2018-02-03T12:04:33Z,MERGED,True,38,12,8,https://github.com/bsmiles32,Add support for different flashram types.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/460,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/460#issuecomment-343328695,"Default to MX29L1100 as it is the most common one and is what pj64 uses.
I don't understand Japanese, but it looked like Derby Stallion could save stuff so it is a potential fix for #458
Will need some more testing with other flashram games though before being merged.",Did some more test with many flashram based games and no issue so far. Also it effectively fixes Derby Stallion saves. So I think it is ready for merge.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,460,2017-10-27T23:43:10Z,2017-11-10T01:38:53Z,2018-02-03T12:04:33Z,MERGED,True,38,12,8,https://github.com/bsmiles32,Add support for different flashram types.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/460,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/460#issuecomment-343332323,"Default to MX29L1100 as it is the most common one and is what pj64 uses.
I don't understand Japanese, but it looked like Derby Stallion could save stuff so it is a potential fix for #458
Will need some more testing with other flashram games though before being merged.","Looks good to me, this is basically how it works in PJ64 so we knows it's received a lot of testing",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,461,2017-10-28T15:23:25Z,2017-11-01T18:01:54Z,2017-11-09T15:49:51Z,MERGED,True,1,63,3,https://github.com/loganmc10,Get rid of USE_SDL flag,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/461,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/461,"I added this flag a while ago as the beginning of an effort to make SDL usage optional in the core. It never got very far, other parts of the core still rely on SDL, so there is no use for this flag.
Also, I never actually added the USE_SDL flag to the MSVC project files, so the MSVC version probably hasn't been dealing with the SDL mutex at all.","I added this flag a while ago as the beginning of an effort to make SDL usage optional in the core. It never got very far, other parts of the core still rely on SDL, so there is no use for this flag.
Also, I never actually added the USE_SDL flag to the MSVC project files, so the MSVC version probably hasn't been dealing with the SDL mutex at all.",True,{'THUMBS_UP': ['https://github.com/rlabrecque']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,461,2017-10-28T15:23:25Z,2017-11-01T18:01:54Z,2017-11-09T15:49:51Z,MERGED,True,1,63,3,https://github.com/loganmc10,Get rid of USE_SDL flag,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/461,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/461#issuecomment-340198902,"I added this flag a while ago as the beginning of an effort to make SDL usage optional in the core. It never got very far, other parts of the core still rely on SDL, so there is no use for this flag.
Also, I never actually added the USE_SDL flag to the MSVC project files, so the MSVC version probably hasn't been dealing with the SDL mutex at all.",Here is the original PR for reference: #202,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,464,2017-10-30T14:15:58Z,2017-10-31T00:53:08Z,2017-11-09T15:49:49Z,MERGED,True,1,1,1,https://github.com/loganmc10,Increase Delay DP Interrupt time,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/464,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/464,"Fixes #462
The 2 other games I know of that need this are Pokemon Snap (picture taking needs it), and Kirby 64 (HUD needs it). They both still work fine.","Fixes #462
The 2 other games I know of that need this are Pokemon Snap (picture taking needs it), and Kirby 64 (HUD needs it). They both still work fine.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,465,2017-10-31T17:20:39Z,2017-11-01T18:06:03Z,2017-11-03T16:04:06Z,MERGED,True,31,19,2,https://github.com/Gillou68310,new_dynarec: Fix Dance Dance revolution,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/465,https://github.com/Gillou68310,1,https://github.com/mupen64plus/mupen64plus-core/pull/465,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,465,2017-10-31T17:20:39Z,2017-11-01T18:06:03Z,2017-11-03T16:04:06Z,MERGED,True,31,19,2,https://github.com/Gillou68310,new_dynarec: Fix Dance Dance revolution,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/465,https://github.com/Gillou68310,2,https://github.com/mupen64plus/mupen64plus-core/pull/465#issuecomment-340837634,,@fzurita could you test if this fixes the issue for you?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,465,2017-10-31T17:20:39Z,2017-11-01T18:06:03Z,2017-11-03T16:04:06Z,MERGED,True,31,19,2,https://github.com/Gillou68310,new_dynarec: Fix Dance Dance revolution,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/465,https://github.com/fzurita,3,https://github.com/mupen64plus/mupen64plus-core/pull/465#issuecomment-340848486,,"Yep, I will test once I get a chance.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,465,2017-10-31T17:20:39Z,2017-11-01T18:06:03Z,2017-11-03T16:04:06Z,MERGED,True,31,19,2,https://github.com/Gillou68310,new_dynarec: Fix Dance Dance revolution,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/465,https://github.com/fzurita,4,https://github.com/mupen64plus/mupen64plus-core/pull/465#issuecomment-340929039,,I can confirm that it's working again with the ARM new dynarec.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,466,2017-10-31T21:46:19Z,2017-11-01T17:55:11Z,2017-11-01T21:10:28Z,MERGED,True,6,1,1,None,CountPerOp=1 for Densha de Go! 64,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/466,None,1,https://github.com/mupen64plus/mupen64plus-core/pull/466,"This fixes audio crackling and it seems to keep the audio from randomly playing too fast.
I also added one game and removed CountPerOp=3 from Wave Race 64 - Shindou Edition. CPO=3 makes the game run slower and it isn't required to boot the game anymore.","This fixes audio crackling and it seems to keep the audio from randomly playing too fast.
I also added one game and removed CountPerOp=3 from Wave Race 64 - Shindou Edition. CPO=3 makes the game run slower and it isn't required to boot the game anymore.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,468,2017-11-03T23:00:40Z,2017-11-08T19:36:20Z,2017-11-08T19:36:21Z,CLOSED,False,88,2,4,https://github.com/bsmiles32,Use virtual memory to allocate g_mem_base (if possible).,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/468,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/468,"This should fix issue #467
Basically, it replaces (if possible) the big malloc with virtual memory allocation in such a way that no unneeded physical pages gets allocated. When available (-DHAVE_MMAP) we use the mmap/munmap/mprotect functions, otherwise if it is a Windows plateform we use the VirtualAlloc/VirtualFree functions and otherwise only rely on the C standard library malloc/free and hope that internally, given the size of the alloc, it will use virtual memory.
I have tested myself on Linux with and without mmap, but couldn't test other platforms.","This should fix issue #467
Basically, it replaces (if possible) the big malloc with virtual memory allocation in such a way that no unneeded physical pages gets allocated. When available (-DHAVE_MMAP) we use the mmap/munmap/mprotect functions, otherwise if it is a Windows plateform we use the VirtualAlloc/VirtualFree functions and otherwise only rely on the C standard library malloc/free and hope that internally, given the size of the alloc, it will use virtual memory.
I have tested myself on Linux with and without mmap, but couldn't test other platforms.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,468,2017-11-03T23:00:40Z,2017-11-08T19:36:20Z,2017-11-08T19:36:21Z,CLOSED,False,88,2,4,https://github.com/bsmiles32,Use virtual memory to allocate g_mem_base (if possible).,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/468,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/468#issuecomment-341914711,"This should fix issue #467
Basically, it replaces (if possible) the big malloc with virtual memory allocation in such a way that no unneeded physical pages gets allocated. When available (-DHAVE_MMAP) we use the mmap/munmap/mprotect functions, otherwise if it is a Windows plateform we use the VirtualAlloc/VirtualFree functions and otherwise only rely on the C standard library malloc/free and hope that internally, given the size of the alloc, it will use virtual memory.
I have tested myself on Linux with and without mmap, but couldn't test other platforms.","This didn't work. Allocation succeeds, but the core crashes when trying to use the memory allocated. I'll try to get a back trace later today. It looks like Samsung is not implementing mmap correctly in their kernel.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,468,2017-11-03T23:00:40Z,2017-11-08T19:36:20Z,2017-11-08T19:36:21Z,CLOSED,False,88,2,4,https://github.com/bsmiles32,Use virtual memory to allocate g_mem_base (if possible).,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/468,https://github.com/fzurita,3,https://github.com/mupen64plus/mupen64plus-core/pull/468#issuecomment-341917545,"This should fix issue #467
Basically, it replaces (if possible) the big malloc with virtual memory allocation in such a way that no unneeded physical pages gets allocated. When available (-DHAVE_MMAP) we use the mmap/munmap/mprotect functions, otherwise if it is a Windows plateform we use the VirtualAlloc/VirtualFree functions and otherwise only rely on the C standard library malloc/free and hope that internally, given the size of the alloc, it will use virtual memory.
I have tested myself on Linux with and without mmap, but couldn't test other platforms.","Ok, it seems that API level less than 21 doesn't support mmap... That's terrible. API level 21 is Android 5.0.
How hard would it be to implement a fallback mechanism to the old memory allocation method?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,468,2017-11-03T23:00:40Z,2017-11-08T19:36:20Z,2017-11-08T19:36:21Z,CLOSED,False,88,2,4,https://github.com/bsmiles32,Use virtual memory to allocate g_mem_base (if possible).,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/468,https://github.com/fzurita,4,https://github.com/mupen64plus/mupen64plus-core/pull/468#issuecomment-341967711,"This should fix issue #467
Basically, it replaces (if possible) the big malloc with virtual memory allocation in such a way that no unneeded physical pages gets allocated. When available (-DHAVE_MMAP) we use the mmap/munmap/mprotect functions, otherwise if it is a Windows plateform we use the VirtualAlloc/VirtualFree functions and otherwise only rely on the C standard library malloc/free and hope that internally, given the size of the alloc, it will use virtual memory.
I have tested myself on Linux with and without mmap, but couldn't test other platforms.","Ok, I must had been looking at the wrong log file. It didn't crash, but the allocation failed. We got the M64ERR_NO_MEMORY error code. I made sure that the mmap portion of the code was being used by removing the malloc and Windows versions.
I think it's the mmap called that failed because I never saw ""Failed to change memory protection.""",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,468,2017-11-03T23:00:40Z,2017-11-08T19:36:20Z,2017-11-08T19:36:21Z,CLOSED,False,88,2,4,https://github.com/bsmiles32,Use virtual memory to allocate g_mem_base (if possible).,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/468,https://github.com/bsmiles32,5,https://github.com/mupen64plus/mupen64plus-core/pull/468#issuecomment-341990033,"This should fix issue #467
Basically, it replaces (if possible) the big malloc with virtual memory allocation in such a way that no unneeded physical pages gets allocated. When available (-DHAVE_MMAP) we use the mmap/munmap/mprotect functions, otherwise if it is a Windows plateform we use the VirtualAlloc/VirtualFree functions and otherwise only rely on the C standard library malloc/free and hope that internally, given the size of the alloc, it will use virtual memory.
I have tested myself on Linux with and without mmap, but couldn't test other platforms.","Rebased against master, fixed the C99-ism (variable declaration inside for loop).
@fzurita Does the workaround suggested in [1] works ? (eg reducing dalvik.vm.heapsize to increase chances of having a continuous 512M chunk available ?).

Ok, it seems that API level less than 21 doesn't support mmap... That's terrible. API level 21 is Android 5.0

Do you have a link for that please ?
[1] https://stackoverflow.com/questions/33897711/android-mmap-fails-with-out-of-memory",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,468,2017-11-03T23:00:40Z,2017-11-08T19:36:20Z,2017-11-08T19:36:21Z,CLOSED,False,88,2,4,https://github.com/bsmiles32,Use virtual memory to allocate g_mem_base (if possible).,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/468,https://github.com/fzurita,6,https://github.com/mupen64plus/mupen64plus-core/pull/468#issuecomment-341991135,"This should fix issue #467
Basically, it replaces (if possible) the big malloc with virtual memory allocation in such a way that no unneeded physical pages gets allocated. When available (-DHAVE_MMAP) we use the mmap/munmap/mprotect functions, otherwise if it is a Windows plateform we use the VirtualAlloc/VirtualFree functions and otherwise only rely on the C standard library malloc/free and hope that internally, given the size of the alloc, it will use virtual memory.
I have tested myself on Linux with and without mmap, but couldn't test other platforms.","This is what I found suggesting that:
android/ndk#449
It may be that it only affects mmap64.
I did not find the page you found. That's a nice find. I'll look into that.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,468,2017-11-03T23:00:40Z,2017-11-08T19:36:20Z,2017-11-08T19:36:21Z,CLOSED,False,88,2,4,https://github.com/bsmiles32,Use virtual memory to allocate g_mem_base (if possible).,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/468,https://github.com/bsmiles32,7,https://github.com/mupen64plus/mupen64plus-core/pull/468#issuecomment-341991492,"This should fix issue #467
Basically, it replaces (if possible) the big malloc with virtual memory allocation in such a way that no unneeded physical pages gets allocated. When available (-DHAVE_MMAP) we use the mmap/munmap/mprotect functions, otherwise if it is a Windows plateform we use the VirtualAlloc/VirtualFree functions and otherwise only rely on the C standard library malloc/free and hope that internally, given the size of the alloc, it will use virtual memory.
I have tested myself on Linux with and without mmap, but couldn't test other platforms.","android/ndk#449

In this link they use mmap for file-backed memory, not anonymous allocation. So I think the issue was more that in their device your users didn't have a continuous 512M block available in their virtual address space. Trying the suggested workaround might help (and maybe even without this PR).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,468,2017-11-03T23:00:40Z,2017-11-08T19:36:20Z,2017-11-08T19:36:21Z,CLOSED,False,88,2,4,https://github.com/bsmiles32,Use virtual memory to allocate g_mem_base (if possible).,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/468,https://github.com/fzurita,8,https://github.com/mupen64plus/mupen64plus-core/pull/468#issuecomment-341991989,"This should fix issue #467
Basically, it replaces (if possible) the big malloc with virtual memory allocation in such a way that no unneeded physical pages gets allocated. When available (-DHAVE_MMAP) we use the mmap/munmap/mprotect functions, otherwise if it is a Windows plateform we use the VirtualAlloc/VirtualFree functions and otherwise only rely on the C standard library malloc/free and hope that internally, given the size of the alloc, it will use virtual memory.
I have tested myself on Linux with and without mmap, but couldn't test other platforms.",@bsmiles32 The proposed solution requires a rooted device. It's not something I can change for the app. It's something users have to do on their devices.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,468,2017-11-03T23:00:40Z,2017-11-08T19:36:20Z,2017-11-08T19:36:21Z,CLOSED,False,88,2,4,https://github.com/bsmiles32,Use virtual memory to allocate g_mem_base (if possible).,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/468,https://github.com/fzurita,9,https://github.com/mupen64plus/mupen64plus-core/pull/468#issuecomment-342023468,"This should fix issue #467
Basically, it replaces (if possible) the big malloc with virtual memory allocation in such a way that no unneeded physical pages gets allocated. When available (-DHAVE_MMAP) we use the mmap/munmap/mprotect functions, otherwise if it is a Windows plateform we use the VirtualAlloc/VirtualFree functions and otherwise only rely on the C standard library malloc/free and hope that internally, given the size of the alloc, it will use virtual memory.
I have tested myself on Linux with and without mmap, but couldn't test other platforms.","Currently, about 25% of the users of Mupen64plus-AE on Android are using 5.0 to 5.1.
They are probably all affected. Since there is nothing I can do from the app itself, it's probably better to have some kind of workaround.
One option would be for Mupen64plus-AE to roll back to the older version of the core.
Another option would be to keep two versions of the core, an old one and a newer up to date one. In the app, if I detect Android 5.0 or 5.1, I can make the app use the older version of the core.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,468,2017-11-03T23:00:40Z,2017-11-08T19:36:20Z,2017-11-08T19:36:21Z,CLOSED,False,88,2,4,https://github.com/bsmiles32,Use virtual memory to allocate g_mem_base (if possible).,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/468,https://github.com/loganmc10,10,https://github.com/mupen64plus/mupen64plus-core/pull/468#issuecomment-342036440,"This should fix issue #467
Basically, it replaces (if possible) the big malloc with virtual memory allocation in such a way that no unneeded physical pages gets allocated. When available (-DHAVE_MMAP) we use the mmap/munmap/mprotect functions, otherwise if it is a Windows plateform we use the VirtualAlloc/VirtualFree functions and otherwise only rely on the C standard library malloc/free and hope that internally, given the size of the alloc, it will use virtual memory.
I have tested myself on Linux with and without mmap, but couldn't test other platforms.","I thought most Linux systems used mmap under the hood anyway. If malloc is returning NULL, I don't think you're going to have much luck tricking it into succeeding. Android has a mind of its own when it comes to memory management.
From looking at the code, the only real benefit g_mem_base currently offers is getting rid of the if statement in fast_mem_access, but I believe the plan was to implement this: #277, which would make having some kind of fallback system probably quite complex.
Anyway if #277 isn't going to happen, then I'd say get rid of g_mem_base, but if that is going to happen, this is quite a tricky problem...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,468,2017-11-03T23:00:40Z,2017-11-08T19:36:20Z,2017-11-08T19:36:21Z,CLOSED,False,88,2,4,https://github.com/bsmiles32,Use virtual memory to allocate g_mem_base (if possible).,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/468,https://github.com/fzurita,11,https://github.com/mupen64plus/mupen64plus-core/pull/468#issuecomment-342037775,"This should fix issue #467
Basically, it replaces (if possible) the big malloc with virtual memory allocation in such a way that no unneeded physical pages gets allocated. When available (-DHAVE_MMAP) we use the mmap/munmap/mprotect functions, otherwise if it is a Windows plateform we use the VirtualAlloc/VirtualFree functions and otherwise only rely on the C standard library malloc/free and hope that internally, given the size of the alloc, it will use virtual memory.
I have tested myself on Linux with and without mmap, but couldn't test other platforms.","What kind of speed up would #277 give?
If it's a 10% speed up, it wouldn't be of much help since the dynarec uses very little compared to the graphics plugin.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,468,2017-11-03T23:00:40Z,2017-11-08T19:36:20Z,2017-11-08T19:36:21Z,CLOSED,False,88,2,4,https://github.com/bsmiles32,Use virtual memory to allocate g_mem_base (if possible).,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/468,https://github.com/bsmiles32,12,https://github.com/mupen64plus/mupen64plus-core/pull/468#issuecomment-342746547,"This should fix issue #467
Basically, it replaces (if possible) the big malloc with virtual memory allocation in such a way that no unneeded physical pages gets allocated. When available (-DHAVE_MMAP) we use the mmap/munmap/mprotect functions, otherwise if it is a Windows plateform we use the VirtualAlloc/VirtualFree functions and otherwise only rely on the C standard library malloc/free and hope that internally, given the size of the alloc, it will use virtual memory.
I have tested myself on Linux with and without mmap, but couldn't test other platforms.","I will push another attempt when I get back home tonight, which tries the big 256M alloc first and if it fails does a smaller alloc (~73M) and uses some if/else if/else for selecting the right address.
In my wip proof of concept of fast mem I wasn't able to get much speed up for the pure/cached interpreter because of the overhead of page faults (< 2% speedup if I remember correctly). However, for the dynarec we can optimistically emit the page-fault way and if it triggers too much regen the block with the non page-fault way, I expect maybe a 10% speedup, but as you say this may not be the bottleneck, so meh. Anyway, this work is still very early WIP and may not be successfull after all.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,468,2017-11-03T23:00:40Z,2017-11-08T19:36:20Z,2017-11-08T19:36:21Z,CLOSED,False,88,2,4,https://github.com/bsmiles32,Use virtual memory to allocate g_mem_base (if possible).,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/468,https://github.com/bsmiles32,13,https://github.com/mupen64plus/mupen64plus-core/pull/468#issuecomment-342934186,"This should fix issue #467
Basically, it replaces (if possible) the big malloc with virtual memory allocation in such a way that no unneeded physical pages gets allocated. When available (-DHAVE_MMAP) we use the mmap/munmap/mprotect functions, otherwise if it is a Windows plateform we use the VirtualAlloc/VirtualFree functions and otherwise only rely on the C standard library malloc/free and hope that internally, given the size of the alloc, it will use virtual memory.
I have tested myself on Linux with and without mmap, but couldn't test other platforms.",Replaced with another approach in #474,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,470,2017-11-05T16:41:33Z,2017-11-06T11:19:35Z,2017-11-06T11:19:35Z,MERGED,True,46,1,1,None,Build MXE targets as additional tests in travis build matrix,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/470,None,1,https://github.com/mupen64plus/mupen64plus-core/pull/470,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,471,2017-11-05T17:18:31Z,2017-11-08T19:36:41Z,2018-02-03T12:04:31Z,MERGED,True,42,26,1,https://github.com/bsmiles32,"Fix LWL, LWR, LDL, LDR, SWL, SWR, SDL, SDR implementations",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/471,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/471,"Fixes #469
Did similar fixes for other unaligned memory accesses to avoid undefined behavior. But I suspect there are more bugs in there because all these instructions don't look symmetrical...","Fixes #469
Did similar fixes for other unaligned memory accesses to avoid undefined behavior. But I suspect there are more bugs in there because all these instructions don't look symmetrical...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,471,2017-11-05T17:18:31Z,2017-11-08T19:36:41Z,2018-02-03T12:04:31Z,MERGED,True,42,26,1,https://github.com/bsmiles32,"Fix LWL, LWR, LDL, LDR, SWL, SWR, SDL, SDR implementations",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/471,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/471#issuecomment-342002293,"Fixes #469
Did similar fixes for other unaligned memory accesses to avoid undefined behavior. But I suspect there are more bugs in there because all these instructions don't look symmetrical...","Hey You Pikachu does appear to be fixed, but now the emulator fails the LWL test (it passed before). It now passes the SWL test.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,471,2017-11-05T17:18:31Z,2017-11-08T19:36:41Z,2018-02-03T12:04:31Z,MERGED,True,42,26,1,https://github.com/bsmiles32,"Fix LWL, LWR, LDL, LDR, SWL, SWR, SDL, SDR implementations",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/471,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/471#issuecomment-342744111,"Fixes #469
Did similar fixes for other unaligned memory accesses to avoid undefined behavior. But I suspect there are more bugs in there because all these instructions don't look symmetrical...","@loganmc10 When I try to run this test rom, I don't get anything printed on screen (GLideN64) what is your configuration to get that running ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,471,2017-11-05T17:18:31Z,2017-11-08T19:36:41Z,2018-02-03T12:04:31Z,MERGED,True,42,26,1,https://github.com/bsmiles32,"Fix LWL, LWR, LDL, LDR, SWL, SWR, SDL, SDR implementations",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/471,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/471#issuecomment-342787010,"Fixes #469
Did similar fixes for other unaligned memory accesses to avoid undefined behavior. But I suspect there are more bugs in there because all these instructions don't look symmetrical...","Yeah I use Angrylion (https://github.com/ata4/angrylion-rdp-plus) + rsp-cxd4, the text is hard to read unless you set ViMode=1 in the config for angrylion plus",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,471,2017-11-05T17:18:31Z,2017-11-08T19:36:41Z,2018-02-03T12:04:31Z,MERGED,True,42,26,1,https://github.com/bsmiles32,"Fix LWL, LWR, LDL, LDR, SWL, SWR, SDL, SDR implementations",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/471,https://github.com/bsmiles32,5,https://github.com/mupen64plus/mupen64plus-core/pull/471#issuecomment-342927456,"Fixes #469
Did similar fixes for other unaligned memory accesses to avoid undefined behavior. But I suspect there are more bugs in there because all these instructions don't look symmetrical...","@loganmc10 Thanks for the info.
Updated PR with fixed LWL, LDL instructions.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,471,2017-11-05T17:18:31Z,2017-11-08T19:36:41Z,2018-02-03T12:04:31Z,MERGED,True,42,26,1,https://github.com/bsmiles32,"Fix LWL, LWR, LDL, LDR, SWL, SWR, SDL, SDR implementations",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/471,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/471#issuecomment-342929212,"Fixes #469
Did similar fixes for other unaligned memory accesses to avoid undefined behavior. But I suspect there are more bugs in there because all these instructions don't look symmetrical...","Yep, Hey You Pikachu works, and it passes all the PeterLemon SW/LW tests, looks good to me",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,472,2017-11-06T05:22:01Z,2017-11-08T19:34:29Z,2017-11-08T19:34:29Z,MERGED,True,10,0,1,https://github.com/fzurita,"If an invalid controller pak is selected, use NONE instead",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/472,https://github.com/fzurita,1,https://github.com/mupen64plus/mupen64plus-core/pull/472,"If an invalid controller pak is selected for a game, use no controller pak instead.
See #445
This way if a user selects an invalid controller pak, they don't get an unexpected one instead.","If an invalid controller pak is selected for a game, use no controller pak instead.
See #445
This way if a user selects an invalid controller pak, they don't get an unexpected one instead.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,472,2017-11-06T05:22:01Z,2017-11-08T19:34:29Z,2017-11-08T19:34:29Z,MERGED,True,10,0,1,https://github.com/fzurita,"If an invalid controller pak is selected, use NONE instead",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/472,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/472#issuecomment-342049485,"If an invalid controller pak is selected for a game, use no controller pak instead.
See #445
This way if a user selects an invalid controller pak, they don't get an unexpected one instead.",@bsmiles32 is this ok?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,472,2017-11-06T05:22:01Z,2017-11-08T19:34:29Z,2017-11-08T19:34:29Z,MERGED,True,10,0,1,https://github.com/fzurita,"If an invalid controller pak is selected, use NONE instead",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/472,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/472#issuecomment-342933569,"If an invalid controller pak is selected for a game, use no controller pak instead.
See #445
This way if a user selects an invalid controller pak, they don't get an unexpected one instead.",👍,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,473,2017-11-06T23:09:30Z,2017-11-08T19:47:00Z,2017-11-08T21:37:54Z,MERGED,True,20,8,1,None,CountPerOp=1 for Bokujou Monogatari 2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/473,None,1,https://github.com/mupen64plus/mupen64plus-core/pull/473,"Fixes the out of sync audio during the intro cutscene. Harvest Moon 64 (U) already has CPO=1 enabled.
I also fixed a few Mempak/Rumble/Player entries.","Fixes the out of sync audio during the intro cutscene. Harvest Moon 64 (U) already has CPO=1 enabled.
I also fixed a few Mempak/Rumble/Player entries.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,474,2017-11-08T17:36:36Z,2017-11-09T07:07:31Z,2018-02-03T12:04:28Z,MERGED,True,125,29,11,https://github.com/bsmiles32,Big alloc fallback,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/474,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/474,"Another try at the memory allocation failure encountered in some Android devices. As this is likely due to a shortage of virtual memory, in this PR we provide a fallback mechanism which requires much less memory.","Another try at the memory allocation failure encountered in some Android devices. As this is likely due to a shortage of virtual memory, in this PR we provide a fallback mechanism which requires much less memory.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,474,2017-11-08T17:36:36Z,2017-11-09T07:07:31Z,2018-02-03T12:04:28Z,MERGED,True,125,29,11,https://github.com/bsmiles32,Big alloc fallback,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/474,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/474#issuecomment-342925247,"Another try at the memory allocation failure encountered in some Android devices. As this is likely due to a shortage of virtual memory, in this PR we provide a fallback mechanism which requires much less memory.","Tested both modes on Linux, no issues",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,474,2017-11-08T17:36:36Z,2017-11-09T07:07:31Z,2018-02-03T12:04:28Z,MERGED,True,125,29,11,https://github.com/bsmiles32,Big alloc fallback,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/474,https://github.com/fzurita,3,https://github.com/mupen64plus/mupen64plus-core/pull/474#issuecomment-343048702,"Another try at the memory allocation failure encountered in some Android devices. As this is likely due to a shortage of virtual memory, in this PR we provide a fallback mechanism which requires much less memory.",I have confirmation from a user with the issue that this now works correctly! I can also confirm that it works correctly on Android devices that don't have the issue. This should be merged soon.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,475,2017-11-08T21:42:06Z,2017-11-10T20:13:04Z,2018-02-03T12:04:25Z,MERGED,True,519,257,4,https://github.com/bsmiles32,"Fix handlers[i].{read,write}32 comparison in dynarec.",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/475,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/475,"Edit: There was another regression introduced also during the memory refactoring; handlers array is now indexed with physical addresses instead of physical, so we need to mask higher bits.
So everything should be good now. I used Derby Stallion for testing because it crashed with the dynarec almost instantaneously.
---- Previous message
I'm trying to fix computation of handlers[i].{read,write]32 inside dynarec but not done yet.
It crashes dynarec for now
Offsets computation are wrong now because each element of handlers array is sizeof(struct mem_handler), not just sizeof(void*). Given that struct mem_handler is basically 3 pointers we just need to multiply by 3 the array index to fix the computation. At least that is what I think, but doing so seems to crash... so anyone has a suggestion ?
Commit message below :
This regression has been introduced in
commit 82b20c8.
Implementation assumes that sizeof(mem_handler) is 3 * sizeof(void*)
therefore we just need to multiply (address >> 16) by 3 to get the right
offset. Multiplication by 3 can be achieved with lea dst, [reg + 2*reg]
instruction.","Edit: There was another regression introduced also during the memory refactoring; handlers array is now indexed with physical addresses instead of physical, so we need to mask higher bits.
So everything should be good now. I used Derby Stallion for testing because it crashed with the dynarec almost instantaneously.
---- Previous message
I'm trying to fix computation of handlers[i].{read,write]32 inside dynarec but not done yet.
It crashes dynarec for now
Offsets computation are wrong now because each element of handlers array is sizeof(struct mem_handler), not just sizeof(void*). Given that struct mem_handler is basically 3 pointers we just need to multiply by 3 the array index to fix the computation. At least that is what I think, but doing so seems to crash... so anyone has a suggestion ?
Commit message below :
This regression has been introduced in
commit 82b20c8.
Implementation assumes that sizeof(mem_handler) is 3 * sizeof(void*)
therefore we just need to multiply (address >> 16) by 3 to get the right
offset. Multiplication by 3 can be achieved with lea dst, [reg + 2*reg]
instruction.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,475,2017-11-08T21:42:06Z,2017-11-10T20:13:04Z,2018-02-03T12:04:25Z,MERGED,True,519,257,4,https://github.com/bsmiles32,"Fix handlers[i].{read,write}32 comparison in dynarec.",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/475,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/475#issuecomment-343320889,"Edit: There was another regression introduced also during the memory refactoring; handlers array is now indexed with physical addresses instead of physical, so we need to mask higher bits.
So everything should be good now. I used Derby Stallion for testing because it crashed with the dynarec almost instantaneously.
---- Previous message
I'm trying to fix computation of handlers[i].{read,write]32 inside dynarec but not done yet.
It crashes dynarec for now
Offsets computation are wrong now because each element of handlers array is sizeof(struct mem_handler), not just sizeof(void*). Given that struct mem_handler is basically 3 pointers we just need to multiply by 3 the array index to fix the computation. At least that is what I think, but doing so seems to crash... so anyone has a suggestion ?
Commit message below :
This regression has been introduced in
commit 82b20c8.
Implementation assumes that sizeof(mem_handler) is 3 * sizeof(void*)
therefore we just need to multiply (address >> 16) by 3 to get the right
offset. Multiplication by 3 can be achieved with lea dst, [reg + 2*reg]
instruction.",@loganmc10 Can you test this please :),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,475,2017-11-08T21:42:06Z,2017-11-10T20:13:04Z,2018-02-03T12:04:25Z,MERGED,True,519,257,4,https://github.com/bsmiles32,"Fix handlers[i].{read,write}32 comparison in dynarec.",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/475,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/475#issuecomment-343553236,"Edit: There was another regression introduced also during the memory refactoring; handlers array is now indexed with physical addresses instead of physical, so we need to mask higher bits.
So everything should be good now. I used Derby Stallion for testing because it crashed with the dynarec almost instantaneously.
---- Previous message
I'm trying to fix computation of handlers[i].{read,write]32 inside dynarec but not done yet.
It crashes dynarec for now
Offsets computation are wrong now because each element of handlers array is sizeof(struct mem_handler), not just sizeof(void*). Given that struct mem_handler is basically 3 pointers we just need to multiply by 3 the array index to fix the computation. At least that is what I think, but doing so seems to crash... so anyone has a suggestion ?
Commit message below :
This regression has been introduced in
commit 82b20c8.
Implementation assumes that sizeof(mem_handler) is 3 * sizeof(void*)
therefore we just need to multiply (address >> 16) by 3 to get the right
offset. Multiplication by 3 can be achieved with lea dst, [reg + 2*reg]
instruction.","Yes the crashing seems to be fixed now! I've got FBInfo working with the dynarec again.
I only tested x64, I've never had much luck cross compiling the x86 build on Linux",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,476,2017-11-11T00:44:50Z,2017-11-15T00:05:23Z,2018-02-03T12:04:23Z,MERGED,True,67,67,16,https://github.com/bsmiles32,Preliminary refactorings ,6,[],https://github.com/mupen64plus/mupen64plus-core/pull/476,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/476,This PR is just a collection of preliminary refactoring commits extracted from PR #446. They are not directly related to 64DD so we can incorporate them hopefully sooner.,This PR is just a collection of preliminary refactoring commits extracted from PR #446. They are not directly related to 64DD so we can incorporate them hopefully sooner.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,476,2017-11-11T00:44:50Z,2017-11-15T00:05:23Z,2018-02-03T12:04:23Z,MERGED,True,67,67,16,https://github.com/bsmiles32,Preliminary refactorings ,6,[],https://github.com/mupen64plus/mupen64plus-core/pull/476,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/476#issuecomment-343627003,This PR is just a collection of preliminary refactoring commits extracted from PR #446. They are not directly related to 64DD so we can incorporate them hopefully sooner.,"Added a last minute fix which should help regarding soft reset ""locking"".",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,476,2017-11-11T00:44:50Z,2017-11-15T00:05:23Z,2018-02-03T12:04:23Z,MERGED,True,67,67,16,https://github.com/bsmiles32,Preliminary refactorings ,6,[],https://github.com/mupen64plus/mupen64plus-core/pull/476,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/476#issuecomment-343629698,This PR is just a collection of preliminary refactoring commits extracted from PR #446. They are not directly related to 64DD so we can incorporate them hopefully sooner.,"Looks good to me, the only difference besides the soft reset fix that I noticed is that force_detected_rdram_size_hack() is now called after the Pi DMA write, it's done before the write currently (if I'm reading correctly). I assume it makes no difference",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,476,2017-11-11T00:44:50Z,2017-11-15T00:05:23Z,2018-02-03T12:04:23Z,MERGED,True,67,67,16,https://github.com/bsmiles32,Preliminary refactorings ,6,[],https://github.com/mupen64plus/mupen64plus-core/pull/476,https://github.com/bsmiles32,4,https://github.com/mupen64plus/mupen64plus-core/pull/476#issuecomment-343630289,This PR is just a collection of preliminary refactoring commits extracted from PR #446. They are not directly related to 64DD so we can incorporate them hopefully sooner.,"Doing the force rdram detection hack before or after the DMA is not important, both are fine indeed.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,477,2017-11-11T03:10:25Z,2017-11-12T00:36:02Z,2017-11-12T04:53:51Z,CLOSED,False,112,65,3,https://github.com/loganmc10,Fix FBInfo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/477,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/477,"This should be ready to merge.
This doesn't fix FBInfo with the new dynarec, it writes directly to RDRAM, so someone who is more familiar with the new dynarec will need to find a way to have it call write_rdram_fb/read_rdram_fb for the addresses in fb->infos[].addr
You can test this out in Mario Kart (Luigi's Raceway with the monitor), or Dr Mario (the pills), or Pokemon Snap (the red dot) using a recent version of GLideN64.
If someone knows a better/more eloquent way to determine the actual address & length in write_rdram_fb() I'm all ears, right now I just have a switch statement going through the various mask possibilities.
FBInfo in general still has some issues, Super Mario and Donkey Kong both freeze, but they also freeze in 1964, which is supposed to have a good (but slow) implementation of FBInfo. The puzzle transition in Banjo-Kazooie also has issues, but it seems to be timing related, changing CountPerOp will affect how much of the puzzle transition appears. But I figured if we are going to support this feature, we should have a good implementation, even if the GFX plugin could probably still use some work","This should be ready to merge.
This doesn't fix FBInfo with the new dynarec, it writes directly to RDRAM, so someone who is more familiar with the new dynarec will need to find a way to have it call write_rdram_fb/read_rdram_fb for the addresses in fb->infos[].addr
You can test this out in Mario Kart (Luigi's Raceway with the monitor), or Dr Mario (the pills), or Pokemon Snap (the red dot) using a recent version of GLideN64.
If someone knows a better/more eloquent way to determine the actual address & length in write_rdram_fb() I'm all ears, right now I just have a switch statement going through the various mask possibilities.
FBInfo in general still has some issues, Super Mario and Donkey Kong both freeze, but they also freeze in 1964, which is supposed to have a good (but slow) implementation of FBInfo. The puzzle transition in Banjo-Kazooie also has issues, but it seems to be timing related, changing CountPerOp will affect how much of the puzzle transition appears. But I figured if we are going to support this feature, we should have a good implementation, even if the GFX plugin could probably still use some work",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,477,2017-11-11T03:10:25Z,2017-11-12T00:36:02Z,2017-11-12T04:53:51Z,CLOSED,False,112,65,3,https://github.com/loganmc10,Fix FBInfo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/477,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/477#issuecomment-343665820,"This should be ready to merge.
This doesn't fix FBInfo with the new dynarec, it writes directly to RDRAM, so someone who is more familiar with the new dynarec will need to find a way to have it call write_rdram_fb/read_rdram_fb for the addresses in fb->infos[].addr
You can test this out in Mario Kart (Luigi's Raceway with the monitor), or Dr Mario (the pills), or Pokemon Snap (the red dot) using a recent version of GLideN64.
If someone knows a better/more eloquent way to determine the actual address & length in write_rdram_fb() I'm all ears, right now I just have a switch statement going through the various mask possibilities.
FBInfo in general still has some issues, Super Mario and Donkey Kong both freeze, but they also freeze in 1964, which is supposed to have a good (but slow) implementation of FBInfo. The puzzle transition in Banjo-Kazooie also has issues, but it seems to be timing related, changing CountPerOp will affect how much of the puzzle transition appears. But I figured if we are going to support this feature, we should have a good implementation, even if the GFX plugin could probably still use some work","Can confirm that Mario 64 freezes, Dr Mario pills are working, and that I can see something in the Luigi RaceWay screen, but it seems upside down for me. Still it is an improvement compared to a black screen, so you are on a good track. Will try to look a bit closer :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,477,2017-11-11T03:10:25Z,2017-11-12T00:36:02Z,2017-11-12T04:53:51Z,CLOSED,False,112,65,3,https://github.com/loganmc10,Fix FBInfo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/477,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/477#issuecomment-343679815,"This should be ready to merge.
This doesn't fix FBInfo with the new dynarec, it writes directly to RDRAM, so someone who is more familiar with the new dynarec will need to find a way to have it call write_rdram_fb/read_rdram_fb for the addresses in fb->infos[].addr
You can test this out in Mario Kart (Luigi's Raceway with the monitor), or Dr Mario (the pills), or Pokemon Snap (the red dot) using a recent version of GLideN64.
If someone knows a better/more eloquent way to determine the actual address & length in write_rdram_fb() I'm all ears, right now I just have a switch statement going through the various mask possibilities.
FBInfo in general still has some issues, Super Mario and Donkey Kong both freeze, but they also freeze in 1964, which is supposed to have a good (but slow) implementation of FBInfo. The puzzle transition in Banjo-Kazooie also has issues, but it seems to be timing related, changing CountPerOp will affect how much of the puzzle transition appears. But I figured if we are going to support this feature, we should have a good implementation, even if the GFX plugin could probably still use some work","I did a similar attempt at fixing FB info in https://github.com/bsmiles32/mupen64plus-core/tree/fbinfo
Basically :

there was a bug in how we track ""dirty pages""
taking into account the write mask fixes Dr Mario pills
looking at the spec, it seems that we need to notify the gfx plugin after having written a value to rdram not before. But it doesn't seem to matter that much as I saw no real change during my limited testing.

However contrary to your PR I didn't change the dirty page tracking part. I think here the spec is ambiguous. In our implementation we divide the RDRAM into 0x800 * 4k pages and mark these as dirty if gfx plugin says that they contain some fb data. Then before notifying the GFX plugin about CPU reads, we check if the corresponding page has already been read and if not notify the GFX plugin and mark it as non dirty. This kind of page tracking allows for efficient tracking of page dirty-ness.
However, it seems that GLideN64 understand the spec differently (and it is understandable) and doesn't track pages the same way, the 4k range starts at the address of access making the tracking of the 4k ranges more difficult.
Given that, at the time of writing the spec computers were more modest, I think that the intended page tracking is the one we have in mupen64plus aka 0x800 * 4k pages.
Also what concerns me is that in the spec we mandate a 4k page read, but do we have guarantees that it won't overwrite any non FB data ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,477,2017-11-11T03:10:25Z,2017-11-12T00:36:02Z,2017-11-12T04:53:51Z,CLOSED,False,112,65,3,https://github.com/loganmc10,Fix FBInfo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/477,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/477#issuecomment-343682691,"This should be ready to merge.
This doesn't fix FBInfo with the new dynarec, it writes directly to RDRAM, so someone who is more familiar with the new dynarec will need to find a way to have it call write_rdram_fb/read_rdram_fb for the addresses in fb->infos[].addr
You can test this out in Mario Kart (Luigi's Raceway with the monitor), or Dr Mario (the pills), or Pokemon Snap (the red dot) using a recent version of GLideN64.
If someone knows a better/more eloquent way to determine the actual address & length in write_rdram_fb() I'm all ears, right now I just have a switch statement going through the various mask possibilities.
FBInfo in general still has some issues, Super Mario and Donkey Kong both freeze, but they also freeze in 1964, which is supposed to have a good (but slow) implementation of FBInfo. The puzzle transition in Banjo-Kazooie also has issues, but it seems to be timing related, changing CountPerOp will affect how much of the puzzle transition appears. But I figured if we are going to support this feature, we should have a good implementation, even if the GFX plugin could probably still use some work","Awesome I'll try it out in a bit. I agree about the 4k block, but I noticed that GLideN64 did ""address + 0x1000"". Not even 1964 implements the dirty page tracking, so I think I can talk to gonetz and get him to switch to using 4k blocks.

Also what concerns me is that in the spec we mandate a 4k page read, but do we have guarantees that it won't overwrite any non FB data ?

The GFX plugin should know where the Framebuffer ends, so I think it's up to the GFX plugin to not write outside the actual FB. GLideN64 does have a related problem however, in that sometimes FBRead will be called for an address that is no longer being used as a Framebuffer, but the GFX plugin doesn't realize that, so it copies data that it shouldn't into rdram. GLideN64 hasn't really figured this out yet, and it's probably why some games are freezing",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,477,2017-11-11T03:10:25Z,2017-11-12T00:36:02Z,2017-11-12T04:53:51Z,CLOSED,False,112,65,3,https://github.com/loganmc10,Fix FBInfo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/477,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/477#issuecomment-343686797,"This should be ready to merge.
This doesn't fix FBInfo with the new dynarec, it writes directly to RDRAM, so someone who is more familiar with the new dynarec will need to find a way to have it call write_rdram_fb/read_rdram_fb for the addresses in fb->infos[].addr
You can test this out in Mario Kart (Luigi's Raceway with the monitor), or Dr Mario (the pills), or Pokemon Snap (the red dot) using a recent version of GLideN64.
If someone knows a better/more eloquent way to determine the actual address & length in write_rdram_fb() I'm all ears, right now I just have a switch statement going through the various mask possibilities.
FBInfo in general still has some issues, Super Mario and Donkey Kong both freeze, but they also freeze in 1964, which is supposed to have a good (but slow) implementation of FBInfo. The puzzle transition in Banjo-Kazooie also has issues, but it seems to be timing related, changing CountPerOp will affect how much of the puzzle transition appears. But I figured if we are going to support this feature, we should have a good implementation, even if the GFX plugin could probably still use some work","Also I think:
for (j = fb_mapping.begin >> 12; j < (fb_mapping.end >> 12); ++j)

Should be <= end right?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,477,2017-11-11T03:10:25Z,2017-11-12T00:36:02Z,2017-11-12T04:53:51Z,CLOSED,False,112,65,3,https://github.com/loganmc10,Fix FBInfo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/477,https://github.com/bsmiles32,6,https://github.com/mupen64plus/mupen64plus-core/pull/477#issuecomment-343687195,"This should be ready to merge.
This doesn't fix FBInfo with the new dynarec, it writes directly to RDRAM, so someone who is more familiar with the new dynarec will need to find a way to have it call write_rdram_fb/read_rdram_fb for the addresses in fb->infos[].addr
You can test this out in Mario Kart (Luigi's Raceway with the monitor), or Dr Mario (the pills), or Pokemon Snap (the red dot) using a recent version of GLideN64.
If someone knows a better/more eloquent way to determine the actual address & length in write_rdram_fb() I'm all ears, right now I just have a switch statement going through the various mask possibilities.
FBInfo in general still has some issues, Super Mario and Donkey Kong both freeze, but they also freeze in 1964, which is supposed to have a good (but slow) implementation of FBInfo. The puzzle transition in Banjo-Kazooie also has issues, but it seems to be timing related, changing CountPerOp will affect how much of the puzzle transition appears. But I figured if we are going to support this feature, we should have a good implementation, even if the GFX plugin could probably still use some work","Good catch ! fb_mapping.end is inclusive.
Will fix",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,477,2017-11-11T03:10:25Z,2017-11-12T00:36:02Z,2017-11-12T04:53:51Z,CLOSED,False,112,65,3,https://github.com/loganmc10,Fix FBInfo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/477,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/477#issuecomment-343690877,"This should be ready to merge.
This doesn't fix FBInfo with the new dynarec, it writes directly to RDRAM, so someone who is more familiar with the new dynarec will need to find a way to have it call write_rdram_fb/read_rdram_fb for the addresses in fb->infos[].addr
You can test this out in Mario Kart (Luigi's Raceway with the monitor), or Dr Mario (the pills), or Pokemon Snap (the red dot) using a recent version of GLideN64.
If someone knows a better/more eloquent way to determine the actual address & length in write_rdram_fb() I'm all ears, right now I just have a switch statement going through the various mask possibilities.
FBInfo in general still has some issues, Super Mario and Donkey Kong both freeze, but they also freeze in 1964, which is supposed to have a good (but slow) implementation of FBInfo. The puzzle transition in Banjo-Kazooie also has issues, but it seems to be timing related, changing CountPerOp will affect how much of the puzzle transition appears. But I figured if we are going to support this feature, we should have a good implementation, even if the GFX plugin could probably still use some work","One other thing, are you sure you've got the masks right? I noticed you did it opposite of me, if you look at the red dot in Pokemon Snap, it looks off in your version:

Here is the diff to fix it:
             switch(mask)
             {
             case 0x000000ff:
-                addr += 3;
+                addr += 0;
                 size = 1;
                 break;
             case 0x0000ff00:
-                addr += 2;
+                addr += 1;
                 size = 1;
                 break;
             case 0x00ff0000:
-                addr += 1;
+                addr += 2;
                 size = 1;
                 break;
             case 0xff000000:
-                addr += 0;
+                addr += 3;
                 size = 1;
                 break;
 
             case 0x0000ffff:
-                addr += 2;
+                addr += 0;
                 size = 2;
                 break;
 
             case 0xffff0000:
-                addr += 0;
+                addr += 2;
                 size = 2;
                 break;

then it looks like this:",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,477,2017-11-11T03:10:25Z,2017-11-12T00:36:02Z,2017-11-12T04:53:51Z,CLOSED,False,112,65,3,https://github.com/loganmc10,Fix FBInfo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/477,https://github.com/bsmiles32,8,https://github.com/mupen64plus/mupen64plus-core/pull/477#issuecomment-343691799,"This should be ready to merge.
This doesn't fix FBInfo with the new dynarec, it writes directly to RDRAM, so someone who is more familiar with the new dynarec will need to find a way to have it call write_rdram_fb/read_rdram_fb for the addresses in fb->infos[].addr
You can test this out in Mario Kart (Luigi's Raceway with the monitor), or Dr Mario (the pills), or Pokemon Snap (the red dot) using a recent version of GLideN64.
If someone knows a better/more eloquent way to determine the actual address & length in write_rdram_fb() I'm all ears, right now I just have a switch statement going through the various mask possibilities.
FBInfo in general still has some issues, Super Mario and Donkey Kong both freeze, but they also freeze in 1964, which is supposed to have a good (but slow) implementation of FBInfo. The puzzle transition in Banjo-Kazooie also has issues, but it seems to be timing related, changing CountPerOp will affect how much of the puzzle transition appears. But I figured if we are going to support this feature, we should have a good implementation, even if the GFX plugin could probably still use some work","I always get confused regarding byte/word endianness issue. Seeing that your code gets better results, I think you're probably right. However then I would correct it with :
addr += {0,1,2,3}^S8 // for byte accesses
addr += {0,2}^S16 // for hword accesses",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,477,2017-11-11T03:10:25Z,2017-11-12T00:36:02Z,2017-11-12T04:53:51Z,CLOSED,False,112,65,3,https://github.com/loganmc10,Fix FBInfo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/477,https://github.com/loganmc10,9,https://github.com/mupen64plus/mupen64plus-core/pull/477#issuecomment-343703217,"This should be ready to merge.
This doesn't fix FBInfo with the new dynarec, it writes directly to RDRAM, so someone who is more familiar with the new dynarec will need to find a way to have it call write_rdram_fb/read_rdram_fb for the addresses in fb->infos[].addr
You can test this out in Mario Kart (Luigi's Raceway with the monitor), or Dr Mario (the pills), or Pokemon Snap (the red dot) using a recent version of GLideN64.
If someone knows a better/more eloquent way to determine the actual address & length in write_rdram_fb() I'm all ears, right now I just have a switch statement going through the various mask possibilities.
FBInfo in general still has some issues, Super Mario and Donkey Kong both freeze, but they also freeze in 1964, which is supposed to have a good (but slow) implementation of FBInfo. The puzzle transition in Banjo-Kazooie also has issues, but it seems to be timing related, changing CountPerOp will affect how much of the puzzle transition appears. But I figured if we are going to support this feature, we should have a good implementation, even if the GFX plugin could probably still use some work","Ok Pokemon Snap looks good with those changes. I think your branch is good to be merged. There are still issues on the GFX plugin side, and there might be other reads/writes we need to track (technically the RSP DMA or PI DMA could read/write to the FB address space as well), but for now this is good I think",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,478,2017-11-12T00:35:30Z,2017-11-12T00:42:51Z,2018-02-03T12:04:21Z,MERGED,True,153,105,3,https://github.com/bsmiles32,Fix FbInfo 2,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/478,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/478,This PR does almost the same as PR #477 but doesn't change the dirty page tracking method.,This PR does almost the same as PR #477 but doesn't change the dirty page tracking method.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,478,2017-11-12T00:35:30Z,2017-11-12T00:42:51Z,2018-02-03T12:04:21Z,MERGED,True,153,105,3,https://github.com/bsmiles32,Fix FbInfo 2,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/478,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/478#issuecomment-343705307,This PR does almost the same as PR #477 but doesn't change the dirty page tracking method.,"Did you see that this has an AppVeyor failure? It didn't like the ""inline"" I think",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,478,2017-11-12T00:35:30Z,2017-11-12T00:42:51Z,2018-02-03T12:04:21Z,MERGED,True,153,105,3,https://github.com/bsmiles32,Fix FbInfo 2,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/478,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/478#issuecomment-343705493,This PR does almost the same as PR #477 but doesn't change the dirty page tracking method.,I think you can use osal_inline instead of inline,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,478,2017-11-12T00:35:30Z,2017-11-12T00:42:51Z,2018-02-03T12:04:21Z,MERGED,True,153,105,3,https://github.com/bsmiles32,Fix FbInfo 2,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/478,https://github.com/bsmiles32,4,https://github.com/mupen64plus/mupen64plus-core/pull/478#issuecomment-343705573,This PR does almost the same as PR #477 but doesn't change the dirty page tracking method.,Done: 067f45c,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,480,2017-11-13T12:22:17Z,2017-11-13T14:36:41Z,2017-11-13T15:15:59Z,MERGED,True,2,0,1,https://github.com/fzurita,Fix 40 winks ini,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/480,https://github.com/fzurita,1,https://github.com/mupen64plus/mupen64plus-core/pull/480,It does have rumble and mempak support.,It does have rumble and mempak support.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,481,2017-11-14T16:10:53Z,2017-12-01T03:35:42Z,2018-12-03T03:50:58Z,MERGED,True,88,50,6,https://github.com/loganmc10,Add more FB writes and reads,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/481,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/481,"There are a few other instances where the framebuffer might be modified. This tracks reads/writes in the PI and SP DMA's.
If you test the latest master version of GLideN64 with this PR Super Mario 64 no longer freezes.
It exposes another bug with have with the dynarec. When using the Cached Interpreter with FBInfo, you can see Mario's head in the Super Mario 64 intro. If you use the 64-bit dynarec, the head is missing","There are a few other instances where the framebuffer might be modified. This tracks reads/writes in the PI and SP DMA's.
If you test the latest master version of GLideN64 with this PR Super Mario 64 no longer freezes.
It exposes another bug with have with the dynarec. When using the Cached Interpreter with FBInfo, you can see Mario's head in the Super Mario 64 intro. If you use the 64-bit dynarec, the head is missing",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,481,2017-11-14T16:10:53Z,2017-12-01T03:35:42Z,2018-12-03T03:50:58Z,MERGED,True,88,50,6,https://github.com/loganmc10,Add more FB writes and reads,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/481,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/481#issuecomment-348264390,"There are a few other instances where the framebuffer might be modified. This tracks reads/writes in the PI and SP DMA's.
If you test the latest master version of GLideN64 with this PR Super Mario 64 no longer freezes.
It exposes another bug with have with the dynarec. When using the Cached Interpreter with FBInfo, you can see Mario's head in the Super Mario 64 intro. If you use the 64-bit dynarec, the head is missing","This should be ready to merge and relatively safe as well, it only affects FBInfo",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,483,2017-11-18T16:16:44Z,2017-11-28T02:00:39Z,2018-02-03T12:04:19Z,MERGED,True,684,662,56,https://github.com/bsmiles32,"Extract PIF, RCP and RDRAM modules",7,[],https://github.com/mupen64plus/mupen64plus-core/pull/483,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/483,Just moving some files around to isolate PIF and RCP modules.,Just moving some files around to isolate PIF and RCP modules.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,483,2017-11-18T16:16:44Z,2017-11-28T02:00:39Z,2018-02-03T12:04:19Z,MERGED,True,684,662,56,https://github.com/bsmiles32,"Extract PIF, RCP and RDRAM modules",7,[],https://github.com/mupen64plus/mupen64plus-core/pull/483,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/483#issuecomment-345830190,Just moving some files around to isolate PIF and RCP modules.,Also extracting RDRAM module.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,485,2017-11-20T20:31:47Z,2017-11-29T06:10:31Z,2019-07-15T22:35:05Z,MERGED,True,42,27,7,https://github.com/loganmc10,Modify DPC_STATUS_FREEZE hack,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/485,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/485,"Right now the hack works like this:
If DPC_STATUS_FREEZE bit is set when RSP task should run, run the RSP task when DPC_STATUS_FREEZE is unset.
This works mostly ok, but we did have to add dp->sp->regs[SP_STATUS_REG] &= ~SP_STATUS_YIELD; to get Perfect Dark working in LLE, as well as the !get_event(&dp->r4300->cp0.q, SP_INT) check to get it working in HLE. Also, the ""puzzle effect"" in Banjo-Kazooie is half-black when using FBInfo in GLideN64.
What this change does:
If DPC_STATUS_FREEZE is set when RSP task should run, still run the RSP task, but delay the DP Interrupt until the DPC_STATUS_FREEZE bit is unset. The RSP should still run even in the RDP is frozen.
If a VI Interrupt happens when DPC_STATUS_FREEZE is set, delay updating the screen until its unset. This should simulate the RDP not finishing until the DPC_STATUS_FREEZE bit is unset.
I tested every Rare game in HLE and LLE and they all work still, no hacky checks like we had before. Additionally, the ""puzzle effect"" in Banjo-Kazooie now works with FBinfo in GLIdeN64.
I updated the savestate to include this, I noticed we aren't actually using the v1.2 save states currently, I updated the file to start using v1.2, @bsmiles32 I don't know if you held that back on purpose or not.
Testing is welcome, Rare games are the only ones I know of that use this bit. Additionally, it seems like many LLE GFX plugins are unsetting the DPC_STATUS_FREEZE bit (GLideN64 and angrylion-plus do this). I submitted a PR to angrylion-plus to stop doing this (ata4/angrylion-rdp-plus#41) and I'll submit one to GLideN64 as well, unsetting that bit breaks this system.","Right now the hack works like this:
If DPC_STATUS_FREEZE bit is set when RSP task should run, run the RSP task when DPC_STATUS_FREEZE is unset.
This works mostly ok, but we did have to add dp->sp->regs[SP_STATUS_REG] &= ~SP_STATUS_YIELD; to get Perfect Dark working in LLE, as well as the !get_event(&dp->r4300->cp0.q, SP_INT) check to get it working in HLE. Also, the ""puzzle effect"" in Banjo-Kazooie is half-black when using FBInfo in GLideN64.
What this change does:
If DPC_STATUS_FREEZE is set when RSP task should run, still run the RSP task, but delay the DP Interrupt until the DPC_STATUS_FREEZE bit is unset. The RSP should still run even in the RDP is frozen.
If a VI Interrupt happens when DPC_STATUS_FREEZE is set, delay updating the screen until its unset. This should simulate the RDP not finishing until the DPC_STATUS_FREEZE bit is unset.
I tested every Rare game in HLE and LLE and they all work still, no hacky checks like we had before. Additionally, the ""puzzle effect"" in Banjo-Kazooie now works with FBinfo in GLIdeN64.
I updated the savestate to include this, I noticed we aren't actually using the v1.2 save states currently, I updated the file to start using v1.2, @bsmiles32 I don't know if you held that back on purpose or not.
Testing is welcome, Rare games are the only ones I know of that use this bit. Additionally, it seems like many LLE GFX plugins are unsetting the DPC_STATUS_FREEZE bit (GLideN64 and angrylion-plus do this). I submitted a PR to angrylion-plus to stop doing this (ata4/angrylion-rdp-plus#41) and I'll submit one to GLideN64 as well, unsetting that bit breaks this system.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,485,2017-11-20T20:31:47Z,2017-11-29T06:10:31Z,2019-07-15T22:35:05Z,MERGED,True,42,27,7,https://github.com/loganmc10,Modify DPC_STATUS_FREEZE hack,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/485,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/485#issuecomment-345840933,"Right now the hack works like this:
If DPC_STATUS_FREEZE bit is set when RSP task should run, run the RSP task when DPC_STATUS_FREEZE is unset.
This works mostly ok, but we did have to add dp->sp->regs[SP_STATUS_REG] &= ~SP_STATUS_YIELD; to get Perfect Dark working in LLE, as well as the !get_event(&dp->r4300->cp0.q, SP_INT) check to get it working in HLE. Also, the ""puzzle effect"" in Banjo-Kazooie is half-black when using FBInfo in GLideN64.
What this change does:
If DPC_STATUS_FREEZE is set when RSP task should run, still run the RSP task, but delay the DP Interrupt until the DPC_STATUS_FREEZE bit is unset. The RSP should still run even in the RDP is frozen.
If a VI Interrupt happens when DPC_STATUS_FREEZE is set, delay updating the screen until its unset. This should simulate the RDP not finishing until the DPC_STATUS_FREEZE bit is unset.
I tested every Rare game in HLE and LLE and they all work still, no hacky checks like we had before. Additionally, the ""puzzle effect"" in Banjo-Kazooie now works with FBinfo in GLIdeN64.
I updated the savestate to include this, I noticed we aren't actually using the v1.2 save states currently, I updated the file to start using v1.2, @bsmiles32 I don't know if you held that back on purpose or not.
Testing is welcome, Rare games are the only ones I know of that use this bit. Additionally, it seems like many LLE GFX plugins are unsetting the DPC_STATUS_FREEZE bit (GLideN64 and angrylion-plus do this). I submitted a PR to angrylion-plus to stop doing this (ata4/angrylion-rdp-plus#41) and I'll submit one to GLideN64 as well, unsetting that bit breaks this system.","Also tested this on my end (Mario Kart, OoT, MajorasMask, IndianaJones, Mischief Maker, ...). Didn't find any obvious regression. I also tested Knife Edge Nose Gunner, but it is still running too fast.
As for the savestate version, it is an oversight on my part.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,485,2017-11-20T20:31:47Z,2017-11-29T06:10:31Z,2019-07-15T22:35:05Z,MERGED,True,42,27,7,https://github.com/loganmc10,Modify DPC_STATUS_FREEZE hack,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/485,https://github.com/Jj0YzL5nvJ,3,https://github.com/mupen64plus/mupen64plus-core/pull/485#issuecomment-426179138,"Right now the hack works like this:
If DPC_STATUS_FREEZE bit is set when RSP task should run, run the RSP task when DPC_STATUS_FREEZE is unset.
This works mostly ok, but we did have to add dp->sp->regs[SP_STATUS_REG] &= ~SP_STATUS_YIELD; to get Perfect Dark working in LLE, as well as the !get_event(&dp->r4300->cp0.q, SP_INT) check to get it working in HLE. Also, the ""puzzle effect"" in Banjo-Kazooie is half-black when using FBInfo in GLideN64.
What this change does:
If DPC_STATUS_FREEZE is set when RSP task should run, still run the RSP task, but delay the DP Interrupt until the DPC_STATUS_FREEZE bit is unset. The RSP should still run even in the RDP is frozen.
If a VI Interrupt happens when DPC_STATUS_FREEZE is set, delay updating the screen until its unset. This should simulate the RDP not finishing until the DPC_STATUS_FREEZE bit is unset.
I tested every Rare game in HLE and LLE and they all work still, no hacky checks like we had before. Additionally, the ""puzzle effect"" in Banjo-Kazooie now works with FBinfo in GLIdeN64.
I updated the savestate to include this, I noticed we aren't actually using the v1.2 save states currently, I updated the file to start using v1.2, @bsmiles32 I don't know if you held that back on purpose or not.
Testing is welcome, Rare games are the only ones I know of that use this bit. Additionally, it seems like many LLE GFX plugins are unsetting the DPC_STATUS_FREEZE bit (GLideN64 and angrylion-plus do this). I submitted a PR to angrylion-plus to stop doing this (ata4/angrylion-rdp-plus#41) and I'll submit one to GLideN64 as well, unsetting that bit breaks this system.",This pull cause shaky graphics on Banjo-Kazooie by using rsp-cxd4 + GLideN64 with HLE mode.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,485,2017-11-20T20:31:47Z,2017-11-29T06:10:31Z,2019-07-15T22:35:05Z,MERGED,True,42,27,7,https://github.com/loganmc10,Modify DPC_STATUS_FREEZE hack,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/485,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/485#issuecomment-427394183,"Right now the hack works like this:
If DPC_STATUS_FREEZE bit is set when RSP task should run, run the RSP task when DPC_STATUS_FREEZE is unset.
This works mostly ok, but we did have to add dp->sp->regs[SP_STATUS_REG] &= ~SP_STATUS_YIELD; to get Perfect Dark working in LLE, as well as the !get_event(&dp->r4300->cp0.q, SP_INT) check to get it working in HLE. Also, the ""puzzle effect"" in Banjo-Kazooie is half-black when using FBInfo in GLideN64.
What this change does:
If DPC_STATUS_FREEZE is set when RSP task should run, still run the RSP task, but delay the DP Interrupt until the DPC_STATUS_FREEZE bit is unset. The RSP should still run even in the RDP is frozen.
If a VI Interrupt happens when DPC_STATUS_FREEZE is set, delay updating the screen until its unset. This should simulate the RDP not finishing until the DPC_STATUS_FREEZE bit is unset.
I tested every Rare game in HLE and LLE and they all work still, no hacky checks like we had before. Additionally, the ""puzzle effect"" in Banjo-Kazooie now works with FBinfo in GLIdeN64.
I updated the savestate to include this, I noticed we aren't actually using the v1.2 save states currently, I updated the file to start using v1.2, @bsmiles32 I don't know if you held that back on purpose or not.
Testing is welcome, Rare games are the only ones I know of that use this bit. Additionally, it seems like many LLE GFX plugins are unsetting the DPC_STATUS_FREEZE bit (GLideN64 and angrylion-plus do this). I submitted a PR to angrylion-plus to stop doing this (ata4/angrylion-rdp-plus#41) and I'll submit one to GLideN64 as well, unsetting that bit breaks this system.","This pull cause shaky graphics on Banjo-Kazooie by using rsp-cxd4 +GLideN64 with HLE mode.

This does seem to be the case, however the shaky graphics don't happen with rsp-hle, and they don't happen in LLE mode with any plugin, so it would probably be safe to assume that a change could be made to rsp-cxd4 to fix that issue",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,485,2017-11-20T20:31:47Z,2017-11-29T06:10:31Z,2019-07-15T22:35:05Z,MERGED,True,42,27,7,https://github.com/loganmc10,Modify DPC_STATUS_FREEZE hack,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/485,https://github.com/purpasmart96,5,https://github.com/mupen64plus/mupen64plus-core/pull/485#issuecomment-511595049,"Right now the hack works like this:
If DPC_STATUS_FREEZE bit is set when RSP task should run, run the RSP task when DPC_STATUS_FREEZE is unset.
This works mostly ok, but we did have to add dp->sp->regs[SP_STATUS_REG] &= ~SP_STATUS_YIELD; to get Perfect Dark working in LLE, as well as the !get_event(&dp->r4300->cp0.q, SP_INT) check to get it working in HLE. Also, the ""puzzle effect"" in Banjo-Kazooie is half-black when using FBInfo in GLideN64.
What this change does:
If DPC_STATUS_FREEZE is set when RSP task should run, still run the RSP task, but delay the DP Interrupt until the DPC_STATUS_FREEZE bit is unset. The RSP should still run even in the RDP is frozen.
If a VI Interrupt happens when DPC_STATUS_FREEZE is set, delay updating the screen until its unset. This should simulate the RDP not finishing until the DPC_STATUS_FREEZE bit is unset.
I tested every Rare game in HLE and LLE and they all work still, no hacky checks like we had before. Additionally, the ""puzzle effect"" in Banjo-Kazooie now works with FBinfo in GLIdeN64.
I updated the savestate to include this, I noticed we aren't actually using the v1.2 save states currently, I updated the file to start using v1.2, @bsmiles32 I don't know if you held that back on purpose or not.
Testing is welcome, Rare games are the only ones I know of that use this bit. Additionally, it seems like many LLE GFX plugins are unsetting the DPC_STATUS_FREEZE bit (GLideN64 and angrylion-plus do this). I submitted a PR to angrylion-plus to stop doing this (ata4/angrylion-rdp-plus#41) and I'll submit one to GLideN64 as well, unsetting that bit breaks this system.","Yeah this makes rsp-cxd4 freak out on the banjo games, works with mupens hle rsp though",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,487,2017-11-23T06:33:34Z,2017-11-29T06:26:13Z,2018-12-03T03:50:59Z,MERGED,True,13,51,10,https://github.com/loganmc10,Remove GoldenEye TLB hack,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/487,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/487,"Fixes #447
This will need to be tested on every dynarec/interpreter. I've tested the Pure/Cached Interpreter as well as the 64-bit dynarec. I tested the x86 new dynarec a while ago, but it probably should be tested again. ARM should also be tested ( @fzurita )
The only game that should be affected is GoldenEye, however I did make a change to how the Pure Interpreter works generally.","Fixes #447
This will need to be tested on every dynarec/interpreter. I've tested the Pure/Cached Interpreter as well as the 64-bit dynarec. I tested the x86 new dynarec a while ago, but it probably should be tested again. ARM should also be tested ( @fzurita )
The only game that should be affected is GoldenEye, however I did make a change to how the Pure Interpreter works generally.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,487,2017-11-23T06:33:34Z,2017-11-29T06:26:13Z,2018-12-03T03:50:59Z,MERGED,True,13,51,10,https://github.com/loganmc10,Remove GoldenEye TLB hack,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/487,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/487#issuecomment-346643549,"Fixes #447
This will need to be tested on every dynarec/interpreter. I've tested the Pure/Cached Interpreter as well as the 64-bit dynarec. I tested the x86 new dynarec a while ago, but it probably should be tested again. ARM should also be tested ( @fzurita )
The only game that should be affected is GoldenEye, however I did make a change to how the Pure Interpreter works generally.",Just re-tested the x86 new dynarec and it still works without the hack,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,487,2017-11-23T06:33:34Z,2017-11-29T06:26:13Z,2018-12-03T03:50:59Z,MERGED,True,13,51,10,https://github.com/loganmc10,Remove GoldenEye TLB hack,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/487,https://github.com/fzurita,3,https://github.com/mupen64plus/mupen64plus-core/pull/487#issuecomment-346650320,"Fixes #447
This will need to be tested on every dynarec/interpreter. I've tested the Pure/Cached Interpreter as well as the 64-bit dynarec. I tested the x86 new dynarec a while ago, but it probably should be tested again. ARM should also be tested ( @fzurita )
The only game that should be affected is GoldenEye, however I did make a change to how the Pure Interpreter works generally.","The game seems to start and run. Performance seems a lot worse though, at least in Android. Was this a performance hack?
Performance seems to be 25% slower overall. Enough to make it not run real time with GLideN64 in my phone.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,487,2017-11-23T06:33:34Z,2017-11-29T06:26:13Z,2018-12-03T03:50:59Z,MERGED,True,13,51,10,https://github.com/loganmc10,Remove GoldenEye TLB hack,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/487,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/487#issuecomment-346657434,"Fixes #447
This will need to be tested on every dynarec/interpreter. I've tested the Pure/Cached Interpreter as well as the 64-bit dynarec. I tested the x86 new dynarec a while ago, but it probably should be tested again. ARM should also be tested ( @fzurita )
The only game that should be affected is GoldenEye, however I did make a change to how the Pure Interpreter works generally.","Well it's possible when it was first implemented it was necessary for some reason, but now it is basically a performance hack.
GoldenEye is a strange game in that is will purposely trigger TLB exceptions (it will try to execute code that isn't TLB mapped, which triggers a TLB exception, which will then map the TLB entry, and then try to execute the code again).
The hack bypasses the TLB exceptions, and points to the address needed directly. So yes I would expect that CPU usage would go up since all these TLB exceptions need to be processed.
It still runs fine on my laptop, the new dynarec implements its own TLB code so there is the chance that this affects the new dynarec more negativity than the other methods? I'm not really sure.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,487,2017-11-23T06:33:34Z,2017-11-29T06:26:13Z,2018-12-03T03:50:59Z,MERGED,True,13,51,10,https://github.com/loganmc10,Remove GoldenEye TLB hack,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/487,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/487#issuecomment-346661610,"Fixes #447
This will need to be tested on every dynarec/interpreter. I've tested the Pure/Cached Interpreter as well as the 64-bit dynarec. I tested the x86 new dynarec a while ago, but it probably should be tested again. ARM should also be tested ( @fzurita )
The only game that should be affected is GoldenEye, however I did make a change to how the Pure Interpreter works generally.","So potentially we could leave the hack in place for the new dynarec, since that is mostly targeted at mobile devices? thoughts @bsmiles32 @Gillou68310 ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,487,2017-11-23T06:33:34Z,2017-11-29T06:26:13Z,2018-12-03T03:50:59Z,MERGED,True,13,51,10,https://github.com/loganmc10,Remove GoldenEye TLB hack,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/487,https://github.com/sgorman,6,https://github.com/mupen64plus/mupen64plus-core/pull/487#issuecomment-346675695,"Fixes #447
This will need to be tested on every dynarec/interpreter. I've tested the Pure/Cached Interpreter as well as the 64-bit dynarec. I tested the x86 new dynarec a while ago, but it probably should be tested again. ARM should also be tested ( @fzurita )
The only game that should be affected is GoldenEye, however I did make a change to how the Pure Interpreter works generally.","It was implemented back in the day during the initial versions of the
project for performance enhancements as Logan mentioned the ROM does some
kind of mapping that wasn't being handled correctly, there was a big demand
by some communities for some of the tweaks to appear in the emulator
system. I think the solution is to implement the correct exception handlers
for the TLB, otherwise you will probably notice a big performance hit as
mentioned in the comments. Good luck.

- ODS
…
On Thu, Nov 23, 2017 at 11:35 AM, Logan ***@***.***> wrote:
 So potentially we could leave the hack in place for the new dynarec, since
 that is mostly targeted at mobile devices? thoughts @bsmiles32
 <https://github.com/bsmiles32> @Gillou68310
 <https://github.com/gillou68310> ?

 —
 You are receiving this because you are subscribed to this thread.
 Reply to this email directly, view it on GitHub
 <#487 (comment)>,
 or mute the thread
 <https://github.com/notifications/unsubscribe-auth/AAke39JDMwFx0Au8JGhtl8bRXiB8z-9Cks5s5Z7igaJpZM4QoUb8>
 .",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,487,2017-11-23T06:33:34Z,2017-11-29T06:26:13Z,2018-12-03T03:50:59Z,MERGED,True,13,51,10,https://github.com/loganmc10,Remove GoldenEye TLB hack,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/487,https://github.com/fzurita,7,https://github.com/mupen64plus/mupen64plus-core/pull/487#issuecomment-346677884,"Fixes #447
This will need to be tested on every dynarec/interpreter. I've tested the Pure/Cached Interpreter as well as the 64-bit dynarec. I tested the x86 new dynarec a while ago, but it probably should be tested again. ARM should also be tested ( @fzurita )
The only game that should be affected is GoldenEye, however I did make a change to how the Pure Interpreter works generally.","That does bring up the question. Could this hack be applied to other TLB games with bad performance? For example, Conker's bad Fur day?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,487,2017-11-23T06:33:34Z,2017-11-29T06:26:13Z,2018-12-03T03:50:59Z,MERGED,True,13,51,10,https://github.com/loganmc10,Remove GoldenEye TLB hack,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/487,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/487#issuecomment-346684926,"Fixes #447
This will need to be tested on every dynarec/interpreter. I've tested the Pure/Cached Interpreter as well as the 64-bit dynarec. I tested the x86 new dynarec a while ago, but it probably should be tested again. ARM should also be tested ( @fzurita )
The only game that should be affected is GoldenEye, however I did make a change to how the Pure Interpreter works generally.",Ok I modified the PR to leave the new dynarec as it is (I just renamed tlb_hacks() to tlb_speed_hacks() to make it clear that it's not needed for accuracy).,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,487,2017-11-23T06:33:34Z,2017-11-29T06:26:13Z,2018-12-03T03:50:59Z,MERGED,True,13,51,10,https://github.com/loganmc10,Remove GoldenEye TLB hack,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/487,https://github.com/loganmc10,9,https://github.com/mupen64plus/mupen64plus-core/pull/487#issuecomment-346687760,"Fixes #447
This will need to be tested on every dynarec/interpreter. I've tested the Pure/Cached Interpreter as well as the 64-bit dynarec. I tested the x86 new dynarec a while ago, but it probably should be tested again. ARM should also be tested ( @fzurita )
The only game that should be affected is GoldenEye, however I did make a change to how the Pure Interpreter works generally.","Could this hack be applied to other TLB games with bad performance? For example, Conker's bad Fur day?

I assume so, it looks like Conker's is doing a very similar thing (same company so it makes sense):
It does this (it's slightly different since GoldenEye actually maps the TLB into the ROM address space, Conkers looks like it's using the RDRAM address space):
tlb exception !!! @ 151e8620, 2, add:15019f08
map 151e8000 : 8035afff
tlb exception !!! @ 151ebb50, 2, add:151e865c
map 151eb000 : 8035bfff
tlb exception !!! @ 150432bc, 2, add:151ebcb8
map 15042000 : 802d0fff
map 15043000 : 8033efff
tlb exception !!! @ 151ec164, 2, add:151ebd04
map 151ec000 : 8035cfff
map 151ed000 : 8035ffff
tlb exception !!! @ 150417ac, 2, add:150436b0
map 15041000 : 8035dfff
tlb exception !!! @ 1517f4d8, 2, add:15019c3c
map 1517e000 : 80328fff
map 1517f000 : 8034bfff
tlb exception !!! @ 150347e8, 2, add:15018c6c

You can see a TLB exception happens, and then it maps the area into the TLB. If we pre-mapped those entries, the TLB exceptions would never happen.
If you look at the very top example, what you want to have happen is that when the game asks for address 0x151e8620, you want the function to return 0x8035a620 as the ""TLB match""
For GoldenEye they figured out a simple pattern that would match all cases. I don't immediately see a simple pattern, but I'm not great at that sort of thing",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,487,2017-11-23T06:33:34Z,2017-11-29T06:26:13Z,2018-12-03T03:50:59Z,MERGED,True,13,51,10,https://github.com/loganmc10,Remove GoldenEye TLB hack,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/487,https://github.com/fzurita,10,https://github.com/mupen64plus/mupen64plus-core/pull/487#issuecomment-346688309,"Fixes #447
This will need to be tested on every dynarec/interpreter. I've tested the Pure/Cached Interpreter as well as the 64-bit dynarec. I tested the x86 new dynarec a while ago, but it probably should be tested again. ARM should also be tested ( @fzurita )
The only game that should be affected is GoldenEye, however I did make a change to how the Pure Interpreter works generally.","It may explain why N64oid had so much better performance in some TLB games.
In wonder if a hack like this could be automated.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,487,2017-11-23T06:33:34Z,2017-11-29T06:26:13Z,2018-12-03T03:50:59Z,MERGED,True,13,51,10,https://github.com/loganmc10,Remove GoldenEye TLB hack,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/487,https://github.com/fzurita,11,https://github.com/mupen64plus/mupen64plus-core/pull/487#issuecomment-346725135,"Fixes #447
This will need to be tested on every dynarec/interpreter. I've tested the Pure/Cached Interpreter as well as the 64-bit dynarec. I tested the x86 new dynarec a while ago, but it probably should be tested again. ARM should also be tested ( @fzurita )
The only game that should be affected is GoldenEye, however I did make a change to how the Pure Interpreter works generally.",Just a thought. Is this the performance improvement that bsmiles32 fastmem is supposed to give?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,487,2017-11-23T06:33:34Z,2017-11-29T06:26:13Z,2018-12-03T03:50:59Z,MERGED,True,13,51,10,https://github.com/loganmc10,Remove GoldenEye TLB hack,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/487,https://github.com/fzurita,12,https://github.com/mupen64plus/mupen64plus-core/pull/487#issuecomment-347003399,"Fixes #447
This will need to be tested on every dynarec/interpreter. I've tested the Pure/Cached Interpreter as well as the 64-bit dynarec. I tested the x86 new dynarec a while ago, but it probably should be tested again. ARM should also be tested ( @fzurita )
The only game that should be affected is GoldenEye, however I did make a change to how the Pure Interpreter works generally.","I did some more research on fastmem, it seems like it would be great for TLB games. So the answer to my question would be a yes.
See this dolphin article for some background: https://en.dolphin-emu.org/blog/2016/09/06/booting-the-final-gc-game
What we need is something similar to dolphin's MMU speed hack which we can do once we get fastmem.
The performance difference I saw in Goldeneye with the TLB hack disabled is what a universal ""MMU hack"" would give us for all tlb games.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,487,2017-11-23T06:33:34Z,2017-11-29T06:26:13Z,2018-12-03T03:50:59Z,MERGED,True,13,51,10,https://github.com/loganmc10,Remove GoldenEye TLB hack,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/487,https://github.com/psyke83,13,https://github.com/mupen64plus/mupen64plus-core/pull/487#issuecomment-348089505,"Fixes #447
This will need to be tested on every dynarec/interpreter. I've tested the Pure/Cached Interpreter as well as the 64-bit dynarec. I tested the x86 new dynarec a while ago, but it probably should be tested again. ARM should also be tested ( @fzurita )
The only game that should be affected is GoldenEye, however I did make a change to how the Pure Interpreter works generally.",Thanks - PR sent. #491,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/488,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/","In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/",True,{'THUMBS_UP': ['https://github.com/desiderantes']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/Gillou68310,2,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-346934655,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/","Tried on windows with msvc but it fails, here's the log:
The Meson build system
Version: 0.43.0
Source dir: D:\Projects\GSI\mupen64plus\mupen64plus-core
Build dir: D:\Projects\GSI\mupen64plus\mupen64plus-core\build
Build type: native build
Project name: mupen64plus-core
Native C compiler: cl (msvc 18.00.31101)
Native C++ compiler: cl (msvc 18.00.31101)
Build machine cpu family: x86
Build machine cpu: x86
Compiler for C supports argument -ffast-math: NO
Compiler for C supports argument -fno-strict-aliasing: NO
Compiler for C supports argument -fvisibility=hidden: NO
Compiler for C supports argument -Wno-unused-function: NO
Compiler for C supports argument -Wno-unused-parameter: NO
Compiler for C++ supports argument -ffast-math: NO
Compiler for C++ supports argument -fno-strict-aliasing: NO
Compiler for C++ supports argument -fvisibility=hidden: NO
Compiler for C++ supports argument -Wno-unused-function: NO
Compiler for C++ supports argument -Wno-unused-parameter: NO
Compiler for C++ supports argument -fvisibility-inlines-hidden: NO
Found Pkg-config: NO

Meson encountered an error in file meson.build, line 192, column 0:
Pkg-config not found.

Also I'm not sure to understand, is this also going to generate a visual studio project file?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-346948666,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/","@Gillou68310 Thanks for giving a try :)
By default, meson uses the ninja backend, but you can also tell it to generate a vs project file using the --backend {vs,vs2010,vs2015,vs2017}
You might have to run this under the vs command prompt [1].
As for your error about missing pkg-config, I'll need to look a bit deeper into it. Indeed, meson rely on pkg-config to find dependencies. This works well in linux, but in windows, no so much. Two solution here: either we go the source route and use wrap files, or we go the prebuild binary way [2].
[1] http://mesonbuild.com/Using-with-Visual-Studio.html
[2] http://mesonbuild.com/Shipping-prebuilt-binaries-as-wraps.html",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/richard42,4,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-346950372,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/","My initial thought on this is that I don't like it. Makefiles and MSVC project files are ""native"" on linux/bsd/windows, so generally they're easiest to use for end users. Adding another system on top adds new things to break and additional dependencies, plus a new thing for developers to learn and maintain.
I think having separate project/make files for linux and windows is not as much of a hassle for developers as the fact that we have so many different modules, each with their own build system. So if a developer is working on a single module, like for instance RSP-HLE, and he or she adds a new file, this only requires changes in 2 places. But if a developer makes a general build system change (like, adding a new unix-like target system to the makefile) it requires changes to N files in N repositories, which is a bigger pain. Going to meson isn't necessarily going to address this issue.
Some projects do have success with other system like cmake, so I'm not saying that I would never accept this type of change. But it's going to be difficult, because at a minimum we need it to support all of the systems on which we currently build, and not introduce any additional complexity.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/bsmiles32,5,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-346953555,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/","@richard42 Thanks for joining the discussion
meson can generate ninja files (equivalent to Makefiles), VS solutions (2010, 2015 and 2017) files and XCode files. So normally each developer should get something native on their plateform. Then adding/removing/moving a file is just a matter of editing the meson.build file (eg just as easy as what it is with our current Makefile, and much easier than editing manually a vs project+filter file).
Learning meson is not that hard. I've made this work in less than a week, working on it while commuting. The documentation is okay and in case of doubt there are many unit tests to learn from.
The point you raise about having many repo for each plugin is valid and I think here meson can help a little bit : if we have only 1 meson.build to edit per repo, that's half what we have to edit now (1 Makefile, 1vsproj). Also because meson.build files are ""composable"" (you can embed projects inside another) we might be able to switch to a single top repo with all core+ui+plugins as subprojects and factor some common build logic in the top project. This could maybe address the current maintenance issue.
Also some benefits I see with this transition :

many projects have reported a much better build time by switch to meson, especially on Windows.
better tracking of the compilation chain, meaning that when I make a change in a file or in a build option, meson will only rebuild what's really needed. I don't need  to do a ""make clean & make DEBUG=1 all"" all the time. This speeds up my dev flow quite a bit.
dependency management looks good also. With the possibility to either use the system dependencies or some fallback (be it from source or some prebuilt objects).
Migration to other newer Visual Studio version will not require a significant effort anymore, just switch backend. And when I add a new directory, I don't need to care about some UniqueIdentifier in the filter file anymore.

Anyway, we don't have to switch to meson overnight. It can coexists (eventually in a separate branch if you don't wan't it in master yet) for some time until it has proven its value to other devs.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/richard42,6,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-348394942,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/","There are some interesting potential advantages there. However I would suggest moving the meson files into a sibling directory of the other projects, ie /project/meson/, instead of the root, to avoid cluttering up the base folder.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/bsmiles32,7,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-348810990,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/","Rebased against master. Tried to use the fallback parameter for dependencies. Tried to fix some concerns from @bentley.
@richard42 I'm not sure meson supports meson.build in non source root directory.
Moved some ""external"" files outside of src dir, but didn't update Makefile and VisualStudio. So build failures with them is expected.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/bsmiles32,8,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-352195186,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/","Rebased against master, addressed some concerns from @bentley, and tried to update CI files, but it looks like meson documentation is not up-to-date (http://mesonbuild.com/Continuous-Integration.html). Will look into that later.
@Gillou68310 Can you try again building with msvc to see if the fallback subprojects work please ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/bsmiles32,9,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-352281737,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/","@Narann I've done an epic fail while trying to get appveyor to build (starting an interactive python env...) and I'd like to cancel the build, but I can't since I don't have the rights, can you add me the ""Run Project builds"" role so that I can cancel this jobs, otherwise our Appveyor instance will be unavailable for several hours (each jobs has a 1 hour time quota). Thanks",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/Narann,10,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-352353046,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/","Hi @bsmiles32, sorry for delay, I've added the whole mupen64plus/Maintainers group as admin of appveyor, this mean you and @Gillou68310 have access to the project. :)
Tell me if you find what you need with this!",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/Gillou68310,11,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-352482652,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/","I managed to generate the msvc solution with osd=false.
Looks awful:

This will hardly be usable for development purpose IMO.
Sorry if I sound rude but this reminds me cmake and god I hate cmake :-)
Anyway here's the build error log:
Error	239	error MSB3073: The command """"C:\Program Files (x86)\Meson\meson.exe"" ""--internal"" ""exe"" ""C:\Projects\GSI\mupen64plus\mupen64plus-core\build\meson-private\meson_exe_nasm.exe_047df892b97caaff0a74baa7b4fce314c91bbf73.dat""
:VCEnd"" exited with code 1.	C:\Program Files (x86)\MSBuild\Microsoft.Cpp\v4.0\V120\Microsoft.CppCommon.targets	202
Error	529	error LNK1104: cannot open file '..\..\subprojects\zlib-1.2.8\z.lib'	C:\Projects\GSI\mupen64plus\mupen64plus-core\build\subprojects\libpng-1.6.17\LINK
Error	555	error C1083: Cannot open include file: 'zlib.h': No such file or directory	C:\Projects\GSI\mupen64plus\mupen64plus-core\subprojects\libpng-1.6.17\pngtest.c	72
Error	1638	error C2143: syntax error : missing ')' before '('	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	43
Error	1639	error C2091: function returns function	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	43
Error	1640	error C2143: syntax error : missing ')' before 'string'	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	43
Error	1641	error C2143: syntax error : missing '{' before 'string'	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	43
Error	1642	error C2059: syntax error : 'string'	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	43
Error	1643	error C2059: syntax error : ')'	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	43
Error	1644	error C2143: syntax error : missing ')' before '('	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	52
Error	1645	error C2091: function returns function	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	52
Error	1646	error C2143: syntax error : missing ')' before 'string'	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	52
Error	1647	error C2143: syntax error : missing '{' before 'string'	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	52
Error	1648	error C2059: syntax error : 'string'	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	52
Error	1649	error C2059: syntax error : ')'	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	52
Error	1650	error C2143: syntax error : missing ')' before '('	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	62
Error	1651	error C2091: function returns function	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	62
Error	1652	error C2143: syntax error : missing ')' before 'string'	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	62
Error	1653	error C2143: syntax error : missing '{' before 'string'	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	62
Error	1654	error C2059: syntax error : 'string'	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	62
Error	1655	error C2059: syntax error : ')'	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	62
Error	1656	error C2143: syntax error : missing ')' before '('	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	72
Error	1657	error C2091: function returns function	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	72
Error	1658	error C2143: syntax error : missing ')' before 'string'	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	72
Error	1659	error C2143: syntax error : missing '{' before 'string'	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	72
Error	1660	error C2059: syntax error : 'string'	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	72
Error	1661	error C2059: syntax error : ')'	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	72
Error	1662	error C2143: syntax error : missing ')' before '('	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	82
Error	1663	error C2091: function returns function	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	82
Error	1664	error C2143: syntax error : missing ')' before 'string'	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	82
Error	1665	error C2143: syntax error : missing '{' before 'string'	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	82
Error	1666	error C2059: syntax error : 'string'	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	82
Error	1667	error C2059: syntax error : ')'	c:\projects\gsi\mupen64plus\mupen64plus-core\src\api\m64p_common.h	82
Error	1668	error C2143: syntax error : missing ')' before '('	C:\Projects\GSI\mupen64plus\mupen64plus-core\src\api\common.c	34
Error	1669	error C2091: function returns function	C:\Projects\GSI\mupen64plus\mupen64plus-core\src\api\common.c	34
Error	1670	error C2143: syntax error : missing ')' before 'string'	C:\Projects\GSI\mupen64plus\mupen64plus-core\src\api\common.c	34
Error	1671	error C2143: syntax error : missing '{' before 'string'	C:\Projects\GSI\mupen64plus\mupen64plus-core\src\api\common.c	34
Error	1672	error C2059: syntax error : 'string'	C:\Projects\GSI\mupen64plus\mupen64plus-core\src\api\common.c	34
Error	1673	error C2059: syntax error : ')'	C:\Projects\GSI\mupen64plus\mupen64plus-core\src\api\common.c	34
Error	1674	error C2143: syntax error : missing ')' before '('	C:\Projects\GSI\mupen64plus\mupen64plus-core\src\api\common.c	66
Error	1675	error C2091: function returns function	C:\Projects\GSI\mupen64plus\mupen64plus-core\src\api\common.c	66
Error	1676	error C2143: syntax error : missing ')' before 'string'	C:\Projects\GSI\mupen64plus\mupen64plus-core\src\api\common.c	66
Error	1677	error C2143: syntax error : missing '{' before 'string'	C:\Projects\GSI\mupen64plus\mupen64plus-core\src\api\common.c	66
Error	1678	error C2059: syntax error : 'string'	C:\Projects\GSI\mupen64plus\mupen64plus-core\src\api\common.c	66
Error	1679	error C2059: syntax error : ')'	C:\Projects\GSI\mupen64plus\mupen64plus-core\src\api\common.c	66
Error	1680	error C2143: syntax error : missing ')' before '('	C:\Projects\GSI\mupen64plus\mupen64plus-core\src\api\common.c	101
Error	1681	error C2091: function returns function	C:\Projects\GSI\mupen64plus\mupen64plus-core\src\api\common.c	101
Error	1682	error C2143: syntax error : missing ')' before 'string'	C:\Projects\GSI\mupen64plus\mupen64plus-core\src\api\common.c	101
Error	1683	error C2143: syntax error : missing '{' before 'string'	C:\Projects\GSI\mupen64plus\mupen64plus-core\src\api\common.c	101
Error	1684	error C2059: syntax error : 'string'	C:\Projects\GSI\mupen64plus\mupen64plus-core\src\api\common.c	101
Error	1685	error C2059: syntax error : ')'	C:\Projects\GSI\mupen64plus\mupen64plus-core\src\api\common.c	101",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/bsmiles32,12,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-352527921,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/","@Narann  Thanks for looking into it. I haven't figured out how to cancel a job, but I got added to the administrator team, so I don't know...
@Gillou68310 Thanks for taking the time to try it. I'll try to make it work in appveyor and see how it goes from here. I have yet to explore all the cross compilation aspect of it. Sadly as you said, it indeed looks like a cmake generated solution... not sure what can I do about it. Yet if it avoids all the pain of either clicking all the vs menus or editing the always changing sln/vcproj files...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/bsmiles32,13,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-352541575,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/",@Narann Help ! Endless appveyor job detected !,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/Narann,14,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-352545013,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/","Mhhh, you should have admin rights if you sign in with github account. Do you see the cancel build button once signed in?
https://ci.appveyor.com/project/Narann/mupen64plus-core/build/1.0.291",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/bsmiles32,15,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-352546530,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/","Sorry can't see it !
Edit : here is a screenshot of what I have",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/Narann,16,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-352547622,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/","Looks like you where in a sub job, if you would have clicked in ""Latest build"" you would be in the main job and should be able to manage the whole test.
For example, now you should be able to rerun the build:",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/bsmiles32,17,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-352548095,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/",Nope,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/Narann,18,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-352549169,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/","Click on your name, Account details, what do you see in ""GitHub authorization""? I have this:

AppVeyor was authorized 3 months ago for ...  access to GitHub repositories as Narann account. Your account authorizations.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/bsmiles32,19,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-352549535,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/","I have this


AppVeyor was authorized 2 hours ago for admin:repo_hook,read:org,repo:status access to GitHub repositories as bsmiles32 account. Your account authorizations.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/bsmiles32,20,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-352549708,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/","I think you should look inside your ""Team"" menu item and work from there to allow me to run jobs",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/Narann,21,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-352551108,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/","Looks like there was an ""organization"" webhook to set in the mupen64plus organization to make things work.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/bsmiles32,22,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-357456361,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/",updated against master.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/bsmiles32,23,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-413374610,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/","Updated against master, but still struggling with CI (both travis and Appveyor)... Will retry at a later date.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/bsmiles32,24,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-414019740,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/","Yeah ! First time TravisCI and AppVeyor build simultaneously :)
Still a bit WIP as I still have to disable various dependencies when building in VS2013 (eg OSD OpenCV) under AppVeyor. I also need to test building under mingw32. Also there are quite a few warnings in the logs...",True,{'THUMBS_UP': ['https://github.com/Narann']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/bsmiles32,25,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-414486334,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/","x86 versions (new_dynarec and hacktarux dynarec) also builds on Windows !
Had a hard time finding why it was failing before.... just to find out that it was because of a bug in nasm (-MD option prevented other options such as -D LEADING_UNDERSCORE to be taken into account)...
I guess to reach ""parity"" with current Makefile+VS2013 I need to have the OSD build in Windows, and have MINGW32 builds in TravisCI.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/bsmiles32,26,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-415177352,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/",Now the OSD builds on windows too !,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/bsmiles32,27,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-415975467,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/","I think I've now reached parity with Makefile+VS2013 projects as both now build on Appveyor and TravisCI.
I also got the MXE cross compilation working on Travis.
However, I had to disable LTO with Clang and MXE. For the former I hit LLVMgold plugin error, which I think is due to using an old version of Ubuntu. For the latter, I get unresolved symbols on my own subprojects symbols (md5, minizip, oglft, ...) and some warning about LTO and ""ar"". So I disabled these for now.
Freetype library has not been yet properly imported as a meson subproject, so you either need to get it through pkg-config or use the prebuilt version in mupen64plus-win32-deps.
As a small bonus I added the generation of pkg-config file to ease consumption of this library by others. This has been asked recently #562.
I could still do some more cleanings and refinements here and there, but I feel like asking for some feedback first could be beneficial.
My porting to meson has been quite good overall even if a bit hard at times :

the meson documentation and test suite are very good resources to learn how to do things with meson
it has helped me finding some errors and bugs such as #583, #581 and we got a huge list of warnings now (maybe I should reduce the warning level for now to avoid compiler spam for casual user/contributor, and tackle in my own fork the warnings fixing)
the first difficulty was getting dependencies right. meson subprojects and wraps have been really helpful here and I'd like to go a little bit further so we can have all of our dependencies as subprojects (and even some as wrap). These would allow full flexibility regarding dependencies, eg. have them static or dynamic, have them properly configured (which features to enable/disable) ... without relying on the package manager which some system don't support (Windows, iOS?).
the second difficulty was getting things to build on Appveyor and TravisCI. Apart from the difficulty of getting the dependencies right, the main issue was circumventing the fact that these mostly provide old version of software (ninja, meson). So I need to fetch them from elsewhere which makes the build and configuration more complex (and longer) than it should be. Yet we could mitigate these downloads times by caching some of them, I think Appveyor and TravisCI support that.

So yeah, now is a good time to test this PR, so I can fix the remaining concerns.
cc : @richard42, @loganmc10 @Gillou68310 @bentley @fzurita",True,{'HOORAY': ['https://github.com/bsmiles32']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/bsmiles32,28,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-423854626,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/","Added git-based freetype2 wrap (2.9.1)
updated with master",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,488,2017-11-25T02:01:33Z,,2019-11-13T16:12:06Z,OPEN,False,842,28,16,https://github.com/bsmiles32,[WIP] Preliminary support of meson builds.,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/488,https://github.com/bsmiles32,29,https://github.com/mupen64plus/mupen64plus-core/pull/488#issuecomment-437704077,"In order to lower the maintenance burden of the build system (eg. keeping in sync both Makefile and Visual studio files) I've explored the possibility of migrating to the meson build system [1].
So, I've ported the original Makefile to meson with some minor arrangements to fit in the new paradigm.
What I'm looking for now is feedback from other developers to see if there is interest in that work and what can be done to ease the eventual transition to it. I've tested this on my machine (linux, x64) and I'd like to know if it works in other platforms (windows, bsd, mac), cpu (arm, x86, mips?, ppc?) and dev env (cross-compilation, msvc).
In order to test (assuming the use of the ninja backend):
cd <path_to_m64p-core>
mkdir build
cd build
meson ../
ninja

You can also inspect and change build options with
meson configure

Note that this build system relies on python3 which might not be available by default in windows (should we add it to win32-deps repo ?).
Please report any issue, feedback or comment.
When/If we get this repo into shape with meson, I'll also port other repo to it (should be more easy).
cc: @richard42
[1] http://mesonbuild.com/","I've also had some success building using meson on my Raspberry Pi 3 (aarch64). There are still some stuff that are not supported (no_asm=1) and some dependencies still have some troubles getting compiled as subprojects from meson (libpng and sdl2) but eventually will get there :)
update: PR pending for libpng (mesonbuild/libpng#9)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,490,2017-11-28T01:17:02Z,2017-12-01T04:06:27Z,2018-02-03T12:04:17Z,MERGED,True,256,262,44,https://github.com/bsmiles32,Warnings,23,[],https://github.com/mupen64plus/mupen64plus-core/pull/490,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/490,With this PR all warnings except those about unused parameters should be gone. This is tested on GCC with -Wall -Wextra -pedantic.,With this PR all warnings except those about unused parameters should be gone. This is tested on GCC with -Wall -Wextra -pedantic.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,490,2017-11-28T01:17:02Z,2017-12-01T04:06:27Z,2018-02-03T12:04:17Z,MERGED,True,256,262,44,https://github.com/bsmiles32,Warnings,23,[],https://github.com/mupen64plus/mupen64plus-core/pull/490,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/490#issuecomment-347392413,With this PR all warnings except those about unused parameters should be gone. This is tested on GCC with -Wall -Wextra -pedantic.,@richard42 rebased against master,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,491,2017-11-30T05:50:41Z,2017-11-30T07:18:33Z,2017-11-30T07:18:33Z,MERGED,True,0,2,1,https://github.com/psyke83,Remove orphaned line related to removed GoldenEye TLB hack,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/491,https://github.com/psyke83,1,https://github.com/mupen64plus/mupen64plus-core/pull/491,Needed to resolve build error (on Raspberry Pi 3).,Needed to resolve build error (on Raspberry Pi 3).,True,{'THUMBS_UP': ['https://github.com/loganmc10']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,492,2017-11-30T17:48:01Z,2017-12-01T03:36:15Z,2018-12-03T03:50:56Z,MERGED,True,1,0,1,https://github.com/loganmc10,"If DEBUG not set, set NDEBUG",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/492,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/492,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,494,2017-12-02T20:49:18Z,2018-01-06T02:41:05Z,2018-01-06T02:41:05Z,MERGED,True,4,0,1,https://github.com/StenApp,Update Makefile,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/494,https://github.com/StenApp,1,https://github.com/mupen64plus/mupen64plus-core/pull/494,First try to get it fixed for macOS,First try to get it fixed for macOS,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,494,2017-12-02T20:49:18Z,2018-01-06T02:41:05Z,2018-01-06T02:41:05Z,MERGED,True,4,0,1,https://github.com/StenApp,Update Makefile,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/494,https://github.com/StenApp,2,https://github.com/mupen64plus/mupen64plus-core/pull/494#issuecomment-352229817,First try to get it fixed for macOS,Needed for files_macos.c to compile and set paths right,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,495,2017-12-02T20:50:42Z,2018-01-06T02:30:29Z,2018-01-06T02:30:29Z,MERGED,True,221,0,1,https://github.com/StenApp,Create files_macos.c,6,[],https://github.com/mupen64plus/mupen64plus-core/pull/495,https://github.com/StenApp,1,https://github.com/mupen64plus/mupen64plus-core/pull/495,First try to get a proper Mupen64Plus app on macOS,First try to get a proper Mupen64Plus app on macOS,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,495,2017-12-02T20:50:42Z,2018-01-06T02:30:29Z,2018-01-06T02:30:29Z,MERGED,True,221,0,1,https://github.com/StenApp,Create files_macos.c,6,[],https://github.com/mupen64plus/mupen64plus-core/pull/495,https://github.com/StenApp,2,https://github.com/mupen64plus/mupen64plus-core/pull/495#issuecomment-348804420,First try to get a proper Mupen64Plus app on macOS,"Doesn't work completely,  CFCopyHomeDirectoryURL() is iOS only...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,495,2017-12-02T20:50:42Z,2018-01-06T02:30:29Z,2018-01-06T02:30:29Z,MERGED,True,221,0,1,https://github.com/StenApp,Create files_macos.c,6,[],https://github.com/mupen64plus/mupen64plus-core/pull/495,https://github.com/richard42,3,https://github.com/mupen64plus/mupen64plus-core/pull/495#issuecomment-349203517,First try to get a proper Mupen64Plus app on macOS,looks pretty good. I can't merge this until the ios-only function is fixed though,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,495,2017-12-02T20:50:42Z,2018-01-06T02:30:29Z,2018-01-06T02:30:29Z,MERGED,True,221,0,1,https://github.com/StenApp,Create files_macos.c,6,[],https://github.com/mupen64plus/mupen64plus-core/pull/495,https://github.com/StenApp,4,https://github.com/mupen64plus/mupen64plus-core/pull/495#issuecomment-349409685,First try to get a proper Mupen64Plus app on macOS,Looking on how to get the path anyhow.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,495,2017-12-02T20:50:42Z,2018-01-06T02:30:29Z,2018-01-06T02:30:29Z,MERGED,True,221,0,1,https://github.com/StenApp,Create files_macos.c,6,[],https://github.com/mupen64plus/mupen64plus-core/pull/495,https://github.com/StenApp,5,https://github.com/mupen64plus/mupen64plus-core/pull/495#issuecomment-352225660,First try to get a proper Mupen64Plus app on macOS,"Grrrrrrrr!
save folder goes to ApplicXsave in user Library instead of created folder /Users/currentuser/Library/ApplicationSupport/Mupen64Plus/
need help!
../../src/osal/files_macos.c:187:10: warning: address of array 'path' will always evaluate to 'true' [-Wpointer-bool-conversion] if (!path) { ~^~~~ ../../src/osal/files_macos.c:205:12: warning: address of stack memory associated with local variable 'path' returned [-Wreturn-stack-address] return path;
only GlideN64 creates shader folder correctly and GlideN64.log.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,495,2017-12-02T20:50:42Z,2018-01-06T02:30:29Z,2018-01-06T02:30:29Z,MERGED,True,221,0,1,https://github.com/StenApp,Create files_macos.c,6,[],https://github.com/mupen64plus/mupen64plus-core/pull/495,https://github.com/richard42,6,https://github.com/mupen64plus/mupen64plus-core/pull/495#issuecomment-352274478,First try to get a proper Mupen64Plus app on macOS,"this change looks okay. You might also want to check that getenv(""HOME"") returns a non-NULL pointer, initialize the path[] array to an empty string, and keep the fallback to the getpwuid() function, with something like this:
    if (strlen(path) == 0) { struct passwd* pwd = getpwuid(getuid()); if (pwd) strcpy(path, pwd->pw_dir); }",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,496,2017-12-03T20:21:48Z,2017-12-05T05:57:12Z,2018-02-03T12:04:14Z,MERGED,True,336,37,9,https://github.com/bsmiles32,Various GB cart enhancements.,5,[],https://github.com/mupen64plus/mupen64plus-core/pull/496,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/496,"With this work we get :

partial support for gb camera (no image capture yet, but may come in the future)
mbc2 support
mbc5 rumble support","With this work we get :

partial support for gb camera (no image capture yet, but may come in the future)
mbc2 support
mbc5 rumble support",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,496,2017-12-03T20:21:48Z,2017-12-05T05:57:12Z,2018-02-03T12:04:14Z,MERGED,True,336,37,9,https://github.com/bsmiles32,Various GB cart enhancements.,5,[],https://github.com/mupen64plus/mupen64plus-core/pull/496,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/496#issuecomment-348811859,"With this work we get :

partial support for gb camera (no image capture yet, but may come in the future)
mbc2 support
mbc5 rumble support","Won't modifying the save state like that break compatibility with current save states? Won't it throw off the offsets of the data if you don't add it to the end?
That being said, we only actually started using v1.2 a couple days ago so if this was merged soon it probably won't affect many people",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,496,2017-12-03T20:21:48Z,2017-12-05T05:57:12Z,2018-02-03T12:04:14Z,MERGED,True,336,37,9,https://github.com/bsmiles32,Various GB cart enhancements.,5,[],https://github.com/mupen64plus/mupen64plus-core/pull/496,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/496#issuecomment-348812962,"With this work we get :

partial support for gb camera (no image capture yet, but may come in the future)
mbc2 support
mbc5 rumble support","Yeah it will break recent savestates, but anyway, people using a non released version should expect breakages unfortunately.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,496,2017-12-03T20:21:48Z,2017-12-05T05:57:12Z,2018-02-03T12:04:14Z,MERGED,True,336,37,9,https://github.com/bsmiles32,Various GB cart enhancements.,5,[],https://github.com/mupen64plus/mupen64plus-core/pull/496,https://github.com/fzurita,4,https://github.com/mupen64plus/mupen64plus-core/pull/496#issuecomment-348993269,"With this work we get :

partial support for gb camera (no image capture yet, but may come in the future)
mbc2 support
mbc5 rumble support",Shouldn't we try to maintain compatibility with older save states?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,496,2017-12-03T20:21:48Z,2017-12-05T05:57:12Z,2018-02-03T12:04:14Z,MERGED,True,336,37,9,https://github.com/bsmiles32,Various GB cart enhancements.,5,[],https://github.com/mupen64plus/mupen64plus-core/pull/496,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/496#issuecomment-348996091,"With this work we get :

partial support for gb camera (no image capture yet, but may come in the future)
mbc2 support
mbc5 rumble support","Since we don't have a consistent release schedule, and I don't even know if another release is ever going to happen, I tend to agree.
In this case, it'll only break save states made since Nov 28 (when 7abc818 was merged). It should also only break save states where a gb cart is present, save states without a gb cart shouldn't be affected based on my understanding",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,496,2017-12-03T20:21:48Z,2017-12-05T05:57:12Z,2018-02-03T12:04:14Z,MERGED,True,336,37,9,https://github.com/bsmiles32,Various GB cart enhancements.,5,[],https://github.com/mupen64plus/mupen64plus-core/pull/496,https://github.com/fzurita,6,https://github.com/mupen64plus/mupen64plus-core/pull/496#issuecomment-349025175,"With this work we get :

partial support for gb camera (no image capture yet, but may come in the future)
mbc2 support
mbc5 rumble support","Ok, that's good, not a big deal then.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,498,2017-12-12T17:13:08Z,2017-12-13T02:44:19Z,2018-12-03T03:50:54Z,MERGED,True,4,0,1,https://github.com/loganmc10,Fix crash when loading save state,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/498,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/498,"Fix for #497
Tested and working on my end","Fix for #497
Tested and working on my end",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,499,2017-12-14T00:41:59Z,2017-12-16T01:40:53Z,2018-02-03T12:04:12Z,MERGED,True,1,1,1,https://github.com/bsmiles32,Fix copy pasting error in MBC2 messages.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/499,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/499,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,500,2017-12-14T00:42:36Z,2017-12-16T01:42:07Z,2018-02-03T12:04:11Z,MERGED,True,5,7,3,https://github.com/bsmiles32,Fix reset bug introduced in commit 1c01c233.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/500,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/500,"Values comming from CIC at poweron/reset were written too early in PIF
RAM. There was a possibility of them getting overwritten by some SI DMA
requests (such as reading mempaks [Perfect Dark]) during the time window
between PIF_INT and NMI_INT.
Now we delay this until NMI_INT is triggered.","Values comming from CIC at poweron/reset were written too early in PIF
RAM. There was a possibility of them getting overwritten by some SI DMA
requests (such as reading mempaks [Perfect Dark]) during the time window
between PIF_INT and NMI_INT.
Now we delay this until NMI_INT is triggered.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,501,2017-12-14T00:43:26Z,2017-12-16T01:46:33Z,2018-02-03T12:04:07Z,MERGED,True,282,145,12,https://github.com/bsmiles32,Implement enough of RDRAM subsystem to remove rdram detection hack.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/501,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/501,"Previously, the RDRAM detection/initialization was wrong and a post
RDRAM initialization hack was triggered (just before initial PI DMA)
to force specified amount of RDRAM to be recognized.
With this PR, several aspects of the RDRAM have been implemented which
results in proper detection of RDRAM by the IPL3:

support for up to 8 (IPL3 hardcoded limitation) RDRAM modules
partial support for individual rdram address mapping,
ADDR_SELECT has not been implemented though
support broadcast register writes
simulating read failure when current calibration is not done yet","Previously, the RDRAM detection/initialization was wrong and a post
RDRAM initialization hack was triggered (just before initial PI DMA)
to force specified amount of RDRAM to be recognized.
With this PR, several aspects of the RDRAM have been implemented which
results in proper detection of RDRAM by the IPL3:

support for up to 8 (IPL3 hardcoded limitation) RDRAM modules
partial support for individual rdram address mapping,
ADDR_SELECT has not been implemented though
support broadcast register writes
simulating read failure when current calibration is not done yet",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,501,2017-12-14T00:43:26Z,2017-12-16T01:46:33Z,2018-02-03T12:04:07Z,MERGED,True,282,145,12,https://github.com/bsmiles32,Implement enough of RDRAM subsystem to remove rdram detection hack.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/501,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/501#issuecomment-351575425,"Previously, the RDRAM detection/initialization was wrong and a post
RDRAM initialization hack was triggered (just before initial PI DMA)
to force specified amount of RDRAM to be recognized.
With this PR, several aspects of the RDRAM have been implemented which
results in proper detection of RDRAM by the IPL3:

support for up to 8 (IPL3 hardcoded limitation) RDRAM modules
partial support for individual rdram address mapping,
ADDR_SELECT has not been implemented though
support broadcast register writes
simulating read failure when current calibration is not done yet",cc : @tj90241 I guess you could be interested in this ?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,501,2017-12-14T00:43:26Z,2017-12-16T01:46:33Z,2018-02-03T12:04:07Z,MERGED,True,282,145,12,https://github.com/bsmiles32,Implement enough of RDRAM subsystem to remove rdram detection hack.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/501,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/501#issuecomment-352092545,"Previously, the RDRAM detection/initialization was wrong and a post
RDRAM initialization hack was triggered (just before initial PI DMA)
to force specified amount of RDRAM to be recognized.
With this PR, several aspects of the RDRAM have been implemented which
results in proper detection of RDRAM by the IPL3:

support for up to 8 (IPL3 hardcoded limitation) RDRAM modules
partial support for individual rdram address mapping,
ADDR_SELECT has not been implemented though
support broadcast register writes
simulating read failure when current calibration is not done yet","I tested a good number of games with the expansion pak on and off. Didn't see any issues, everything seemed to work as expected.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,502,2017-12-16T14:29:52Z,2017-12-16T17:47:37Z,2018-02-03T12:04:05Z,MERGED,True,11,4,3,https://github.com/bsmiles32,Bugfixes,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/502,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/502,Some small bugfixes found while looking around.,Some small bugfixes found while looking around.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,503,2017-12-17T19:59:52Z,2017-12-18T04:24:27Z,2017-12-18T04:24:27Z,MERGED,True,1,1,1,https://github.com/Miouyouyou,Device: RDRAM: Use the R4300 helpers to get the R4300 registers,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/503,https://github.com/Miouyouyou,1,https://github.com/mupen64plus/mupen64plus-core/pull/503,"Since the ""regs"" member is not available on the r4300_core
structure when enabling ARM DYNAREC, accessing this member
directly will cause compilation errors with this setup.
Signed-off-by: Myy Miouyouyou myy@miouyouyou.fr","Since the ""regs"" member is not available on the r4300_core
structure when enabling ARM DYNAREC, accessing this member
directly will cause compilation errors with this setup.
Signed-off-by: Myy Miouyouyou myy@miouyouyou.fr",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,503,2017-12-17T19:59:52Z,2017-12-18T04:24:27Z,2017-12-18T04:24:27Z,MERGED,True,1,1,1,https://github.com/Miouyouyou,Device: RDRAM: Use the R4300 helpers to get the R4300 registers,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/503,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/503#issuecomment-352282249,"Since the ""regs"" member is not available on the r4300_core
structure when enabling ARM DYNAREC, accessing this member
directly will cause compilation errors with this setup.
Signed-off-by: Myy Miouyouyou myy@miouyouyou.fr","Thanks for your PR. It looks good and was indeed an oversight from my part.
Unfortunately our AppVeyor instance is stuck at the moment so CI checks will take a while before completing. But after, I'll merge that.
Good Work !",True,{'THUMBS_UP': ['https://github.com/Miouyouyou']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,505,2017-12-22T15:27:00Z,2018-01-01T16:38:31Z,2018-12-03T03:50:53Z,MERGED,True,46,27,2,https://github.com/loganmc10,Update xxHash to 0.6.4,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/505,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/505,Just pulling in the latest xxHash from upstream (https://github.com/Cyan4973/xxHash),Just pulling in the latest xxHash from upstream (https://github.com/Cyan4973/xxHash),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,507,2017-12-28T23:57:56Z,2018-01-01T16:42:46Z,2018-01-01T16:42:46Z,MERGED,True,203,203,197,https://github.com/bentley,Update homepage links,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/507,https://github.com/bentley,1,https://github.com/mupen64plus/mupen64plus-core/pull/507,"Linking to the Google Code page isn’t much use anymore.
Across all repos, I changed issue tracker links to the Github tracker, wiki links to the mupen64plus.org wiki, and homepage links to mupen64plus.org.
For the most part I didn’t link to individual repos, for maintenance reasons (if we ever move away from Github, or if we copy files across repos, or…).","Linking to the Google Code page isn’t much use anymore.
Across all repos, I changed issue tracker links to the Github tracker, wiki links to the mupen64plus.org wiki, and homepage links to mupen64plus.org.
For the most part I didn’t link to individual repos, for maintenance reasons (if we ever move away from Github, or if we copy files across repos, or…).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,510,2018-01-09T00:33:12Z,2018-01-09T02:04:17Z,2018-02-03T12:04:02Z,MERGED,True,2728,2932,43,https://github.com/bsmiles32,Cleanings,16,[],https://github.com/mupen64plus/mupen64plus-core/pull/510,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/510,"This is just some more internal source cleanings such as reindentation, forward declaration, header inclusion or just moving some code around.","This is just some more internal source cleanings such as reindentation, forward declaration, header inclusion or just moving some code around.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,510,2018-01-09T00:33:12Z,2018-01-09T02:04:17Z,2018-02-03T12:04:02Z,MERGED,True,2728,2932,43,https://github.com/bsmiles32,Cleanings,16,[],https://github.com/mupen64plus/mupen64plus-core/pull/510,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/510#issuecomment-357146776,"This is just some more internal source cleanings such as reindentation, forward declaration, header inclusion or just moving some code around.","@bsmiles32 This broke the new dynarec build in Android ARM. You are just missing this include in new_dynarec.c:
#include ""device/r4300/x86/assemble.h""",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,510,2018-01-09T00:33:12Z,2018-01-09T02:04:17Z,2018-02-03T12:04:02Z,MERGED,True,2728,2932,43,https://github.com/bsmiles32,Cleanings,16,[],https://github.com/mupen64plus/mupen64plus-core/pull/510,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/510#issuecomment-357312515,"This is just some more internal source cleanings such as reindentation, forward declaration, header inclusion or just moving some code around.","Could you post the compiler error please so I can check what declaration is missing.
Also, it seems counter intuitive that the ARM dynarec would require x86 specific declarations...
I can see for instance, EAX being needed in syscall_assemble, do_ccstub without proper ifdef x86/endif, so is that a bug or using this in the ARM dynarec is ok ?
cc: @Gillou68310",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,510,2018-01-09T00:33:12Z,2018-01-09T02:04:17Z,2018-02-03T12:04:02Z,MERGED,True,2728,2932,43,https://github.com/bsmiles32,Cleanings,16,[],https://github.com/mupen64plus/mupen64plus-core/pull/510,https://github.com/fzurita,4,https://github.com/mupen64plus/mupen64plus-core/pull/510#issuecomment-357319484,"This is just some more internal source cleanings such as reindentation, forward declaration, header inclusion or just moving some code around.","Yes, it was complaining about a missing EAX declaration. Even in the arm build, that was pointing to the x86 assemble.h in the old code.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,510,2018-01-09T00:33:12Z,2018-01-09T02:04:17Z,2018-02-03T12:04:02Z,MERGED,True,2728,2932,43,https://github.com/bsmiles32,Cleanings,16,[],https://github.com/mupen64plus/mupen64plus-core/pull/510,https://github.com/fzurita,5,https://github.com/mupen64plus/mupen64plus-core/pull/510#issuecomment-357319614,"This is just some more internal source cleanings such as reindentation, forward declaration, header inclusion or just moving some code around.",I can't give you the exact error right now since I'm not close to a computer I can use to build.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,511,2018-01-09T00:43:07Z,2018-01-10T18:48:34Z,2020-02-17T14:57:35Z,CLOSED,False,5,35,4,https://github.com/bsmiles32,Remove write_cart_rom,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/511,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/511,"This doesn't seem to be needed anymore.
All-Star Baseball 2001, International Track & Field 2000, Midway's
Greatest Arcade Hits Vol. 1 are still playable.
Something (maybe in the TLB handling code) must have made these bootable again, without the write_cart_rom hack(?).
See #311, #221","This doesn't seem to be needed anymore.
All-Star Baseball 2001, International Track & Field 2000, Midway's
Greatest Arcade Hits Vol. 1 are still playable.
Something (maybe in the TLB handling code) must have made these bootable again, without the write_cart_rom hack(?).
See #311, #221",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,511,2018-01-09T00:43:07Z,2018-01-10T18:48:34Z,2020-02-17T14:57:35Z,CLOSED,False,5,35,4,https://github.com/bsmiles32,Remove write_cart_rom,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/511,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/511#issuecomment-356350024,"This doesn't seem to be needed anymore.
All-Star Baseball 2001, International Track & Field 2000, Midway's
Greatest Arcade Hits Vol. 1 are still playable.
Something (maybe in the TLB handling code) must have made these bootable again, without the write_cart_rom hack(?).
See #311, #221","I went back to before #311 (#334) was merged and removed write_cart_rom and it actually makes these games boot even then. The issue they had was because they were trying to write ""0"" to the ROM and that wasn't registering, but it seems that just disabling all writes also fixes the issue.
I assume there are other games that are doing this, it's just that International Track & Field 2000 and Midway's Greatest Arcade Hits Vol. 1 were trying to write ""0"" which didn't work before. PJ64 has a similar hack in place. It would be interesting to know the history behind it.
But anyway, I actually tested about 20-25 games and I didn't see any issues.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,511,2018-01-09T00:43:07Z,2018-01-10T18:48:34Z,2020-02-17T14:57:35Z,CLOSED,False,5,35,4,https://github.com/bsmiles32,Remove write_cart_rom,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/511,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/511#issuecomment-356360468,"This doesn't seem to be needed anymore.
All-Star Baseball 2001, International Track & Field 2000, Midway's
Greatest Arcade Hits Vol. 1 are still playable.
Something (maybe in the TLB handling code) must have made these bootable again, without the write_cart_rom hack(?).
See #311, #221","I looked into this, mupen64 and 1964 also had/have this hack in place.
The 1964 source code has:
NeedToApplyRomWriteHack = FALSE;
	if( strnicmp(currentromoptions.Game_Name, ""A Bug's Life"", 12) == 0 ||
		strnicmp(currentromoptions.Game_Name, ""Toy Story 2"", 11) == 0 )
	{
		NeedToApplyRomWriteHack = TRUE;
		TRACE0(""Using Rom Write Hack"");
	}

Sure enough, this PR breaks A Bug's Life and Toy Story 2
They print a bunch of these kinds of messages:
Core Error: Invalid PIF address: 1FC0FF88
Core Error: Invalid PIF address: 1FC0FF88
Core Error: Invalid PIF address: 1FC0FF90
Core Error: Invalid PIF address: 1FC0FF90
Core Error: Invalid PIF address: 1FC0FF98
Core Error: Invalid PIF address: 1FC0FF98
Core Error: Invalid PIF address: 1FC0FFA0
Core Error: Invalid PIF address: 1FC0FFA0
Core Error: Invalid PIF address: 1FC0FFA8
Core Error: Invalid PIF address: 1FC0FFA8
Core Error: Invalid PIF address: 1FC0FFB0

Perhaps this hack represents some kind of actual hardware bug that someone figured out long ago? Or maybe there is a clue in the PIF errors, I'm not exactly sure.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,511,2018-01-09T00:43:07Z,2018-01-10T18:48:34Z,2020-02-17T14:57:35Z,CLOSED,False,5,35,4,https://github.com/bsmiles32,Remove write_cart_rom,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/511,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/511#issuecomment-356374867,"This doesn't seem to be needed anymore.
All-Star Baseball 2001, International Track & Field 2000, Midway's
Greatest Arcade Hits Vol. 1 are still playable.
Something (maybe in the TLB handling code) must have made these bootable again, without the write_cart_rom hack(?).
See #311, #221","Just a bit more info, I asked zilmar about this on Discord and he said:

I tried it on a real n64, that is the behaviour my n64 gave


if i remember correct, it is like it stored any write to rom in like memory, then  the next read, read that back


if you read it again it is back to normal",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,511,2018-01-09T00:43:07Z,2018-01-10T18:48:34Z,2020-02-17T14:57:35Z,CLOSED,False,5,35,4,https://github.com/bsmiles32,Remove write_cart_rom,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/511,https://github.com/bsmiles32,5,https://github.com/mupen64plus/mupen64plus-core/pull/511#issuecomment-356698713,"This doesn't seem to be needed anymore.
All-Star Baseball 2001, International Track & Field 2000, Midway's
Greatest Arcade Hits Vol. 1 are still playable.
Something (maybe in the TLB handling code) must have made these bootable again, without the write_cart_rom hack(?).
See #311, #221","@loganmc10 Awesome investigation work ! Thanks !
Closing this as this cart write behavior is indeed needed.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,511,2018-01-09T00:43:07Z,2018-01-10T18:48:34Z,2020-02-17T14:57:35Z,CLOSED,False,5,35,4,https://github.com/bsmiles32,Remove write_cart_rom,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/511,https://github.com/jago85,6,https://github.com/mupen64plus/mupen64plus-core/pull/511#issuecomment-443264685,"This doesn't seem to be needed anymore.
All-Star Baseball 2001, International Track & Field 2000, Midway's
Greatest Arcade Hits Vol. 1 are still playable.
Something (maybe in the TLB handling code) must have made these bootable again, without the write_cart_rom hack(?).
See #311, #221","I've just read this conversation after I stumbled across the write_cart_rom-function. I was curious what this function is good for and investigated what happens on real hardware. I think I've found some details that could be interesting for you.
First of all, I think that the implemented behaviour is wrong. I don't know exactly why you need this, but the behaviour is impossible on a real cart. The write signal is not even connected to the ROM chip. I think the guy who claimed he had tested it on a real N64 just forgot to wait for the flag PI_STATUS_IO_BUSY to reset.
I've tried 3 test cases:

Write a value to 0xB0000000 (first cart rom addr) and read it back immediately
Write a value to 0xB0000000, wait while PI_STATUS_IO_BUSY is set and than read it back
Write a value to 0xB0000000 when a button is pressed, read it back, when another button is pressed (don't check the flag)

The results were the following:

The written value is read back (tried 0x00000000 and 0x5555AAAA), the flag PI_STATUS_ERROR is set atfer this. I had a look at the data bus with a logic analyser. The read request isn't even transmitted to the cart. Seems that the PI is then returning the last written value.
The read value is 0x80371240 (the error flag is not set)
like 2.) because the buttons can't be pressed that fast and there is at least one frame between the accesses (which is much longer than the PI is busy)

After having a deeper look with the logic analyzer at the write coming from Midway's Greatest Arcade Hits Volume 1 (U) I saw that it writes 0 to 0x1000010C (which is 0xB000010C) and than 0x49533634 to 0x10000100 (which is 0xB0000100). 0x49533634 is ASCII for ""IS64"" so this likely has something to do with the IS64 dev kit. After this it read multiple times from 0x1000010C and always gets 0x3C0FA3F0 back from the cart which is the ROM data at this address.
So I think you really could get rid of this function unless there is a serious reason to keep it. Or you could emulate the correct behaviour of the PI and restore the normal read functionality after the PI is not busy anymore. However, this is only necessary if a software uses the PI incorrectly. In the current state, the game definitely gets different data than in the real hardware.
Here are some of my logic analyzer images. For those who know about the PI hardware signals: The read and write signals are inverted to be displayed active high. ad_ff2 is the multiplex bidirectional address/data bus either carrying addresses or write data from the console to the cart or read data from the cart to the console. The value of cart_addr is calculated by the analyzer.
This is an image of the whole process from Midway's Greatest Arcade Hits Volume 1 (U):
(more reads from the same address follow after the end of the sample buffer)

Zoomed into the write of ""IS64"" to 0x10000100 (marked the data 0x49533634 coming from the console):

And the read from 0x1000010C:

This is my test case 2:

And finally test case 1:
You can see that the read access is missing, because it was launched while the PI was busy:",True,"{'HEART': ['https://github.com/Narann', 'https://github.com/oddMLan']}"
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,511,2018-01-09T00:43:07Z,2018-01-10T18:48:34Z,2020-02-17T14:57:35Z,CLOSED,False,5,35,4,https://github.com/bsmiles32,Remove write_cart_rom,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/511,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/511#issuecomment-587032586,"This doesn't seem to be needed anymore.
All-Star Baseball 2001, International Track & Field 2000, Midway's
Greatest Arcade Hits Vol. 1 are still playable.
Something (maybe in the TLB handling code) must have made these bootable again, without the write_cart_rom hack(?).
See #311, #221","@jago85 thanks so much for looking into this. Sorry it took this long to implement. As far as I can tell there are actually 2 games that attempt to read the written value while IO_BUSY is still set (A Bug's Life and Toy Story 2). In those games, case 1 applies, and they expect to get the last written value back.
Another game we came across (WCW Backstage Assault), writes to the ROM and then attempts to read back the value after IO_BUSY is clear, so case 2 applies",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,513,2018-01-10T22:07:02Z,2018-01-17T04:18:33Z,2018-02-03T12:03:56Z,MERGED,True,50,3,8,https://github.com/bsmiles32,Add SiDmaDuration option.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/513,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/513,"This is a hack on SI DMA timings to allow games with different timing
requirements to work.
We keep the previously hardcoded value of 0x900 as the default value
but fine-tune it for Tetris 64 (J) which can be made to boot with a
lower value of it.
Therefore we can get both Body Harvest and Tertis 64 (J) to work.
Temporary fix for #512","This is a hack on SI DMA timings to allow games with different timing
requirements to work.
We keep the previously hardcoded value of 0x900 as the default value
but fine-tune it for Tetris 64 (J) which can be made to boot with a
lower value of it.
Therefore we can get both Body Harvest and Tertis 64 (J) to work.
Temporary fix for #512",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,513,2018-01-10T22:07:02Z,2018-01-17T04:18:33Z,2018-02-03T12:03:56Z,MERGED,True,50,3,8,https://github.com/bsmiles32,Add SiDmaDuration option.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/513,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/513#issuecomment-356756607,"This is a hack on SI DMA timings to allow games with different timing
requirements to work.
We keep the previously hardcoded value of 0x900 as the default value
but fine-tune it for Tetris 64 (J) which can be made to boot with a
lower value of it.
Therefore we can get both Body Harvest and Tertis 64 (J) to work.
Temporary fix for #512","@richard42 This PR fixes a regression and should have no border effect, so I'd like to have it in the coming release if that's fine for you. Thanks",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,513,2018-01-10T22:07:02Z,2018-01-17T04:18:33Z,2018-02-03T12:03:56Z,MERGED,True,50,3,8,https://github.com/bsmiles32,Add SiDmaDuration option.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/513,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/513#issuecomment-356758625,"This is a hack on SI DMA timings to allow games with different timing
requirements to work.
We keep the previously hardcoded value of 0x900 as the default value
but fine-tune it for Tetris 64 (J) which can be made to boot with a
lower value of it.
Therefore we can get both Body Harvest and Tertis 64 (J) to work.
Temporary fix for #512","Looks good to me, tested and played a few short games, no issues.
Given that the timing of these interrupts is mostly guesswork, there may not be a better option.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,513,2018-01-10T22:07:02Z,2018-01-17T04:18:33Z,2018-02-03T12:03:56Z,MERGED,True,50,3,8,https://github.com/bsmiles32,Add SiDmaDuration option.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/513,https://github.com/bsmiles32,4,https://github.com/mupen64plus/mupen64plus-core/pull/513#issuecomment-356774099,"This is a hack on SI DMA timings to allow games with different timing
requirements to work.
We keep the previously hardcoded value of 0x900 as the default value
but fine-tune it for Tetris 64 (J) which can be made to boot with a
lower value of it.
Therefore we can get both Body Harvest and Tertis 64 (J) to work.
Temporary fix for #512",Fixed self-referencing RefMD5 for ROM derived from Tetris 64 (J),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,514,2018-01-11T16:55:53Z,2018-01-12T21:15:45Z,2018-12-03T03:50:52Z,MERGED,True,2,5,2,https://github.com/loganmc10,Fix potential crash with FBInfo and save states,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/514,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/514,"I believe this should fix #489
Doing memset(&g_dev.dp.fb, 0, sizeof(g_dev.dp.fb)); will wipe out fb->mem, fb->rdram, fb->r4300, which is probably what was causing the crash.
Using poweron_fb will only wipe the necessary data
This regression was introduced in 99f00d7
@fzurita perhaps you could test and @bsmiles32 you could review as well?","I believe this should fix #489
Doing memset(&g_dev.dp.fb, 0, sizeof(g_dev.dp.fb)); will wipe out fb->mem, fb->rdram, fb->r4300, which is probably what was causing the crash.
Using poweron_fb will only wipe the necessary data
This regression was introduced in 99f00d7
@fzurita perhaps you could test and @bsmiles32 you could review as well?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,514,2018-01-11T16:55:53Z,2018-01-12T21:15:45Z,2018-12-03T03:50:52Z,MERGED,True,2,5,2,https://github.com/loganmc10,Fix potential crash with FBInfo and save states,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/514,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/514#issuecomment-356994191,"I believe this should fix #489
Doing memset(&g_dev.dp.fb, 0, sizeof(g_dev.dp.fb)); will wipe out fb->mem, fb->rdram, fb->r4300, which is probably what was causing the crash.
Using poweron_fb will only wipe the necessary data
This regression was introduced in 99f00d7
@fzurita perhaps you could test and @bsmiles32 you could review as well?","Sure, I'll give it a shot.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,514,2018-01-11T16:55:53Z,2018-01-12T21:15:45Z,2018-12-03T03:50:52Z,MERGED,True,2,5,2,https://github.com/loganmc10,Fix potential crash with FBInfo and save states,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/514,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/514#issuecomment-357055507,"I believe this should fix #489
Doing memset(&g_dev.dp.fb, 0, sizeof(g_dev.dp.fb)); will wipe out fb->mem, fb->rdram, fb->r4300, which is probably what was causing the crash.
Using poweron_fb will only wipe the necessary data
This regression was introduced in 99f00d7
@fzurita perhaps you could test and @bsmiles32 you could review as well?",Good catch ! Savestate was indeed overwriting components pointers. Lgtm,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,514,2018-01-11T16:55:53Z,2018-01-12T21:15:45Z,2018-12-03T03:50:52Z,MERGED,True,2,5,2,https://github.com/loganmc10,Fix potential crash with FBInfo and save states,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/514,https://github.com/fzurita,4,https://github.com/mupen64plus/mupen64plus-core/pull/514#issuecomment-357147803,"I believe this should fix #489
Doing memset(&g_dev.dp.fb, 0, sizeof(g_dev.dp.fb)); will wipe out fb->mem, fb->rdram, fb->r4300, which is probably what was causing the crash.
Using poweron_fb will only wipe the necessary data
This regression was introduced in 99f00d7
@fzurita perhaps you could test and @bsmiles32 you could review as well?","I can confirm, this fixes the crashing reported in #489.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,514,2018-01-11T16:55:53Z,2018-01-12T21:15:45Z,2018-12-03T03:50:52Z,MERGED,True,2,5,2,https://github.com/loganmc10,Fix potential crash with FBInfo and save states,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/514,https://github.com/fzurita,5,https://github.com/mupen64plus/mupen64plus-core/pull/514#issuecomment-357533014,"I believe this should fix #489
Doing memset(&g_dev.dp.fb, 0, sizeof(g_dev.dp.fb)); will wipe out fb->mem, fb->rdram, fb->r4300, which is probably what was causing the crash.
Using poweron_fb will only wipe the necessary data
This regression was introduced in 99f00d7
@fzurita perhaps you could test and @bsmiles32 you could review as well?","After this change, the crash rate reported in the play store is massively reduced. It's even less than before 99f00d7
There are still a few lingering crashes. I'll create issue for them soon.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,515,2018-01-12T21:20:22Z,2018-01-13T16:52:01Z,2018-01-15T22:12:01Z,MERGED,True,2,0,1,https://github.com/bsmiles32,Fix compilation of new dynarec.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/515,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/515,reported by @fzurita in PR #510,reported by @fzurita in PR #510,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,519,2018-01-14T19:22:56Z,2018-01-18T03:11:54Z,2018-02-03T12:03:45Z,MERGED,True,2780,2756,38,https://github.com/bsmiles32,Less g dev,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/519,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/519,"Reduce usage of global variable g_dev (and other derived variables) in emulation modules.
Also some formattings cleanings and prefer usage of standard fixed-size types in debugger modules.","Reduce usage of global variable g_dev (and other derived variables) in emulation modules.
Also some formattings cleanings and prefer usage of standard fixed-size types in debugger modules.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,519,2018-01-14T19:22:56Z,2018-01-18T03:11:54Z,2018-02-03T12:03:45Z,MERGED,True,2780,2756,38,https://github.com/bsmiles32,Less g dev,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/519,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/519#issuecomment-357746387,"Reduce usage of global variable g_dev (and other derived variables) in emulation modules.
Also some formattings cleanings and prefer usage of standard fixed-size types in debugger modules.","Tested with the x64 dynarec (MinGW/Windows), no issues",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,519,2018-01-14T19:22:56Z,2018-01-18T03:11:54Z,2018-02-03T12:03:45Z,MERGED,True,2780,2756,38,https://github.com/bsmiles32,Less g dev,15,[],https://github.com/mupen64plus/mupen64plus-core/pull/519,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/519#issuecomment-357800460,"Reduce usage of global variable g_dev (and other derived variables) in emulation modules.
Also some formattings cleanings and prefer usage of standard fixed-size types in debugger modules.","Went a bit further in the reduced usage of global variables inside emulation modules.
grep -rwc g_dev --exclude=""*~"" --exclude=""*.swp"" src/ | sort -t: -k 2 -n

... showing only files with more than 1 occurence of g_dev

src/backends/plugins_compat/audio_plugin_compat.c:1
src/device/r4300/cached_interp.c:1
src/device/r4300/new_dynarec/arm/assem_arm.h:1
src/device/r4300/new_dynarec/arm/linkage_arm.S:1
src/device/r4300/x86_64/dynarec.c:1
src/device/r4300/x86/dynarec.c:1
src/device/r4300/x86/regcache.c:1
src/main/main.h:1
src/main/savestates.c:2
src/device/r4300/x86/assemble.h:3
src/device/r4300/x86_64/assemble.h:5
src/device/r4300/x86_64/dyna_start.asm:5
src/device/r4300/x86/dyna_start.asm:8
src/device/r4300/new_dynarec/x86/linkage_x86.asm:15
src/device/r4300/recomp.c:19
src/api/debugger.c:20
src/main/main.c:29
src/plugin/plugin.c:49
src/device/r4300/new_dynarec/arm/assem_arm.c:211
src/device/r4300/new_dynarec/x86/assem_x86.c:219
src/device/r4300/new_dynarec/new_dynarec.c:239

A part from new_dynarec, x86{,_64}/assemble.h and one or two isolated cases, what prevents going with full removal of g_dev is that dynarec don't know how to pass arguments to functions. This is difficult because of the various calling conventions it would have to handle.
edited with updated grep result",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,521,2018-01-19T02:09:55Z,2018-01-20T03:32:19Z,2018-02-03T12:03:42Z,MERGED,True,2,2,1,https://github.com/bsmiles32,Fix empty dynarec,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/521,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/521,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,523,2018-01-26T16:06:09Z,2020-02-21T09:32:53Z,2020-02-21T09:32:53Z,CLOSED,False,89,36,2,https://github.com/Gillou68310,Add synchronization event between RSP and CPU,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/523,https://github.com/Gillou68310,1,https://github.com/mupen64plus/mupen64plus-core/pull/523,"The idea of this PR is to use the unused upper 16bits of SP_STATUS_REG in order to generate sync event between RSP and CPU.
Here's an example how this could be used:
Gillou68310/GLideN64@a9cc149
The main advantage of this method is to avoid resuming the locked rsp task while the event has not occurred.","The idea of this PR is to use the unused upper 16bits of SP_STATUS_REG in order to generate sync event between RSP and CPU.
Here's an example how this could be used:
Gillou68310/GLideN64@a9cc149
The main advantage of this method is to avoid resuming the locked rsp task while the event has not occurred.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,523,2018-01-26T16:06:09Z,2020-02-21T09:32:53Z,2020-02-21T09:32:53Z,CLOSED,False,89,36,2,https://github.com/Gillou68310,Add synchronization event between RSP and CPU,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/523,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/523#issuecomment-360842155,"The idea of this PR is to use the unused upper 16bits of SP_STATUS_REG in order to generate sync event between RSP and CPU.
Here's an example how this could be used:
Gillou68310/GLideN64@a9cc149
The main advantage of this method is to avoid resuming the locked rsp task while the event has not occurred.","Looks good to me, tested on the games that use this (WDC, Stunt Racer, Gauntlet Legends) and saw no issue (although visually inspecting the code I wouldn't expect there to be any difference anyway).
Out of curiosity, why rewrite the do_SP_Task() function so much? Why not just add:
// Fallback for undefined rsp<->cpu sync event       
if ((sp->regs[SP_STATUS_REG] >> 16) == 0)
    sp->mi->regs[MI_INTR_REG] |= MI_INTR_SP;

To the existing if ((sp->regs[SP_STATUS_REG] & (SP_STATUS_HALT | SP_STATUS_BROKE)) == 0) statement? It seems like it wouldn't make any difference",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,523,2018-01-26T16:06:09Z,2020-02-21T09:32:53Z,2020-02-21T09:32:53Z,CLOSED,False,89,36,2,https://github.com/Gillou68310,Add synchronization event between RSP and CPU,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/523,https://github.com/Gillou68310,3,https://github.com/mupen64plus/mupen64plus-core/pull/523#issuecomment-361197450,"The idea of this PR is to use the unused upper 16bits of SP_STATUS_REG in order to generate sync event between RSP and CPU.
Here's an example how this could be used:
Gillou68310/GLideN64@a9cc149
The main advantage of this method is to avoid resuming the locked rsp task while the event has not occurred.","I moved the if ((sp->regs[SP_STATUS_REG] & (SP_STATUS_HALT | SP_STATUS_BROKE)) == 0) condition inside the if (sp->mem[0xfc0/4] == 1) block because it should only happen in video ucodes, also new_frame should only be called when the rsp task is not locked.
But I agree with you that it was not necessary to refactor the if (sp->mi->regs[MI_INTR_REG] & MI_INTR_SP) block. It's just a personal preference for code readability. If people don't like it I can revert this part.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,523,2018-01-26T16:06:09Z,2020-02-21T09:32:53Z,2020-02-21T09:32:53Z,CLOSED,False,89,36,2,https://github.com/Gillou68310,Add synchronization event between RSP and CPU,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/523,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/523#issuecomment-361284750,"The idea of this PR is to use the unused upper 16bits of SP_STATUS_REG in order to generate sync event between RSP and CPU.
Here's an example how this could be used:
Gillou68310/GLideN64@a9cc149
The main advantage of this method is to avoid resuming the locked rsp task while the event has not occurred.","I moved the if ((sp->regs[SP_STATUS_REG] & (SP_STATUS_HALT | SP_STATUS_BROKE)) == 0) condition inside the if (sp->mem[0xfc0/4] == 1) block because it should only happen in video ucodes

We only know of games that do that in the video ucodes (and it might be the case), but wouldn't it be possible for a game to do that in an audio/other ucode?

It's just a personal preference for code readability

I guess it doesn't really matter, it just seems to duplicate code to me, you do cp0_update_count(sp->mi->r4300); and sp->mi->regs[MI_INTR_REG] &= ~MI_INTR_SP; in every if block, you might as well just put cp0_update_count(sp->mi->r4300); before the if block and sp->mi->regs[MI_INTR_REG] &= ~MI_INTR_SP; after",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,523,2018-01-26T16:06:09Z,2020-02-21T09:32:53Z,2020-02-21T09:32:53Z,CLOSED,False,89,36,2,https://github.com/Gillou68310,Add synchronization event between RSP and CPU,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/523,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/523#issuecomment-364463274,"The idea of this PR is to use the unused upper 16bits of SP_STATUS_REG in order to generate sync event between RSP and CPU.
Here's an example how this could be used:
Gillou68310/GLideN64@a9cc149
The main advantage of this method is to avoid resuming the locked rsp task while the event has not occurred.","It seems like you were able to implement the ucode without this change, right? What does it do exactly, does it improve performance or something?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,523,2018-01-26T16:06:09Z,2020-02-21T09:32:53Z,2020-02-21T09:32:53Z,CLOSED,False,89,36,2,https://github.com/Gillou68310,Add synchronization event between RSP and CPU,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/523,https://github.com/Gillou68310,6,https://github.com/mupen64plus/mupen64plus-core/pull/523#issuecomment-364472312,"The idea of this PR is to use the unused upper 16bits of SP_STATUS_REG in order to generate sync event between RSP and CPU.
Here's an example how this could be used:
Gillou68310/GLideN64@a9cc149
The main advantage of this method is to avoid resuming the locked rsp task while the event has not occurred.","It's just an accuracy improvement to avoid calling do_SP_Task() at an improper time, at least for WDC and stunt racer. It might improve performance a bit I honestly didn't checked.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,523,2018-01-26T16:06:09Z,2020-02-21T09:32:53Z,2020-02-21T09:32:53Z,CLOSED,False,89,36,2,https://github.com/Gillou68310,Add synchronization event between RSP and CPU,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/523,https://github.com/fzurita,7,https://github.com/mupen64plus/mupen64plus-core/pull/523#issuecomment-364976354,"The idea of this PR is to use the unused upper 16bits of SP_STATUS_REG in order to generate sync event between RSP and CPU.
Here's an example how this could be used:
Gillou68310/GLideN64@a9cc149
The main advantage of this method is to avoid resuming the locked rsp task while the event has not occurred.",This should really be merged now that GLideN64 has merged the referenced commit.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,523,2018-01-26T16:06:09Z,2020-02-21T09:32:53Z,2020-02-21T09:32:53Z,CLOSED,False,89,36,2,https://github.com/Gillou68310,Add synchronization event between RSP and CPU,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/523,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/523#issuecomment-364976638,"The idea of this PR is to use the unused upper 16bits of SP_STATUS_REG in order to generate sync event between RSP and CPU.
Here's an example how this could be used:
Gillou68310/GLideN64@a9cc149
The main advantage of this method is to avoid resuming the locked rsp task while the event has not occurred.","I believe this is an ""extra"" piece that wasn't part of the stuff that was just merged into GLideN64",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,523,2018-01-26T16:06:09Z,2020-02-21T09:32:53Z,2020-02-21T09:32:53Z,CLOSED,False,89,36,2,https://github.com/Gillou68310,Add synchronization event between RSP and CPU,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/523,https://github.com/fzurita,9,https://github.com/mupen64plus/mupen64plus-core/pull/523#issuecomment-364977530,"The idea of this PR is to use the unused upper 16bits of SP_STATUS_REG in order to generate sync event between RSP and CPU.
Here's an example how this could be used:
Gillou68310/GLideN64@a9cc149
The main advantage of this method is to avoid resuming the locked rsp task while the event has not occurred.","Yeah, good point. Although, according to @Gillou68310 it was supposed to fix the lockups when resuming from a save state in the Boss games. That's the main reason.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,523,2018-01-26T16:06:09Z,2020-02-21T09:32:53Z,2020-02-21T09:32:53Z,CLOSED,False,89,36,2,https://github.com/Gillou68310,Add synchronization event between RSP and CPU,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/523,https://github.com/loganmc10,10,https://github.com/mupen64plus/mupen64plus-core/pull/523#issuecomment-364978309,"The idea of this PR is to use the unused upper 16bits of SP_STATUS_REG in order to generate sync event between RSP and CPU.
Here's an example how this could be used:
Gillou68310/GLideN64@a9cc149
The main advantage of this method is to avoid resuming the locked rsp task while the event has not occurred.","I think that this commit: Gillou68310@d9129e1 was supposed to do that, I'm going to work on that next (getting it mergable/removing the g_dev usage)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,523,2018-01-26T16:06:09Z,2020-02-21T09:32:53Z,2020-02-21T09:32:53Z,CLOSED,False,89,36,2,https://github.com/Gillou68310,Add synchronization event between RSP and CPU,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/523,https://github.com/fzurita,11,https://github.com/mupen64plus/mupen64plus-core/pull/523#issuecomment-364979797,"The idea of this PR is to use the unused upper 16bits of SP_STATUS_REG in order to generate sync event between RSP and CPU.
Here's an example how this could be used:
Gillou68310/GLideN64@a9cc149
The main advantage of this method is to avoid resuming the locked rsp task while the event has not occurred.","Ok, I must have misunderstood what he said.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,523,2018-01-26T16:06:09Z,2020-02-21T09:32:53Z,2020-02-21T09:32:53Z,CLOSED,False,89,36,2,https://github.com/Gillou68310,Add synchronization event between RSP and CPU,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/523,https://github.com/fzurita,12,https://github.com/mupen64plus/mupen64plus-core/pull/523#issuecomment-366522354,"The idea of this PR is to use the unused upper 16bits of SP_STATUS_REG in order to generate sync event between RSP and CPU.
Here's an example how this could be used:
Gillou68310/GLideN64@a9cc149
The main advantage of this method is to avoid resuming the locked rsp task while the event has not occurred.",I tested guantlet legends to see if it would impact performance there. I didn't really see any difference though.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,523,2018-01-26T16:06:09Z,2020-02-21T09:32:53Z,2020-02-21T09:32:53Z,CLOSED,False,89,36,2,https://github.com/Gillou68310,Add synchronization event between RSP and CPU,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/523,https://github.com/fzurita,13,https://github.com/mupen64plus/mupen64plus-core/pull/523#issuecomment-462076057,"The idea of this PR is to use the unused upper 16bits of SP_STATUS_REG in order to generate sync event between RSP and CPU.
Here's an example how this could be used:
Gillou68310/GLideN64@a9cc149
The main advantage of this method is to avoid resuming the locked rsp task while the event has not occurred.",Any reason why this wasn't merged?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,523,2018-01-26T16:06:09Z,2020-02-21T09:32:53Z,2020-02-21T09:32:53Z,CLOSED,False,89,36,2,https://github.com/Gillou68310,Add synchronization event between RSP and CPU,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/523,https://github.com/richard42,14,https://github.com/mupen64plus/mupen64plus-core/pull/523#issuecomment-462079993,"The idea of this PR is to use the unused upper 16bits of SP_STATUS_REG in order to generate sync event between RSP and CPU.
Here's an example how this could be used:
Gillou68310/GLideN64@a9cc149
The main advantage of this method is to avoid resuming the locked rsp task while the event has not occurred.",it has a conflict with the master now,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,523,2018-01-26T16:06:09Z,2020-02-21T09:32:53Z,2020-02-21T09:32:53Z,CLOSED,False,89,36,2,https://github.com/Gillou68310,Add synchronization event between RSP and CPU,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/523,https://github.com/loganmc10,15,https://github.com/mupen64plus/mupen64plus-core/pull/523#issuecomment-462081281,"The idea of this PR is to use the unused upper 16bits of SP_STATUS_REG in order to generate sync event between RSP and CPU.
Here's an example how this could be used:
Gillou68310/GLideN64@a9cc149
The main advantage of this method is to avoid resuming the locked rsp task while the event has not occurred.",The other thing is I don't think it actually modified any behavior in any of the games (no known improvements from this change),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,526,2018-02-01T23:16:56Z,2018-02-02T07:09:30Z,2018-02-03T12:03:35Z,MERGED,True,24,1,2,https://github.com/bsmiles32,Fix undefined reference to print_insn_i386 with libopcode >= 2.29,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/526,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/526,"This broke with upstream commit 6394c606997f88acfc80de4dff33a4ae2de987b4
""Don't use print_insn_XXX in GDB"".","This broke with upstream commit 6394c606997f88acfc80de4dff33a4ae2de987b4
""Don't use print_insn_XXX in GDB"".",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,529,2018-02-05T18:49:14Z,2018-02-10T05:39:51Z,2018-12-03T03:50:49Z,MERGED,True,2,1,1,https://github.com/loganmc10,Fix compile on MinGW,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/529,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/529,"For some reason, recent builds on MinGW are failing, the asm_defines_nasm.h file looks like this:
)define offsetof_struct_cached_interp_invalid_code (0x00000000
)define offsetof_struct_r4300_core_cached_interp (0x00000af8
)define offsetof_struct_tlb_LUT_w (0x00400680
)define offsetof_struct_tlb_LUT_r (0x00000680
)define offsetof_struct_tlb_entries (0x00000000
)define offsetof_struct_cp0_tlb (0x000002ec
)define offsetof_struct_cp0_count_per_op (0x000002e8
)define offsetof_struct_cp0_last_addr (0x000002e4
)define offsetof_struct_cp0_next_interrupt (0x00000218
)define offsetof_struct_cp0_regs (0x00000000
)define offsetof_struct_r4300_core_cp0 (0x00900c60
)define offsetof_struct_r4300_core_return_address (0x00000a20
)define offsetof_struct_r4300_core_save_rip (0x00000a18
)define offsetof_struct_r4300_core_save_rsp (0x00000a10
)define offsetof_struct_r4300_core_stop (0x00000134
)define offsetof_struct_r4300_core_lo (0x00000108
)define offsetof_struct_r4300_core_hi (0x00000100
)define offsetof_struct_r4300_core_regs (0x00000000
)define offsetof_struct_device_r4300 (0x00000000

The output from strings seems to have Windows newlines, and then gawk can't properly parse the file. Piping it to dos2unix on the way fixes the issue.
dos2unix should be available on all Linux distributions, so I think this would be a pretty safe change. If someone know of a way to fix the gawk script to deal with Windows newlines that would probably work as well.","For some reason, recent builds on MinGW are failing, the asm_defines_nasm.h file looks like this:
)define offsetof_struct_cached_interp_invalid_code (0x00000000
)define offsetof_struct_r4300_core_cached_interp (0x00000af8
)define offsetof_struct_tlb_LUT_w (0x00400680
)define offsetof_struct_tlb_LUT_r (0x00000680
)define offsetof_struct_tlb_entries (0x00000000
)define offsetof_struct_cp0_tlb (0x000002ec
)define offsetof_struct_cp0_count_per_op (0x000002e8
)define offsetof_struct_cp0_last_addr (0x000002e4
)define offsetof_struct_cp0_next_interrupt (0x00000218
)define offsetof_struct_cp0_regs (0x00000000
)define offsetof_struct_r4300_core_cp0 (0x00900c60
)define offsetof_struct_r4300_core_return_address (0x00000a20
)define offsetof_struct_r4300_core_save_rip (0x00000a18
)define offsetof_struct_r4300_core_save_rsp (0x00000a10
)define offsetof_struct_r4300_core_stop (0x00000134
)define offsetof_struct_r4300_core_lo (0x00000108
)define offsetof_struct_r4300_core_hi (0x00000100
)define offsetof_struct_r4300_core_regs (0x00000000
)define offsetof_struct_device_r4300 (0x00000000

The output from strings seems to have Windows newlines, and then gawk can't properly parse the file. Piping it to dos2unix on the way fixes the issue.
dos2unix should be available on all Linux distributions, so I think this would be a pretty safe change. If someone know of a way to fix the gawk script to deal with Windows newlines that would probably work as well.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,529,2018-02-05T18:49:14Z,2018-02-10T05:39:51Z,2018-12-03T03:50:49Z,MERGED,True,2,1,1,https://github.com/loganmc10,Fix compile on MinGW,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/529,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/529#issuecomment-364174775,"For some reason, recent builds on MinGW are failing, the asm_defines_nasm.h file looks like this:
)define offsetof_struct_cached_interp_invalid_code (0x00000000
)define offsetof_struct_r4300_core_cached_interp (0x00000af8
)define offsetof_struct_tlb_LUT_w (0x00400680
)define offsetof_struct_tlb_LUT_r (0x00000680
)define offsetof_struct_tlb_entries (0x00000000
)define offsetof_struct_cp0_tlb (0x000002ec
)define offsetof_struct_cp0_count_per_op (0x000002e8
)define offsetof_struct_cp0_last_addr (0x000002e4
)define offsetof_struct_cp0_next_interrupt (0x00000218
)define offsetof_struct_cp0_regs (0x00000000
)define offsetof_struct_r4300_core_cp0 (0x00900c60
)define offsetof_struct_r4300_core_return_address (0x00000a20
)define offsetof_struct_r4300_core_save_rip (0x00000a18
)define offsetof_struct_r4300_core_save_rsp (0x00000a10
)define offsetof_struct_r4300_core_stop (0x00000134
)define offsetof_struct_r4300_core_lo (0x00000108
)define offsetof_struct_r4300_core_hi (0x00000100
)define offsetof_struct_r4300_core_regs (0x00000000
)define offsetof_struct_device_r4300 (0x00000000

The output from strings seems to have Windows newlines, and then gawk can't properly parse the file. Piping it to dos2unix on the way fixes the issue.
dos2unix should be available on all Linux distributions, so I think this would be a pretty safe change. If someone know of a way to fix the gawk script to deal with Windows newlines that would probably work as well.",@bsmiles32 @richard42,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,529,2018-02-05T18:49:14Z,2018-02-10T05:39:51Z,2018-12-03T03:50:49Z,MERGED,True,2,1,1,https://github.com/loganmc10,Fix compile on MinGW,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/529,https://github.com/richard42,3,https://github.com/mupen64plus/mupen64plus-core/pull/529#issuecomment-364303396,"For some reason, recent builds on MinGW are failing, the asm_defines_nasm.h file looks like this:
)define offsetof_struct_cached_interp_invalid_code (0x00000000
)define offsetof_struct_r4300_core_cached_interp (0x00000af8
)define offsetof_struct_tlb_LUT_w (0x00400680
)define offsetof_struct_tlb_LUT_r (0x00000680
)define offsetof_struct_tlb_entries (0x00000000
)define offsetof_struct_cp0_tlb (0x000002ec
)define offsetof_struct_cp0_count_per_op (0x000002e8
)define offsetof_struct_cp0_last_addr (0x000002e4
)define offsetof_struct_cp0_next_interrupt (0x00000218
)define offsetof_struct_cp0_regs (0x00000000
)define offsetof_struct_r4300_core_cp0 (0x00900c60
)define offsetof_struct_r4300_core_return_address (0x00000a20
)define offsetof_struct_r4300_core_save_rip (0x00000a18
)define offsetof_struct_r4300_core_save_rsp (0x00000a10
)define offsetof_struct_r4300_core_stop (0x00000134
)define offsetof_struct_r4300_core_lo (0x00000108
)define offsetof_struct_r4300_core_hi (0x00000100
)define offsetof_struct_r4300_core_regs (0x00000000
)define offsetof_struct_device_r4300 (0x00000000

The output from strings seems to have Windows newlines, and then gawk can't properly parse the file. Piping it to dos2unix on the way fixes the issue.
dos2unix should be available on all Linux distributions, so I think this would be a pretty safe change. If someone know of a way to fix the gawk script to deal with Windows newlines that would probably work as well.","Yeah I saw this but I kind of don't like it because I think dos2unix is not a standard system tool on many Linux distros; it's something that you have to install. I always want to keep dependencies to a minimum. Another possible solution is to use 'tr', which is part of coreutils and installed everywhere. The syntax would look like this:
tr -d '\r' < input.file  > new.file",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,529,2018-02-05T18:49:14Z,2018-02-10T05:39:51Z,2018-12-03T03:50:49Z,MERGED,True,2,1,1,https://github.com/loganmc10,Fix compile on MinGW,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/529,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/529#issuecomment-364464921,"For some reason, recent builds on MinGW are failing, the asm_defines_nasm.h file looks like this:
)define offsetof_struct_cached_interp_invalid_code (0x00000000
)define offsetof_struct_r4300_core_cached_interp (0x00000af8
)define offsetof_struct_tlb_LUT_w (0x00400680
)define offsetof_struct_tlb_LUT_r (0x00000680
)define offsetof_struct_tlb_entries (0x00000000
)define offsetof_struct_cp0_tlb (0x000002ec
)define offsetof_struct_cp0_count_per_op (0x000002e8
)define offsetof_struct_cp0_last_addr (0x000002e4
)define offsetof_struct_cp0_next_interrupt (0x00000218
)define offsetof_struct_cp0_regs (0x00000000
)define offsetof_struct_r4300_core_cp0 (0x00900c60
)define offsetof_struct_r4300_core_return_address (0x00000a20
)define offsetof_struct_r4300_core_save_rip (0x00000a18
)define offsetof_struct_r4300_core_save_rsp (0x00000a10
)define offsetof_struct_r4300_core_stop (0x00000134
)define offsetof_struct_r4300_core_lo (0x00000108
)define offsetof_struct_r4300_core_hi (0x00000100
)define offsetof_struct_r4300_core_regs (0x00000000
)define offsetof_struct_device_r4300 (0x00000000

The output from strings seems to have Windows newlines, and then gawk can't properly parse the file. Piping it to dos2unix on the way fixes the issue.
dos2unix should be available on all Linux distributions, so I think this would be a pretty safe change. If someone know of a way to fix the gawk script to deal with Windows newlines that would probably work as well.","Yes using tr works as well, I've updated the PR",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,529,2018-02-05T18:49:14Z,2018-02-10T05:39:51Z,2018-12-03T03:50:49Z,MERGED,True,2,1,1,https://github.com/loganmc10,Fix compile on MinGW,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/529,https://github.com/richard42,5,https://github.com/mupen64plus/mupen64plus-core/pull/529#issuecomment-364628101,"For some reason, recent builds on MinGW are failing, the asm_defines_nasm.h file looks like this:
)define offsetof_struct_cached_interp_invalid_code (0x00000000
)define offsetof_struct_r4300_core_cached_interp (0x00000af8
)define offsetof_struct_tlb_LUT_w (0x00400680
)define offsetof_struct_tlb_LUT_r (0x00000680
)define offsetof_struct_tlb_entries (0x00000000
)define offsetof_struct_cp0_tlb (0x000002ec
)define offsetof_struct_cp0_count_per_op (0x000002e8
)define offsetof_struct_cp0_last_addr (0x000002e4
)define offsetof_struct_cp0_next_interrupt (0x00000218
)define offsetof_struct_cp0_regs (0x00000000
)define offsetof_struct_r4300_core_cp0 (0x00900c60
)define offsetof_struct_r4300_core_return_address (0x00000a20
)define offsetof_struct_r4300_core_save_rip (0x00000a18
)define offsetof_struct_r4300_core_save_rsp (0x00000a10
)define offsetof_struct_r4300_core_stop (0x00000134
)define offsetof_struct_r4300_core_lo (0x00000108
)define offsetof_struct_r4300_core_hi (0x00000100
)define offsetof_struct_r4300_core_regs (0x00000000
)define offsetof_struct_device_r4300 (0x00000000

The output from strings seems to have Windows newlines, and then gawk can't properly parse the file. Piping it to dos2unix on the way fixes the issue.
dos2unix should be available on all Linux distributions, so I think this would be a pretty safe change. If someone know of a way to fix the gawk script to deal with Windows newlines that would probably work as well.",ok thanks.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,532,2018-02-10T18:56:27Z,2018-02-11T04:32:02Z,2018-02-11T04:32:02Z,MERGED,True,6,6,1,https://github.com/fzurita,"If a ROM is not in the database, use 4 players, enable mempak, and enable rumble pak",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/532,https://github.com/fzurita,1,https://github.com/mupen64plus/mupen64plus-core/pull/532,"If a ROM is not on the database (like ROM hacks), they tend to mostly work, except for the mempak and rumble pak not working. I think that to work more correctly when a ROM is not in the database, we should enable these by default.","If a ROM is not on the database (like ROM hacks), they tend to mostly work, except for the mempak and rumble pak not working. I think that to work more correctly when a ROM is not in the database, we should enable these by default.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,533,2018-02-12T16:09:20Z,2018-02-13T15:13:56Z,2018-12-03T03:50:47Z,MERGED,True,0,6,1,https://github.com/loganmc10,Remove CountPerOp=1 for Vigilante games,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/533,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/533,"The Vigilante games are very demanding on the CPU. Having CountPerOp=1 makes this even more pronounced.
@AmbientMalice you seem to know a lot of the history behind these settings. Do you know why the Vigilante games have CountPerOp=1? I assume we just copied it over from PJ64
I tested the games briefly and they seem to work the same using CountPerOp=2, but much less CPU usage.","The Vigilante games are very demanding on the CPU. Having CountPerOp=1 makes this even more pronounced.
@AmbientMalice you seem to know a lot of the history behind these settings. Do you know why the Vigilante games have CountPerOp=1? I assume we just copied it over from PJ64
I tested the games briefly and they seem to work the same using CountPerOp=2, but much less CPU usage.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,533,2018-02-12T16:09:20Z,2018-02-13T15:13:56Z,2018-12-03T03:50:47Z,MERGED,True,0,6,1,https://github.com/loganmc10,Remove CountPerOp=1 for Vigilante games,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/533,https://github.com/AmbientMalice,2,https://github.com/mupen64plus/mupen64plus-core/pull/533#issuecomment-365105352,"The Vigilante games are very demanding on the CPU. Having CountPerOp=1 makes this even more pronounced.
@AmbientMalice you seem to know a lot of the history behind these settings. Do you know why the Vigilante games have CountPerOp=1? I assume we just copied it over from PJ64
I tested the games briefly and they seem to work the same using CountPerOp=2, but much less CPU usage.","Nothing comes to mind, sorry.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,534,2018-02-12T16:55:05Z,2018-02-15T23:58:42Z,2018-12-03T03:51:21Z,CLOSED,False,7,5,4,https://github.com/loganmc10,Don't deal with save states when RSP task is locked,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/534,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/534,"This is based off of @Gillou68310's work here: Gillou68310@d9129e1 to make sure that save states don't lock up in WDC/Stunt Racer.
@fzurita perhaps you could test this on the device that had the issue?
@bsmiles32 are you happy with how the pointer is passed around?","This is based off of @Gillou68310's work here: Gillou68310@d9129e1 to make sure that save states don't lock up in WDC/Stunt Racer.
@fzurita perhaps you could test this on the device that had the issue?
@bsmiles32 are you happy with how the pointer is passed around?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,534,2018-02-12T16:55:05Z,2018-02-15T23:58:42Z,2018-12-03T03:51:21Z,CLOSED,False,7,5,4,https://github.com/loganmc10,Don't deal with save states when RSP task is locked,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/534,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/534#issuecomment-365150059,"This is based off of @Gillou68310's work here: Gillou68310@d9129e1 to make sure that save states don't lock up in WDC/Stunt Racer.
@fzurita perhaps you could test this on the device that had the issue?
@bsmiles32 are you happy with how the pointer is passed around?",It doesn't seem to work. It still locks up when resuming a save state in the ARM new dynarec.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,534,2018-02-12T16:55:05Z,2018-02-15T23:58:42Z,2018-12-03T03:51:21Z,CLOSED,False,7,5,4,https://github.com/loganmc10,Don't deal with save states when RSP task is locked,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/534,https://github.com/fzurita,3,https://github.com/mupen64plus/mupen64plus-core/pull/534#issuecomment-365150728,"This is based off of @Gillou68310's work here: Gillou68310@d9129e1 to make sure that save states don't lock up in WDC/Stunt Racer.
@fzurita perhaps you could test this on the device that had the issue?
@bsmiles32 are you happy with how the pointer is passed around?","Here is something interesting though. It only locks up if the save state is loaded at startup. If the save state is loaded after the game starts up, it doesn't freeze. Here is a save state that freezes when loaded at startup for world driver championship (U):
2018-02-12-23-51-05.v2.sav.zip",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,534,2018-02-12T16:55:05Z,2018-02-15T23:58:42Z,2018-12-03T03:51:21Z,CLOSED,False,7,5,4,https://github.com/loganmc10,Don't deal with save states when RSP task is locked,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/534,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/534#issuecomment-365158702,"This is based off of @Gillou68310's work here: Gillou68310@d9129e1 to make sure that save states don't lock up in WDC/Stunt Racer.
@fzurita perhaps you could test this on the device that had the issue?
@bsmiles32 are you happy with how the pointer is passed around?","Does this PR make any difference? I don't think I ever experienced freezing before, I'll have to test again tomorrow. I never tested loading at startup",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,534,2018-02-12T16:55:05Z,2018-02-15T23:58:42Z,2018-12-03T03:51:21Z,CLOSED,False,7,5,4,https://github.com/loganmc10,Don't deal with save states when RSP task is locked,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/534,https://github.com/fzurita,5,https://github.com/mupen64plus/mupen64plus-core/pull/534#issuecomment-365158813,"This is based off of @Gillou68310's work here: Gillou68310@d9129e1 to make sure that save states don't lock up in WDC/Stunt Racer.
@fzurita perhaps you could test this on the device that had the issue?
@bsmiles32 are you happy with how the pointer is passed around?",It didn't seem to make any difference. It only took a couple of tries to make it freeze.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,534,2018-02-12T16:55:05Z,2018-02-15T23:58:42Z,2018-12-03T03:51:21Z,CLOSED,False,7,5,4,https://github.com/loganmc10,Don't deal with save states when RSP task is locked,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/534,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/534#issuecomment-365158939,"This is based off of @Gillou68310's work here: Gillou68310@d9129e1 to make sure that save states don't lock up in WDC/Stunt Racer.
@fzurita perhaps you could test this on the device that had the issue?
@bsmiles32 are you happy with how the pointer is passed around?",Does it only happen with the dynarec?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,534,2018-02-12T16:55:05Z,2018-02-15T23:58:42Z,2018-12-03T03:51:21Z,CLOSED,False,7,5,4,https://github.com/loganmc10,Don't deal with save states when RSP task is locked,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/534,https://github.com/fzurita,7,https://github.com/mupen64plus/mupen64plus-core/pull/534#issuecomment-365159365,"This is based off of @Gillou68310's work here: Gillou68310@d9129e1 to make sure that save states don't lock up in WDC/Stunt Racer.
@fzurita perhaps you could test this on the device that had the issue?
@bsmiles32 are you happy with how the pointer is passed around?",I was able to easily reproduce using interpreter as well.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,534,2018-02-12T16:55:05Z,2018-02-15T23:58:42Z,2018-12-03T03:51:21Z,CLOSED,False,7,5,4,https://github.com/loganmc10,Don't deal with save states when RSP task is locked,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/534,https://github.com/Gillou68310,8,https://github.com/mupen64plus/mupen64plus-core/pull/534#issuecomment-365214715,"This is based off of @Gillou68310's work here: Gillou68310@d9129e1 to make sure that save states don't lock up in WDC/Stunt Racer.
@fzurita perhaps you could test this on the device that had the issue?
@bsmiles32 are you happy with how the pointer is passed around?","It didn't seem to make any difference. It only took a couple of tries to make it freeze.

I can't reproduce the issue on windows with x86 new dynarec.

Here is something interesting though. It only locks up if the save state is loaded at startup

This should fix the issue when loading a savestate at startup Gillou68310/GLideN64@7f20b53
@gonetz The problem is that all CRC in the specialMicrocodes need to be updated!",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,534,2018-02-12T16:55:05Z,2018-02-15T23:58:42Z,2018-12-03T03:51:21Z,CLOSED,False,7,5,4,https://github.com/loganmc10,Don't deal with save states when RSP task is locked,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/534,https://github.com/loganmc10,9,https://github.com/mupen64plus/mupen64plus-core/pull/534#issuecomment-365313188,"This is based off of @Gillou68310's work here: Gillou68310@d9129e1 to make sure that save states don't lock up in WDC/Stunt Racer.
@fzurita perhaps you could test this on the device that had the issue?
@bsmiles32 are you happy with how the pointer is passed around?","@Gillou68310 in your opinion is this PR still needed? It seems to help. In the current master (x64) I can get it to lock up when saving/loading save states (maybe once every 5-8th time). With this PR, it seems to be stable, doesn't lock up.
Or would fixing the CRC's in GLideN64 fix the issue as well (both at startup and in-game)?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,534,2018-02-12T16:55:05Z,2018-02-15T23:58:42Z,2018-12-03T03:51:21Z,CLOSED,False,7,5,4,https://github.com/loganmc10,Don't deal with save states when RSP task is locked,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/534,https://github.com/Gillou68310,10,https://github.com/mupen64plus/mupen64plus-core/pull/534#issuecomment-365315128,"This is based off of @Gillou68310's work here: Gillou68310@d9129e1 to make sure that save states don't lock up in WDC/Stunt Racer.
@fzurita perhaps you could test this on the device that had the issue?
@bsmiles32 are you happy with how the pointer is passed around?",The CRC fix will only fix the load at startup issue. So yes this PR is still needed to fix the in-game lock up.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,534,2018-02-12T16:55:05Z,2018-02-15T23:58:42Z,2018-12-03T03:51:21Z,CLOSED,False,7,5,4,https://github.com/loganmc10,Don't deal with save states when RSP task is locked,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/534,https://github.com/fzurita,11,https://github.com/mupen64plus/mupen64plus-core/pull/534#issuecomment-365496327,"This is based off of @Gillou68310's work here: Gillou68310@d9129e1 to make sure that save states don't lock up in WDC/Stunt Racer.
@fzurita perhaps you could test this on the device that had the issue?
@bsmiles32 are you happy with how the pointer is passed around?",@Gillou68310 Can you make a pull request for Gillou68310/GLideN64@7f20b53?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,534,2018-02-12T16:55:05Z,2018-02-15T23:58:42Z,2018-12-03T03:51:21Z,CLOSED,False,7,5,4,https://github.com/loganmc10,Don't deal with save states when RSP task is locked,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/534,https://github.com/gonetz,12,https://github.com/mupen64plus/mupen64plus-core/pull/534#issuecomment-365539695,"This is based off of @Gillou68310's work here: Gillou68310@d9129e1 to make sure that save states don't lock up in WDC/Stunt Racer.
@fzurita perhaps you could test this on the device that had the issue?
@bsmiles32 are you happy with how the pointer is passed around?","The problem is that all CRC in the specialMicrocodes need to be updated!

Could you explain, why?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,534,2018-02-12T16:55:05Z,2018-02-15T23:58:42Z,2018-12-03T03:51:21Z,CLOSED,False,7,5,4,https://github.com/loganmc10,Don't deal with save states when RSP task is locked,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/534,https://github.com/Gillou68310,13,https://github.com/mupen64plus/mupen64plus-core/pull/534#issuecomment-365547319,"This is based off of @Gillou68310's work here: Gillou68310@d9129e1 to make sure that save states don't lock up in WDC/Stunt Racer.
@fzurita perhaps you could test this on the device that had the issue?
@bsmiles32 are you happy with how the pointer is passed around?","The CRC will only have the correct value if uc_size = 4096 which is unlikely, except if uc_size = 0.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,534,2018-02-12T16:55:05Z,2018-02-15T23:58:42Z,2018-12-03T03:51:21Z,CLOSED,False,7,5,4,https://github.com/loganmc10,Don't deal with save states when RSP task is locked,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/534,https://github.com/gonetz,14,https://github.com/mupen64plus/mupen64plus-core/pull/534#issuecomment-365611973,"This is based off of @Gillou68310's work here: Gillou68310@d9129e1 to make sure that save states don't lock up in WDC/Stunt Racer.
@fzurita perhaps you could test this on the device that had the issue?
@bsmiles32 are you happy with how the pointer is passed around?","Will it work with zilmar-spec emulators?
Is uc_size constant for given ucode?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,534,2018-02-12T16:55:05Z,2018-02-15T23:58:42Z,2018-12-03T03:51:21Z,CLOSED,False,7,5,4,https://github.com/loganmc10,Don't deal with save states when RSP task is locked,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/534,https://github.com/Gillou68310,15,https://github.com/mupen64plus/mupen64plus-core/pull/534#issuecomment-365614807,"This is based off of @Gillou68310's work here: Gillou68310@d9129e1 to make sure that save states don't lock up in WDC/Stunt Racer.
@fzurita perhaps you could test this on the device that had the issue?
@bsmiles32 are you happy with how the pointer is passed around?","Will it work with zilmar-spec emulators?

Yes it will

Is uc_size constant for given ucode?

Yes we are already using it to compute ucode's checksum in rsp-hle (see normal_task_dispatching in hle.c)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,534,2018-02-12T16:55:05Z,2018-02-15T23:58:42Z,2018-12-03T03:51:21Z,CLOSED,False,7,5,4,https://github.com/loganmc10,Don't deal with save states when RSP task is locked,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/534,https://github.com/bsmiles32,16,https://github.com/mupen64plus/mupen64plus-core/pull/534#issuecomment-366093664,"This is based off of @Gillou68310's work here: Gillou68310@d9129e1 to make sure that save states don't lock up in WDC/Stunt Racer.
@fzurita perhaps you could test this on the device that had the issue?
@bsmiles32 are you happy with how the pointer is passed around?","@bsmiles32 are you happy with how the pointer is passed around?

@loganmc10 : I'm okay with how you passed the pointers around.
An alternative, would have been to make  interrupt_unsafe_state a bitfield such that any component (eg r4300 and now rsp) can signal collectively wether it is safe or not to savestate.
The test to allow savestating, is still interrupt_unsafe_state == 0, eg all components signals that they are in a state where it is safe to do a savestate.
This way there is no need to pass any pointer around because the rsp can directly prevent savestates by setting the proper bit of rsp->r4300->interrupt_unsafe_state.
@Gillou68310 Congratulations for your work on the Boss ZSort ucode ! This is really a great achievement.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,534,2018-02-12T16:55:05Z,2018-02-15T23:58:42Z,2018-12-03T03:51:21Z,CLOSED,False,7,5,4,https://github.com/loganmc10,Don't deal with save states when RSP task is locked,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/534,https://github.com/loganmc10,17,https://github.com/mupen64plus/mupen64plus-core/pull/534#issuecomment-366094349,"This is based off of @Gillou68310's work here: Gillou68310@d9129e1 to make sure that save states don't lock up in WDC/Stunt Racer.
@fzurita perhaps you could test this on the device that had the issue?
@bsmiles32 are you happy with how the pointer is passed around?","An alternative, would have been to make interrupt_unsafe_state a bitfield

Good point, I'll modify it to work that way.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,534,2018-02-12T16:55:05Z,2018-02-15T23:58:42Z,2018-12-03T03:51:21Z,CLOSED,False,7,5,4,https://github.com/loganmc10,Don't deal with save states when RSP task is locked,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/534,https://github.com/bsmiles32,18,https://github.com/mupen64plus/mupen64plus-core/pull/534#issuecomment-366102618,"This is based off of @Gillou68310's work here: Gillou68310@d9129e1 to make sure that save states don't lock up in WDC/Stunt Racer.
@fzurita perhaps you could test this on the device that had the issue?
@bsmiles32 are you happy with how the pointer is passed around?","@loganmc10 I've made the alternative implementation in #538
cc : @Gillou68310",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,534,2018-02-12T16:55:05Z,2018-02-15T23:58:42Z,2018-12-03T03:51:21Z,CLOSED,False,7,5,4,https://github.com/loganmc10,Don't deal with save states when RSP task is locked,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/534,https://github.com/loganmc10,19,https://github.com/mupen64plus/mupen64plus-core/pull/534#issuecomment-366102768,"This is based off of @Gillou68310's work here: Gillou68310@d9129e1 to make sure that save states don't lock up in WDC/Stunt Racer.
@fzurita perhaps you could test this on the device that had the issue?
@bsmiles32 are you happy with how the pointer is passed around?",Thanks,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,535,2018-02-14T04:45:50Z,2018-02-18T17:09:08Z,2018-02-18T17:09:08Z,MERGED,True,36,21,6,https://github.com/fzurita,Allow game controllers to be unplugged and plugged in on the fly,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/535,https://github.com/fzurita,1,https://github.com/mupen64plus/mupen64plus-core/pull/535,"This can be done using the controller plugin interface using the ""Present"" flag for each controller. I have to do more testing on it to make sure everything works correctly.
@bsmiles32 Can you review this and suggest improvements if necessary?
The main changes I did were to always initialize all controllers and use the controller API in pif.c to determine if a controller is present instead of checking for a null pointer for the controller interface.
I did a quick test using the smash brother player select screen and the hands were disappearing and appearing when the controller Present flag was toggled.
This is my attempt at fixing: #531","This can be done using the controller plugin interface using the ""Present"" flag for each controller. I have to do more testing on it to make sure everything works correctly.
@bsmiles32 Can you review this and suggest improvements if necessary?
The main changes I did were to always initialize all controllers and use the controller API in pif.c to determine if a controller is present instead of checking for a null pointer for the controller interface.
I did a quick test using the smash brother player select screen and the hands were disappearing and appearing when the controller Present flag was toggled.
This is my attempt at fixing: #531",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,535,2018-02-14T04:45:50Z,2018-02-18T17:09:08Z,2018-02-18T17:09:08Z,MERGED,True,36,21,6,https://github.com/fzurita,Allow game controllers to be unplugged and plugged in on the fly,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/535,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/535#issuecomment-365842564,"This can be done using the controller plugin interface using the ""Present"" flag for each controller. I have to do more testing on it to make sure everything works correctly.
@bsmiles32 Can you review this and suggest improvements if necessary?
The main changes I did were to always initialize all controllers and use the controller API in pif.c to determine if a controller is present instead of checking for a null pointer for the controller interface.
I did a quick test using the smash brother player select screen and the hands were disappearing and appearing when the controller Present flag was toggled.
This is my attempt at fixing: #531","Just quick notes for now (I'll try to submit some code later tonight) :

I'd prefer if we regroup the controller presence and button state query to a single method eg

enum controller_input_error_code
{ NO_ERROR, NOT_PLUGGED }
enum controller_input_error_code controller_input_backend_interface.get_input(uint32_t* input)

This is simpler to implement for plugins and avoid incoherent state (controller present at presence check, but not at button polling).

The joybus api shouldn't be changed. The controller presence check should be (re)done in the process_controller_command method.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,535,2018-02-14T04:45:50Z,2018-02-18T17:09:08Z,2018-02-18T17:09:08Z,MERGED,True,36,21,6,https://github.com/fzurita,Allow game controllers to be unplugged and plugged in on the fly,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/535,https://github.com/fzurita,3,https://github.com/mupen64plus/mupen64plus-core/pull/535#issuecomment-365843482,"This can be done using the controller plugin interface using the ""Present"" flag for each controller. I have to do more testing on it to make sure everything works correctly.
@bsmiles32 Can you review this and suggest improvements if necessary?
The main changes I did were to always initialize all controllers and use the controller API in pif.c to determine if a controller is present instead of checking for a null pointer for the controller interface.
I did a quick test using the smash brother player select screen and the hands were disappearing and appearing when the controller Present flag was toggled.
This is my attempt at fixing: #531","Yes, that was my initial approach, but I quickly discovered that process_controller_command did not seem to be intended to be called when a controller is not present. I guess, I could change that so it's always called.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,535,2018-02-14T04:45:50Z,2018-02-18T17:09:08Z,2018-02-18T17:09:08Z,MERGED,True,36,21,6,https://github.com/fzurita,Allow game controllers to be unplugged and plugged in on the fly,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/535,https://github.com/bsmiles32,4,https://github.com/mupen64plus/mupen64plus-core/pull/535#issuecomment-366087405,"This can be done using the controller plugin interface using the ""Present"" flag for each controller. I have to do more testing on it to make sure everything works correctly.
@bsmiles32 Can you review this and suggest improvements if necessary?
The main changes I did were to always initialize all controllers and use the controller API in pif.c to determine if a controller is present instead of checking for a null pointer for the controller interface.
I did a quick test using the smash brother player select screen and the hands were disappearing and appearing when the controller Present flag was toggled.
This is my attempt at fixing: #531","@fzurita Ok, pushed some modifications to make it work with the approach I proposed. Combined with mupen64plus/mupen64plus-input-sdl#66, I am able to disconnect / reconnect a controller and see the select hand disappear/reappear. However a few gotcha's when reconnecting the controller (which looks related to the input plugin, not the core):

there is some garbage data coming from the input driver just after reconnection.
when testing with multiple controllers (eg. 3 controllers plugged, then unplug 1, then another, then replug the former, then the latter....) the input plugin gets confused about which controller maps which N64 controller

Edit : also, hot pluggin doesn't work for controllers that were not plugged at program start... this is quite unfortunate",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,535,2018-02-14T04:45:50Z,2018-02-18T17:09:08Z,2018-02-18T17:09:08Z,MERGED,True,36,21,6,https://github.com/fzurita,Allow game controllers to be unplugged and plugged in on the fly,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/535,https://github.com/fzurita,5,https://github.com/mupen64plus/mupen64plus-core/pull/535#issuecomment-366098747,"This can be done using the controller plugin interface using the ""Present"" flag for each controller. I have to do more testing on it to make sure everything works correctly.
@bsmiles32 Can you review this and suggest improvements if necessary?
The main changes I did were to always initialize all controllers and use the controller API in pif.c to determine if a controller is present instead of checking for a null pointer for the controller interface.
I did a quick test using the smash brother player select screen and the hands were disappearing and appearing when the controller Present flag was toggled.
This is my attempt at fixing: #531",Is that hot plug-in limitation a limitation of the sdl input plugin itself? The Android input plugin doesn't have such problem. I was able to hot plug without having the controllers connected at startup with my initial implementation.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,535,2018-02-14T04:45:50Z,2018-02-18T17:09:08Z,2018-02-18T17:09:08Z,MERGED,True,36,21,6,https://github.com/fzurita,Allow game controllers to be unplugged and plugged in on the fly,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/535,https://github.com/bsmiles32,6,https://github.com/mupen64plus/mupen64plus-core/pull/535#issuecomment-366101820,"This can be done using the controller plugin interface using the ""Present"" flag for each controller. I have to do more testing on it to make sure everything works correctly.
@bsmiles32 Can you review this and suggest improvements if necessary?
The main changes I did were to always initialize all controllers and use the controller API in pif.c to determine if a controller is present instead of checking for a null pointer for the controller interface.
I did a quick test using the smash brother player select screen and the hands were disappearing and appearing when the controller Present flag was toggled.
This is my attempt at fixing: #531",I think it is a limitation of current sdl input plugin. Not sure if it is SDL itself or the input plugin with it's SDL1 heritage.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,535,2018-02-14T04:45:50Z,2018-02-18T17:09:08Z,2018-02-18T17:09:08Z,MERGED,True,36,21,6,https://github.com/fzurita,Allow game controllers to be unplugged and plugged in on the fly,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/535,https://github.com/fzurita,7,https://github.com/mupen64plus/mupen64plus-core/pull/535#issuecomment-366414100,"This can be done using the controller plugin interface using the ""Present"" flag for each controller. I have to do more testing on it to make sure everything works correctly.
@bsmiles32 Can you review this and suggest improvements if necessary?
The main changes I did were to always initialize all controllers and use the controller API in pif.c to determine if a controller is present instead of checking for a null pointer for the controller interface.
I did a quick test using the smash brother player select screen and the hands were disappearing and appearing when the controller Present flag was toggled.
This is my attempt at fixing: #531","@bsmiles32 I tested your changes against Android and everything works as well as my implementation. I'm able to start with controllers unplugged and then plugged them in on the fly, and the game will see them. Same goes with unplugging. Not to mention, it also fixes #528.
I think this should get merged.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,535,2018-02-14T04:45:50Z,2018-02-18T17:09:08Z,2018-02-18T17:09:08Z,MERGED,True,36,21,6,https://github.com/fzurita,Allow game controllers to be unplugged and plugged in on the fly,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/535,https://github.com/fzurita,8,https://github.com/mupen64plus/mupen64plus-core/pull/535#issuecomment-366414595,"This can be done using the controller plugin interface using the ""Present"" flag for each controller. I have to do more testing on it to make sure everything works correctly.
@bsmiles32 Can you review this and suggest improvements if necessary?
The main changes I did were to always initialize all controllers and use the controller API in pif.c to determine if a controller is present instead of checking for a null pointer for the controller interface.
I did a quick test using the smash brother player select screen and the hands were disappearing and appearing when the controller Present flag was toggled.
This is my attempt at fixing: #531","One thing I noticed though, in my implementation I made it so that channel->ijbd could never be null and I don't think you reverted that, but you put back the checks for channel->ijbd == NULL",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,535,2018-02-14T04:45:50Z,2018-02-18T17:09:08Z,2018-02-18T17:09:08Z,MERGED,True,36,21,6,https://github.com/fzurita,Allow game controllers to be unplugged and plugged in on the fly,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/535,https://github.com/bsmiles32,9,https://github.com/mupen64plus/mupen64plus-core/pull/535#issuecomment-366421327,"This can be done using the controller plugin interface using the ""Present"" flag for each controller. I have to do more testing on it to make sure everything works correctly.
@bsmiles32 Can you review this and suggest improvements if necessary?
The main changes I did were to always initialize all controllers and use the controller API in pif.c to determine if a controller is present instead of checking for a null pointer for the controller interface.
I did a quick test using the smash brother player select screen and the hands were disappearing and appearing when the controller Present flag was toggled.
This is my attempt at fixing: #531","You're right, channel->ijbd can't be NULL anymore because of how it is currently set up in main.c. However, I'll keep these tests for now in pif.c until I decide how I'll evolve the ""device setup"" part in main.c. Indeed, in some future work I'd like to add more flexibility regarding backends selection, and this work might make use of ijbd being NULL.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,535,2018-02-14T04:45:50Z,2018-02-18T17:09:08Z,2018-02-18T17:09:08Z,MERGED,True,36,21,6,https://github.com/fzurita,Allow game controllers to be unplugged and plugged in on the fly,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/535,https://github.com/fzurita,10,https://github.com/mupen64plus/mupen64plus-core/pull/535#issuecomment-366466586,"This can be done using the controller plugin interface using the ""Present"" flag for each controller. I have to do more testing on it to make sure everything works correctly.
@bsmiles32 Can you review this and suggest improvements if necessary?
The main changes I did were to always initialize all controllers and use the controller API in pif.c to determine if a controller is present instead of checking for a null pointer for the controller interface.
I did a quick test using the smash brother player select screen and the hands were disappearing and appearing when the controller Present flag was toggled.
This is my attempt at fixing: #531","Were there any N64 games that didn't support ""hot-pluggin""?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,535,2018-02-14T04:45:50Z,2018-02-18T17:09:08Z,2018-02-18T17:09:08Z,MERGED,True,36,21,6,https://github.com/fzurita,Allow game controllers to be unplugged and plugged in on the fly,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/535,https://github.com/fzurita,11,https://github.com/mupen64plus/mupen64plus-core/pull/535#issuecomment-366521121,"This can be done using the controller plugin interface using the ""Present"" flag for each controller. I have to do more testing on it to make sure everything works correctly.
@bsmiles32 Can you review this and suggest improvements if necessary?
The main changes I did were to always initialize all controllers and use the controller API in pif.c to determine if a controller is present instead of checking for a null pointer for the controller interface.
I did a quick test using the smash brother player select screen and the hands were disappearing and appearing when the controller Present flag was toggled.
This is my attempt at fixing: #531",@richard42 can this be merged?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,537,2018-02-15T16:42:51Z,2018-02-17T03:58:40Z,2018-02-22T13:35:27Z,MERGED,True,257,148,5,https://github.com/Gillou68310,new_dynarec: Fix DMULT/DMULTU recompiled code,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/537,https://github.com/Gillou68310,1,https://github.com/mupen64plus/mupen64plus-core/pull/537,Interpreted version could be used instead by defining INTERPRETED_MULT64,Interpreted version could be used instead by defining INTERPRETED_MULT64,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,537,2018-02-15T16:42:51Z,2018-02-17T03:58:40Z,2018-02-22T13:35:27Z,MERGED,True,257,148,5,https://github.com/Gillou68310,new_dynarec: Fix DMULT/DMULTU recompiled code,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/537,https://github.com/Gillou68310,2,https://github.com/mupen64plus/mupen64plus-core/pull/537#issuecomment-365986971,Interpreted version could be used instead by defining INTERPRETED_MULT64,"@fzurita, @loganmc10 could you guys test this for regressions?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,537,2018-02-15T16:42:51Z,2018-02-17T03:58:40Z,2018-02-22T13:35:27Z,MERGED,True,257,148,5,https://github.com/Gillou68310,new_dynarec: Fix DMULT/DMULTU recompiled code,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/537,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/537#issuecomment-366011702,Interpreted version could be used instead by defining INTERPRETED_MULT64,"I tested x86 (Windows). Looks ok to me, no issues in WDC",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,537,2018-02-15T16:42:51Z,2018-02-17T03:58:40Z,2018-02-22T13:35:27Z,MERGED,True,257,148,5,https://github.com/Gillou68310,new_dynarec: Fix DMULT/DMULTU recompiled code,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/537,https://github.com/fzurita,4,https://github.com/mupen64plus/mupen64plus-core/pull/537#issuecomment-366112801,Interpreted version could be used instead by defining INTERPRETED_MULT64,"I can verify that this fixed the arm new dynarec with boss games. I was hoping this would fix MRC, but it didn't. It sounds like a similar issue to this one. I could try your approach of replacing dynarec instructions with interpreter ones to see which one fixes it.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,538,2018-02-15T23:56:16Z,2018-02-17T04:05:32Z,2021-02-01T11:21:47Z,MERGED,True,21,13,4,https://github.com/bsmiles32,"Alternative implementation of ""Don't deal with save states when RSP t…",2,[],https://github.com/mupen64plus/mupen64plus-core/pull/538,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/538,"…ask is locked""
See #534","…ask is locked""
See #534",True,{'THUMBS_UP': ['https://github.com/loganmc10']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,538,2018-02-15T23:56:16Z,2018-02-17T04:05:32Z,2021-02-01T11:21:47Z,MERGED,True,21,13,4,https://github.com/bsmiles32,"Alternative implementation of ""Don't deal with save states when RSP t…",2,[],https://github.com/mupen64plus/mupen64plus-core/pull/538,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/538#issuecomment-366103613,"…ask is locked""
See #534",The only real difference I see is that rsp_task_locked is stored in the save state right? So when we load a save state you should probably set the flag there as well,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,538,2018-02-15T23:56:16Z,2018-02-17T04:05:32Z,2021-02-01T11:21:47Z,MERGED,True,21,13,4,https://github.com/bsmiles32,"Alternative implementation of ""Don't deal with save states when RSP t…",2,[],https://github.com/mupen64plus/mupen64plus-core/pull/538,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/538#issuecomment-366105447,"…ask is locked""
See #534","rsp_task_locked is indeed stored inside the savestate, but it may not be needed anymore now that we prevent savestating when rsp_task_locked is set... so updating interrupt_unsafe_state inside the save state loading doesn't much sense as it must be 0 to begin with.
Maybe I should also remove the rsp_task_locked variable from the savestate ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,538,2018-02-15T23:56:16Z,2018-02-17T04:05:32Z,2021-02-01T11:21:47Z,MERGED,True,21,13,4,https://github.com/bsmiles32,"Alternative implementation of ""Don't deal with save states when RSP t…",2,[],https://github.com/mupen64plus/mupen64plus-core/pull/538,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/538#issuecomment-366106259,"…ask is locked""
See #534","Oh right it must always be 0 with this change. I would just leave it, who knows if it may be used in the future again",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,538,2018-02-15T23:56:16Z,2018-02-17T04:05:32Z,2021-02-01T11:21:47Z,MERGED,True,21,13,4,https://github.com/bsmiles32,"Alternative implementation of ""Don't deal with save states when RSP t…",2,[],https://github.com/mupen64plus/mupen64plus-core/pull/538,https://github.com/bsmiles32,5,https://github.com/mupen64plus/mupen64plus-core/pull/538#issuecomment-366327235,"…ask is locked""
See #534",Squashed a small copy paste error which completely broke old savestates loading. Should be fixed now.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,541,2018-02-23T22:46:48Z,2018-02-27T05:49:39Z,2018-12-03T03:50:46Z,MERGED,True,4,4,1,https://github.com/loganmc10,Force alignment of PI DMA,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/541,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/541,"This needs more testing, I'll report back once I've tested it more.
Fixes: project64/project64#633
Taz Express tries to do an unaligned PI DMA transfer. Cart addresses must be 2-byte aligned and DRAM address must be 8-byte aligned.
This may/probably will break some ROM hacks (particularly some popular SM64 hacks). They don't work on a real console, and this is one of the main reasons.","This needs more testing, I'll report back once I've tested it more.
Fixes: project64/project64#633
Taz Express tries to do an unaligned PI DMA transfer. Cart addresses must be 2-byte aligned and DRAM address must be 8-byte aligned.
This may/probably will break some ROM hacks (particularly some popular SM64 hacks). They don't work on a real console, and this is one of the main reasons.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,541,2018-02-23T22:46:48Z,2018-02-27T05:49:39Z,2018-12-03T03:50:46Z,MERGED,True,4,4,1,https://github.com/loganmc10,Force alignment of PI DMA,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/541,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/541#issuecomment-368176644,"This needs more testing, I'll report back once I've tested it more.
Fixes: project64/project64#633
Taz Express tries to do an unaligned PI DMA transfer. Cart addresses must be 2-byte aligned and DRAM address must be 8-byte aligned.
This may/probably will break some ROM hacks (particularly some popular SM64 hacks). They don't work on a real console, and this is one of the main reasons.","Can we not break ROM hacks? Maybe at the same time as introducing this, add a core configuration parameters to allow overriding this?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,541,2018-02-23T22:46:48Z,2018-02-27T05:49:39Z,2018-12-03T03:50:46Z,MERGED,True,4,4,1,https://github.com/loganmc10,Force alignment of PI DMA,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/541,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/541#issuecomment-368180848,"This needs more testing, I'll report back once I've tested it more.
Fixes: project64/project64#633
Taz Express tries to do an unaligned PI DMA transfer. Cart addresses must be 2-byte aligned and DRAM address must be 8-byte aligned.
This may/probably will break some ROM hacks (particularly some popular SM64 hacks). They don't work on a real console, and this is one of the main reasons.","Well I guess that's sort of a philosophical disagreement. Those games don't run on a N64, they don't work with GLideN64 or Angrylion. We already ran into another issue with the VSYNC_REG
In my view they aren't really N64 games. The ""system"" they were written to run on is Project64 1.X
I'm not talking about all ROM hacks of course, just the ones that don't work on the N64.
But this is something that should be decided by @richard42 , it's sort of a project direction decision",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,541,2018-02-23T22:46:48Z,2018-02-27T05:49:39Z,2018-12-03T03:50:46Z,MERGED,True,4,4,1,https://github.com/loganmc10,Force alignment of PI DMA,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/541,https://github.com/fzurita,4,https://github.com/mupen64plus/mupen64plus-core/pull/541#issuecomment-368186408,"This needs more testing, I'll report back once I've tested it more.
Fixes: project64/project64#633
Taz Express tries to do an unaligned PI DMA transfer. Cart addresses must be 2-byte aligned and DRAM address must be 8-byte aligned.
This may/probably will break some ROM hacks (particularly some popular SM64 hacks). They don't work on a real console, and this is one of the main reasons.","Well, I completely agree with you. ROM hacks that don't work with the real hardware are a thing that should had never existed. Unfortunately, there are a lot of people that still play them.
I agree, from a preservation stand point, if the ROM hack doesn't work with the real hardware, it shouldn't work in the emulator. At the same time, if we want this emulator to be more ""popular"" we should maintain some sort of compatibility.
I think, clearly documented configuration parameters stating that they are not accurate to real hardware is a good compromise in my opinion.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,541,2018-02-23T22:46:48Z,2018-02-27T05:49:39Z,2018-12-03T03:50:46Z,MERGED,True,4,4,1,https://github.com/loganmc10,Force alignment of PI DMA,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/541,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/541#issuecomment-368199324,"This needs more testing, I'll report back once I've tested it more.
Fixes: project64/project64#633
Taz Express tries to do an unaligned PI DMA transfer. Cart addresses must be 2-byte aligned and DRAM address must be 8-byte aligned.
This may/probably will break some ROM hacks (particularly some popular SM64 hacks). They don't work on a real console, and this is one of the main reasons.","@Narann I'm not sure why the AppVeyor build failed, can you try restarting it?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,541,2018-02-23T22:46:48Z,2018-02-27T05:49:39Z,2018-12-03T03:50:46Z,MERGED,True,4,4,1,https://github.com/loganmc10,Force alignment of PI DMA,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/541,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/541#issuecomment-368199589,"This needs more testing, I'll report back once I've tested it more.
Fixes: project64/project64#633
Taz Express tries to do an unaligned PI DMA transfer. Cart addresses must be 2-byte aligned and DRAM address must be 8-byte aligned.
This may/probably will break some ROM hacks (particularly some popular SM64 hacks). They don't work on a real console, and this is one of the main reasons.","I think, clearly documented configuration parameters stating that they are not accurate to real hardware is a good compromise in my opinion

I guess I disagree, we'd already need something in the VI and PI controllers, and potentially other places in the future. I feel like it'd just be mucking up the code to support these ROMs. It's the ROMs that are broken, one of the many ROM ninjas out there should go to work in fixing the ROMs.
These broken ROM hacks are still being made to this day, I feel like purposely adding support in the emulator is just encouraging it",True,{'THUMBS_UP': ['https://github.com/dankcushions']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,541,2018-02-23T22:46:48Z,2018-02-27T05:49:39Z,2018-12-03T03:50:46Z,MERGED,True,4,4,1,https://github.com/loganmc10,Force alignment of PI DMA,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/541,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/541#issuecomment-368684641,"This needs more testing, I'll report back once I've tested it more.
Fixes: project64/project64#633
Taz Express tries to do an unaligned PI DMA transfer. Cart addresses must be 2-byte aligned and DRAM address must be 8-byte aligned.
This may/probably will break some ROM hacks (particularly some popular SM64 hacks). They don't work on a real console, and this is one of the main reasons.","I haven't come across any issues in the many retail games I've tested. I tested ""Super Mario Star Road"" (ROM Hack), and this change does indeed break it.
So we need some kind of direction from somebody with merge rights @richard42 @bsmiles32 . Do we add a config option like ""Allow unaligned DMAs"", or do we add INI entries for the ROM hacks to allow unaligned DMAs, or do we break compatibility with the ROM hacks?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,541,2018-02-23T22:46:48Z,2018-02-27T05:49:39Z,2018-12-03T03:50:46Z,MERGED,True,4,4,1,https://github.com/loganmc10,Force alignment of PI DMA,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/541,https://github.com/richard42,8,https://github.com/mupen64plus/mupen64plus-core/pull/541#issuecomment-368755455,"This needs more testing, I'll report back once I've tested it more.
Fixes: project64/project64#633
Taz Express tries to do an unaligned PI DMA transfer. Cart addresses must be 2-byte aligned and DRAM address must be 8-byte aligned.
This may/probably will break some ROM hacks (particularly some popular SM64 hacks). They don't work on a real console, and this is one of the main reasons.","This is a worthwhile patch as it increases accuracy and fixes Taz Express. I think it's not worth the extra complexity to add configuration options or INI entries to support ""homebrew"" ROMs which don't work on the real hardware.",True,"{'THUMBS_UP': ['https://github.com/Isotarge', 'https://github.com/AmbientMalice']}"
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,544,2018-03-09T20:22:26Z,2018-03-10T01:05:12Z,2018-12-03T03:50:44Z,MERGED,True,0,37,3,https://github.com/loganmc10,Fix DSLLV in x86 dynarec,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/544,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/544,"This is based on @richard42's advice in #542 (comment)
Removing the force_32 function does indeed fix Indiana Jones in the x86 dynarec.
I also ran PeterLemon's CPUDSLLV.N64, CPUDSRAV.N64, and CPUDSRLV.N64 test ROM's and we still pass those tests (we passed before this change as well).
I really don't know anything about assembly or the dynarec, I was jus testing/implementing @richard42's suggestion and it seems to work, so I created this PR","This is based on @richard42's advice in #542 (comment)
Removing the force_32 function does indeed fix Indiana Jones in the x86 dynarec.
I also ran PeterLemon's CPUDSLLV.N64, CPUDSRAV.N64, and CPUDSRLV.N64 test ROM's and we still pass those tests (we passed before this change as well).
I really don't know anything about assembly or the dynarec, I was jus testing/implementing @richard42's suggestion and it seems to work, so I created this PR",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,545,2018-03-09T21:28:46Z,2018-03-19T03:33:05Z,2021-02-01T11:21:49Z,MERGED,True,140,12,1,https://github.com/bsmiles32,Fix: try to keep savestates offsets aligned.,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/545,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/545,"Lame attempt at keeping savestate offsets aligned... not really proud of what I've done because it is still very fragile, but should fix current crashes.
Should also probably bump savestate version ? But is it considered a major version bump or minor ?
@Gillou68310 @fzurita can you test if this indeed fixes your crashes ? Thanks","Lame attempt at keeping savestate offsets aligned... not really proud of what I've done because it is still very fragile, but should fix current crashes.
Should also probably bump savestate version ? But is it considered a major version bump or minor ?
@Gillou68310 @fzurita can you test if this indeed fixes your crashes ? Thanks",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,545,2018-03-09T21:28:46Z,2018-03-19T03:33:05Z,2021-02-01T11:21:49Z,MERGED,True,140,12,1,https://github.com/bsmiles32,Fix: try to keep savestates offsets aligned.,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/545,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/545#issuecomment-371953802,"Lame attempt at keeping savestate offsets aligned... not really proud of what I've done because it is still very fragile, but should fix current crashes.
Should also probably bump savestate version ? But is it considered a major version bump or minor ?
@Gillou68310 @fzurita can you test if this indeed fixes your crashes ? Thanks","It does fix the crashing when compiling with LTO enabled and loading save states.
Loading save states produced before this change is broken though, probably because you changed the structure of the save state file.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,545,2018-03-09T21:28:46Z,2018-03-19T03:33:05Z,2021-02-01T11:21:49Z,MERGED,True,140,12,1,https://github.com/bsmiles32,Fix: try to keep savestates offsets aligned.,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/545,https://github.com/fzurita,3,https://github.com/mupen64plus/mupen64plus-core/pull/545#issuecomment-371954989,"Lame attempt at keeping savestate offsets aligned... not really proud of what I've done because it is still very fragile, but should fix current crashes.
Should also probably bump savestate version ? But is it considered a major version bump or minor ?
@Gillou68310 @fzurita can you test if this indeed fixes your crashes ? Thanks","Since you changed the structure of the save state, you do need to change the version I guess so that we don't load broken save states.
Although, I think we should still make a way to load the old save states. Maybe have a converter that is able to convert the old save state format to the new one in memory? It looks like we just need to shift everything by two bytes where you inserted those two extra bytes.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,545,2018-03-09T21:28:46Z,2018-03-19T03:33:05Z,2021-02-01T11:21:49Z,MERGED,True,140,12,1,https://github.com/bsmiles32,Fix: try to keep savestates offsets aligned.,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/545,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/545#issuecomment-371955985,"Lame attempt at keeping savestate offsets aligned... not really proud of what I've done because it is still very fragile, but should fix current crashes.
Should also probably bump savestate version ? But is it considered a major version bump or minor ?
@Gillou68310 @fzurita can you test if this indeed fixes your crashes ? Thanks","It looks like we just need to shift everything by two bytes where you inserted those two extra bytes.

I believe the shifting of the other variables is important as well to keep everything 8-byte aligned, it's not just the extra padding, that's what will make upping the save state version or loading old versions a little trickier",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,545,2018-03-09T21:28:46Z,2018-03-19T03:33:05Z,2021-02-01T11:21:49Z,MERGED,True,140,12,1,https://github.com/bsmiles32,Fix: try to keep savestates offsets aligned.,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/545,https://github.com/fzurita,5,https://github.com/mupen64plus/mupen64plus-core/pull/545#issuecomment-371957128,"Lame attempt at keeping savestate offsets aligned... not really proud of what I've done because it is still very fragile, but should fix current crashes.
Should also probably bump savestate version ? But is it considered a major version bump or minor ?
@Gillou68310 @fzurita can you test if this indeed fixes your crashes ? Thanks","Yep, you are right. Stuff got moved around. I didn't pay enough attention. That does make it tricky to load the old save states.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,545,2018-03-09T21:28:46Z,2018-03-19T03:33:05Z,2021-02-01T11:21:49Z,MERGED,True,140,12,1,https://github.com/bsmiles32,Fix: try to keep savestates offsets aligned.,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/545,https://github.com/fzurita,6,https://github.com/mupen64plus/mupen64plus-core/pull/545#issuecomment-371961270,"Lame attempt at keeping savestate offsets aligned... not really proud of what I've done because it is still very fragile, but should fix current crashes.
Should also probably bump savestate version ? But is it considered a major version bump or minor ?
@Gillou68310 @fzurita can you test if this indeed fixes your crashes ? Thanks","To me it seems simple to keep compatibility. Increment save state version, and don't load the ""data_0001_0200"" if we have the old save state version. Treat the previous save state version like they didn't have the data_0001_0200 at all.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,545,2018-03-09T21:28:46Z,2018-03-19T03:33:05Z,2021-02-01T11:21:49Z,MERGED,True,140,12,1,https://github.com/bsmiles32,Fix: try to keep savestates offsets aligned.,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/545,https://github.com/bsmiles32,7,https://github.com/mupen64plus/mupen64plus-core/pull/545#issuecomment-371973332,"Lame attempt at keeping savestate offsets aligned... not really proud of what I've done because it is still very fragile, but should fix current crashes.
Should also probably bump savestate version ? But is it considered a major version bump or minor ?
@Gillou68310 @fzurita can you test if this indeed fixes your crashes ? Thanks","Updated PR with better implementation :

v1.2 is finally kept unchanged, we just pre-load data to an aligned buffer before doing the real access
v1.3 changes data offsets to have them aligned like I did in previous commit.

@fzurita @loganmc10 What do you think ? :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,545,2018-03-09T21:28:46Z,2018-03-19T03:33:05Z,2021-02-01T11:21:49Z,MERGED,True,140,12,1,https://github.com/bsmiles32,Fix: try to keep savestates offsets aligned.,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/545,https://github.com/fzurita,8,https://github.com/mupen64plus/mupen64plus-core/pull/545#issuecomment-371983088,"Lame attempt at keeping savestate offsets aligned... not really proud of what I've done because it is still very fragile, but should fix current crashes.
Should also probably bump savestate version ? But is it considered a major version bump or minor ?
@Gillou68310 @fzurita can you test if this indeed fixes your crashes ? Thanks",I think this is better. Old save states still work and no crashing.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,545,2018-03-09T21:28:46Z,2018-03-19T03:33:05Z,2021-02-01T11:21:49Z,MERGED,True,140,12,1,https://github.com/bsmiles32,Fix: try to keep savestates offsets aligned.,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/545,https://github.com/fzurita,9,https://github.com/mupen64plus/mupen64plus-core/pull/545#issuecomment-373502963,"Lame attempt at keeping savestate offsets aligned... not really proud of what I've done because it is still very fragile, but should fix current crashes.
Should also probably bump savestate version ? But is it considered a major version bump or minor ?
@Gillou68310 @fzurita can you test if this indeed fixes your crashes ? Thanks",@richard42 Can this be merged?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,547,2018-03-19T02:02:02Z,2018-03-28T03:36:07Z,2021-02-01T11:21:52Z,MERGED,True,5114,7060,42,https://github.com/bsmiles32,R4300 refactorings,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/547,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/547,"This is a first step toward R4300 sub-module cleaning.
Main changes from this PR are:

better decoupling of new_dynarec from old dynarec (for example, empty_dynarec is not needed anymore)
better decoupling of dynarec / cached_interpreter (except for precomp_{block,inst} structures, cached_interp doesn't depends on dynarec)
dynarec variables are now inside r4300.recomp, cached_interp inside r4300.cached_interp
introduction of table based instruction decoder which is key this decoupling and should allow better maintenance of instruction decoding logic. In further work, I could possibly expand it's usage in pure_interpreter, and possibly streamline some more register/constants decodings.
various cleanings

I've tested a bunch of games with no obvious regression (x64 dynarec, cached_interpreter), but I welcome other to test this, especially with new_dynarec and od 32 bit dynarec.","This is a first step toward R4300 sub-module cleaning.
Main changes from this PR are:

better decoupling of new_dynarec from old dynarec (for example, empty_dynarec is not needed anymore)
better decoupling of dynarec / cached_interpreter (except for precomp_{block,inst} structures, cached_interp doesn't depends on dynarec)
dynarec variables are now inside r4300.recomp, cached_interp inside r4300.cached_interp
introduction of table based instruction decoder which is key this decoupling and should allow better maintenance of instruction decoding logic. In further work, I could possibly expand it's usage in pure_interpreter, and possibly streamline some more register/constants decodings.
various cleanings

I've tested a bunch of games with no obvious regression (x64 dynarec, cached_interpreter), but I welcome other to test this, especially with new_dynarec and od 32 bit dynarec.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,547,2018-03-19T02:02:02Z,2018-03-28T03:36:07Z,2021-02-01T11:21:52Z,MERGED,True,5114,7060,42,https://github.com/bsmiles32,R4300 refactorings,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/547,https://github.com/Jj0YzL5nvJ,2,https://github.com/mupen64plus/mupen64plus-core/pull/547#issuecomment-374556446,"This is a first step toward R4300 sub-module cleaning.
Main changes from this PR are:

better decoupling of new_dynarec from old dynarec (for example, empty_dynarec is not needed anymore)
better decoupling of dynarec / cached_interpreter (except for precomp_{block,inst} structures, cached_interp doesn't depends on dynarec)
dynarec variables are now inside r4300.recomp, cached_interp inside r4300.cached_interp
introduction of table based instruction decoder which is key this decoupling and should allow better maintenance of instruction decoding logic. In further work, I could possibly expand it's usage in pure_interpreter, and possibly streamline some more register/constants decodings.
various cleanings

I've tested a bunch of games with no obvious regression (x64 dynarec, cached_interpreter), but I welcome other to test this, especially with new_dynarec and od 32 bit dynarec.","For x64, when compiled using clang/clang++, this pull gives a lot of warnings (256)
$ clang-5.0 --version
clang version 5.0.1-1~oibaf~x (tags/RELEASE_501/final)
Target: x86_64-pc-linux-gnu
Thread model: posix
InstalledDir: /usr/bin",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,547,2018-03-19T02:02:02Z,2018-03-28T03:36:07Z,2021-02-01T11:21:52Z,MERGED,True,5114,7060,42,https://github.com/bsmiles32,R4300 refactorings,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/547,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/547#issuecomment-374764444,"This is a first step toward R4300 sub-module cleaning.
Main changes from this PR are:

better decoupling of new_dynarec from old dynarec (for example, empty_dynarec is not needed anymore)
better decoupling of dynarec / cached_interpreter (except for precomp_{block,inst} structures, cached_interp doesn't depends on dynarec)
dynarec variables are now inside r4300.recomp, cached_interp inside r4300.cached_interp
introduction of table based instruction decoder which is key this decoupling and should allow better maintenance of instruction decoding logic. In further work, I could possibly expand it's usage in pure_interpreter, and possibly streamline some more register/constants decodings.
various cleanings

I've tested a bunch of games with no obvious regression (x64 dynarec, cached_interpreter), but I welcome other to test this, especially with new_dynarec and od 32 bit dynarec.","@Jj0YzL5nvJ Thanks for testing and providing your feedback. The warnings should now be fixed.
I did a bit more testing performance-wise (time to render 1000 frames, no sound, nospeedlimit).[before/after in seconds]:
Mario Kart (dynarec - cached interpreter): 19.9 / 19.5 - 23.7 / 23.3
CBFD (dynarec - cached interpreter): 31.3 / 30.7 - 38 / 37.8
GoldenEye (dynarec) : 13.2 / 13.2
F-Zero (dynarec) : 15.5 / 15.2
PerfectDark (dynarec - cached interpreter) : 17.9 / 17.9 - 21.5 / 22.0
WorldDriverChampionship (dynarec - cached interpreter) : 7.7 / 7.8 - 9.7 / 10.0
MajorasMask (dynarec) : 29.1 / 28.7
Performance is equivalent maybe slightly better. But with a much more maintainable code base :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,547,2018-03-19T02:02:02Z,2018-03-28T03:36:07Z,2021-02-01T11:21:52Z,MERGED,True,5114,7060,42,https://github.com/bsmiles32,R4300 refactorings,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/547,https://github.com/bsmiles32,4,https://github.com/mupen64plus/mupen64plus-core/pull/547#issuecomment-374777578,"This is a first step toward R4300 sub-module cleaning.
Main changes from this PR are:

better decoupling of new_dynarec from old dynarec (for example, empty_dynarec is not needed anymore)
better decoupling of dynarec / cached_interpreter (except for precomp_{block,inst} structures, cached_interp doesn't depends on dynarec)
dynarec variables are now inside r4300.recomp, cached_interp inside r4300.cached_interp
introduction of table based instruction decoder which is key this decoupling and should allow better maintenance of instruction decoding logic. In further work, I could possibly expand it's usage in pure_interpreter, and possibly streamline some more register/constants decodings.
various cleanings

I've tested a bunch of games with no obvious regression (x64 dynarec, cached_interpreter), but I welcome other to test this, especially with new_dynarec and od 32 bit dynarec.","The new commit seems to also improve slightly the perf.
Mario Kart (dynarec - cached interpreter) [master/44b92.../01aec...] : 19.9/19.5/19.3 - 23.7/23.3/23.1
So pretty cool :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,547,2018-03-19T02:02:02Z,2018-03-28T03:36:07Z,2021-02-01T11:21:52Z,MERGED,True,5114,7060,42,https://github.com/bsmiles32,R4300 refactorings,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/547,https://github.com/Jj0YzL5nvJ,5,https://github.com/mupen64plus/mupen64plus-core/pull/547#issuecomment-375270731,"This is a first step toward R4300 sub-module cleaning.
Main changes from this PR are:

better decoupling of new_dynarec from old dynarec (for example, empty_dynarec is not needed anymore)
better decoupling of dynarec / cached_interpreter (except for precomp_{block,inst} structures, cached_interp doesn't depends on dynarec)
dynarec variables are now inside r4300.recomp, cached_interp inside r4300.cached_interp
introduction of table based instruction decoder which is key this decoupling and should allow better maintenance of instruction decoding logic. In further work, I could possibly expand it's usage in pure_interpreter, and possibly streamline some more register/constants decodings.
various cleanings

I've tested a bunch of games with no obvious regression (x64 dynarec, cached_interpreter), but I welcome other to test this, especially with new_dynarec and od 32 bit dynarec.","Maybe it's just my imagination, but using the dynamic recompiler (x64) in CBFD, when you start controlling Conker. On the way to the scarecrow, Conker speaks less (he complains less).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,547,2018-03-19T02:02:02Z,2018-03-28T03:36:07Z,2021-02-01T11:21:52Z,MERGED,True,5114,7060,42,https://github.com/bsmiles32,R4300 refactorings,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/547,https://github.com/fzurita,6,https://github.com/mupen64plus/mupen64plus-core/pull/547#issuecomment-375656324,"This is a first step toward R4300 sub-module cleaning.
Main changes from this PR are:

better decoupling of new_dynarec from old dynarec (for example, empty_dynarec is not needed anymore)
better decoupling of dynarec / cached_interpreter (except for precomp_{block,inst} structures, cached_interp doesn't depends on dynarec)
dynarec variables are now inside r4300.recomp, cached_interp inside r4300.cached_interp
introduction of table based instruction decoder which is key this decoupling and should allow better maintenance of instruction decoding logic. In further work, I could possibly expand it's usage in pure_interpreter, and possibly streamline some more register/constants decodings.
various cleanings

I've tested a bunch of games with no obvious regression (x64 dynarec, cached_interpreter), but I welcome other to test this, especially with new_dynarec and od 32 bit dynarec.","Is this part of the refactoring?
  [armeabi-v7a] Compile arm    : mupen64plus-core <= ioapi.c
  /home/fzurita/git_projects/mupen64plus/mupen64plus-ae/mupen64plus-core/./upstream/src/main/zip/ioapi.c:157:11: warning: implicit declaration of function 'ftello' is invalid in C99 [-Wimplicit-function-declaration]
      ret = FTELLO_FUNC((FILE *)stream);
            ^
  /home/fzurita/git_projects/mupen64plus/mupen64plus-ae/mupen64plus-core/./upstream/src/main/zip/ioapi.c:20:29: note: expanded from macro 'FTELLO_FUNC'
  #define FTELLO_FUNC(stream) ftello(stream)
                              ^
  /home/fzurita/git_projects/mupen64plus/mupen64plus-ae/mupen64plus-core/./upstream/src/main/zip/ioapi.c:203:8: warning: implicit declaration of function 'fseeko' is invalid in C99 [-Wimplicit-function-declaration]
      if(FSEEKO_FUNC((FILE *)stream, offset, fseek_origin) != 0)
         ^
  /home/fzurita/git_projects/mupen64plus/mupen64plus-ae/mupen64plus-core/./upstream/src/main/zip/ioapi.c:21:45: note: expanded from macro 'FSEEKO_FUNC'
  #define FSEEKO_FUNC(stream, offset, origin) fseeko(stream, offset, origin)
                                              ^",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,547,2018-03-19T02:02:02Z,2018-03-28T03:36:07Z,2021-02-01T11:21:52Z,MERGED,True,5114,7060,42,https://github.com/bsmiles32,R4300 refactorings,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/547,https://github.com/fzurita,7,https://github.com/mupen64plus/mupen64plus-core/pull/547#issuecomment-375660564,"This is a first step toward R4300 sub-module cleaning.
Main changes from this PR are:

better decoupling of new_dynarec from old dynarec (for example, empty_dynarec is not needed anymore)
better decoupling of dynarec / cached_interpreter (except for precomp_{block,inst} structures, cached_interp doesn't depends on dynarec)
dynarec variables are now inside r4300.recomp, cached_interp inside r4300.cached_interp
introduction of table based instruction decoder which is key this decoupling and should allow better maintenance of instruction decoding logic. In further work, I could possibly expand it's usage in pure_interpreter, and possibly streamline some more register/constants decodings.
various cleanings

I've tested a bunch of games with no obvious regression (x64 dynarec, cached_interpreter), but I welcome other to test this, especially with new_dynarec and od 32 bit dynarec.","Some errors when building the new dynarec:
 In file included from ./src/device/r4300/new_dynarec/new_dynarec.c:1675:
 ./src/device/r4300/new_dynarec/arm/assem_arm.c:447:8: warning: initializing 'int *' with an expression of type 'u_int *' (aka 'unsigned int *') converts between pointers to integer types with different sign [-Wpointer-sign]
    int *ptr=((u_int *)addr)+6;
         ^   ~~~~~~~~~~~~~~~~~
  ./src/device/r4300/new_dynarec/arm/assem_arm.c:4484:24: error: use of undeclared identifier 'cached_interpreter_table'
          emit_call((int)cached_interpreter_table.DDIV);
                         ^
  ./src/device/r4300/new_dynarec/arm/assem_arm.c:4512:24: error: use of undeclared identifier 'cached_interpreter_table'
          emit_call((int)cached_interpreter_table.DDIVU);
                         ^
  ./src/device/r4300/new_dynarec/new_dynarec.c:2213:67: warning: comparison of unsigned expression >= 0 is always true [-Wtautological-compare]
        if((start!=0)&&(page<2048)&&((start-(u_int)g_dev.rdram.dram)>=0)&&((end-(u_int)g_dev.rdram.dram)<0x800000)) {
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^ ~
  ./src/device/r4300/new_dynarec/new_dynarec.c:10840:35: warning: passing 'u_char *' (aka 'unsigned char *') to parameter of type 'char *' converts between pointers to integer types with different sign [-Wpointer-sign]
    __clear_cache((void *)beginning,out);
                                    ^~~
  ./src/device/r4300/new_dynarec/arm/assem_arm.h:46:46: note: passing argument to parameter 'end' here
  void __clear_cache_bugfix(char* begin, char *end);",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,547,2018-03-19T02:02:02Z,2018-03-28T03:36:07Z,2021-02-01T11:21:52Z,MERGED,True,5114,7060,42,https://github.com/bsmiles32,R4300 refactorings,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/547,https://github.com/fzurita,8,https://github.com/mupen64plus/mupen64plus-core/pull/547#issuecomment-375662101,"This is a first step toward R4300 sub-module cleaning.
Main changes from this PR are:

better decoupling of new_dynarec from old dynarec (for example, empty_dynarec is not needed anymore)
better decoupling of dynarec / cached_interpreter (except for precomp_{block,inst} structures, cached_interp doesn't depends on dynarec)
dynarec variables are now inside r4300.recomp, cached_interp inside r4300.cached_interp
introduction of table based instruction decoder which is key this decoupling and should allow better maintenance of instruction decoding logic. In further work, I could possibly expand it's usage in pure_interpreter, and possibly streamline some more register/constants decodings.
various cleanings

I've tested a bunch of games with no obvious regression (x64 dynarec, cached_interpreter), but I welcome other to test this, especially with new_dynarec and od 32 bit dynarec.","After I fix the two errors I get:
  [armeabi-v7a] SharedLibrary  : libmupen64plus-core.so
  ./src/device/r4300/new_dynarec/arm/linkage_arm.o(.text+0x19c): error: undefined reference to 'dynarec_gen_interrupt'",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,547,2018-03-19T02:02:02Z,2018-03-28T03:36:07Z,2021-02-01T11:21:52Z,MERGED,True,5114,7060,42,https://github.com/bsmiles32,R4300 refactorings,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/547,https://github.com/fzurita,9,https://github.com/mupen64plus/mupen64plus-core/pull/547#issuecomment-375663611,"This is a first step toward R4300 sub-module cleaning.
Main changes from this PR are:

better decoupling of new_dynarec from old dynarec (for example, empty_dynarec is not needed anymore)
better decoupling of dynarec / cached_interpreter (except for precomp_{block,inst} structures, cached_interp doesn't depends on dynarec)
dynarec variables are now inside r4300.recomp, cached_interp inside r4300.cached_interp
introduction of table based instruction decoder which is key this decoupling and should allow better maintenance of instruction decoding logic. In further work, I could possibly expand it's usage in pure_interpreter, and possibly streamline some more register/constants decodings.
various cleanings

I've tested a bunch of games with no obvious regression (x64 dynarec, cached_interpreter), but I welcome other to test this, especially with new_dynarec and od 32 bit dynarec.","I fixed the above error by adding this to assem_arm.c
void dynarec_gen_interrupt(void)
{
    gen_interrupt(&g_dev.r4300);
}

Now the new dynarec is crashing at startup.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,547,2018-03-19T02:02:02Z,2018-03-28T03:36:07Z,2021-02-01T11:21:52Z,MERGED,True,5114,7060,42,https://github.com/bsmiles32,R4300 refactorings,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/547,https://github.com/fzurita,10,https://github.com/mupen64plus/mupen64plus-core/pull/547#issuecomment-375664691,"This is a first step toward R4300 sub-module cleaning.
Main changes from this PR are:

better decoupling of new_dynarec from old dynarec (for example, empty_dynarec is not needed anymore)
better decoupling of dynarec / cached_interpreter (except for precomp_{block,inst} structures, cached_interp doesn't depends on dynarec)
dynarec variables are now inside r4300.recomp, cached_interp inside r4300.cached_interp
introduction of table based instruction decoder which is key this decoupling and should allow better maintenance of instruction decoding logic. In further work, I could possibly expand it's usage in pure_interpreter, and possibly streamline some more register/constants decodings.
various cleanings

I've tested a bunch of games with no obvious regression (x64 dynarec, cached_interpreter), but I welcome other to test this, especially with new_dynarec and od 32 bit dynarec.","Here is the crash:
********** Crash dump: **********
Build fingerprint: 'razer/cheryl/cheryl:7.1.1/NMF26X-RZR-180118/3005:user/release-keys'
pid: 11514, tid: 11543, name: ServiceStartArg  >>> paulscode.android.mupen64plusae.GameActivity <<<
signal 7 (SIGBUS), code 1 (BUS_ADRALN), fault addr 0xca6fc9f6
#00 pc 0001cda8 ./libmupen64plus-core.so: Routine savestates_load_m64p at ./src/main/savestates.c:539
#01 pc 000b4aec ./libmupen64plus-core.so: Routine .E1 at linkage_arm.S:?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,547,2018-03-19T02:02:02Z,2018-03-28T03:36:07Z,2021-02-01T11:21:52Z,MERGED,True,5114,7060,42,https://github.com/bsmiles32,R4300 refactorings,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/547,https://github.com/fzurita,11,https://github.com/mupen64plus/mupen64plus-core/pull/547#issuecomment-375666331,"This is a first step toward R4300 sub-module cleaning.
Main changes from this PR are:

better decoupling of new_dynarec from old dynarec (for example, empty_dynarec is not needed anymore)
better decoupling of dynarec / cached_interpreter (except for precomp_{block,inst} structures, cached_interp doesn't depends on dynarec)
dynarec variables are now inside r4300.recomp, cached_interp inside r4300.cached_interp
introduction of table based instruction decoder which is key this decoupling and should allow better maintenance of instruction decoding logic. In further work, I could possibly expand it's usage in pure_interpreter, and possibly streamline some more register/constants decodings.
various cleanings

I've tested a bunch of games with no obvious regression (x64 dynarec, cached_interpreter), but I welcome other to test this, especially with new_dynarec and od 32 bit dynarec.","It looks like you don't have this:
#545",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,547,2018-03-19T02:02:02Z,2018-03-28T03:36:07Z,2021-02-01T11:21:52Z,MERGED,True,5114,7060,42,https://github.com/bsmiles32,R4300 refactorings,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/547,https://github.com/fzurita,12,https://github.com/mupen64plus/mupen64plus-core/pull/547#issuecomment-375667130,"This is a first step toward R4300 sub-module cleaning.
Main changes from this PR are:

better decoupling of new_dynarec from old dynarec (for example, empty_dynarec is not needed anymore)
better decoupling of dynarec / cached_interpreter (except for precomp_{block,inst} structures, cached_interp doesn't depends on dynarec)
dynarec variables are now inside r4300.recomp, cached_interp inside r4300.cached_interp
introduction of table based instruction decoder which is key this decoupling and should allow better maintenance of instruction decoding logic. In further work, I could possibly expand it's usage in pure_interpreter, and possibly streamline some more register/constants decodings.
various cleanings

I've tested a bunch of games with no obvious regression (x64 dynarec, cached_interpreter), but I welcome other to test this, especially with new_dynarec and od 32 bit dynarec.","After fixing all that, it seems to run ok.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,547,2018-03-19T02:02:02Z,2018-03-28T03:36:07Z,2021-02-01T11:21:52Z,MERGED,True,5114,7060,42,https://github.com/bsmiles32,R4300 refactorings,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/547,https://github.com/fzurita,13,https://github.com/mupen64plus/mupen64plus-core/pull/547#issuecomment-375669114,"This is a first step toward R4300 sub-module cleaning.
Main changes from this PR are:

better decoupling of new_dynarec from old dynarec (for example, empty_dynarec is not needed anymore)
better decoupling of dynarec / cached_interpreter (except for precomp_{block,inst} structures, cached_interp doesn't depends on dynarec)
dynarec variables are now inside r4300.recomp, cached_interp inside r4300.cached_interp
introduction of table based instruction decoder which is key this decoupling and should allow better maintenance of instruction decoding logic. In further work, I could possibly expand it's usage in pure_interpreter, and possibly streamline some more register/constants decodings.
various cleanings

I've tested a bunch of games with no obvious regression (x64 dynarec, cached_interpreter), but I welcome other to test this, especially with new_dynarec and od 32 bit dynarec.","Performance seems identical in the new dynarec in ARM, maybe it's faster in interpreter only?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,547,2018-03-19T02:02:02Z,2018-03-28T03:36:07Z,2021-02-01T11:21:52Z,MERGED,True,5114,7060,42,https://github.com/bsmiles32,R4300 refactorings,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/547,https://github.com/bsmiles32,14,https://github.com/mupen64plus/mupen64plus-core/pull/547#issuecomment-375872466,"This is a first step toward R4300 sub-module cleaning.
Main changes from this PR are:

better decoupling of new_dynarec from old dynarec (for example, empty_dynarec is not needed anymore)
better decoupling of dynarec / cached_interpreter (except for precomp_{block,inst} structures, cached_interp doesn't depends on dynarec)
dynarec variables are now inside r4300.recomp, cached_interp inside r4300.cached_interp
introduction of table based instruction decoder which is key this decoupling and should allow better maintenance of instruction decoding logic. In further work, I could possibly expand it's usage in pure_interpreter, and possibly streamline some more register/constants decodings.
various cleanings

I've tested a bunch of games with no obvious regression (x64 dynarec, cached_interpreter), but I welcome other to test this, especially with new_dynarec and od 32 bit dynarec.",@fzurita Thanks for your tests. I pushed some fixes you reported. I don't know why you got the savestate regression though.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,547,2018-03-19T02:02:02Z,2018-03-28T03:36:07Z,2021-02-01T11:21:52Z,MERGED,True,5114,7060,42,https://github.com/bsmiles32,R4300 refactorings,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/547,https://github.com/fzurita,15,https://github.com/mupen64plus/mupen64plus-core/pull/547#issuecomment-375874041,"This is a first step toward R4300 sub-module cleaning.
Main changes from this PR are:

better decoupling of new_dynarec from old dynarec (for example, empty_dynarec is not needed anymore)
better decoupling of dynarec / cached_interpreter (except for precomp_{block,inst} structures, cached_interp doesn't depends on dynarec)
dynarec variables are now inside r4300.recomp, cached_interp inside r4300.cached_interp
introduction of table based instruction decoder which is key this decoupling and should allow better maintenance of instruction decoding logic. In further work, I could possibly expand it's usage in pure_interpreter, and possibly streamline some more register/constants decodings.
various cleanings

I've tested a bunch of games with no obvious regression (x64 dynarec, cached_interpreter), but I welcome other to test this, especially with new_dynarec and od 32 bit dynarec.","Well, I got the save state regression because it seems that you don't have #545 in your branch.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,547,2018-03-19T02:02:02Z,2018-03-28T03:36:07Z,2021-02-01T11:21:52Z,MERGED,True,5114,7060,42,https://github.com/bsmiles32,R4300 refactorings,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/547,https://github.com/bsmiles32,16,https://github.com/mupen64plus/mupen64plus-core/pull/547#issuecomment-375884936,"This is a first step toward R4300 sub-module cleaning.
Main changes from this PR are:

better decoupling of new_dynarec from old dynarec (for example, empty_dynarec is not needed anymore)
better decoupling of dynarec / cached_interpreter (except for precomp_{block,inst} structures, cached_interp doesn't depends on dynarec)
dynarec variables are now inside r4300.recomp, cached_interp inside r4300.cached_interp
introduction of table based instruction decoder which is key this decoupling and should allow better maintenance of instruction decoding logic. In further work, I could possibly expand it's usage in pure_interpreter, and possibly streamline some more register/constants decodings.
various cleanings

I've tested a bunch of games with no obvious regression (x64 dynarec, cached_interpreter), but I welcome other to test this, especially with new_dynarec and od 32 bit dynarec.","Indeed, was not up-to-date with upstream. I've rebased against latest master now.
@richard42 : I'll let you decide if you want it to be part of the incoming release or not. But looking at the feedback, it should be in mergeable state now.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,547,2018-03-19T02:02:02Z,2018-03-28T03:36:07Z,2021-02-01T11:21:52Z,MERGED,True,5114,7060,42,https://github.com/bsmiles32,R4300 refactorings,49,[],https://github.com/mupen64plus/mupen64plus-core/pull/547,https://github.com/fzurita,17,https://github.com/mupen64plus/mupen64plus-core/pull/547#issuecomment-375930827,"This is a first step toward R4300 sub-module cleaning.
Main changes from this PR are:

better decoupling of new_dynarec from old dynarec (for example, empty_dynarec is not needed anymore)
better decoupling of dynarec / cached_interpreter (except for precomp_{block,inst} structures, cached_interp doesn't depends on dynarec)
dynarec variables are now inside r4300.recomp, cached_interp inside r4300.cached_interp
introduction of table based instruction decoder which is key this decoupling and should allow better maintenance of instruction decoding logic. In further work, I could possibly expand it's usage in pure_interpreter, and possibly streamline some more register/constants decodings.
various cleanings

I've tested a bunch of games with no obvious regression (x64 dynarec, cached_interpreter), but I welcome other to test this, especially with new_dynarec and od 32 bit dynarec.",Could a branch be made for a release? That way the master branch doesn't miss a beat and the release branch can happen at any revision.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,548,2018-03-20T22:26:40Z,2018-03-28T05:35:20Z,2018-03-28T05:49:58Z,MERGED,True,36,0,2,https://github.com/steto-scope,Added missing Joy Mappings,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/548,https://github.com/steto-scope,1,https://github.com/mupen64plus/mupen64plus-core/pull/548,"Added the 4 missing Joystick counterparts of the Keyboard Mappings

Reset
Speed Down
Speed Up
Frame Advance","Added the 4 missing Joystick counterparts of the Keyboard Mappings

Reset
Speed Down
Speed Up
Frame Advance",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,548,2018-03-20T22:26:40Z,2018-03-28T05:35:20Z,2018-03-28T05:49:58Z,MERGED,True,36,0,2,https://github.com/steto-scope,Added missing Joy Mappings,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/548,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/548#issuecomment-375887574,"Added the 4 missing Joystick counterparts of the Keyboard Mappings

Reset
Speed Down
Speed Up
Frame Advance",Looks good to me. Thanks for your contribution !,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,548,2018-03-20T22:26:40Z,2018-03-28T05:35:20Z,2018-03-28T05:49:58Z,MERGED,True,36,0,2,https://github.com/steto-scope,Added missing Joy Mappings,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/548,https://github.com/paradadf,3,https://github.com/mupen64plus/mupen64plus-core/pull/548#issuecomment-376430666,"Added the 4 missing Joystick counterparts of the Keyboard Mappings

Reset
Speed Down
Speed Up
Frame Advance","Should this be updated accordingly?
https://github.com/mupen64plus/mupen64plus-core/blob/master/doc/emuwiki-api-doc/Mupen64Plus-Core-Parameters.mediawiki",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,548,2018-03-20T22:26:40Z,2018-03-28T05:35:20Z,2018-03-28T05:49:58Z,MERGED,True,36,0,2,https://github.com/steto-scope,Added missing Joy Mappings,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/548,https://github.com/richard42,4,https://github.com/mupen64plus/mupen64plus-core/pull/548#issuecomment-376747452,"Added the 4 missing Joystick counterparts of the Keyboard Mappings

Reset
Speed Down
Speed Up
Frame Advance","yes, it would be nice to update the table in the wiki documentation (in the doc/emuwiki-api-doc/ folder of this repository).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,549,2018-03-21T20:23:19Z,2018-03-28T03:18:27Z,2018-12-03T03:50:43Z,MERGED,True,26,12,2,https://github.com/loganmc10,Clear CLOCK_REG when requested,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/549,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/549,"I have seen some interest lately in emulating the DPC_CLOCK_REG register. See for example cxd4/rsp#14
This should be a harmless change, we currently don't clear the CLOCK_REG when the game writes DPC_CLR_CLOCK_CTR to DPC_STATUS_REG. Given that some RSP/GFX plugins might start incrementing this register, we should implement clearing it. I know of a few games that write DPC_CLR_CLOCK_CTR (Gauntlet Legends and Taz Express come to mind).
Also, DPC_STATUS_START_GCLK should be set on boot, I'm not aware of any game where this makes a difference though.
Renamed some of the status flags to match what is in rcp.h","I have seen some interest lately in emulating the DPC_CLOCK_REG register. See for example cxd4/rsp#14
This should be a harmless change, we currently don't clear the CLOCK_REG when the game writes DPC_CLR_CLOCK_CTR to DPC_STATUS_REG. Given that some RSP/GFX plugins might start incrementing this register, we should implement clearing it. I know of a few games that write DPC_CLR_CLOCK_CTR (Gauntlet Legends and Taz Express come to mind).
Also, DPC_STATUS_START_GCLK should be set on boot, I'm not aware of any game where this makes a difference though.
Renamed some of the status flags to match what is in rcp.h",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,549,2018-03-21T20:23:19Z,2018-03-28T03:18:27Z,2018-12-03T03:50:43Z,MERGED,True,26,12,2,https://github.com/loganmc10,Clear CLOCK_REG when requested,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/549,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/549#issuecomment-375083541,"I have seen some interest lately in emulating the DPC_CLOCK_REG register. See for example cxd4/rsp#14
This should be a harmless change, we currently don't clear the CLOCK_REG when the game writes DPC_CLR_CLOCK_CTR to DPC_STATUS_REG. Given that some RSP/GFX plugins might start incrementing this register, we should implement clearing it. I know of a few games that write DPC_CLR_CLOCK_CTR (Gauntlet Legends and Taz Express come to mind).
Also, DPC_STATUS_START_GCLK should be set on boot, I'm not aware of any game where this makes a difference though.
Renamed some of the status flags to match what is in rcp.h","Oh also I added DPC_STATUS_START_VALID and DPC_STATUS_END_VALID. Again, I'm not aware of any game that uses these bits, but they are supposed to be set to indicate that a valid entry was written to START_REG/END_REG",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,549,2018-03-21T20:23:19Z,2018-03-28T03:18:27Z,2018-12-03T03:50:43Z,MERGED,True,26,12,2,https://github.com/loganmc10,Clear CLOCK_REG when requested,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/549,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/549#issuecomment-375887181,"I have seen some interest lately in emulating the DPC_CLOCK_REG register. See for example cxd4/rsp#14
This should be a harmless change, we currently don't clear the CLOCK_REG when the game writes DPC_CLR_CLOCK_CTR to DPC_STATUS_REG. Given that some RSP/GFX plugins might start incrementing this register, we should implement clearing it. I know of a few games that write DPC_CLR_CLOCK_CTR (Gauntlet Legends and Taz Express come to mind).
Also, DPC_STATUS_START_GCLK should be set on boot, I'm not aware of any game where this makes a difference though.
Renamed some of the status flags to match what is in rcp.h",Tested a few games and didn't noticed any regression. Looks good to me.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,550,2018-03-23T18:23:14Z,2019-02-09T20:59:28Z,2020-04-27T19:40:29Z,MERGED,True,0,1,1,https://github.com/loganmc10,Don't call SDL_PumpEvents() in core,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/550,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/550,"SDL_PumpEvents is described as:
SDL_PumpEvents() gathers all the pending input information from devices and places it in the event queue

It is related to the input functions. In the past, mupen64plus-ae has used a slightly modified version of SDL2, but now I am trying to update it to use a vanilla version of 2.0.8, however it crashes when calling SDL_PumpEvents(). Presumably because there is no keyboard and SDL_INIT_JOYSTICK is never called. The input subsystem is not setup.
I moved SDL_PumpEvents to the beginning of the GetKeys() function in input-sdl. I tested using a keyboard and a joystick, both in-game inputs and events (like pause/quit game) still work with keyboard or joystick. See mupen64plus/mupen64plus-input-sdl#68","SDL_PumpEvents is described as:
SDL_PumpEvents() gathers all the pending input information from devices and places it in the event queue

It is related to the input functions. In the past, mupen64plus-ae has used a slightly modified version of SDL2, but now I am trying to update it to use a vanilla version of 2.0.8, however it crashes when calling SDL_PumpEvents(). Presumably because there is no keyboard and SDL_INIT_JOYSTICK is never called. The input subsystem is not setup.
I moved SDL_PumpEvents to the beginning of the GetKeys() function in input-sdl. I tested using a keyboard and a joystick, both in-game inputs and events (like pause/quit game) still work with keyboard or joystick. See mupen64plus/mupen64plus-input-sdl#68",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,550,2018-03-23T18:23:14Z,2019-02-09T20:59:28Z,2020-04-27T19:40:29Z,MERGED,True,0,1,1,https://github.com/loganmc10,Don't call SDL_PumpEvents() in core,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/550,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/550#issuecomment-375886617,"SDL_PumpEvents is described as:
SDL_PumpEvents() gathers all the pending input information from devices and places it in the event queue

It is related to the input functions. In the past, mupen64plus-ae has used a slightly modified version of SDL2, but now I am trying to update it to use a vanilla version of 2.0.8, however it crashes when calling SDL_PumpEvents(). Presumably because there is no keyboard and SDL_INIT_JOYSTICK is never called. The input subsystem is not setup.
I moved SDL_PumpEvents to the beginning of the GetKeys() function in input-sdl. I tested using a keyboard and a joystick, both in-game inputs and events (like pause/quit game) still work with keyboard or joystick. See mupen64plus/mupen64plus-input-sdl#68","Not an expert on this matter so don't hesitate to point if I'm wrong, but I'm not sure it is the best move to completely remove this from the core as the core itself relies on it for checking various button-presses for triggering pause,savestates,mute,.... There are also non-SDL input plugins (raphnet comes to mind) that would probably break the core with this scheme.
Maybe we could start thinking about moving input plugins inside the core so we can have a tighter integration/control over what's done.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,550,2018-03-23T18:23:14Z,2019-02-09T20:59:28Z,2020-04-27T19:40:29Z,MERGED,True,0,1,1,https://github.com/loganmc10,Don't call SDL_PumpEvents() in core,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/550,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/550#issuecomment-376180903,"SDL_PumpEvents is described as:
SDL_PumpEvents() gathers all the pending input information from devices and places it in the event queue

It is related to the input functions. In the past, mupen64plus-ae has used a slightly modified version of SDL2, but now I am trying to update it to use a vanilla version of 2.0.8, however it crashes when calling SDL_PumpEvents(). Presumably because there is no keyboard and SDL_INIT_JOYSTICK is never called. The input subsystem is not setup.
I moved SDL_PumpEvents to the beginning of the GetKeys() function in input-sdl. I tested using a keyboard and a joystick, both in-game inputs and events (like pause/quit game) still work with keyboard or joystick. See mupen64plus/mupen64plus-input-sdl#68","I'm not sure it is the best move to completely remove this from the core as the core itself relies on it for checking various button-presses for triggering pause,savestates,mute,.... There are also non-SDL input plugins (raphnet comes to mind) that would probably break the core with this scheme.

I tested this using Input-SDL and all the hotkeys like fast-forward, pause, save state, etc... still work. You make a good point about non-SDL input plugins like raphnet though. I just tested this with the raphnet plugin and all the hotkeys still work. I'll will admit I'm not 100% sure why they still work... but they do, so it doesn't seem like this change will break any of the existing input plugins",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,550,2018-03-23T18:23:14Z,2019-02-09T20:59:28Z,2020-04-27T19:40:29Z,MERGED,True,0,1,1,https://github.com/loganmc10,Don't call SDL_PumpEvents() in core,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/550,https://github.com/fzurita,4,https://github.com/mupen64plus/mupen64plus-core/pull/550#issuecomment-462075900,"SDL_PumpEvents is described as:
SDL_PumpEvents() gathers all the pending input information from devices and places it in the event queue

It is related to the input functions. In the past, mupen64plus-ae has used a slightly modified version of SDL2, but now I am trying to update it to use a vanilla version of 2.0.8, however it crashes when calling SDL_PumpEvents(). Presumably because there is no keyboard and SDL_INIT_JOYSTICK is never called. The input subsystem is not setup.
I moved SDL_PumpEvents to the beginning of the GetKeys() function in input-sdl. I tested using a keyboard and a joystick, both in-game inputs and events (like pause/quit game) still work with keyboard or joystick. See mupen64plus/mupen64plus-input-sdl#68",Could an alternative be to move this call into the input plugin and then it can be called with an API call? It would mean expanding the input plugin API.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,550,2018-03-23T18:23:14Z,2019-02-09T20:59:28Z,2020-04-27T19:40:29Z,MERGED,True,0,1,1,https://github.com/loganmc10,Don't call SDL_PumpEvents() in core,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/550,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/550#issuecomment-462076995,"SDL_PumpEvents is described as:
SDL_PumpEvents() gathers all the pending input information from devices and places it in the event queue

It is related to the input functions. In the past, mupen64plus-ae has used a slightly modified version of SDL2, but now I am trying to update it to use a vanilla version of 2.0.8, however it crashes when calling SDL_PumpEvents(). Presumably because there is no keyboard and SDL_INIT_JOYSTICK is never called. The input subsystem is not setup.
I moved SDL_PumpEvents to the beginning of the GetKeys() function in input-sdl. I tested using a keyboard and a joystick, both in-game inputs and events (like pause/quit game) still work with keyboard or joystick. See mupen64plus/mupen64plus-input-sdl#68","It's already called in the input plugin, this call is redundant as far as I could tell",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,550,2018-03-23T18:23:14Z,2019-02-09T20:59:28Z,2020-04-27T19:40:29Z,MERGED,True,0,1,1,https://github.com/loganmc10,Don't call SDL_PumpEvents() in core,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/550,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/550#issuecomment-462098823,"SDL_PumpEvents is described as:
SDL_PumpEvents() gathers all the pending input information from devices and places it in the event queue

It is related to the input functions. In the past, mupen64plus-ae has used a slightly modified version of SDL2, but now I am trying to update it to use a vanilla version of 2.0.8, however it crashes when calling SDL_PumpEvents(). Presumably because there is no keyboard and SDL_INIT_JOYSTICK is never called. The input subsystem is not setup.
I moved SDL_PumpEvents to the beginning of the GetKeys() function in input-sdl. I tested using a keyboard and a joystick, both in-game inputs and events (like pause/quit game) still work with keyboard or joystick. See mupen64plus/mupen64plus-input-sdl#68",@fzurita if I recall correctly this change should allow you to update the version of sdl2 used in AE to the latest upstream version without any real modifications,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,550,2018-03-23T18:23:14Z,2019-02-09T20:59:28Z,2020-04-27T19:40:29Z,MERGED,True,0,1,1,https://github.com/loganmc10,Don't call SDL_PumpEvents() in core,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/550,https://github.com/fzurita,7,https://github.com/mupen64plus/mupen64plus-core/pull/550#issuecomment-462098956,"SDL_PumpEvents is described as:
SDL_PumpEvents() gathers all the pending input information from devices and places it in the event queue

It is related to the input functions. In the past, mupen64plus-ae has used a slightly modified version of SDL2, but now I am trying to update it to use a vanilla version of 2.0.8, however it crashes when calling SDL_PumpEvents(). Presumably because there is no keyboard and SDL_INIT_JOYSTICK is never called. The input subsystem is not setup.
I moved SDL_PumpEvents to the beginning of the GetKeys() function in input-sdl. I tested using a keyboard and a joystick, both in-game inputs and events (like pause/quit game) still work with keyboard or joystick. See mupen64plus/mupen64plus-input-sdl#68","Yep, I remember, I'll get to that.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,550,2018-03-23T18:23:14Z,2019-02-09T20:59:28Z,2020-04-27T19:40:29Z,MERGED,True,0,1,1,https://github.com/loganmc10,Don't call SDL_PumpEvents() in core,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/550,https://github.com/Zapeth,8,https://github.com/mupen64plus/mupen64plus-core/pull/550#issuecomment-568274373,"SDL_PumpEvents is described as:
SDL_PumpEvents() gathers all the pending input information from devices and places it in the event queue

It is related to the input functions. In the past, mupen64plus-ae has used a slightly modified version of SDL2, but now I am trying to update it to use a vanilla version of 2.0.8, however it crashes when calling SDL_PumpEvents(). Presumably because there is no keyboard and SDL_INIT_JOYSTICK is never called. The input subsystem is not setup.
I moved SDL_PumpEvents to the beginning of the GetKeys() function in input-sdl. I tested using a keyboard and a joystick, both in-game inputs and events (like pause/quit game) still work with keyboard or joystick. See mupen64plus/mupen64plus-input-sdl#68","This change causes the emulator to become unresponsive for certain roms. More specifically those who don't process any controller input, like most of these test roms (process_controller_command() is never called in those cases).
Previously the SDL_PumpEvents() call would have ensured that events get processed at least on every VI interrupt.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,553,2018-03-29T15:52:07Z,2018-04-10T18:47:24Z,2018-04-10T18:47:47Z,MERGED,True,3,2,1,https://github.com/rogual,Fix write_memory_8,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/553,https://github.com/rogual,1,https://github.com/mupen64plus/mupen64plus-core/pull/553,"This was overflowing a u8, causing zeroes to be written most of
the time instead of the intended value.","This was overflowing a u8, causing zeroes to be written most of
the time instead of the intended value.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,553,2018-03-29T15:52:07Z,2018-04-10T18:47:24Z,2018-04-10T18:47:47Z,MERGED,True,3,2,1,https://github.com/rogual,Fix write_memory_8,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/553,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/553#issuecomment-380207660,"This was overflowing a u8, causing zeroes to be written most of
the time instead of the intended value.",Thanks for your contribution !,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,556,2018-04-02T19:40:43Z,2018-05-08T04:45:29Z,2018-12-03T03:50:41Z,MERGED,True,45,7,7,https://github.com/loganmc10,Add VidExt_GL_GetDefaultFramebuffer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/556,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/556,"On some platforms (for instance, iOS) the default framebuffer object depends on the surface being rendered to, and might be different from 0.
This is also true for Qt. If the rendering surface is a QOpenGLWidget, the application must call GLuint QOpenGLContext::defaultFramebufferObject() to get the name of the default FBO. See (http://doc.qt.io/qt-5/qopenglcontext.html#defaultFramebufferObject). If it is a QOpenGLWindow, then the default FBO is ""0"".
GTK is the same, it doesn't allow rendering into the ""0"" framebuffer, the application must render into a framebuffer created by GTK. RetroArch does the same thing.
This was recently identified as an issue for the Provenance project (https://github.com/Provenance-Emu/Provenance) which is an iOS app that includes mupen64plus.
@braindx @JoeMatt can you please review this and comment whether this will meet the requirements for your project?","On some platforms (for instance, iOS) the default framebuffer object depends on the surface being rendered to, and might be different from 0.
This is also true for Qt. If the rendering surface is a QOpenGLWidget, the application must call GLuint QOpenGLContext::defaultFramebufferObject() to get the name of the default FBO. See (http://doc.qt.io/qt-5/qopenglcontext.html#defaultFramebufferObject). If it is a QOpenGLWindow, then the default FBO is ""0"".
GTK is the same, it doesn't allow rendering into the ""0"" framebuffer, the application must render into a framebuffer created by GTK. RetroArch does the same thing.
This was recently identified as an issue for the Provenance project (https://github.com/Provenance-Emu/Provenance) which is an iOS app that includes mupen64plus.
@braindx @JoeMatt can you please review this and comment whether this will meet the requirements for your project?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,556,2018-04-02T19:40:43Z,2018-05-08T04:45:29Z,2018-12-03T03:50:41Z,MERGED,True,45,7,7,https://github.com/loganmc10,Add VidExt_GL_GetDefaultFramebuffer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/556,https://github.com/braindx,2,https://github.com/mupen64plus/mupen64plus-core/pull/556#issuecomment-378025391,"On some platforms (for instance, iOS) the default framebuffer object depends on the surface being rendered to, and might be different from 0.
This is also true for Qt. If the rendering surface is a QOpenGLWidget, the application must call GLuint QOpenGLContext::defaultFramebufferObject() to get the name of the default FBO. See (http://doc.qt.io/qt-5/qopenglcontext.html#defaultFramebufferObject). If it is a QOpenGLWindow, then the default FBO is ""0"".
GTK is the same, it doesn't allow rendering into the ""0"" framebuffer, the application must render into a framebuffer created by GTK. RetroArch does the same thing.
This was recently identified as an issue for the Provenance project (https://github.com/Provenance-Emu/Provenance) which is an iOS app that includes mupen64plus.
@braindx @JoeMatt can you please review this and comment whether this will meet the requirements for your project?","Yes, this would work for us. Alternatively, video plugins could just call glGet* using GL_FRAMEBUFFER_BINDING to cache the default framebuffer before the first time they change it. I'm unsure as to whether any platforms have a need to change this during runtime.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,556,2018-04-02T19:40:43Z,2018-05-08T04:45:29Z,2018-12-03T03:50:41Z,MERGED,True,45,7,7,https://github.com/loganmc10,Add VidExt_GL_GetDefaultFramebuffer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/556,https://github.com/JoeMatt,3,https://github.com/mupen64plus/mupen64plus-core/pull/556#issuecomment-378025917,"On some platforms (for instance, iOS) the default framebuffer object depends on the surface being rendered to, and might be different from 0.
This is also true for Qt. If the rendering surface is a QOpenGLWidget, the application must call GLuint QOpenGLContext::defaultFramebufferObject() to get the name of the default FBO. See (http://doc.qt.io/qt-5/qopenglcontext.html#defaultFramebufferObject). If it is a QOpenGLWindow, then the default FBO is ""0"".
GTK is the same, it doesn't allow rendering into the ""0"" framebuffer, the application must render into a framebuffer created by GTK. RetroArch does the same thing.
This was recently identified as an issue for the Provenance project (https://github.com/Provenance-Emu/Provenance) which is an iOS app that includes mupen64plus.
@braindx @JoeMatt can you please review this and comment whether this will meet the requirements for your project?",I'll need to update our project to pull mupen64plus-core as a submodule since we're pretty out of date too. I'll work on that next so we can actually use / test this change.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,556,2018-04-02T19:40:43Z,2018-05-08T04:45:29Z,2018-12-03T03:50:41Z,MERGED,True,45,7,7,https://github.com/loganmc10,Add VidExt_GL_GetDefaultFramebuffer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/556,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/556#issuecomment-378026287,"On some platforms (for instance, iOS) the default framebuffer object depends on the surface being rendered to, and might be different from 0.
This is also true for Qt. If the rendering surface is a QOpenGLWidget, the application must call GLuint QOpenGLContext::defaultFramebufferObject() to get the name of the default FBO. See (http://doc.qt.io/qt-5/qopenglcontext.html#defaultFramebufferObject). If it is a QOpenGLWindow, then the default FBO is ""0"".
GTK is the same, it doesn't allow rendering into the ""0"" framebuffer, the application must render into a framebuffer created by GTK. RetroArch does the same thing.
This was recently identified as an issue for the Provenance project (https://github.com/Provenance-Emu/Provenance) which is an iOS app that includes mupen64plus.
@braindx @JoeMatt can you please review this and comment whether this will meet the requirements for your project?","@braindx Yes, but that is still assuming that the video subsystem is binding the default framebuffer for you when it creates the GL context. That isn't necessarily the case. They could just leave the binding at ""0"" and expect you to call QOpenGLContext::defaultFramebufferObject() (for instance) to get the correct framebuffer to bind. So I think this is the safer approach.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,556,2018-04-02T19:40:43Z,2018-05-08T04:45:29Z,2018-12-03T03:50:41Z,MERGED,True,45,7,7,https://github.com/loganmc10,Add VidExt_GL_GetDefaultFramebuffer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/556,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/556#issuecomment-378026709,"On some platforms (for instance, iOS) the default framebuffer object depends on the surface being rendered to, and might be different from 0.
This is also true for Qt. If the rendering surface is a QOpenGLWidget, the application must call GLuint QOpenGLContext::defaultFramebufferObject() to get the name of the default FBO. See (http://doc.qt.io/qt-5/qopenglcontext.html#defaultFramebufferObject). If it is a QOpenGLWindow, then the default FBO is ""0"".
GTK is the same, it doesn't allow rendering into the ""0"" framebuffer, the application must render into a framebuffer created by GTK. RetroArch does the same thing.
This was recently identified as an issue for the Provenance project (https://github.com/Provenance-Emu/Provenance) which is an iOS app that includes mupen64plus.
@braindx @JoeMatt can you please review this and comment whether this will meet the requirements for your project?","Although it would be pretty crazy for them to leave it at ""0"", I doubt Qt does this, I'm just saying it's not technically ""illegal"" for them to do, so we should probably deal with it in the API",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,556,2018-04-02T19:40:43Z,2018-05-08T04:45:29Z,2018-12-03T03:50:41Z,MERGED,True,45,7,7,https://github.com/loganmc10,Add VidExt_GL_GetDefaultFramebuffer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/556,https://github.com/JoeMatt,6,https://github.com/mupen64plus/mupen64plus-core/pull/556#issuecomment-378124064,"On some platforms (for instance, iOS) the default framebuffer object depends on the surface being rendered to, and might be different from 0.
This is also true for Qt. If the rendering surface is a QOpenGLWidget, the application must call GLuint QOpenGLContext::defaultFramebufferObject() to get the name of the default FBO. See (http://doc.qt.io/qt-5/qopenglcontext.html#defaultFramebufferObject). If it is a QOpenGLWindow, then the default FBO is ""0"".
GTK is the same, it doesn't allow rendering into the ""0"" framebuffer, the application must render into a framebuffer created by GTK. RetroArch does the same thing.
This was recently identified as an issue for the Provenance project (https://github.com/Provenance-Emu/Provenance) which is an iOS app that includes mupen64plus.
@braindx @JoeMatt can you please review this and comment whether this will meet the requirements for your project?","OK, so I have our app updated to using submodule of mupen64plus-core so we're ready to pull this PR at any time.
Only issue we have is we need to overwrite new_vi(void) because it completely slows down our rendering pipeline. I tried just using a callback for M64CMD_SET_FRAME_CALLBACK to do our gl context mutex unlocking, but I get horrible FPS that way. We basically just do,
void new_vi(void)
{
    GET_CURRENT_OR_RETURN();
    
	struct r4300_core* r4300 = &g_dev.r4300;

	if (g_gs_vi_counter < 60)
	{
		if (g_gs_vi_counter == 0)
			cheat_apply_cheats(&g_cheat_ctx, r4300, ENTRY_BOOT);
		g_gs_vi_counter++;
	}
	else
	{
		cheat_apply_cheats(&g_cheat_ctx, r4300, ENTRY_VI);
	}

    [current videoInterrupt]; // Mutex  unlocking happens here
}

I think the     apply_speed_limiter(); call in the default version messes with our mutex rendering, @braindx can comment on why that's required since he wrote it and I don't do GL.
I had to use a fork to use a submodule with one change to comment out that function to replace with our own. Maybe that's something we can also extern out so I don't need a custom fork.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,556,2018-04-02T19:40:43Z,2018-05-08T04:45:29Z,2018-12-03T03:50:41Z,MERGED,True,45,7,7,https://github.com/loganmc10,Add VidExt_GL_GetDefaultFramebuffer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/556,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/556#issuecomment-378125778,"On some platforms (for instance, iOS) the default framebuffer object depends on the surface being rendered to, and might be different from 0.
This is also true for Qt. If the rendering surface is a QOpenGLWidget, the application must call GLuint QOpenGLContext::defaultFramebufferObject() to get the name of the default FBO. See (http://doc.qt.io/qt-5/qopenglcontext.html#defaultFramebufferObject). If it is a QOpenGLWindow, then the default FBO is ""0"".
GTK is the same, it doesn't allow rendering into the ""0"" framebuffer, the application must render into a framebuffer created by GTK. RetroArch does the same thing.
This was recently identified as an issue for the Provenance project (https://github.com/Provenance-Emu/Provenance) which is an iOS app that includes mupen64plus.
@braindx @JoeMatt can you please review this and comment whether this will meet the requirements for your project?",I'm not familiar with what mutex rendering is but perhaps you can open a different issue for that? In my experience getting API changes merged can take time so we should work through this issue if we can,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,556,2018-04-02T19:40:43Z,2018-05-08T04:45:29Z,2018-12-03T03:50:41Z,MERGED,True,45,7,7,https://github.com/loganmc10,Add VidExt_GL_GetDefaultFramebuffer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/556,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/556#issuecomment-378126645,"On some platforms (for instance, iOS) the default framebuffer object depends on the surface being rendered to, and might be different from 0.
This is also true for Qt. If the rendering surface is a QOpenGLWidget, the application must call GLuint QOpenGLContext::defaultFramebufferObject() to get the name of the default FBO. See (http://doc.qt.io/qt-5/qopenglcontext.html#defaultFramebufferObject). If it is a QOpenGLWindow, then the default FBO is ""0"".
GTK is the same, it doesn't allow rendering into the ""0"" framebuffer, the application must render into a framebuffer created by GTK. RetroArch does the same thing.
This was recently identified as an issue for the Provenance project (https://github.com/Provenance-Emu/Provenance) which is an iOS app that includes mupen64plus.
@braindx @JoeMatt can you please review this and comment whether this will meet the requirements for your project?","On that note though, if you already have some speed limiting mechanism, you can disable the built-in speed limiter by calling CoreDoCommand(M64CMD_CORE_STATE_SET, M64CORE_SPEED_LIMITER, 0); before the ROM starts",True,{'THUMBS_UP': ['https://github.com/JoeMatt']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,556,2018-04-02T19:40:43Z,2018-05-08T04:45:29Z,2018-12-03T03:50:41Z,MERGED,True,45,7,7,https://github.com/loganmc10,Add VidExt_GL_GetDefaultFramebuffer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/556,https://github.com/loganmc10,9,https://github.com/mupen64plus/mupen64plus-core/pull/556#issuecomment-381180198,"On some platforms (for instance, iOS) the default framebuffer object depends on the surface being rendered to, and might be different from 0.
This is also true for Qt. If the rendering surface is a QOpenGLWidget, the application must call GLuint QOpenGLContext::defaultFramebufferObject() to get the name of the default FBO. See (http://doc.qt.io/qt-5/qopenglcontext.html#defaultFramebufferObject). If it is a QOpenGLWindow, then the default FBO is ""0"".
GTK is the same, it doesn't allow rendering into the ""0"" framebuffer, the application must render into a framebuffer created by GTK. RetroArch does the same thing.
This was recently identified as an issue for the Provenance project (https://github.com/Provenance-Emu/Provenance) which is an iOS app that includes mupen64plus.
@braindx @JoeMatt can you please review this and comment whether this will meet the requirements for your project?",@richard42 @bsmiles32 any comment on this?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,556,2018-04-02T19:40:43Z,2018-05-08T04:45:29Z,2018-12-03T03:50:41Z,MERGED,True,45,7,7,https://github.com/loganmc10,Add VidExt_GL_GetDefaultFramebuffer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/556,https://github.com/bsmiles32,10,https://github.com/mupen64plus/mupen64plus-core/pull/556#issuecomment-381744781,"On some platforms (for instance, iOS) the default framebuffer object depends on the surface being rendered to, and might be different from 0.
This is also true for Qt. If the rendering surface is a QOpenGLWidget, the application must call GLuint QOpenGLContext::defaultFramebufferObject() to get the name of the default FBO. See (http://doc.qt.io/qt-5/qopenglcontext.html#defaultFramebufferObject). If it is a QOpenGLWindow, then the default FBO is ""0"".
GTK is the same, it doesn't allow rendering into the ""0"" framebuffer, the application must render into a framebuffer created by GTK. RetroArch does the same thing.
This was recently identified as an issue for the Provenance project (https://github.com/Provenance-Emu/Provenance) which is an iOS app that includes mupen64plus.
@braindx @JoeMatt can you please review this and comment whether this will meet the requirements for your project?","@loganmc10 Sorry for late reply. Looks good to me.
Maybe for consistency I would have returned a m64p_error from the API
m64p_error VidExt_GL_GetDefaultFramebuffer(uint32_t* fbo)

But if no meaningfull error code can be returned, then I'm fine with how you went.
@richard42 Hope you can have look at it also. It is needed for several frontends to correctly function.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,556,2018-04-02T19:40:43Z,2018-05-08T04:45:29Z,2018-12-03T03:50:41Z,MERGED,True,45,7,7,https://github.com/loganmc10,Add VidExt_GL_GetDefaultFramebuffer,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/556,https://github.com/loganmc10,11,https://github.com/mupen64plus/mupen64plus-core/pull/556#issuecomment-387283586,"On some platforms (for instance, iOS) the default framebuffer object depends on the surface being rendered to, and might be different from 0.
This is also true for Qt. If the rendering surface is a QOpenGLWidget, the application must call GLuint QOpenGLContext::defaultFramebufferObject() to get the name of the default FBO. See (http://doc.qt.io/qt-5/qopenglcontext.html#defaultFramebufferObject). If it is a QOpenGLWindow, then the default FBO is ""0"".
GTK is the same, it doesn't allow rendering into the ""0"" framebuffer, the application must render into a framebuffer created by GTK. RetroArch does the same thing.
This was recently identified as an issue for the Provenance project (https://github.com/Provenance-Emu/Provenance) which is an iOS app that includes mupen64plus.
@braindx @JoeMatt can you please review this and comment whether this will meet the requirements for your project?","Just a reminder to front-end developers like @fzurita , now that this has been merged, the front-end VidExt API portion needs to be updated to include this new function, or else the core will reject the VidExt implementation from the front-end",True,"{'THUMBS_UP': ['https://github.com/fzurita', 'https://github.com/JoeMatt']}"
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,557,2018-04-03T21:14:45Z,2018-05-08T04:51:15Z,2018-05-08T04:51:15Z,MERGED,True,1,1,1,https://github.com/JoeMatt,Increase DebugMessage buffer size to prevent overflows,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/557,https://github.com/JoeMatt,1,https://github.com/mupen64plus/mupen64plus-core/pull/557,"When running on iOS simulator, some paths are really long. This was causing mupen64plus core to crash DebugMessage with a buffer overflow when printing out statements related to paths.","When running on iOS simulator, some paths are really long. This was causing mupen64plus core to crash DebugMessage with a buffer overflow when printing out statements related to paths.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,557,2018-04-03T21:14:45Z,2018-05-08T04:51:15Z,2018-05-08T04:51:15Z,MERGED,True,1,1,1,https://github.com/JoeMatt,Increase DebugMessage buffer size to prevent overflows,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/557,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/557#issuecomment-378402219,"When running on iOS simulator, some paths are really long. This was causing mupen64plus core to crash DebugMessage with a buffer overflow when printing out statements related to paths.",Doesn't vsnprintf exist? We should probably use that as well to ensure there aren't any buffer overflows,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,561,2018-04-18T21:38:47Z,2018-05-08T05:15:04Z,2018-12-03T03:50:33Z,MERGED,True,328,177,2,https://github.com/loganmc10,Update xxHash to 0.6.5,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/561,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/561,https://github.com/Cyan4973/xxHash/releases/tag/v0.6.5,https://github.com/Cyan4973/xxHash/releases/tag/v0.6.5,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,561,2018-04-18T21:38:47Z,2018-05-08T05:15:04Z,2018-12-03T03:50:33Z,MERGED,True,328,177,2,https://github.com/loganmc10,Update xxHash to 0.6.5,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/561,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/561#issuecomment-382544788,https://github.com/Cyan4973/xxHash/releases/tag/v0.6.5,"Did you see any performance improvement from the update to improve performance on ""small"" hashes?
Also, should you define XXH_INLINE_ALL in the CMake file?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,561,2018-04-18T21:38:47Z,2018-05-08T05:15:04Z,2018-12-03T03:50:33Z,MERGED,True,328,177,2,https://github.com/loganmc10,Update xxHash to 0.6.5,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/561,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/561#issuecomment-382545736,https://github.com/Cyan4973/xxHash/releases/tag/v0.6.5,"I didn't actually do any testing for this update, I think they do more/better testing than I'd be capable of so I tend to just take their word for it.
I don't know if XXH_INLINE_ALL would add any benefit to us, I guess we'd have to test, you would remove xxhash.c from the source list in that case and just define XXH_INLINE_ALL if I understand correctly",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,564,2018-05-11T23:36:51Z,2018-05-22T05:05:13Z,2021-02-01T11:22:06Z,MERGED,True,815,58,16,https://github.com/bsmiles32,GB Camera support,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/564,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/564,"Following discussion with @LuigiBlood in PR #446, this PR adds GB camera support.
See commit message for more information.
NOTE: I haven't updated the msvc files yet, I'd like to get some feedback first.
@AntonioND: big thanks for sharing your RE work on the GB camera !","Following discussion with @LuigiBlood in PR #446, this PR adds GB camera support.
See commit message for more information.
NOTE: I haven't updated the msvc files yet, I'd like to get some feedback first.
@AntonioND: big thanks for sharing your RE work on the GB camera !",True,{'HOORAY': ['https://github.com/AntonioND']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,564,2018-05-11T23:36:51Z,2018-05-22T05:05:13Z,2021-02-01T11:22:06Z,MERGED,True,815,58,16,https://github.com/bsmiles32,GB Camera support,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/564,https://github.com/LuigiBlood,2,https://github.com/mupen64plus/mupen64plus-core/pull/564#issuecomment-388511144,"Following discussion with @LuigiBlood in PR #446, this PR adds GB camera support.
See commit message for more information.
NOTE: I haven't updated the msvc files yet, I'd like to get some feedback first.
@AntonioND: big thanks for sharing your RE work on the GB camera !","Oh wait you really went that far to support a camera as well. I didn't even do that.
You've used the same base as I did too :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,564,2018-05-11T23:36:51Z,2018-05-22T05:05:13Z,2021-02-01T11:22:06Z,MERGED,True,815,58,16,https://github.com/bsmiles32,GB Camera support,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/564,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/564#issuecomment-388511791,"Following discussion with @LuigiBlood in PR #446, this PR adds GB camera support.
See commit message for more information.
NOTE: I haven't updated the msvc files yet, I'd like to get some feedback first.
@AntonioND: big thanks for sharing your RE work on the GB camera !","Yep, full GB camera support (as far as documented by @AntonioND) with live capture.
I know the quality of the GB camera is not great, but I see that as a first step... I have greater ambitions for the video input backend :) If you have some info on the A/V capture cart we could look into that as well",True,{'THUMBS_UP': ['https://github.com/AntonioND']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,564,2018-05-11T23:36:51Z,2018-05-22T05:05:13Z,2021-02-01T11:22:06Z,MERGED,True,815,58,16,https://github.com/bsmiles32,GB Camera support,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/564,https://github.com/LuigiBlood,4,https://github.com/mupen64plus/mupen64plus-core/pull/564#issuecomment-388512572,"Following discussion with @LuigiBlood in PR #446, this PR adds GB camera support.
See commit message for more information.
NOTE: I haven't updated the msvc files yet, I'd like to get some feedback first.
@AntonioND: big thanks for sharing your RE work on the GB camera !","This is as far as I got about the Capture Cartridge:
https://github.com/LuigiBlood/64dd/wiki/Capture-Cartridge
I don't understand the video portion a single bit. It's very confusing and each game handles it slightly differently.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,564,2018-05-11T23:36:51Z,2018-05-22T05:05:13Z,2021-02-01T11:22:06Z,MERGED,True,815,58,16,https://github.com/bsmiles32,GB Camera support,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/564,https://github.com/bsmiles32,5,https://github.com/mupen64plus/mupen64plus-core/pull/564#issuecomment-388512753,"Following discussion with @LuigiBlood in PR #446, this PR adds GB camera support.
See commit message for more information.
NOTE: I haven't updated the msvc files yet, I'd like to get some feedback first.
@AntonioND: big thanks for sharing your RE work on the GB camera !",Updated travis-ci file.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,564,2018-05-11T23:36:51Z,2018-05-22T05:05:13Z,2021-02-01T11:22:06Z,MERGED,True,815,58,16,https://github.com/bsmiles32,GB Camera support,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/564,https://github.com/bsmiles32,6,https://github.com/mupen64plus/mupen64plus-core/pull/564#issuecomment-388513625,"Following discussion with @LuigiBlood in PR #446, this PR adds GB camera support.
See commit message for more information.
NOTE: I haven't updated the msvc files yet, I'd like to get some feedback first.
@AntonioND: big thanks for sharing your RE work on the GB camera !","@LuigiBlood Thanks for the link, will look into it",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,564,2018-05-11T23:36:51Z,2018-05-22T05:05:13Z,2021-02-01T11:22:06Z,MERGED,True,815,58,16,https://github.com/bsmiles32,GB Camera support,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/564,https://github.com/AntonioND,7,https://github.com/mupen64plus/mupen64plus-core/pull/564#issuecomment-388546297,"Following discussion with @LuigiBlood in PR #446, this PR adds GB camera support.
See commit message for more information.
NOTE: I haven't updated the msvc files yet, I'd like to get some feedback first.
@AntonioND: big thanks for sharing your RE work on the GB camera !","Thanks for telling me, @bsmiles32! It's nice to see that other people find that documentation useful. :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,564,2018-05-11T23:36:51Z,2018-05-22T05:05:13Z,2021-02-01T11:22:06Z,MERGED,True,815,58,16,https://github.com/bsmiles32,GB Camera support,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/564,https://github.com/bsmiles32,8,https://github.com/mupen64plus/mupen64plus-core/pull/564#issuecomment-388955551,"Following discussion with @LuigiBlood in PR #446, this PR adds GB camera support.
See commit message for more information.
NOTE: I haven't updated the msvc files yet, I'd like to get some feedback first.
@AntonioND: big thanks for sharing your RE work on the GB camera !","Added vs2013 support (require mupen64plus/mupen64plus-win32-deps#6)
Support older OpenCV version from ubuntu used in travis

@Jj0YzL5nvJ Obsolete URL fixed. Thanks.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,564,2018-05-11T23:36:51Z,2018-05-22T05:05:13Z,2021-02-01T11:22:06Z,MERGED,True,815,58,16,https://github.com/bsmiles32,GB Camera support,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/564,https://github.com/bsmiles32,9,https://github.com/mupen64plus/mupen64plus-core/pull/564#issuecomment-389039025,"Following discussion with @LuigiBlood in PR #446, this PR adds GB camera support.
See commit message for more information.
NOTE: I haven't updated the msvc files yet, I'd like to get some feedback first.
@AntonioND: big thanks for sharing your RE work on the GB camera !","Few things to consider before considering merging this :

I've put the opencv specific configuration parameter in the Core section, but since it's backend specific it may be better to put it in a opencv video backend specific section
OpenCV is quite a big dependency that I don't want to force upon our users, maybe we should allow to make it optional at compile time (or completely disable camera support). Better, we should be able to enable available backends at compile-time, and for enabled backends be able to select which one to use at run-time. This not just for the video input backends, but for all backends when multiple implementation are available.
Only 1 camera can be used for all emulated gb cameras (up to 4 because one per game controller).
I went with OpenCV because it was easy to implement in a cross plateform way video capture, but if you happen to know a simpler cross-plateform video capture library I'm all ears :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,564,2018-05-11T23:36:51Z,2018-05-22T05:05:13Z,2021-02-01T11:22:06Z,MERGED,True,815,58,16,https://github.com/bsmiles32,GB Camera support,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/564,https://github.com/richard42,10,https://github.com/mupen64plus/mupen64plus-core/pull/564#issuecomment-389041750,"Following discussion with @LuigiBlood in PR #446, this PR adds GB camera support.
See commit message for more information.
NOTE: I haven't updated the msvc files yet, I'd like to get some feedback first.
@AntonioND: big thanks for sharing your RE work on the GB camera !","I don't like having such a big dependency for something that most of our users will never use, so a compile-time make flag is probably necessary. You're using this for cross-platform capability of video capture with whatever cameras happen to be attached to the computer?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,564,2018-05-11T23:36:51Z,2018-05-22T05:05:13Z,2021-02-01T11:22:06Z,MERGED,True,815,58,16,https://github.com/bsmiles32,GB Camera support,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/564,https://github.com/bsmiles32,11,https://github.com/mupen64plus/mupen64plus-core/pull/564#issuecomment-389074428,"Following discussion with @LuigiBlood in PR #446, this PR adds GB camera support.
See commit message for more information.
NOTE: I haven't updated the msvc files yet, I'd like to get some feedback first.
@AntonioND: big thanks for sharing your RE work on the GB camera !","I don't like having such a big dependency for something that most of our users will never use, so a compile-time make flag is probably necessary.

Agreed.

You're using this for cross-platform capability of video capture with whatever cameras happen to be attached to the computer?

Yes. Note that the OpenCV capture API allow to use webcams but also video/image files transparently (not tested but advertised on their documentation). Internally it wraps different backends depending on the plateform it is run.
Beside the capture stuff I also use some functions to resize the captured image to the desired resolution (and to display images for debug purpose, but that's disabled by default). But I don't use any ""image processing"" OpenCV stuff.
The ideal solution would be to work with SDL upstream to have them integrate a cross-plateform video capture API, so we can benefit from that without all the OpenCV burden. But way too much work for a rarely used feature... Or find a much lighter library, or do an optimized windows build with only video capture and image resizing enabled so we don't bring the full opencv burden.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,564,2018-05-11T23:36:51Z,2018-05-22T05:05:13Z,2021-02-01T11:22:06Z,MERGED,True,815,58,16,https://github.com/bsmiles32,GB Camera support,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/564,https://github.com/bsmiles32,12,https://github.com/mupen64plus/mupen64plus-core/pull/564#issuecomment-389336739,"Following discussion with @LuigiBlood in PR #446, this PR adds GB camera support.
See commit message for more information.
NOTE: I haven't updated the msvc files yet, I'd like to get some feedback first.
@AntonioND: big thanks for sharing your RE work on the GB camera !","Updated with compile-time make flag (OPENCV=1 with Makefile). Not done for VS2013 because editing by hand msvc files is really asking for troubles, so some other Window dev will have to port this compile-time {en,dis}ablement. [For now, OpenCV is required when using VisualStudio].
Fixed a bug with savestates (forgot to rename {M64282FP -> POCKET_CAM}_REGS_COUNT value).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,564,2018-05-11T23:36:51Z,2018-05-22T05:05:13Z,2021-02-01T11:22:06Z,MERGED,True,815,58,16,https://github.com/bsmiles32,GB Camera support,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/564,https://github.com/bsmiles32,13,https://github.com/mupen64plus/mupen64plus-core/pull/564#issuecomment-390779045,"Following discussion with @LuigiBlood in PR #446, this PR adds GB camera support.
See commit message for more information.
NOTE: I haven't updated the msvc files yet, I'd like to get some feedback first.
@AntonioND: big thanks for sharing your RE work on the GB camera !","@richard42 Yep, silly mistake on my part. Updated with Makefile line re-added.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,564,2018-05-11T23:36:51Z,2018-05-22T05:05:13Z,2021-02-01T11:22:06Z,MERGED,True,815,58,16,https://github.com/bsmiles32,GB Camera support,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/564,https://github.com/bsmiles32,14,https://github.com/mupen64plus/mupen64plus-core/pull/564#issuecomment-390788389,"Following discussion with @LuigiBlood in PR #446, this PR adds GB camera support.
See commit message for more information.
NOTE: I haven't updated the msvc files yet, I'd like to get some feedback first.
@AntonioND: big thanks for sharing your RE work on the GB camera !",Disabling opencv stuff in MSVC so that Appveyor has a chance to build it.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,565,2018-05-14T20:53:30Z,2018-05-14T21:10:05Z,2021-02-01T11:21:57Z,MERGED,True,2,2,2,https://github.com/bsmiles32,Fix homepage link in dd_controller files.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/565,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/565,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,566,2018-05-16T23:23:52Z,2018-05-20T01:25:24Z,2021-02-01T11:23:20Z,MERGED,True,167,4,12,https://github.com/bsmiles32,Initial bio pak support.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/566,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/566,"For now, the bio pak only report hard-coded BPM value (but is impacted by fast-forwarding).
In future work remote heart rate monitoring methods (rPPG) could be
implemented to provide an experience similar to the Bio Sensor pak using
a regular webcam. However it could be quite CPU intensive and may prove
challenging in multi-player context.
Another idea to create an ""equivalent"" Bio Sensor experience without the
original device, could be to derive the reported heart rate from the
BPM (or any relevant quantity) from a user specified audio clip.","For now, the bio pak only report hard-coded BPM value (but is impacted by fast-forwarding).
In future work remote heart rate monitoring methods (rPPG) could be
implemented to provide an experience similar to the Bio Sensor pak using
a regular webcam. However it could be quite CPU intensive and may prove
challenging in multi-player context.
Another idea to create an ""equivalent"" Bio Sensor experience without the
original device, could be to derive the reported heart rate from the
BPM (or any relevant quantity) from a user specified audio clip.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,566,2018-05-16T23:23:52Z,2018-05-20T01:25:24Z,2021-02-01T11:23:20Z,MERGED,True,167,4,12,https://github.com/bsmiles32,Initial bio pak support.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/566,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/566#issuecomment-389940905,"For now, the bio pak only report hard-coded BPM value (but is impacted by fast-forwarding).
In future work remote heart rate monitoring methods (rPPG) could be
implemented to provide an experience similar to the Bio Sensor pak using
a regular webcam. However it could be quite CPU intensive and may prove
challenging in multi-player context.
Another idea to create an ""equivalent"" Bio Sensor experience without the
original device, could be to derive the reported heart rate from the
BPM (or any relevant quantity) from a user specified audio clip.",Fixed outdated homepage link.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,569,2018-05-30T00:39:25Z,2018-06-03T05:43:40Z,2021-02-01T11:22:08Z,MERGED,True,126,81,1,https://github.com/bsmiles32,Cleanup tpak savestate loading.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/569,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/569,"This may help fixing some edge-cases of crashes while loading
savetstates.
We isolate the savestate data extraction part from the state committing
part so that curr offset don't depends on external factors which could
lead to crashes.
@fzurita Can you test that to see if it helps with #520 ?","This may help fixing some edge-cases of crashes while loading
savetstates.
We isolate the savestate data extraction part from the state committing
part so that curr offset don't depends on external factors which could
lead to crashes.
@fzurita Can you test that to see if it helps with #520 ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,569,2018-05-30T00:39:25Z,2018-06-03T05:43:40Z,2021-02-01T11:22:08Z,MERGED,True,126,81,1,https://github.com/bsmiles32,Cleanup tpak savestate loading.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/569,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/569#issuecomment-393027175,"This may help fixing some edge-cases of crashes while loading
savetstates.
We isolate the savestate data extraction part from the state committing
part so that curr offset don't depends on external factors which could
lead to crashes.
@fzurita Can you test that to see if it helps with #520 ?","I think #520 was happening before transfer pak support was added, so it will probably not help. I will include it though on my next update to the play store to see if it improves the situation.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,569,2018-05-30T00:39:25Z,2018-06-03T05:43:40Z,2021-02-01T11:22:08Z,MERGED,True,126,81,1,https://github.com/bsmiles32,Cleanup tpak savestate loading.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/569,https://github.com/fzurita,3,https://github.com/mupen64plus/mupen64plus-core/pull/569#issuecomment-402823421,"This may help fixing some edge-cases of crashes while loading
savetstates.
We isolate the savestate data extraction part from the state committing
part so that curr offset don't depends on external factors which could
lead to crashes.
@fzurita Can you test that to see if it helps with #520 ?",I didn't see any changes in the crash rate after this was included in the play store build of mupen64plus AE.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,573,2018-06-03T22:41:13Z,2018-07-29T16:32:14Z,2021-02-01T11:22:10Z,MERGED,True,298,183,11,https://github.com/bsmiles32,Rework Video Capture backend to allow better isolation.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/573,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/573,"By adding init and release methods to video capture backend interface
we can completely separate implementation details from usage.
We don't need to include (nor have) backend implementation header,
and therefore can use true C++ for opencv implementation
(no need for in-place ctor, explicit call to dtor, ...).
Also, backend selection is done by name and multiple instanciation (with
different parameters) can be done by selecting the right config section.
Default video capture backend may be overrided at compile-time by
defining DEFAULT_VIDEO_CAPTURE_BACKEND to appropriate value.
Video input has been renamed to Video Capture.
If this PR gets merged, I will try to use the same pattern for other backends. This is a prelimiary step before audio/input plugin inclusion (as backend) inside the core.
For those who remember, the design is quite similar to what I did in a defunct PR mupen64plus/mupen64plus-ui-console#19.","By adding init and release methods to video capture backend interface
we can completely separate implementation details from usage.
We don't need to include (nor have) backend implementation header,
and therefore can use true C++ for opencv implementation
(no need for in-place ctor, explicit call to dtor, ...).
Also, backend selection is done by name and multiple instanciation (with
different parameters) can be done by selecting the right config section.
Default video capture backend may be overrided at compile-time by
defining DEFAULT_VIDEO_CAPTURE_BACKEND to appropriate value.
Video input has been renamed to Video Capture.
If this PR gets merged, I will try to use the same pattern for other backends. This is a prelimiary step before audio/input plugin inclusion (as backend) inside the core.
For those who remember, the design is quite similar to what I did in a defunct PR mupen64plus/mupen64plus-ui-console#19.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,578,2018-08-01T05:04:51Z,2018-08-01T15:04:19Z,2018-08-01T17:32:08Z,MERGED,True,69,67,3,https://github.com/bugfood,Update readme,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/578,https://github.com/bugfood,1,https://github.com/mupen64plus/mupen64plus-core/pull/578,Simple change: update the README.,Simple change: update the README.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,579,2018-08-03T04:58:40Z,2018-08-28T23:54:03Z,2018-08-28T23:55:34Z,MERGED,True,1,14,2,https://github.com/bugfood,Make --nosaveoptions not ever save options.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/579,https://github.com/bugfood,1,https://github.com/mupen64plus/mupen64plus-core/pull/579,"As a new mupen64plus user, I struggled with the configuration, due to two major categories of unexpected behavior:

Under some circumstances, the configuration was changed and saved even when I specified --nosaveoptions, potentially leading to undesired options being persisted in the configuration.
The program runs when there is no configuration, and it generates a configuration file, but command-line parameters are not always respected unless the configuration is present first.

I do not yet have a proposed solution for problem 2 above, but this should help for problem 1, at least when --nosaveoptions is specified. I would like to first get this patchset accepted, if possible. I will show an example of the problems below. Please let me know if I have not explained things clearly... it's kind of tricky.
I will also post a corresponding patchset for ui-console.
# Set up an alias for convenience; this will be used in examples:
$ alias mupen64plus='/usr/local/src/mupen64plus/install/bin/mupen64plus --plugindir /usr/local/src/mupen64plus/install/lib/mupen64plus/ --datadir /usr/local/src/mupen64plus/install/share/mupen64plus/ --corelib /usr/local/src/mupen64plus/install/lib/libmupen64plus.so.2 --testshots 0'

Example from master branch of core and ui-console:
# Clean out configuration:
$ rm ~/.config/mupen64plus/mupen64plus.cfg

# Do a test run with --nosaveoptions; expected behavior is for configuration to
# not be saved:
$ mupen64plus --nosaveoptions /tmp/test.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Test if configuration was saved:
$ test -f ~/.config/mupen64plus/mupen64plus.cfg ; echo $?
0

# The configuration was saved, contrary to expectation.
# Check joystick order in preparation for next test:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = """"

# Try a different joystick order:
$ mupen64plus --nosaveoptions --set 'Input-SDL-Control1[name]=DragonRise Inc.   Generic   USB  Joystick  ' --set 'Input-SDL-Control1[mode]=1' ~/files/roms/N64/Zelda64.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Check joystick order again; the expected behavior is that the order is
# unchanged, since --nosaveoptions was present:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = """"

# The joystick order was changed, contrary to expectation.

Now the same example using patched UI and core:
# (using the same alias as before)

# Clean out configuration:
$ rm ~/.config/mupen64plus/mupen64plus.cfg

# Do a test run with --nosaveoptions; expected behavior is for configuration to
# not be saved:
$ mupen64plus --nosaveoptions /tmp/test.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Test if configuration was saved:
$ test -f ~/.config/mupen64plus/mupen64plus.cfg ; echo $?
0

# Configuration was not saved, as expected. Now allow the configuration to be
# saved in preparation for the next test.
$ mupen64plus /tmp/test.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Check the joystick order before running the test:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = """"

# Try a different joystick order, with --nosaveoptions present:
$ mupen64plus --nosaveoptions --set 'Input-SDL-Control1[name]=DragonRise Inc.   Generic   USB  Joystick  ' --set 'Input-SDL-Control1[mode]=1' ~/files/roms/N64/Zelda64.rom 2>&1 | tail -n 1
Core Status: Rom closed.


# Check joystick order again; the expected behavior is that the order is
# unchanged, since --nosaveoptions was present:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = """"

# The order is indeed unchanged, as expected.

Thanks,
Corey","As a new mupen64plus user, I struggled with the configuration, due to two major categories of unexpected behavior:

Under some circumstances, the configuration was changed and saved even when I specified --nosaveoptions, potentially leading to undesired options being persisted in the configuration.
The program runs when there is no configuration, and it generates a configuration file, but command-line parameters are not always respected unless the configuration is present first.

I do not yet have a proposed solution for problem 2 above, but this should help for problem 1, at least when --nosaveoptions is specified. I would like to first get this patchset accepted, if possible. I will show an example of the problems below. Please let me know if I have not explained things clearly... it's kind of tricky.
I will also post a corresponding patchset for ui-console.
# Set up an alias for convenience; this will be used in examples:
$ alias mupen64plus='/usr/local/src/mupen64plus/install/bin/mupen64plus --plugindir /usr/local/src/mupen64plus/install/lib/mupen64plus/ --datadir /usr/local/src/mupen64plus/install/share/mupen64plus/ --corelib /usr/local/src/mupen64plus/install/lib/libmupen64plus.so.2 --testshots 0'

Example from master branch of core and ui-console:
# Clean out configuration:
$ rm ~/.config/mupen64plus/mupen64plus.cfg

# Do a test run with --nosaveoptions; expected behavior is for configuration to
# not be saved:
$ mupen64plus --nosaveoptions /tmp/test.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Test if configuration was saved:
$ test -f ~/.config/mupen64plus/mupen64plus.cfg ; echo $?
0

# The configuration was saved, contrary to expectation.
# Check joystick order in preparation for next test:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = """"

# Try a different joystick order:
$ mupen64plus --nosaveoptions --set 'Input-SDL-Control1[name]=DragonRise Inc.   Generic   USB  Joystick  ' --set 'Input-SDL-Control1[mode]=1' ~/files/roms/N64/Zelda64.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Check joystick order again; the expected behavior is that the order is
# unchanged, since --nosaveoptions was present:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = """"

# The joystick order was changed, contrary to expectation.

Now the same example using patched UI and core:
# (using the same alias as before)

# Clean out configuration:
$ rm ~/.config/mupen64plus/mupen64plus.cfg

# Do a test run with --nosaveoptions; expected behavior is for configuration to
# not be saved:
$ mupen64plus --nosaveoptions /tmp/test.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Test if configuration was saved:
$ test -f ~/.config/mupen64plus/mupen64plus.cfg ; echo $?
0

# Configuration was not saved, as expected. Now allow the configuration to be
# saved in preparation for the next test.
$ mupen64plus /tmp/test.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Check the joystick order before running the test:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = """"

# Try a different joystick order, with --nosaveoptions present:
$ mupen64plus --nosaveoptions --set 'Input-SDL-Control1[name]=DragonRise Inc.   Generic   USB  Joystick  ' --set 'Input-SDL-Control1[mode]=1' ~/files/roms/N64/Zelda64.rom 2>&1 | tail -n 1
Core Status: Rom closed.


# Check joystick order again; the expected behavior is that the order is
# unchanged, since --nosaveoptions was present:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = """"

# The order is indeed unchanged, as expected.

Thanks,
Corey",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,579,2018-08-03T04:58:40Z,2018-08-28T23:54:03Z,2018-08-28T23:55:34Z,MERGED,True,1,14,2,https://github.com/bugfood,Make --nosaveoptions not ever save options.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/579,https://github.com/bugfood,2,https://github.com/mupen64plus/mupen64plus-core/pull/579#issuecomment-410145163,"As a new mupen64plus user, I struggled with the configuration, due to two major categories of unexpected behavior:

Under some circumstances, the configuration was changed and saved even when I specified --nosaveoptions, potentially leading to undesired options being persisted in the configuration.
The program runs when there is no configuration, and it generates a configuration file, but command-line parameters are not always respected unless the configuration is present first.

I do not yet have a proposed solution for problem 2 above, but this should help for problem 1, at least when --nosaveoptions is specified. I would like to first get this patchset accepted, if possible. I will show an example of the problems below. Please let me know if I have not explained things clearly... it's kind of tricky.
I will also post a corresponding patchset for ui-console.
# Set up an alias for convenience; this will be used in examples:
$ alias mupen64plus='/usr/local/src/mupen64plus/install/bin/mupen64plus --plugindir /usr/local/src/mupen64plus/install/lib/mupen64plus/ --datadir /usr/local/src/mupen64plus/install/share/mupen64plus/ --corelib /usr/local/src/mupen64plus/install/lib/libmupen64plus.so.2 --testshots 0'

Example from master branch of core and ui-console:
# Clean out configuration:
$ rm ~/.config/mupen64plus/mupen64plus.cfg

# Do a test run with --nosaveoptions; expected behavior is for configuration to
# not be saved:
$ mupen64plus --nosaveoptions /tmp/test.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Test if configuration was saved:
$ test -f ~/.config/mupen64plus/mupen64plus.cfg ; echo $?
0

# The configuration was saved, contrary to expectation.
# Check joystick order in preparation for next test:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = """"

# Try a different joystick order:
$ mupen64plus --nosaveoptions --set 'Input-SDL-Control1[name]=DragonRise Inc.   Generic   USB  Joystick  ' --set 'Input-SDL-Control1[mode]=1' ~/files/roms/N64/Zelda64.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Check joystick order again; the expected behavior is that the order is
# unchanged, since --nosaveoptions was present:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = """"

# The joystick order was changed, contrary to expectation.

Now the same example using patched UI and core:
# (using the same alias as before)

# Clean out configuration:
$ rm ~/.config/mupen64plus/mupen64plus.cfg

# Do a test run with --nosaveoptions; expected behavior is for configuration to
# not be saved:
$ mupen64plus --nosaveoptions /tmp/test.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Test if configuration was saved:
$ test -f ~/.config/mupen64plus/mupen64plus.cfg ; echo $?
0

# Configuration was not saved, as expected. Now allow the configuration to be
# saved in preparation for the next test.
$ mupen64plus /tmp/test.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Check the joystick order before running the test:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = """"

# Try a different joystick order, with --nosaveoptions present:
$ mupen64plus --nosaveoptions --set 'Input-SDL-Control1[name]=DragonRise Inc.   Generic   USB  Joystick  ' --set 'Input-SDL-Control1[mode]=1' ~/files/roms/N64/Zelda64.rom 2>&1 | tail -n 1
Core Status: Rom closed.


# Check joystick order again; the expected behavior is that the order is
# unchanged, since --nosaveoptions was present:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = """"

# The order is indeed unchanged, as expected.

Thanks,
Corey","The companion ui-console PR is here:
mupen64plus/mupen64plus-ui-console#47
Thanks,
Corey",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,579,2018-08-03T04:58:40Z,2018-08-28T23:54:03Z,2018-08-28T23:55:34Z,MERGED,True,1,14,2,https://github.com/bugfood,Make --nosaveoptions not ever save options.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/579,https://github.com/richard42,3,https://github.com/mupen64plus/mupen64plus-core/pull/579#issuecomment-410543705,"As a new mupen64plus user, I struggled with the configuration, due to two major categories of unexpected behavior:

Under some circumstances, the configuration was changed and saved even when I specified --nosaveoptions, potentially leading to undesired options being persisted in the configuration.
The program runs when there is no configuration, and it generates a configuration file, but command-line parameters are not always respected unless the configuration is present first.

I do not yet have a proposed solution for problem 2 above, but this should help for problem 1, at least when --nosaveoptions is specified. I would like to first get this patchset accepted, if possible. I will show an example of the problems below. Please let me know if I have not explained things clearly... it's kind of tricky.
I will also post a corresponding patchset for ui-console.
# Set up an alias for convenience; this will be used in examples:
$ alias mupen64plus='/usr/local/src/mupen64plus/install/bin/mupen64plus --plugindir /usr/local/src/mupen64plus/install/lib/mupen64plus/ --datadir /usr/local/src/mupen64plus/install/share/mupen64plus/ --corelib /usr/local/src/mupen64plus/install/lib/libmupen64plus.so.2 --testshots 0'

Example from master branch of core and ui-console:
# Clean out configuration:
$ rm ~/.config/mupen64plus/mupen64plus.cfg

# Do a test run with --nosaveoptions; expected behavior is for configuration to
# not be saved:
$ mupen64plus --nosaveoptions /tmp/test.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Test if configuration was saved:
$ test -f ~/.config/mupen64plus/mupen64plus.cfg ; echo $?
0

# The configuration was saved, contrary to expectation.
# Check joystick order in preparation for next test:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = """"

# Try a different joystick order:
$ mupen64plus --nosaveoptions --set 'Input-SDL-Control1[name]=DragonRise Inc.   Generic   USB  Joystick  ' --set 'Input-SDL-Control1[mode]=1' ~/files/roms/N64/Zelda64.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Check joystick order again; the expected behavior is that the order is
# unchanged, since --nosaveoptions was present:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = """"

# The joystick order was changed, contrary to expectation.

Now the same example using patched UI and core:
# (using the same alias as before)

# Clean out configuration:
$ rm ~/.config/mupen64plus/mupen64plus.cfg

# Do a test run with --nosaveoptions; expected behavior is for configuration to
# not be saved:
$ mupen64plus --nosaveoptions /tmp/test.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Test if configuration was saved:
$ test -f ~/.config/mupen64plus/mupen64plus.cfg ; echo $?
0

# Configuration was not saved, as expected. Now allow the configuration to be
# saved in preparation for the next test.
$ mupen64plus /tmp/test.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Check the joystick order before running the test:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = """"

# Try a different joystick order, with --nosaveoptions present:
$ mupen64plus --nosaveoptions --set 'Input-SDL-Control1[name]=DragonRise Inc.   Generic   USB  Joystick  ' --set 'Input-SDL-Control1[mode]=1' ~/files/roms/N64/Zelda64.rom 2>&1 | tail -n 1
Core Status: Rom closed.


# Check joystick order again; the expected behavior is that the order is
# unchanged, since --nosaveoptions was present:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = """"

# The order is indeed unchanged, as expected.

Thanks,
Corey","There are a couple of things that I don't like about the design of this pull request. One is taking the static variable l_CoreInit and exposing it to the rest of the core library by making it global. The other is controlling the behavior of the configuration subsystem with specially named configuration variables. This is kind of a hack. It's not the config system's fault that it's saving the file; it is being told to do so by higher level code.
I think it would be better to achieve the desired behavior by adding some sort of core startup parameter instructing it not to save any options, so that it wont call ConfigSaveSection in main.c or event.c.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,579,2018-08-03T04:58:40Z,2018-08-28T23:54:03Z,2018-08-28T23:55:34Z,MERGED,True,1,14,2,https://github.com/bugfood,Make --nosaveoptions not ever save options.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/579,https://github.com/bugfood,4,https://github.com/mupen64plus/mupen64plus-core/pull/579#issuecomment-410587224,"As a new mupen64plus user, I struggled with the configuration, due to two major categories of unexpected behavior:

Under some circumstances, the configuration was changed and saved even when I specified --nosaveoptions, potentially leading to undesired options being persisted in the configuration.
The program runs when there is no configuration, and it generates a configuration file, but command-line parameters are not always respected unless the configuration is present first.

I do not yet have a proposed solution for problem 2 above, but this should help for problem 1, at least when --nosaveoptions is specified. I would like to first get this patchset accepted, if possible. I will show an example of the problems below. Please let me know if I have not explained things clearly... it's kind of tricky.
I will also post a corresponding patchset for ui-console.
# Set up an alias for convenience; this will be used in examples:
$ alias mupen64plus='/usr/local/src/mupen64plus/install/bin/mupen64plus --plugindir /usr/local/src/mupen64plus/install/lib/mupen64plus/ --datadir /usr/local/src/mupen64plus/install/share/mupen64plus/ --corelib /usr/local/src/mupen64plus/install/lib/libmupen64plus.so.2 --testshots 0'

Example from master branch of core and ui-console:
# Clean out configuration:
$ rm ~/.config/mupen64plus/mupen64plus.cfg

# Do a test run with --nosaveoptions; expected behavior is for configuration to
# not be saved:
$ mupen64plus --nosaveoptions /tmp/test.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Test if configuration was saved:
$ test -f ~/.config/mupen64plus/mupen64plus.cfg ; echo $?
0

# The configuration was saved, contrary to expectation.
# Check joystick order in preparation for next test:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = """"

# Try a different joystick order:
$ mupen64plus --nosaveoptions --set 'Input-SDL-Control1[name]=DragonRise Inc.   Generic   USB  Joystick  ' --set 'Input-SDL-Control1[mode]=1' ~/files/roms/N64/Zelda64.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Check joystick order again; the expected behavior is that the order is
# unchanged, since --nosaveoptions was present:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = """"

# The joystick order was changed, contrary to expectation.

Now the same example using patched UI and core:
# (using the same alias as before)

# Clean out configuration:
$ rm ~/.config/mupen64plus/mupen64plus.cfg

# Do a test run with --nosaveoptions; expected behavior is for configuration to
# not be saved:
$ mupen64plus --nosaveoptions /tmp/test.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Test if configuration was saved:
$ test -f ~/.config/mupen64plus/mupen64plus.cfg ; echo $?
0

# Configuration was not saved, as expected. Now allow the configuration to be
# saved in preparation for the next test.
$ mupen64plus /tmp/test.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Check the joystick order before running the test:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = """"

# Try a different joystick order, with --nosaveoptions present:
$ mupen64plus --nosaveoptions --set 'Input-SDL-Control1[name]=DragonRise Inc.   Generic   USB  Joystick  ' --set 'Input-SDL-Control1[mode]=1' ~/files/roms/N64/Zelda64.rom 2>&1 | tail -n 1
Core Status: Rom closed.


# Check joystick order again; the expected behavior is that the order is
# unchanged, since --nosaveoptions was present:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = """"

# The order is indeed unchanged, as expected.

Thanks,
Corey","Thank you for your feedback. My goals in building it this way were:

Maintain backwards/forwards compatibility between UI and core.
Retain the same default behavior.

Are these priorities? If so, then I would appreciate a bit more guidance; I haven't seen another way to do it without breaking either of these goals somehow.
Specifically, the problematic chain of events is:
The UI starts the core via CoreStartup(), which calls main_set_core_defaults(), which calls ConfigSaveSection() (if it thinks it needs to change anything); all this happens before the UI can do anything to specify that configuration should not be saved.
I have seen two alternative approaches that I think could work:

Add a parameter to CoreStartup() so that the UI can specify whether configuration should be saved or not; I think this would break forward/backward compatibility with the UI.
Remove the call to ConfigSaveSection() from main_set_core_defaults() and rely on the UI to call ConfigSaveSection() if desired; configuration could either be saved unconditionally or, if desired, add a way to track whether the internal configuration state is ""dirty"" and only flush to the file when needed. This might change the default behavior for older UIs, but realistically, at least for now, plugins seem to call ConfigSaveSection() pretty often anyway.

Option 1 seems like it matches your suggestion above. Option 2 seems like it might be a better long-term approach, and I think it would allow me to also address your concern about the configuration variable, if it would be acceptable for me to (eventually) remove ConfigSaveSection() from non-UI plugins.
Please let me know how you would like me to proceed. I really care about trying to make this work, if I can.
Thanks,
Corey",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,579,2018-08-03T04:58:40Z,2018-08-28T23:54:03Z,2018-08-28T23:55:34Z,MERGED,True,1,14,2,https://github.com/bugfood,Make --nosaveoptions not ever save options.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/579,https://github.com/richard42,5,https://github.com/mupen64plus/mupen64plus-core/pull/579#issuecomment-416116686,"As a new mupen64plus user, I struggled with the configuration, due to two major categories of unexpected behavior:

Under some circumstances, the configuration was changed and saved even when I specified --nosaveoptions, potentially leading to undesired options being persisted in the configuration.
The program runs when there is no configuration, and it generates a configuration file, but command-line parameters are not always respected unless the configuration is present first.

I do not yet have a proposed solution for problem 2 above, but this should help for problem 1, at least when --nosaveoptions is specified. I would like to first get this patchset accepted, if possible. I will show an example of the problems below. Please let me know if I have not explained things clearly... it's kind of tricky.
I will also post a corresponding patchset for ui-console.
# Set up an alias for convenience; this will be used in examples:
$ alias mupen64plus='/usr/local/src/mupen64plus/install/bin/mupen64plus --plugindir /usr/local/src/mupen64plus/install/lib/mupen64plus/ --datadir /usr/local/src/mupen64plus/install/share/mupen64plus/ --corelib /usr/local/src/mupen64plus/install/lib/libmupen64plus.so.2 --testshots 0'

Example from master branch of core and ui-console:
# Clean out configuration:
$ rm ~/.config/mupen64plus/mupen64plus.cfg

# Do a test run with --nosaveoptions; expected behavior is for configuration to
# not be saved:
$ mupen64plus --nosaveoptions /tmp/test.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Test if configuration was saved:
$ test -f ~/.config/mupen64plus/mupen64plus.cfg ; echo $?
0

# The configuration was saved, contrary to expectation.
# Check joystick order in preparation for next test:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = """"

# Try a different joystick order:
$ mupen64plus --nosaveoptions --set 'Input-SDL-Control1[name]=DragonRise Inc.   Generic   USB  Joystick  ' --set 'Input-SDL-Control1[mode]=1' ~/files/roms/N64/Zelda64.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Check joystick order again; the expected behavior is that the order is
# unchanged, since --nosaveoptions was present:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = """"

# The joystick order was changed, contrary to expectation.

Now the same example using patched UI and core:
# (using the same alias as before)

# Clean out configuration:
$ rm ~/.config/mupen64plus/mupen64plus.cfg

# Do a test run with --nosaveoptions; expected behavior is for configuration to
# not be saved:
$ mupen64plus --nosaveoptions /tmp/test.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Test if configuration was saved:
$ test -f ~/.config/mupen64plus/mupen64plus.cfg ; echo $?
0

# Configuration was not saved, as expected. Now allow the configuration to be
# saved in preparation for the next test.
$ mupen64plus /tmp/test.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Check the joystick order before running the test:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = """"

# Try a different joystick order, with --nosaveoptions present:
$ mupen64plus --nosaveoptions --set 'Input-SDL-Control1[name]=DragonRise Inc.   Generic   USB  Joystick  ' --set 'Input-SDL-Control1[mode]=1' ~/files/roms/N64/Zelda64.rom 2>&1 | tail -n 1
Core Status: Rom closed.


# Check joystick order again; the expected behavior is that the order is
# unchanged, since --nosaveoptions was present:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = """"

# The order is indeed unchanged, as expected.

Thanks,
Corey","I think the best way forward is to remove the call to ConfigSaveSection() from inside of the main_set_core_defaults() function. Then, inside of the ui-console front-end, use the ConfigHasUnsavedChanges() on the Core section, and if there are unsaved changes (and if the --nosaveoptions was not specified), then save the section.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,579,2018-08-03T04:58:40Z,2018-08-28T23:54:03Z,2018-08-28T23:55:34Z,MERGED,True,1,14,2,https://github.com/bugfood,Make --nosaveoptions not ever save options.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/579,https://github.com/bugfood,6,https://github.com/mupen64plus/mupen64plus-core/pull/579#issuecomment-416450713,"As a new mupen64plus user, I struggled with the configuration, due to two major categories of unexpected behavior:

Under some circumstances, the configuration was changed and saved even when I specified --nosaveoptions, potentially leading to undesired options being persisted in the configuration.
The program runs when there is no configuration, and it generates a configuration file, but command-line parameters are not always respected unless the configuration is present first.

I do not yet have a proposed solution for problem 2 above, but this should help for problem 1, at least when --nosaveoptions is specified. I would like to first get this patchset accepted, if possible. I will show an example of the problems below. Please let me know if I have not explained things clearly... it's kind of tricky.
I will also post a corresponding patchset for ui-console.
# Set up an alias for convenience; this will be used in examples:
$ alias mupen64plus='/usr/local/src/mupen64plus/install/bin/mupen64plus --plugindir /usr/local/src/mupen64plus/install/lib/mupen64plus/ --datadir /usr/local/src/mupen64plus/install/share/mupen64plus/ --corelib /usr/local/src/mupen64plus/install/lib/libmupen64plus.so.2 --testshots 0'

Example from master branch of core and ui-console:
# Clean out configuration:
$ rm ~/.config/mupen64plus/mupen64plus.cfg

# Do a test run with --nosaveoptions; expected behavior is for configuration to
# not be saved:
$ mupen64plus --nosaveoptions /tmp/test.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Test if configuration was saved:
$ test -f ~/.config/mupen64plus/mupen64plus.cfg ; echo $?
0

# The configuration was saved, contrary to expectation.
# Check joystick order in preparation for next test:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = """"

# Try a different joystick order:
$ mupen64plus --nosaveoptions --set 'Input-SDL-Control1[name]=DragonRise Inc.   Generic   USB  Joystick  ' --set 'Input-SDL-Control1[mode]=1' ~/files/roms/N64/Zelda64.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Check joystick order again; the expected behavior is that the order is
# unchanged, since --nosaveoptions was present:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = """"

# The joystick order was changed, contrary to expectation.

Now the same example using patched UI and core:
# (using the same alias as before)

# Clean out configuration:
$ rm ~/.config/mupen64plus/mupen64plus.cfg

# Do a test run with --nosaveoptions; expected behavior is for configuration to
# not be saved:
$ mupen64plus --nosaveoptions /tmp/test.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Test if configuration was saved:
$ test -f ~/.config/mupen64plus/mupen64plus.cfg ; echo $?
0

# Configuration was not saved, as expected. Now allow the configuration to be
# saved in preparation for the next test.
$ mupen64plus /tmp/test.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Check the joystick order before running the test:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = """"

# Try a different joystick order, with --nosaveoptions present:
$ mupen64plus --nosaveoptions --set 'Input-SDL-Control1[name]=DragonRise Inc.   Generic   USB  Joystick  ' --set 'Input-SDL-Control1[mode]=1' ~/files/roms/N64/Zelda64.rom 2>&1 | tail -n 1
Core Status: Rom closed.


# Check joystick order again; the expected behavior is that the order is
# unchanged, since --nosaveoptions was present:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = """"

# The order is indeed unchanged, as expected.

Thanks,
Corey","Thanks for your feedback. I have updated this PR to match your suggestion with respect to the core changes. I also had to change event_set_core_defaults() similarly.
The scope is less ambitious than before, but the change does allow the UI to be modified so that configuration saving does not happen automatically until plugin initialization--which doesn't fully fix the problem, but it gets further. If you will accept this change, then I can move onward to modifying plugins to not call ConfigSaveSection().
I will update the corresponding UI-console PR shortly.
Thanks,
Corey",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,579,2018-08-03T04:58:40Z,2018-08-28T23:54:03Z,2018-08-28T23:55:34Z,MERGED,True,1,14,2,https://github.com/bugfood,Make --nosaveoptions not ever save options.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/579,https://github.com/bugfood,7,https://github.com/mupen64plus/mupen64plus-core/pull/579#issuecomment-416452031,"As a new mupen64plus user, I struggled with the configuration, due to two major categories of unexpected behavior:

Under some circumstances, the configuration was changed and saved even when I specified --nosaveoptions, potentially leading to undesired options being persisted in the configuration.
The program runs when there is no configuration, and it generates a configuration file, but command-line parameters are not always respected unless the configuration is present first.

I do not yet have a proposed solution for problem 2 above, but this should help for problem 1, at least when --nosaveoptions is specified. I would like to first get this patchset accepted, if possible. I will show an example of the problems below. Please let me know if I have not explained things clearly... it's kind of tricky.
I will also post a corresponding patchset for ui-console.
# Set up an alias for convenience; this will be used in examples:
$ alias mupen64plus='/usr/local/src/mupen64plus/install/bin/mupen64plus --plugindir /usr/local/src/mupen64plus/install/lib/mupen64plus/ --datadir /usr/local/src/mupen64plus/install/share/mupen64plus/ --corelib /usr/local/src/mupen64plus/install/lib/libmupen64plus.so.2 --testshots 0'

Example from master branch of core and ui-console:
# Clean out configuration:
$ rm ~/.config/mupen64plus/mupen64plus.cfg

# Do a test run with --nosaveoptions; expected behavior is for configuration to
# not be saved:
$ mupen64plus --nosaveoptions /tmp/test.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Test if configuration was saved:
$ test -f ~/.config/mupen64plus/mupen64plus.cfg ; echo $?
0

# The configuration was saved, contrary to expectation.
# Check joystick order in preparation for next test:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = """"

# Try a different joystick order:
$ mupen64plus --nosaveoptions --set 'Input-SDL-Control1[name]=DragonRise Inc.   Generic   USB  Joystick  ' --set 'Input-SDL-Control1[mode]=1' ~/files/roms/N64/Zelda64.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Check joystick order again; the expected behavior is that the order is
# unchanged, since --nosaveoptions was present:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = """"

# The joystick order was changed, contrary to expectation.

Now the same example using patched UI and core:
# (using the same alias as before)

# Clean out configuration:
$ rm ~/.config/mupen64plus/mupen64plus.cfg

# Do a test run with --nosaveoptions; expected behavior is for configuration to
# not be saved:
$ mupen64plus --nosaveoptions /tmp/test.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Test if configuration was saved:
$ test -f ~/.config/mupen64plus/mupen64plus.cfg ; echo $?
0

# Configuration was not saved, as expected. Now allow the configuration to be
# saved in preparation for the next test.
$ mupen64plus /tmp/test.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Check the joystick order before running the test:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = """"

# Try a different joystick order, with --nosaveoptions present:
$ mupen64plus --nosaveoptions --set 'Input-SDL-Control1[name]=DragonRise Inc.   Generic   USB  Joystick  ' --set 'Input-SDL-Control1[mode]=1' ~/files/roms/N64/Zelda64.rom 2>&1 | tail -n 1
Core Status: Rom closed.


# Check joystick order again; the expected behavior is that the order is
# unchanged, since --nosaveoptions was present:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = """"

# The order is indeed unchanged, as expected.

Thanks,
Corey","UI-console PR updated:
mupen64plus/mupen64plus-ui-console#47
As long as --nosaveoptions is not present, the ui-console will call ConfigSaveFile(). Based on my reading of this, that makes it not necessary to check ConfigHasUnsavedChanges() on the core sections; if the entire configuration is about to be saved, there is no need to check individual sections. Is my understanding correct?
Thanks,
Corey",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,579,2018-08-03T04:58:40Z,2018-08-28T23:54:03Z,2018-08-28T23:55:34Z,MERGED,True,1,14,2,https://github.com/bugfood,Make --nosaveoptions not ever save options.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/579,https://github.com/richard42,8,https://github.com/mupen64plus/mupen64plus-core/pull/579#issuecomment-416777818,"As a new mupen64plus user, I struggled with the configuration, due to two major categories of unexpected behavior:

Under some circumstances, the configuration was changed and saved even when I specified --nosaveoptions, potentially leading to undesired options being persisted in the configuration.
The program runs when there is no configuration, and it generates a configuration file, but command-line parameters are not always respected unless the configuration is present first.

I do not yet have a proposed solution for problem 2 above, but this should help for problem 1, at least when --nosaveoptions is specified. I would like to first get this patchset accepted, if possible. I will show an example of the problems below. Please let me know if I have not explained things clearly... it's kind of tricky.
I will also post a corresponding patchset for ui-console.
# Set up an alias for convenience; this will be used in examples:
$ alias mupen64plus='/usr/local/src/mupen64plus/install/bin/mupen64plus --plugindir /usr/local/src/mupen64plus/install/lib/mupen64plus/ --datadir /usr/local/src/mupen64plus/install/share/mupen64plus/ --corelib /usr/local/src/mupen64plus/install/lib/libmupen64plus.so.2 --testshots 0'

Example from master branch of core and ui-console:
# Clean out configuration:
$ rm ~/.config/mupen64plus/mupen64plus.cfg

# Do a test run with --nosaveoptions; expected behavior is for configuration to
# not be saved:
$ mupen64plus --nosaveoptions /tmp/test.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Test if configuration was saved:
$ test -f ~/.config/mupen64plus/mupen64plus.cfg ; echo $?
0

# The configuration was saved, contrary to expectation.
# Check joystick order in preparation for next test:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = """"

# Try a different joystick order:
$ mupen64plus --nosaveoptions --set 'Input-SDL-Control1[name]=DragonRise Inc.   Generic   USB  Joystick  ' --set 'Input-SDL-Control1[mode]=1' ~/files/roms/N64/Zelda64.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Check joystick order again; the expected behavior is that the order is
# unchanged, since --nosaveoptions was present:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = """"

# The joystick order was changed, contrary to expectation.

Now the same example using patched UI and core:
# (using the same alias as before)

# Clean out configuration:
$ rm ~/.config/mupen64plus/mupen64plus.cfg

# Do a test run with --nosaveoptions; expected behavior is for configuration to
# not be saved:
$ mupen64plus --nosaveoptions /tmp/test.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Test if configuration was saved:
$ test -f ~/.config/mupen64plus/mupen64plus.cfg ; echo $?
0

# Configuration was not saved, as expected. Now allow the configuration to be
# saved in preparation for the next test.
$ mupen64plus /tmp/test.rom 2>&1 | tail -n 1
Core Status: Rom closed.

# Check the joystick order before running the test:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = """"

# Try a different joystick order, with --nosaveoptions present:
$ mupen64plus --nosaveoptions --set 'Input-SDL-Control1[name]=DragonRise Inc.   Generic   USB  Joystick  ' --set 'Input-SDL-Control1[mode]=1' ~/files/roms/N64/Zelda64.rom 2>&1 | tail -n 1
Core Status: Rom closed.


# Check joystick order again; the expected behavior is that the order is
# unchanged, since --nosaveoptions was present:
$ grep 'name = ' ~/.config/mupen64plus/mupen64plus.cfg
name = ""Twin USB Joystick""
name = ""Twin USB Joystick""
name = ""DragonRise Inc.   Generic   USB  Joystick  ""
name = """"

# The order is indeed unchanged, as expected.

Thanks,
Corey","yes you are correct, it saves the whole file in 2 places after starting the core.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,581,2018-08-16T22:07:47Z,2018-08-27T05:26:31Z,2018-09-22T13:50:11Z,MERGED,True,8,5,3,https://github.com/bsmiles32,Bugfixes,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/581,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/581,Various compilation fixes found while working on meson porting.,Various compilation fixes found while working on meson porting.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,582,2018-08-16T22:16:12Z,2018-08-27T05:29:14Z,2018-09-22T13:50:07Z,MERGED,True,114,88,21,https://github.com/bsmiles32,Move third-party code into subprojects directory.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/582,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/582,"By moving 3rd party code to a specific directory (which happens to be named ""subprojects"" to ease migration to meson) we can better track (and maybe update) our embedded dependencies.
If we go the meson route (PR #488), we can go further and let meson fetch/embed these dependencies transparently (using wraps) so we can use them as fallback when compiling on a platform that has no package-manager (eg Windows, iOS, ...). Very promising stuff !","By moving 3rd party code to a specific directory (which happens to be named ""subprojects"" to ease migration to meson) we can better track (and maybe update) our embedded dependencies.
If we go the meson route (PR #488), we can go further and let meson fetch/embed these dependencies transparently (using wraps) so we can use them as fallback when compiling on a platform that has no package-manager (eg Windows, iOS, ...). Very promising stuff !",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,583,2018-08-20T21:55:21Z,2018-08-27T05:35:04Z,2018-09-22T13:50:05Z,MERGED,True,8,8,1,https://github.com/bsmiles32,Update nasm path to use latest stable release 2.13.03,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/583,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/583,To be merged after mupen64plus/mupen64plus-win32-deps#7,To be merged after mupen64plus/mupen64plus-win32-deps#7,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,585,2018-08-27T22:57:17Z,2018-08-28T00:10:18Z,2018-09-22T13:49:46Z,MERGED,True,307,118,21,https://github.com/bsmiles32,Cleanings,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/585,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/585,"Some more warnings fixes.
I also wrote a minimal wrapper around OGLFT to expose it as a C API in order to avoid C++ leakage into our code base (no #ifdef __cplusplus extern ""C"" danse, no UB because of thrown exception, ...).","Some more warnings fixes.
I also wrote a minimal wrapper around OGLFT to expose it as a C API in order to avoid C++ leakage into our code base (no #ifdef __cplusplus extern ""C"" danse, no UB because of thrown exception, ...).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,588,2018-09-19T17:04:07Z,2018-09-22T03:23:40Z,2018-09-22T03:23:40Z,MERGED,True,9,0,1,https://github.com/bkeys,added support for aarch64,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/588,https://github.com/bkeys,1,https://github.com/mupen64plus/mupen64plus-core/pull/588,I added support for aarch64 with this addition to the makefile,I added support for aarch64 with this addition to the makefile,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,588,2018-09-19T17:04:07Z,2018-09-22T03:23:40Z,2018-09-22T03:23:40Z,MERGED,True,9,0,1,https://github.com/bkeys,added support for aarch64,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/588,https://github.com/bkeys,2,https://github.com/mupen64plus/mupen64plus-core/pull/588#issuecomment-423445008,I added support for aarch64 with this addition to the makefile,Fixed it for ya.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,589,2018-09-22T13:51:37Z,2018-09-22T14:51:50Z,2021-02-01T11:22:16Z,MERGED,True,55,27,8,https://github.com/bsmiles32,Cleanings,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/589,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/589,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,590,2018-09-23T20:31:45Z,2018-09-23T21:13:39Z,2021-02-01T11:22:18Z,MERGED,True,2,0,1,https://github.com/bsmiles32,Fix missing header in biopak.c,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/590,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/590,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,593,2018-10-29T00:29:20Z,2018-11-04T03:23:57Z,2018-11-04T03:23:57Z,MERGED,True,97,0,7,https://github.com/thyth,Two new debugger APIs: 'DebugBreakpointTriggeredBy' and 'DebugVirtualToPhysical',3,[],https://github.com/mupen64plus/mupen64plus-core/pull/593,https://github.com/thyth,1,https://github.com/mupen64plus/mupen64plus-core/pull/593,"This pull request adds two new debugger APIs:

DebugBreakpointTriggeredBy: this retrieves the flag (e.g. M64P_BKP_FLAG_READ, M64P_BKP_FLAG_WRITE) and trigger address for the currently triggered breakpoint. Existing code can log to the console upon triggering a breakpoint (if M64P_BKP_FLAG_LOG is set), but these values were not programmatically accessible to a debugging front-end.
DebugVirtualToPhysical: this retrieves the physical R4300 memory address corresponding to a virtual R4300 memory address. Memory breakpoints, unlike memory read/write commands, do not undergo virtual to physical address translation prior to being set, so debugging front-ends require a programmatic method of translating on their own.

Adding virtual address translation to breakpoint creation looks to be tricky, since internally they operate on physical addresses, thus you would need to reverse that translation to accurately report on the corresponding virtual address that has been accessed. By exposing translation capabilities to debugging front ends, this process can be controlled and visible to the user.","This pull request adds two new debugger APIs:

DebugBreakpointTriggeredBy: this retrieves the flag (e.g. M64P_BKP_FLAG_READ, M64P_BKP_FLAG_WRITE) and trigger address for the currently triggered breakpoint. Existing code can log to the console upon triggering a breakpoint (if M64P_BKP_FLAG_LOG is set), but these values were not programmatically accessible to a debugging front-end.
DebugVirtualToPhysical: this retrieves the physical R4300 memory address corresponding to a virtual R4300 memory address. Memory breakpoints, unlike memory read/write commands, do not undergo virtual to physical address translation prior to being set, so debugging front-ends require a programmatic method of translating on their own.

Adding virtual address translation to breakpoint creation looks to be tricky, since internally they operate on physical addresses, thus you would need to reverse that translation to accurately report on the corresponding virtual address that has been accessed. By exposing translation capabilities to debugging front ends, this process can be controlled and visible to the user.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,596,2018-11-11T11:00:13Z,2018-11-12T05:54:29Z,2021-02-01T11:22:20Z,MERGED,True,1,1,1,https://github.com/bsmiles32,Fix access to DD_ROM memory pointer.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/596,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/596,"I must have missed this when doing commit
9e4a3fb.","I must have missed this when doing commit
9e4a3fb.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,597,2018-11-11T11:03:00Z,2018-11-12T05:55:19Z,2021-02-01T11:22:22Z,MERGED,True,2,4,1,https://github.com/bsmiles32,Avoid nameless union in r4300_core.h (this is a non standard extension),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/597,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/597,There is still one usage of nameless union in m64p_plugin.h (BUTTONS) but as it is public API changing it would break backward compatibility.,There is still one usage of nameless union in m64p_plugin.h (BUTTONS) but as it is public API changing it would break backward compatibility.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,598,2018-11-13T15:30:10Z,2018-11-14T06:22:00Z,2019-01-29T23:48:28Z,MERGED,True,14,7,3,https://github.com/loganmc10,Fix errors introduced in #444,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/598,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/598,"These changes allow Rugrats and Xena to boot. Tested booting many other games, no regressions found.","These changes allow Rugrats and Xena to boot. Tested booting many other games, no regressions found.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,598,2018-11-13T15:30:10Z,2018-11-14T06:22:00Z,2019-01-29T23:48:28Z,MERGED,True,14,7,3,https://github.com/loganmc10,Fix errors introduced in #444,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/598,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/598#issuecomment-458753537,"These changes allow Rugrats and Xena to boot. Tested booting many other games, no regressions found.","Xena still doesn't seem to be booting, at least in Android.
Err... Never mind, need to update count per operation to 3",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/Gillou68310,1,https://github.com/mupen64plus/mupen64plus-core/pull/602,,,True,"{'HOORAY': ['https://github.com/fzurita', 'https://github.com/sjuut', 'https://github.com/tabnk', 'https://github.com/gjimenezf', 'https://github.com/Clownacy'], 'LAUGH': ['https://github.com/tabnk'], 'HEART': ['https://github.com/gjimenezf']}"
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/Zapeth,2,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-453777760,,"Is there a description somewhere that explains the difference compared to the current implementation?
Like, is there anything in particular that this implementation aims to improve or does different in terms of performance, accuracy and/or portability?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/fzurita,3,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-453778420,,"@Gillou68310 I'm getting this error when I'm trying to compile using clang for x86_64:
  [x86_64] SharedLibrary  : libmupen64plus-core.so
  ../gcc/x86_64-linux-android/4.9.x/../../../../x86_64-linux-android/bin/ld: error: ./upstream/src/device/r4300/new_dynarec/x64/linkage_x64.o: requires dynamic R_X86_64_32 reloc against 'g_dev' which may overflow at runtime; recompile with -fPIC
  ../gcc/x86_64-linux-android/4.9.x/../../../../x86_64-linux-android/bin/ld: warning: shared library text segment is not shareable
  clang++: error: linker command failed with exit code 1 (use -v to see invocation)
  make: *** [libmupen64plus-core.so] Error 1

And I am compiling using fPIC
Also, here is my work in progress, only thing not compiling is the core and only not compiling in x86_64:
https://github.com/mupen64plus-ae/mupen64plus-ae/tree/arm64_new",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/fzurita,4,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-453780654,,"arm64 performance seems to be about 10% worse than arm32 performance, at least in CBFD. Although, it's much better than nothing.
It's hard to determine where the performance difference is coming from since this is just the FPS counter I'm looking at in a static area. It could be other plugins are running slower when compiled in 64 bit vs 32 bit.
Edit: Ok, I think the performance penalty is not coming from the dynarec, running interpreter 32 bit vs 64 bit, 64 bit is about 25% slower.... I wonder why.
Edit 2: Ok, part of my issue was debug vs release builds. Comparing two release builds, one 32 bit compiled and another 64 bit compiled. 64 bit compiled is about 10% faster when using interpreter. When using dynarec 32 bit one is about 5% faster. Not sure why 64 bit would be slower, but it seems consistent that the 64 bit new dynarec seems to run slower, at least in Android.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/Gillou68310,5,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-453807789,,"@fzurita your issue with clang is weird could you send me the verbose compiler+linker output?
Concerning the slowdown, did you try with non TLB games? Wondering if this is a TLB specific issue? For games running fullspeed in both situations, try with dummy audio and framelimiter off ;-)
@Zapeth this is just a basic port to support arm64 and x64 architectures. It's using the same original new_dynarec design. So compatibility and performance are expected to be the same as arm32 and x86 new_dynarec.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/fzurita,6,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-453863771,,"I attached the build output of the x86_64 build.
ndkBuild_build_output.txt
I will look into the TLB theory.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/Gillou68310,7,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-453865342,,"Thanks, just out of curiosity did you try building the old dynarec 64bits?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/fzurita,8,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-453865404,,I have not tried yet.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/Gillou68310,9,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-453865551,,"ok you should definitely get the same issue, not sure where it comes from. Is GCC still an option with latest NDK?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/fzurita,10,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-453865766,,GCC was removed in Android NDK 18: https://developer.android.com/ndk/downloads/revision_history,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/Gillou68310,11,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-453865788,,Ok,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/Gillou68310,12,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-453867718,,"Hum on a second look I have a few non pc relative access to g_dev. Try commenting out those:
mov  reg,   g_dev_*",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/fzurita,13,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-453868335,,"Sure, will do. By the way, the performance difference may have nothing to do with 32 vs 64 bit. I was comparing a build before this pull request to after this pull request. When comparing after the pull request, 32 bit vs 64 bit performance is identical.
When comparing 32 bit only, before and after the pull request, there is about a 5% performance loss after the pull request of the app overall in CBFD. I will need to grab more data point in other games. This was with audio plugin disabled.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/Gillou68310,14,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-453868735,,That's good news! Could you bisect which commit causes the slowdown?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/fzurita,15,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-453869686,,"I commented out all the mov operations in linkage_x64.asm that were accessing g_dev and it allows the core library to compile.
I will try to bisect what commit created the slowdown in the 32 bit arm dynarec next.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/Gillou68310,16,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-453869946,,Thanks I will push a fix for those non pc relative access to g_dev tomorrow ;-),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/Gillou68310,17,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-453870745,,BTW I'm not sure if android is using the x64 or amd64 ABI see assem_x64.h,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/Gillou68310,18,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-453870817,,See #603,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/fzurita,19,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-453872541,,"Good question, I'm not sure how to tell. I would guess AMD64 since it's clang and linux based.
Also, once it's compiling in Android, I don't have a device to test with unfortunately, although Android emulator may work.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/fzurita,20,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-453876711,,"This commit introduced the slowdown:
5ff85aa",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/Gillou68310,21,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-453933375,,"@fzurita Thanks for bisecting! I'll investigate the issue.
1e6d8bd should fix the build issue on android, I'll also add a fix for the slowdown in this PR once I find the cause.
Could you send me the core disassembly I'll check the calling convention to find out which ABI is used.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/fzurita,22,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-453973619,,"Yep, that commit worked. I'll look into the disassembly.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/fzurita,23,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-453976916,,"Here is the disassembly:
disassembly.txt",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/Gillou68310,24,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-453991088,,Thanks but could you generate the disassembly in intel format I hate AT&T ;-),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/fzurita,25,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-453991615,,"Hmmm, any idea on how to make objdump do that?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/fzurita,26,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-453992042,,"Never mind, found it: objdump -M intel -d program_name",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/fzurita,27,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-453992938,,"New one:
disassembly.txt",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/Gillou68310,28,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-454012965,,"Thanks it's much more readable!
Anyway definitely amd64 ABI. If _WIN32 is not defined on android we should be good ;-)
Do you have an android emulator to test?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/Gillou68310,29,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-454020860,,Damn I cannot reproduce the slowdown issue on my odroid do you have a savestate for CBFD where the issue is noticeable for you?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/fzurita,30,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-454058995,,"Yes, it turns out I can make a x86_64 android emulator. It shouldn't be an issue. I'll get a save state.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/Gillou68310,31,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-454059197,,Thanks!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/fzurita,32,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-454059860,,"Here is a save state:
starting_area.zip",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/fzurita,33,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-454071109,,"I wonder if the slowdown is compiler dependent. Have you tried compiling using clang? Also, the slowdown is about 5 to 10%, you may not see it unless you have an FPS counter going. And one last thing, make sure you are compiling with O3, maybe something was changed that makes code less optimizable.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/Gillou68310,34,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-454103093,,"Reading from the dynarec cache seems to be the issue.
CBFD is doing a lot of code invalidation thus get_bounds is called really often. My parse_dirty_stub function is doing more cache memory access than the previous get_bounds function.
Could you check that this is the issue by replacing get_bounds by the previous version of it?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/Gillou68310,35,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-454114598,,"Replacing u_int source=(ptr[0]&0xFFF)+((ptr[0]>>4)&0xF000)+((ptr[2]<<16)&0xFFF0000)+((ptr[2]<<12)&0xF0000000);
By
u_int source=(ptr[0]&0xFFF)+((ptr[0]>>4)&0xF000)+((ptr[1]<<16)&0xFFF0000)+((ptr[1]<<12)&0xF0000000);",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/fzurita,36,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-454118310,,"Sure, I'll do that some time tonight once I'm out of work.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/fzurita,37,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-454158334,,"@Gillou68310 is the above backwards? The old code matches your first statement, so I will assume replace old code with new code. After doing that and testing the same scene in CBFD, performance goes to less than 1FPS, am I doing something wrong?
Edit, I did misunderstand what you meant. Doing it right this time.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/fzurita,38,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-454183567,,I did it correctly the second time around. Making that fix does put performance back to previous levels.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/fzurita,39,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-454266740,,I just tested in an Android x86_64 emulated image. The dynarec seems to run fine. I didn't do any extensive testing since it was so slow though.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/Gillou68310,40,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-454391542,,Nice thanks for testing. I'll see what I can do to fix the slowdown.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/Gillou68310,41,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-454822972,,"@fzurita could you test this branch?
Gillou68310@5eaf9a1
I tried to reduce dynarec cache access to a maximum, let me know if it helps",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/fzurita,42,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-455044720,,"@Gillou68310 That code doesn't seem to compile for x86. Either way, I tested with arm64 and now it runs faster than the original! Nice job. It's about a 5% to 10% faster than before adding the 64 bit new dynarecs.",True,{'LAUGH': ['https://github.com/gjimenezf']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/fzurita,43,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-455165445,,"I put this update in the playstore. I'm seeing some crashes in memcmp, possibly this:
static int verify_dirty(void *addr)
{
  uintptr_t source=0;
  uintptr_t copy=0;
  u_int len=0;
  uintptr_t verifier=0;

  void *ptr=parse_dirty_stub(addr,&source,&copy,&len,&verifier);
  assert(ptr!=NULL);
  assert((verifier==(uintptr_t)verify_code)||(verifier==(uintptr_t)verify_code_vm)||(verifier==(uintptr_t)verify_code_ds));

  if(verifier==(uintptr_t)verify_code_vm||verifier==(uintptr_t)verify_code_ds) {
    unsigned int page=source>>12;
    uintptr_t map_value=g_dev.r4300.new_dynarec_hot_state.memory_map[page];
    if((intptr_t)map_value<(intptr_t)0) return 0;
    while(page<((source+len-1)>>12)) {
      if((g_dev.r4300.new_dynarec_hot_state.memory_map[++page]<<2)!=(map_value<<2)) return 0;
    }
    source = source+(map_value<<2);
  }
  //DebugMessage(M64MSG_VERBOSE, ""verify_dirty: %x %x %x"",source,copy,len);
  return !memcmp((void *)source,(void *)copy,len); // HERE
}

It's hard to get a backtrace, but if you think that's not an issue, I'll generate one.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,602,2019-01-09T15:08:12Z,2019-01-12T18:06:36Z,2019-01-28T11:32:39Z,MERGED,True,14985,2108,27,https://github.com/Gillou68310,new_dynarec: Initial support for x64 and arm64,22,[],https://github.com/mupen64plus/mupen64plus-core/pull/602,https://github.com/Gillou68310,44,https://github.com/mupen64plus/mupen64plus-core/pull/602#issuecomment-455250418,,"I had the crash too I already pushed a fix:
49573d2

@Gillou68310 That code doesn't seem to compile for x86. Either way, I tested with arm64 and now it runs faster than the original! Nice job. It's about a 5% to 10% faster than before adding the 64 bit new dynarecs.

Thanks for testing! I forgot to say it's x64/arm64 only for now ;-)
Now that it I know it gives a small boost I will add support for x86/arm32",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,604,2019-01-13T16:41:40Z,2019-01-13T20:05:25Z,2020-04-27T19:40:26Z,MERGED,True,3,3,2,https://github.com/loganmc10,Fix mingw build,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/604,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/604,Fixes #603,Fixes #603,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,604,2019-01-13T16:41:40Z,2019-01-13T20:05:25Z,2020-04-27T19:40:26Z,MERGED,True,3,3,2,https://github.com/loganmc10,Fix mingw build,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/604,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/604#issuecomment-453844979,Fixes #603,Tested and working on my PC,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,604,2019-01-13T16:41:40Z,2019-01-13T20:05:25Z,2020-04-27T19:40:26Z,MERGED,True,3,3,2,https://github.com/loganmc10,Fix mingw build,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/604,https://github.com/Gillou68310,3,https://github.com/mupen64plus/mupen64plus-core/pull/604#issuecomment-453846095,Fixes #603,Is there no macro shared between both mingw and visual studio? WIN32 maybe?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,604,2019-01-13T16:41:40Z,2019-01-13T20:05:25Z,2020-04-27T19:40:26Z,MERGED,True,3,3,2,https://github.com/loganmc10,Fix mingw build,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/604,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/604#issuecomment-453847705,Fixes #603,"_WIN32 seems to work on MinGW, I assume it works in Visual Studio as well. I've updated the PR",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,604,2019-01-13T16:41:40Z,2019-01-13T20:05:25Z,2020-04-27T19:40:26Z,MERGED,True,3,3,2,https://github.com/loganmc10,Fix mingw build,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/604,https://github.com/Gillou68310,5,https://github.com/mupen64plus/mupen64plus-core/pull/604#issuecomment-453847844,Fixes #603,Thanks I'll check on visual studio,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,604,2019-01-13T16:41:40Z,2019-01-13T20:05:25Z,2020-04-27T19:40:26Z,MERGED,True,3,3,2,https://github.com/loganmc10,Fix mingw build,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/604,https://github.com/Gillou68310,6,https://github.com/mupen64plus/mupen64plus-core/pull/604#issuecomment-453861139,Fixes #603,Looks good,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,605,2019-01-14T01:59:14Z,2019-01-17T03:34:22Z,2019-01-17T03:34:22Z,MERGED,True,8,3,1,https://github.com/bugfood,Preserve floating-point configuration values.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/605,https://github.com/bugfood,1,https://github.com/mupen64plus/mupen64plus-core/pull/605,"Currently, if a floating-point configuration value is equal to an
integer, it gets rewritten as an integer.
Example:
The Video-Rice PolygonOffsetFactor parameter is registered in the source
as a float, default 0.0f. When configuration is not initially present
(the first run of the program), the internal type is M64TYPE_FLOAT, so
the core writes the value to the config file as '0.000000' (default
6-digit precision of fprintf). On the next run, the core reads the value
and translates it to M64TYPE_INT and then writes it to the config file
as '0'.
This patch changes the parsing so that floats are preserved as floats
even when they happen to have an integral value. This way, a user
reading the config file has a visual indication of which values may be
set to floating-point values.","Currently, if a floating-point configuration value is equal to an
integer, it gets rewritten as an integer.
Example:
The Video-Rice PolygonOffsetFactor parameter is registered in the source
as a float, default 0.0f. When configuration is not initially present
(the first run of the program), the internal type is M64TYPE_FLOAT, so
the core writes the value to the config file as '0.000000' (default
6-digit precision of fprintf). On the next run, the core reads the value
and translates it to M64TYPE_INT and then writes it to the config file
as '0'.
This patch changes the parsing so that floats are preserved as floats
even when they happen to have an integral value. This way, a user
reading the config file has a visual indication of which values may be
set to floating-point values.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,1,https://github.com/mupen64plus/mupen64plus-core/pull/606,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-453973174,,"This allows clang to build in Android, thanks!",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,3,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455506791,,"I'm getting crashes with this when trying to stop the core
********** Crash dump: **********
30896-30896/? A/DEBUG: *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***
Build fingerprint: 'razer/cheryl/cheryl:8.1.0/OPM1.171019.011-RZR-180803/6033:user/release-keys'
Revision: '0'
ABI: 'arm64'
pid: 30846, tid: 30873, name: ServiceStartArg  >>> paulscode.android.mupen64plusae.GameActivity <<<
signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x7aab21edc8
    x0   000000000001ee00  x1   0000000000000200  x2   0000007bab200000  x3   0000007babfc0688
    x4   0000007babfc0648  x5   0000007babfc0688  x6   000000000465ca38  x7   000000000465ca58
    x8   0000000000000007  x9   ab0b69c5fb7a2d04  x10  ab0b69c5fb7a2d04  x11  0000000000000011
    x12  0000000000000002  x13  0000007c45118300  x14  0000007bab102588  x15  0000007c4513e8a8
    x16  0000007bab200088  x17  0000000000000008  x18  000000000000003b  x19  0000007aab21edc0
    x20  0000007bab102588  x21  0000007ba7238000  x22  00000000fffffffc  x23  0000007aab21edc0
    x24  0000007b02a00000  x25  0000007ba723b000  x26  0000007baab3ea68  x27  0000007ba2d186d8
    x28  0000007baab3e8c8  x29  0000007baab3e000  x30  0000007ba2cc6500
    sp   0000007bab0f5f20  pc   0000007ba2cc64a8  pstate 0000000060000000


#00 0x00000000000864a8 libmupen64plus-core.so
emit_extjump2
/src/device/r4300/new_dynarec/arm64/assem_arm64.c:0:10
#01 0x000000000001be44 libmupen64plus-core.so
event_sdl_filter
/src/main/eventloop.c:0:25
#02 0x0000000000012100 libmupen64plus-core.so (CoreDoCommand+1132)
                                                                                                                         zipWriteInFileInZip
                                                                                                                         /subprojects/minizip/zip.c:1491:56
#03 0x0000000000005c28 libmupen64plus-ui-console.so (SDL_main+13516)
#04 0x0000000000010684 /data/app/org.mupen64plusae.v3.fzurita-stHn9GHHGS4SmjKxbEVPAw==/oat/arm64/base.odex (offset 0x10000)
Crash dump is completed",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,4,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455508050,,Do you know which commit introduced the crash?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,5,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455509706,,I'll check,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,6,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455511623,,"It was this commit: 4cbf149
And only when trying to stop the core.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,7,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455513743,,Thanks I'll check,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,8,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455567827,,I cannot reproduce this issue on my odroid. Do you have more infos on how to reproduce this issue? Is it random?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,9,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455569019,,It happens to me 100% of the time when commanding the core to stop.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,10,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455569124,,weird,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,11,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455569238,,Have you tried compiling with clang?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,12,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455569286,,arm64? arm32? both?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,13,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455569538,,"I'm crosscompiling for my odroid, I don't have a clang toolchain.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,14,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455574860,,"I have only tested arm64, I'll try arm32 when I get a chance.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,15,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455733056,,I have this code in the google play store and I'm hearing of some reports of paper mario crashing after loading an in-game save. I'm trying to get an in-game save to go with it.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,16,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455734197,,32 bit arm is not crashing on Stop,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,17,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455735601,,"Actually, the paper Mario crash is easy to reproduce, start a new game, it will crash when Luigi leaves his house.
Paper Mario only crashes in arm64.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,18,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455776271,,"More data points, in mario 64, the 64 bit arm dynarec crash on stop command is not entirely reproducible. It crashes maybe 50% of the time.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,19,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455776460,,Could you check that base_addr_rx==base_addr?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,20,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455777282,,E/Core: based_addr=0x7ba745a000 based_addr_rx=0x7ba745a000,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,21,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455777794,,Do you have asserts enable?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,22,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455777940,,"Nope, but I can enable them.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,23,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455778092,,Yes please! I just want to be sure no assert is triggered.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,24,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455779075,,"I managed to reproduce the paper mario crash BTW, I will investigate the issue thanks for reporting",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,25,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455779808,,"Yep, got an assert on stop:
A/libc: /home/fzurita/git_projects/mupen64plus/mupen64plus-ae/mupen64plus-core/./upstream/src/device/r4300/new_dynarec/new_dynarec.c:7713: void new_dynarec_cleanup(void): assertion ""copy_size==0"" failed

Although, I don't see how that assert couldn't fail...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,26,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455780073,,"hum ok something's probably wrong in kill/get_pointer, could you try setting DISABLE_BLOCK_LINKING?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,27,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455780279,,Adding a define for DISABLE_BLOCK_LINKING didn't fix it.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,28,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455780404,,That assert that triggers is always going to fail... copy_size is never assigned to anything but 0.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,29,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455780413,,Ok I have no idea what is going on,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,30,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455780496,,"That assert that triggers is always going to fail... copy_size is never assigned to anything but 0.

?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,31,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455780528,,"Never mind, I'm just mis-reading the code....",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,32,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455780649,,"Yeah, the assert happens even with DISABLE_BLOCK_LINKING set to 1.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,33,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455780828,,Why wouldn't ll_clear always leave copy_size equal to zero?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,34,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455781390,,"If it fails to free all dynamically allocated copy of original source code:
  copy=NULL;
  copy=(char*)malloc((slen*4)+4);
  assert(copy);
  copy_size+=((slen*4)+4);

which means it probably failed to get the correct address from get_copy_addr.
What I don't understand is why I cannot reproduce the issue.
Could you tell me which condition is taken:
  //copy
  offset=(((intptr_t)copy&~0xfffLL)-((intptr_t)out_rx&~0xfffLL));
  if((uintptr_t)copy<4294967296LL){
    emit_movz_lsl16(((uintptr_t)copy>>16)&0xffff,2);
    emit_movk(((uintptr_t)copy)&0xffff,2);
  }else if(offset>=-4294967296LL&&offset<4294967296LL){
    emit_adrp((intptr_t)copy,2);
    emit_addimm64(2,((intptr_t)copy&0xfffLL),2);
  }else{
    emit_loadlp((intptr_t)copy,2);
  }",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,35,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455781546,,"Ok, I feel silly now, I'm misunderstood how assert works... it will abort if the given condition is not true, not the other way around....",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,36,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455781699,,lol don't worry we're all tired during the weekend ;-),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,37,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455782220,,"There are two instances of that code in assem_arm64.c. In Mario 64, it's always the first instance of that code, and it's this condition }else if(offset>=-4294967296LL&&offset<4294967296LL)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,38,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455782355,,Ok thanks I will check,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,39,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455782685,,"If you want to try this yourself, all you need is a 64 bit android device and a PC with Android Studio 3.3.
The offending code is all checked in here: https://github.com/mupen64plus-ae/mupen64plus-ae/commits/master
To enable asserts, change this from release to debug:
https://github.com/mupen64plus-ae/mupen64plus-ae/blob/65de6d32a37a4d7455c4770b666a4fed843d6b38/mupen64plus-core/Application.mk#L5
and delete this code to reproduce the issue: https://github.com/mupen64plus-ae/mupen64plus-ae/blob/65de6d32a37a4d7455c4770b666a4fed843d6b38/app/src/main/java/paulscode/android/mupen64plusae/jni/CoreService.java#L166-L170",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,40,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455867627,,@fzurita I pushed a fix for Paper mario. Could you check it?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,41,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455867883,,Yep!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,42,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455868603,,Also a possible fix for the crash at exit. How did I not see this before!!!!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,43,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455868956,,Paper Mario crash fixed! Crash on stop fixed!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,44,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455869007,,Good to hear! Thanks for testing.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,45,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455869424,,BTW without c43dabc crash can also occur when reaching the end of the dynarec buffer. Banjo-tooie is a known candidate to reach the end of the buffer really quickly. So if you got reports of Banjo-tooie crashing this might also fix the issue.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,46,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455869527,,"Ok, thanks for the heads up!",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,47,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455872364,,@Gillou68310 are you going to include the performance fixes as part of this pull request?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,48,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-455873275,,"yep, I still have a few things to clean up before committing",True,"{'THUMBS_UP': ['https://github.com/fzurita', 'https://github.com/gjimenezf']}"
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,49,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-456394545,,"After all these fixes, I'm getting some reports of Pokemon Stadium 2 (U) crashing when starting a battle. I can't seem to reproduce it though.
Allegedly, it's happening when starting the game and using the ""Battle Now"" option.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,50,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-456398162,,I was able to reproduce. It only happens with the 32 bit arm new dynarec.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,51,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-456402688,,"Could you check if this is a regression, or if it was already there before my commits?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,52,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-456462950,,"This game used to work ok work the 32bit arm new dynarec. So it's a new issue. Not sure yet if from the original 64bit pull request or this one.
I can try to bisect which commit broke it if you wish, but it will have to wait until at least 12 hours from now.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,53,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-456463790,,Please yes it will save me a lot of time. Take your time BTW,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,54,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-456807609,,"It looks like this commit broke 32 bit arm dynarec:
9525ed4",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,55,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-456810604,,Thanks I'll investigate,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,56,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-457414281,,Smash brothers is also crashing when selecting VS mode option with 32bit arm new dynarec. Probably same issue.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,57,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-457540196,,"I do notice a small discrepancy between assem_arm.c and assem_arm64.c. In assem_arm64.c, you have a check for addr==0 in emit_writehword_indexed_tlb. You don't have that same check in assem_arm.c.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,58,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-457771132,,"Another issue, this is a game that used to work as well. Pokemon Puzzle league seems to crash with the 64 bit arm dynarec. It's easy to reproduce, start the game and select puzzle University and try to start a puzzle as a guest.
I was able to recreate the crash one time with the 32 bit arm dynarec, but it seems to happen much more rarely.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,59,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-457836927,,"@fzurita I pushed a fix for storelr, could you check it?

Another issue, this is a game that used to work as well. Pokemon Puzzle league seems to crash with the 64 bit arm dynarec. It's easy to reproduce, start the game and select puzzle University and try to start a puzzle as a guest.

The game doesn't even boot for me! When you say it used to work well, when was that?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,60,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-457837210,,"It boots ok right now, at least in Android. Only the 64bit arm dynarec has real issues. What's the md5 of your ROM?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,61,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-457837784,,E722576A15182CFED6782379CE4BC8BE,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/loganmc10,62,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-457837894,,"I ran into an issue a long time ago with the new dynarec and PPL, I don't think it was ever resolved:
#304",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,63,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-457838151,,"lol totally forget about this one, thanks @loganmc10 it's indeed the same issue on arm64, at least for my ROM",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,64,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-457838218,,@Gillou68310 that matches the md5 of my ROM. I wonder why it behaves differently? Compiler maybe?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,65,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-457838370,,You're testing release mode?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,66,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-457838400,,"Oh... I have asserts disabled by default on my build. That's probably why it's ""working"".",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,67,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-457838504,,yeah,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,68,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-457838562,,Ok since it's not regression I will deal with this later,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,69,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-457839406,,Pokemon Stadium 2 and smash brothers are both fixed with the last commit.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,70,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-457839480,,Cool,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,71,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-457840299,,Ready to merge,True,"{'ROCKET': ['https://github.com/m4xw', 'https://github.com/gjimenezf', 'https://github.com/Narann']}"
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,72,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458238469,,"Huh oh, something changed. I'm getting reports that Mario Tennis (U) is no longer booting. I tried it, and I can confirm, it doesn't crash, but it does hang before any frames are displayed. I can try to track down which commit broke it later.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,73,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458241638,,Yes please,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,74,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458289604,,Ok don't waste your time this is still caused by 9525ed4. I'll investigate further tomorrow.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,75,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458290938,,Ok,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,76,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458388545,,"@Gillou68310 with all the fixes you have done, the number of core dumps being reported has reduced drastically. I'm still seeing two core dumps being reported though, I can't tell if they are new since line number have changed for everything:
********** Crash dump: **********
#00 0x0000000000086948 ./libmupen64plus-core.so
   dma_sp_write
   ./device/rcp/rsp/rsp_core.c:58:33
   write_rsp_regs
   ./device/rcp/rsp/rsp_core.c:235:0
#01 0x000000000004d7c0 ./libmupen64plus-core.so
   mem_write32
   ./device/memory/memory.h:87:5
   r4300_write_aligned_word
   ./device/r4300/r4300_core.c:353:0
#02 0x0000000000080e84 ./libmupen64plus-core.so
   write_word_new
   ./device/r4300/new_dynarec/new_dynarec.c:11279:3
#03 0x0000000000122098 <anonymous>
Crash dump is completed

********** Crash dump: **********
#00 0x00000000000a7e48 ./libmupen64plus-core.so
   read_rdram_dram_corrupted
   ./device/rdram/rdram.c:90:14
#01 0x00000000000a10bc ./libmupen64plus-core.so
   mem_read32
   ./device/memory/memory.h:82:5
   r4300_read_aligned_word
   ./device/r4300/r4300_core.c:298:0
   read_byte_new
   ./device/r4300/new_dynarec/new_dynarec.c:11194:0
#02 0x0000000000037eb0 <anonymous>
Crash dump is completed

The core dumps are against this revision: 85c1630
Plus this patch applied (from you): fzurita/mupen64plus-ae@01e076c",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,77,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458390304,,"For the 2nd core dump, I could see a crash happening since this is the size of RDRAM:
rdram_size = (disable_extra_mem == 0) ? 0x800000 : 0x400000;

But in read_rdram_dram_corrupted where the crash happens the function rdram_dram_address only has this protection for addresses:
return (address & 0xffffff) >> 2;

So, I could see us going past the end of the dram array size.
Edit: Never mind, given an address of the maximum possible value of 0xffffff, you end up with a memory offset of 3FFFFF which is below the size of 0x400000, so I don't see how it's crashing.
Edit 2: It could definitely crash since 0x3FFFFFF is an address offset to an array of uint32 and rdram_size is in bytes. So maximum address offset for 0x800000 is 0x200000",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,78,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458390934,,"Similar issue in the first core dump,sp->mem array, we can go past the end of array there as well.
This seems to be the size of sp->mem
MB_RSP_MEM  = MB_CART_ROM   + CART_ROM_MAX_SIZE,",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,79,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458534563,,@Gillou68310 Here is a crazy idea. Have the new dynarec output code to LLVM IR instead of a specific architecture. Then we can have LLVM have an optimization pass on the generated code and have LLVM output to the right architecture.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,80,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458542698,,"Now that we have emitters for x86/x64/arm/arm64 it's a bit late don't you think?
However LLVM IR will be much more maintainable that's for sure.
Also I never used it so I don't know if we have full control over the optimized output.
Anyway it's not a crazy idea but I prefer having full control on the generated code ;-)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,81,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458543328,,"Lol, yeah, from a maintainability standpoint LLVM IR would be better. But you are right, you did all this work already for all the different architectures.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,82,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458543974,,I just pushed a fix for mario tennis. I hopefully covered all cases this time!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,83,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458544246,,Nice! I'll check it out,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,84,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458545769,,"Concerning the core dump, as usual I won't be able to investigate on it without being able to reproduce the issue, sorry.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,85,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458546007,,But good to hear the number of core dump reduced!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,86,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458549839,,Mario Tennis is not quiet working. I'm getting a core dump now.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,87,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458550629,,Could you share it? arm64 or arm32?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,88,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458550630,,"Back trace is not very useful:
2019-01-29 09:00:54.205 30088-30088/? I/crash_dump64: performing dump of process 30048 (target tid = 30075)
2019-01-29 09:00:54.205 30088-30088/? A/DEBUG: *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***
2019-01-29 09:00:54.205 30088-30088/? A/DEBUG: Build fingerprint: 'razer/cheryl/cheryl:8.1.0/OPM1.171019.011-RZR-180803/6033:user/release-keys'
2019-01-29 09:00:54.205 30088-30088/? A/DEBUG: Revision: '0'
2019-01-29 09:00:54.205 30088-30088/? A/DEBUG: ABI: 'arm64'
2019-01-29 09:00:54.205 30088-30088/? A/DEBUG: pid: 30048, tid: 30075, name: ServiceStartArg  >>> paulscode.android.mupen64plusae.GameActivity <<<
2019-01-29 09:00:54.205 30088-30088/? A/DEBUG: signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x100000004
2019-01-29 09:00:54.205 30088-30088/? A/DEBUG:     x0   000000734932f0e0  x1   00000000a0100000  x2   0000000000000001  x3   0000000000000001
2019-01-29 09:00:54.205 30088-30088/? A/DEBUG:     x4   0000000000800000  x5   00000000803fefe8  x6   0000000080300355  x7   0000000080300064
2019-01-29 09:00:54.205 30088-30088/? A/DEBUG:     x8   00000000a0100000  x9   0000000080031000  x10  00000000ffffffff  x11  00000000ffffffff
2019-01-29 09:00:54.205 30088-30088/? A/DEBUG:     x12  000000008c422ba0  x13  000000003c028003  x14  000000008c422ba0  x15  00000000038c422b
2019-01-29 09:00:54.205 30088-30088/? A/DEBUG:     x16  0000000100000000  x17  0000000080031000  x18  000000000000002f  x19  0000000000000000
2019-01-29 09:00:54.205 30088-30088/? A/DEBUG:     x20  0000000000c0bcee  x21  00000000a40002f4  x22  0000000000000000  x23  0000000000000001
2019-01-29 09:00:54.205 30088-30088/? A/DEBUG:     x24  0000000000000000  x25  00000000ffffffff  x26  00000000ffffffff  x27  0000000000000000
2019-01-29 09:00:54.205 30088-30088/? A/DEBUG:     x28  0000000000000000  x29  000000734bc30000  x30  0000007349c38c74
2019-01-29 09:00:54.205 30088-30088/? A/DEBUG:     sp   000000734d1fd390  pc   0000007349c38d24  pstate 0000000040000000
2019-01-29 09:00:54.206 30088-30088/? A/DEBUG: backtrace:
2019-01-29 09:00:54.207 30088-30088/? A/DEBUG:     #00 pc 0000000000008d24  <anonymous:0000007349c30000>
2019-01-29 09:00:54.207 30088-30088/? A/DEBUG:     #01 pc 0000000000008c70  <anonymous:0000007349c30000>

Crash dump is completed",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,89,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458550773,,arm64,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,90,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458551504,,32 bit doesn't crash.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,91,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458552403,,Where does it crash?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,92,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458554646,,Before it even shows a single frame.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,93,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458554883,,"Weird, it works on my odroid",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,94,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458555618,,BTW I forced push to master to avoid spamming the history with the same issue over and over,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,95,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458557445,,"I'll turn on asserts, maybe it will show something.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,96,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458559411,,"Huh, debug build didn't crash... Maybe I should a clean release build.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,97,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458562305,,"Yeah, very repeatable. Turning on optimization makes it crash, without optimization, it doesn't crash.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,98,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458568186,,"Lol yeah assert(genimm((uint64_t)imm,64,&armval)); in emit_andimm64",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,99,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458577831,,"Whoops, lol",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,100,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458588597,,"Ok, I can confirm, no more crash after getting that code out of the assert.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,101,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458601934,,"This is a weird one. I'm getting some new crash reports with bad back traces with these signals:
signal 5 (SIGTRAP), code 1 (TRAP_BRKPT)
Breakpoint?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,102,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458964314,,Yeah probably brk 0 instruction from linkage_arm64.S. Are you able to reproduce it?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,103,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458964849,,"BTW I did some work on block linking https://github.com/Gillou68310/mupen64plus-core/tree/block_linking
Could you test it when you got time?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,104,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458972990,,"Unfortunately, I can't reproduce it. I need add some kind of crash analytics to the app so that I can get which game they were playing when the issue happened. I pretty much rely right now on direct e-mails, reading reddit topics, and google play store reviews.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,105,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458973207,,"Oh, and yeah, sure, I'll check that branch out.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,106,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458975420,,What would it need to have at least the game name?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,107,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458975876,,Are we sure they are using the latest version BTW?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,108,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458982389,,They were running at least this revision: 0666982 but before you rebased it. I fixed the assert issue myself and put it in the google play store.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,109,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-458983862,,ok,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,110,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-459006003,,I did a test with a few games with your block_linking branch and it seems to run.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,111,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-459006704,,Ok do you see any perf impact?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,112,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-459008029,,"Performance seems mostly identical. Maybe a 1% improvement, but it's in the noise.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/Gillou68310,113,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-459014728,,Ok thanks for testing,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,114,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-460016983,,"@Gillou68310 what is the purpose of emitting brk instructions? It seems to make the new dynarec crash, at least in Android. I don't know what game is doing it though.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,115,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-460017393,,"I'm also seeing some ""illegal opcode"" crashes on this line of code:
./src/device/r4300/new_dynarec/arm64/linkage_arm64.S:197:0

Some android devices don't seem to like this:
    bl     get_addr_ht",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,116,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-460018107,,"Well, this is the cause for the illegal opcode: https://www.google.com/amp/s/www.theregister.co.uk/AMP/2016/09/13/arm_biglittle_gcc_bug/
Buggy samsung CPUs, these illegal instruction core dumps seem to be only happening with Exynos CPUs, specially Galaxy S7.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,606,2019-01-14T08:35:37Z,2019-01-26T17:44:34Z,2019-02-03T02:55:38Z,MERGED,True,688,1267,11,https://github.com/Gillou68310,new_dynarec fixes,12,[],https://github.com/mupen64plus/mupen64plus-core/pull/606,https://github.com/fzurita,117,https://github.com/mupen64plus/mupen64plus-core/pull/606#issuecomment-460018428,,Seems like an easy fix: https://github.com/dolphin-emu/dolphin/pull/4204/files,True,{'THUMBS_UP': ['https://github.com/gjimenezf']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,607,2019-01-15T01:54:01Z,2019-01-17T03:45:28Z,2019-01-17T03:45:28Z,MERGED,True,1,1,1,https://github.com/helviojr,Fix joy_max for initialize loop,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/607,https://github.com/helviojr,1,https://github.com/mupen64plus/mupen64plus-core/pull/607,"During SDL joystick initialization needed for core events hotkeys, the loop of all controllers, in case of a J* hotkey should stop on the last found controller (ex.: for four controllers, should go from J0 to J3, instead of J4).","During SDL joystick initialization needed for core events hotkeys, the loop of all controllers, in case of a J* hotkey should stop on the last found controller (ex.: for four controllers, should go from J0 to J3, instead of J4).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,611,2019-01-22T07:06:14Z,2019-01-23T01:11:47Z,2019-01-23T01:11:47Z,MERGED,True,0,4,1,https://github.com/bugfood,Remove DelaySI from wiki,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/611,https://github.com/bugfood,1,https://github.com/mupen64plus/mupen64plus-core/pull/611,This parameter was removed from the core in 0bcfd3c.,This parameter was removed from the core in 0bcfd3c.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,612,2019-01-25T06:33:17Z,2019-01-26T16:18:14Z,2019-01-27T03:31:30Z,MERGED,True,11,6,1,https://github.com/bugfood,Allow valid interpretations of strings as non-strings,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/612,https://github.com/bugfood,1,https://github.com/mupen64plus/mupen64plus-core/pull/612,"From the commit message of the second patch:
The various ConfigGetParamX() functions can handle string inputs
already, but ConfigGetParameter() rejects such inputs beforehand.

Modify ConfigGetParameter() to validate that a string represents a
numeric value. If so, then ConfigGetParamX() can handle the input.
Factor the checks into a new function to keep them from getting too 
long.

Use case:
Values read from the ui-console command line are always strings, by
necessity. When the config file is empty (or somehow lacking the 
specified parameter), then ui-console cannot know the desired type, so
it defaults to storing the parameter as a string. Without this patch,
this can result in plugin code ignoring a validly-specified
command-line parameter.

Use case:
Without this patch, if a user unknowingly specifies a float or integer
value in the config file within double-quotes, this can result in plugin
code ignoring the parameter.

Thanks,
Corey","From the commit message of the second patch:
The various ConfigGetParamX() functions can handle string inputs
already, but ConfigGetParameter() rejects such inputs beforehand.

Modify ConfigGetParameter() to validate that a string represents a
numeric value. If so, then ConfigGetParamX() can handle the input.
Factor the checks into a new function to keep them from getting too 
long.

Use case:
Values read from the ui-console command line are always strings, by
necessity. When the config file is empty (or somehow lacking the 
specified parameter), then ui-console cannot know the desired type, so
it defaults to storing the parameter as a string. Without this patch,
this can result in plugin code ignoring a validly-specified
command-line parameter.

Use case:
Without this patch, if a user unknowingly specifies a float or integer
value in the config file within double-quotes, this can result in plugin
code ignoring the parameter.

Thanks,
Corey",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,614,2019-01-29T13:53:54Z,2019-01-30T14:23:20Z,2019-01-31T14:20:30Z,MERGED,True,57,18,4,https://github.com/fzurita,Make stop_after_jal a save state parameter instead of configuration,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/614,https://github.com/fzurita,1,https://github.com/mupen64plus/mupen64plus-core/pull/614,That way it can be used when loading save states instead of having speculate recompilation always disabled for compatibility with save states.,That way it can be used when loading save states instead of having speculate recompilation always disabled for compatibility with save states.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,614,2019-01-29T13:53:54Z,2019-01-30T14:23:20Z,2019-01-31T14:20:30Z,MERGED,True,57,18,4,https://github.com/fzurita,Make stop_after_jal a save state parameter instead of configuration,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/614,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/614#issuecomment-458548747,That way it can be used when loading save states instead of having speculate recompilation always disabled for compatibility with save states.,"@Gillou68310 Here you go. It seems to work ok in my ARM devices, but it should probably be tested in a build with NEW_DYNAREC disabled.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,614,2019-01-29T13:53:54Z,2019-01-30T14:23:20Z,2019-01-31T14:20:30Z,MERGED,True,57,18,4,https://github.com/fzurita,Make stop_after_jal a save state parameter instead of configuration,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/614,https://github.com/fzurita,3,https://github.com/mupen64plus/mupen64plus-core/pull/614#issuecomment-458812590,That way it can be used when loading save states instead of having speculate recompilation always disabled for compatibility with save states.,Rebased against master branch.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,614,2019-01-29T13:53:54Z,2019-01-30T14:23:20Z,2019-01-31T14:20:30Z,MERGED,True,57,18,4,https://github.com/fzurita,Make stop_after_jal a save state parameter instead of configuration,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/614,https://github.com/fzurita,4,https://github.com/mupen64plus/mupen64plus-core/pull/614#issuecomment-458925661,That way it can be used when loading save states instead of having speculate recompilation always disabled for compatibility with save states.,Fixed build error when NEW_DYNAREC is not defined.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,614,2019-01-29T13:53:54Z,2019-01-30T14:23:20Z,2019-01-31T14:20:30Z,MERGED,True,57,18,4,https://github.com/fzurita,Make stop_after_jal a save state parameter instead of configuration,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/614,https://github.com/richard42,5,https://github.com/mupen64plus/mupen64plus-core/pull/614#issuecomment-459213645,That way it can be used when loading save states instead of having speculate recompilation always disabled for compatibility with save states.,"I was actually not going to merge this pull request. It has a problem. That 4k buffer at the end (data_0001_0200) was designed to be a fixed block for adding new parameters as necessary. You shouldn't have added a new stop_after_jal_data block after that data_0001_0200 block, you should have just used the empty space which still remains in that block.  The big new block of code which begins with:
else if (version == 0x00010500)
doesn't need to be there.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,614,2019-01-29T13:53:54Z,2019-01-30T14:23:20Z,2019-01-31T14:20:30Z,MERGED,True,57,18,4,https://github.com/fzurita,Make stop_after_jal a save state parameter instead of configuration,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/614,https://github.com/fzurita,6,https://github.com/mupen64plus/mupen64plus-core/pull/614#issuecomment-459214353,That way it can be used when loading save states instead of having speculate recompilation always disabled for compatibility with save states.,"Ok, gotcha, I missed that part of the design by not reading the code carefully enough. Feel free to rebase to remove to change from the master branch. I can make a new pull request tomorrow with the requested change.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,614,2019-01-29T13:53:54Z,2019-01-30T14:23:20Z,2019-01-31T14:20:30Z,MERGED,True,57,18,4,https://github.com/fzurita,Make stop_after_jal a save state parameter instead of configuration,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/614,https://github.com/Gillou68310,7,https://github.com/mupen64plus/mupen64plus-core/pull/614#issuecomment-459226313,That way it can be used when loading save states instead of having speculate recompilation always disabled for compatibility with save states.,Sorry @richard42 I missed that too when reviewing the PR. Do you want me to revert it in the meantime?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,614,2019-01-29T13:53:54Z,2019-01-30T14:23:20Z,2019-01-31T14:20:30Z,MERGED,True,57,18,4,https://github.com/fzurita,Make stop_after_jal a save state parameter instead of configuration,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/614,https://github.com/richard42,8,https://github.com/mupen64plus/mupen64plus-core/pull/614#issuecomment-459228591,That way it can be used when loading save states instead of having speculate recompilation always disabled for compatibility with save states.,"@fzurita it's not your fault. There ought to be some comments in that code explaining that feature of the design. It's not obvious from just looking at the code. Thanks for re-doing it.
@Gillou68310 if you don't mind reverting this you would save me the trouble. Thanks!",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,614,2019-01-29T13:53:54Z,2019-01-30T14:23:20Z,2019-01-31T14:20:30Z,MERGED,True,57,18,4,https://github.com/fzurita,Make stop_after_jal a save state parameter instead of configuration,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/614,https://github.com/fzurita,9,https://github.com/mupen64plus/mupen64plus-core/pull/614#issuecomment-459337285,That way it can be used when loading save states instead of having speculate recompilation always disabled for compatibility with save states.,"@Gillou68310 you don't have to revert if you don't want... I'll have an update to this code in #615
Also... I found a bug in the original code that makes save states produced with the NEW_DYNAREC defined to not load when the NEW_DYNAREC is not defined.
Edit: Turns what I found is not a bug... but somehow still, save states created in ARM devices don't seem to load in PC, even before this change.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,615,2019-01-30T16:01:37Z,2019-02-02T01:03:38Z,2019-02-02T01:04:52Z,MERGED,True,115,143,1,https://github.com/fzurita,Fixes for last save state update,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/615,https://github.com/fzurita,1,https://github.com/mupen64plus/mupen64plus-core/pull/615,Minor cleanup from last pull request. This disables Speculative recompilation when loading pj64 save states.,Minor cleanup from last pull request. This disables Speculative recompilation when loading pj64 save states.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,615,2019-01-30T16:01:37Z,2019-02-02T01:03:38Z,2019-02-02T01:04:52Z,MERGED,True,115,143,1,https://github.com/fzurita,Fixes for last save state update,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/615,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/615#issuecomment-459369341,Minor cleanup from last pull request. This disables Speculative recompilation when loading pj64 save states.,"I made some more corrections. The additional stop_after_jal data was not being stored in the correct place.  Because of that, the correct value was also not being read.
I did a quick test of writing a random value for the stop_after_jal flag and the same value was correctly read back.
In addition, we seem to be relying on unsigned int being 32 bits and short being 16 bits, which is not guaranteed by the C standard. So potentially, a save state created in one platform may not be compatible in another platform. I don't think this is the problem with not being able to load NEW_DYNAREC save states on builds without NEW_DYNAREC.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,615,2019-01-30T16:01:37Z,2019-02-02T01:03:38Z,2019-02-02T01:04:52Z,MERGED,True,115,143,1,https://github.com/fzurita,Fixes for last save state update,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/615,https://github.com/fzurita,3,https://github.com/mupen64plus/mupen64plus-core/pull/615#issuecomment-459711059,Minor cleanup from last pull request. This disables Speculative recompilation when loading pj64 save states.,@richard42 could you review and make comments or merge?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,615,2019-01-30T16:01:37Z,2019-02-02T01:03:38Z,2019-02-02T01:04:52Z,MERGED,True,115,143,1,https://github.com/fzurita,Fixes for last save state update,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/615,https://github.com/richard42,4,https://github.com/mupen64plus/mupen64plus-core/pull/615#issuecomment-459918528,Minor cleanup from last pull request. This disables Speculative recompilation when loading pj64 save states.,"yep, looks good to me.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,615,2019-01-30T16:01:37Z,2019-02-02T01:03:38Z,2019-02-02T01:04:52Z,MERGED,True,115,143,1,https://github.com/fzurita,Fixes for last save state update,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/615,https://github.com/fzurita,5,https://github.com/mupen64plus/mupen64plus-core/pull/615#issuecomment-459918679,Minor cleanup from last pull request. This disables Speculative recompilation when loading pj64 save states.,Thanks!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,618,2019-02-03T03:59:05Z,2019-02-03T13:03:20Z,2019-02-05T13:08:42Z,MERGED,True,43,25,5,https://github.com/fzurita,__clear_cache fix for ARM 64 devices plus ANDROID cleanup,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/618,https://github.com/fzurita,1,https://github.com/mupen64plus/mupen64plus-core/pull/618,"This implements a fix for a bug in some arm 64 bit CPUs as seen here:
dolphin-emu/dolphin#4204
Also, removed some ANDROID specific code that is no longer needed.
@Gillou68310 you should review this please. I didn't see any performance penalties.
Should we attribute the source of the fix in the code?","This implements a fix for a bug in some arm 64 bit CPUs as seen here:
dolphin-emu/dolphin#4204
Also, removed some ANDROID specific code that is no longer needed.
@Gillou68310 you should review this please. I didn't see any performance penalties.
Should we attribute the source of the fix in the code?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,618,2019-02-03T03:59:05Z,2019-02-03T13:03:20Z,2019-02-05T13:08:42Z,MERGED,True,43,25,5,https://github.com/fzurita,__clear_cache fix for ARM 64 devices plus ANDROID cleanup,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/618,https://github.com/Gillou68310,2,https://github.com/mupen64plus/mupen64plus-core/pull/618#issuecomment-460046500,"This implements a fix for a bug in some arm 64 bit CPUs as seen here:
dolphin-emu/dolphin#4204
Also, removed some ANDROID specific code that is no longer needed.
@Gillou68310 you should review this please. I didn't see any performance penalties.
Should we attribute the source of the fix in the code?","Well I don't like intrinsics but I guess I won't ask you to write it in assembly ;-)
You already gave the source in this PR I don't think it's necessary to add it in the source code.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,618,2019-02-03T03:59:05Z,2019-02-03T13:03:20Z,2019-02-05T13:08:42Z,MERGED,True,43,25,5,https://github.com/fzurita,__clear_cache fix for ARM 64 devices plus ANDROID cleanup,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/618,https://github.com/fzurita,3,https://github.com/mupen64plus/mupen64plus-core/pull/618#issuecomment-460048277,"This implements a fix for a bug in some arm 64 bit CPUs as seen here:
dolphin-emu/dolphin#4204
Also, removed some ANDROID specific code that is no longer needed.
@Gillou68310 you should review this please. I didn't see any performance penalties.
Should we attribute the source of the fix in the code?",Feel free to rewrite it in assembly :-),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,618,2019-02-03T03:59:05Z,2019-02-03T13:03:20Z,2019-02-05T13:08:42Z,MERGED,True,43,25,5,https://github.com/fzurita,__clear_cache fix for ARM 64 devices plus ANDROID cleanup,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/618,https://github.com/Gillou68310,4,https://github.com/mupen64plus/mupen64plus-core/pull/618#issuecomment-460049858,"This implements a fix for a bug in some arm 64 bit CPUs as seen here:
dolphin-emu/dolphin#4204
Also, removed some ANDROID specific code that is no longer needed.
@Gillou68310 you should review this please. I didn't see any performance penalties.
Should we attribute the source of the fix in the code?",Maybe later,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,618,2019-02-03T03:59:05Z,2019-02-03T13:03:20Z,2019-02-05T13:08:42Z,MERGED,True,43,25,5,https://github.com/fzurita,__clear_cache fix for ARM 64 devices plus ANDROID cleanup,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/618,https://github.com/fzurita,5,https://github.com/mupen64plus/mupen64plus-core/pull/618#issuecomment-460049910,"This implements a fix for a bug in some arm 64 bit CPUs as seen here:
dolphin-emu/dolphin#4204
Also, removed some ANDROID specific code that is no longer needed.
@Gillou68310 you should review this please. I didn't see any performance penalties.
Should we attribute the source of the fix in the code?",Ok to merge then?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,618,2019-02-03T03:59:05Z,2019-02-03T13:03:20Z,2019-02-05T13:08:42Z,MERGED,True,43,25,5,https://github.com/fzurita,__clear_cache fix for ARM 64 devices plus ANDROID cleanup,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/618,https://github.com/Gillou68310,6,https://github.com/mupen64plus/mupen64plus-core/pull/618#issuecomment-460050003,"This implements a fix for a bug in some arm 64 bit CPUs as seen here:
dolphin-emu/dolphin#4204
Also, removed some ANDROID specific code that is no longer needed.
@Gillou68310 you should review this please. I didn't see any performance penalties.
Should we attribute the source of the fix in the code?",Yep,True,{'THUMBS_UP': ['https://github.com/fzurita']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,618,2019-02-03T03:59:05Z,2019-02-03T13:03:20Z,2019-02-05T13:08:42Z,MERGED,True,43,25,5,https://github.com/fzurita,__clear_cache fix for ARM 64 devices plus ANDROID cleanup,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/618,https://github.com/fzurita,7,https://github.com/mupen64plus/mupen64plus-core/pull/618#issuecomment-460456505,"This implements a fix for a bug in some arm 64 bit CPUs as seen here:
dolphin-emu/dolphin#4204
Also, removed some ANDROID specific code that is no longer needed.
@Gillou68310 you should review this please. I didn't see any performance penalties.
Should we attribute the source of the fix in the code?","@Gillou68310 I'm getting a warning from static analysis with clang tidy (It was added on Android Studio 3.3):
Line 4453: Local variable 'memtarget' might not have been initialized

It may explain all the breakpoint crashes I have been seeing in the play store.
signal 5 (SIGTRAP), code 1 (TRAP_BRKPT)
Thoughts?
This is in the storelr_assemble function.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,618,2019-02-03T03:59:05Z,2019-02-03T13:03:20Z,2019-02-05T13:08:42Z,MERGED,True,43,25,5,https://github.com/fzurita,__clear_cache fix for ARM 64 devices plus ANDROID cleanup,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/618,https://github.com/Gillou68310,8,https://github.com/mupen64plus/mupen64plus-core/pull/618#issuecomment-460575250,"This implements a fix for a bug in some arm 64 bit CPUs as seen here:
dolphin-emu/dolphin#4204
Also, removed some ANDROID specific code that is no longer needed.
@Gillou68310 you should review this please. I didn't see any performance penalties.
Should we attribute the source of the fix in the code?","That uninitialized variable is bad and should be fixed but I don't think it's the cause of the breakpoint.
Currently SWL/SWR/SDL/SDR instructions have no fallback to interpreted opcode, which means that a store with no valid TLB map or an address outside RDRAM (eg: 0xa4000000) will trigger a breakpoint. This is true for all platform except ARM which has no breakpoint.
We really need to find the game that triggers this so I can implement interpreted fallback properly.",True,{'THUMBS_UP': ['https://github.com/fzurita']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,618,2019-02-03T03:59:05Z,2019-02-03T13:03:20Z,2019-02-05T13:08:42Z,MERGED,True,43,25,5,https://github.com/fzurita,__clear_cache fix for ARM 64 devices plus ANDROID cleanup,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/618,https://github.com/fzurita,9,https://github.com/mupen64plus/mupen64plus-core/pull/618#issuecomment-460629751,"This implements a fix for a bug in some arm 64 bit CPUs as seen here:
dolphin-emu/dolphin#4204
Also, removed some ANDROID specific code that is no longer needed.
@Gillou68310 you should review this please. I didn't see any performance penalties.
Should we attribute the source of the fix in the code?","Also, I'm still seeing some of these crashes with bad core dumps in arm64 devices:
signal 4 (SIGILL), code 1 (ILL_ILLOPC)

Any chance we are emitting some bad instruction? I'm not seeing it in arm32.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,618,2019-02-03T03:59:05Z,2019-02-03T13:03:20Z,2019-02-05T13:08:42Z,MERGED,True,43,25,5,https://github.com/fzurita,__clear_cache fix for ARM 64 devices plus ANDROID cleanup,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/618,https://github.com/Gillou68310,10,https://github.com/mupen64plus/mupen64plus-core/pull/618#issuecomment-460630468,"This implements a fix for a bug in some arm 64 bit CPUs as seen here:
dolphin-emu/dolphin#4204
Also, removed some ANDROID specific code that is no longer needed.
@Gillou68310 you should review this please. I didn't see any performance penalties.
Should we attribute the source of the fix in the code?",that's possible indeed,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,618,2019-02-03T03:59:05Z,2019-02-03T13:03:20Z,2019-02-05T13:08:42Z,MERGED,True,43,25,5,https://github.com/fzurita,__clear_cache fix for ARM 64 devices plus ANDROID cleanup,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/618,https://github.com/fzurita,11,https://github.com/mupen64plus/mupen64plus-core/pull/618#issuecomment-460630676,"This implements a fix for a bug in some arm 64 bit CPUs as seen here:
dolphin-emu/dolphin#4204
Also, removed some ANDROID specific code that is no longer needed.
@Gillou68310 you should review this please. I didn't see any performance penalties.
Should we attribute the source of the fix in the code?",Too bad I can't find which game,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,618,2019-02-03T03:59:05Z,2019-02-03T13:03:20Z,2019-02-05T13:08:42Z,MERGED,True,43,25,5,https://github.com/fzurita,__clear_cache fix for ARM 64 devices plus ANDROID cleanup,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/618,https://github.com/Gillou68310,12,https://github.com/mupen64plus/mupen64plus-core/pull/618#issuecomment-460631549,"This implements a fix for a bug in some arm 64 bit CPUs as seen here:
dolphin-emu/dolphin#4204
Also, removed some ANDROID specific code that is no longer needed.
@Gillou68310 you should review this please. I didn't see any performance penalties.
Should we attribute the source of the fix in the code?",¯_(ツ)_/¯,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,619,2019-02-03T21:47:32Z,2019-02-03T22:00:23Z,2019-02-03T22:47:28Z,MERGED,True,0,6,1,https://github.com/bugfood,do not force saving config when file not present,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/619,https://github.com/bugfood,1,https://github.com/mupen64plus/mupen64plus-core/pull/619,"Front-ends now ensure that configuration is saved (when desired) before
starting the game.","Front-ends now ensure that configuration is saved (when desired) before
starting the game.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,620,2019-02-04T04:21:02Z,2019-02-06T03:04:01Z,2019-02-06T03:04:01Z,CLOSED,False,57,3,1,https://github.com/bugfood,safer config file writing,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/620,https://github.com/bugfood,1,https://github.com/mupen64plus/mupen64plus-core/pull/620,"The configuration file writing is subject to two problem situations that
could end up leaving the file empty or with incomplete data:

If the program were to terminate while writing to the configuration
file.
If the system were to crash or lose power shortly after the program
has finished writing the configuration file.

These are covered in detail in:
https://lwn.net/Articles/457667/
https://lwn.net/Articles/322823/
Use a temporary file to mitigate issue #1.
Use fsync() on the file and the directory to mitigate issue #2. This is
not implemented for Windows because I was not able to find evidence that
Windows supports the necessary system calls (or wrappers); I can change
this if I get some feedback giving me direction.","The configuration file writing is subject to two problem situations that
could end up leaving the file empty or with incomplete data:

If the program were to terminate while writing to the configuration
file.
If the system were to crash or lose power shortly after the program
has finished writing the configuration file.

These are covered in detail in:
https://lwn.net/Articles/457667/
https://lwn.net/Articles/322823/
Use a temporary file to mitigate issue #1.
Use fsync() on the file and the directory to mitigate issue #2. This is
not implemented for Windows because I was not able to find evidence that
Windows supports the necessary system calls (or wrappers); I can change
this if I get some feedback giving me direction.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,620,2019-02-04T04:21:02Z,2019-02-06T03:04:01Z,2019-02-06T03:04:01Z,CLOSED,False,57,3,1,https://github.com/bugfood,safer config file writing,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/620,https://github.com/richard42,2,https://github.com/mupen64plus/mupen64plus-core/pull/620#issuecomment-460503165,"The configuration file writing is subject to two problem situations that
could end up leaving the file empty or with incomplete data:

If the program were to terminate while writing to the configuration
file.
If the system were to crash or lose power shortly after the program
has finished writing the configuration file.

These are covered in detail in:
https://lwn.net/Articles/457667/
https://lwn.net/Articles/322823/
Use a temporary file to mitigate issue #1.
Use fsync() on the file and the directory to mitigate issue #2. This is
not implemented for Windows because I was not able to find evidence that
Windows supports the necessary system calls (or wrappers); I can change
this if I get some feedback giving me direction.",This seems unnecessarily complicated. Have you ever experienced any corruption or data loss of the configuration file?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,620,2019-02-04T04:21:02Z,2019-02-06T03:04:01Z,2019-02-06T03:04:01Z,CLOSED,False,57,3,1,https://github.com/bugfood,safer config file writing,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/620,https://github.com/bugfood,3,https://github.com/mupen64plus/mupen64plus-core/pull/620#issuecomment-460512372,"The configuration file writing is subject to two problem situations that
could end up leaving the file empty or with incomplete data:

If the program were to terminate while writing to the configuration
file.
If the system were to crash or lose power shortly after the program
has finished writing the configuration file.

These are covered in detail in:
https://lwn.net/Articles/457667/
https://lwn.net/Articles/322823/
Use a temporary file to mitigate issue #1.
Use fsync() on the file and the directory to mitigate issue #2. This is
not implemented for Windows because I was not able to find evidence that
Windows supports the necessary system calls (or wrappers); I can change
this if I get some feedback giving me direction.","I have only noticed it when running under gdb and restarting the program during the config writing.
This was mostly an exercise to ""do the right thing"". In my experience, rare things eventually happen, given enough chances.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,620,2019-02-04T04:21:02Z,2019-02-06T03:04:01Z,2019-02-06T03:04:01Z,CLOSED,False,57,3,1,https://github.com/bugfood,safer config file writing,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/620,https://github.com/richard42,4,https://github.com/mupen64plus/mupen64plus-core/pull/620#issuecomment-460885937,"The configuration file writing is subject to two problem situations that
could end up leaving the file empty or with incomplete data:

If the program were to terminate while writing to the configuration
file.
If the system were to crash or lose power shortly after the program
has finished writing the configuration file.

These are covered in detail in:
https://lwn.net/Articles/457667/
https://lwn.net/Articles/322823/
Use a temporary file to mitigate issue #1.
Use fsync() on the file and the directory to mitigate issue #2. This is
not implemented for Windows because I was not able to find evidence that
Windows supports the necessary system calls (or wrappers); I can change
this if I get some feedback giving me direction.","I share your philosophy with doing the right thing, and of course rare things aren't impossible.. But at the same time, the harm is pretty small (just delete the file and a new one gets created). And complexity is the enemy of software development; everything that gets added has to justify its added complexity with new or improved functionality. And I don't think this one makes the cut, sorry.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,621,2019-02-09T01:38:45Z,2019-03-18T03:50:49Z,2019-03-18T03:51:04Z,CLOSED,False,92,18,6,https://github.com/fzurita,Allow 16MB of RDRAM,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/621,https://github.com/fzurita,1,https://github.com/mupen64plus/mupen64plus-core/pull/621,So allegedly the N64 allowed for up to expansions paks of 16MB. I modified the code to allow that. @bsmiles32 Does everything look right?,So allegedly the N64 allowed for up to expansions paks of 16MB. I modified the code to allow that. @bsmiles32 Does everything look right?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,621,2019-02-09T01:38:45Z,2019-03-18T03:50:49Z,2019-03-18T03:51:04Z,CLOSED,False,92,18,6,https://github.com/fzurita,Allow 16MB of RDRAM,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/621,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/621#issuecomment-462076233,So allegedly the N64 allowed for up to expansions paks of 16MB. I modified the code to allow that. @bsmiles32 Does everything look right?,@richard42 Do you think this is the right approach for save states?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,621,2019-02-09T01:38:45Z,2019-03-18T03:50:49Z,2019-03-18T03:51:04Z,CLOSED,False,92,18,6,https://github.com/fzurita,Allow 16MB of RDRAM,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/621,https://github.com/richard42,3,https://github.com/mupen64plus/mupen64plus-core/pull/621#issuecomment-462079614,So allegedly the N64 allowed for up to expansions paks of 16MB. I modified the code to allow that. @bsmiles32 Does everything look right?,"In order to retain backwards compatibility, the new data (extra 8MB of RDRAM) should be at the end of the savestate.  Also, I think we shouldn't merge this change until after the release.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,621,2019-02-09T01:38:45Z,2019-03-18T03:50:49Z,2019-03-18T03:51:04Z,CLOSED,False,92,18,6,https://github.com/fzurita,Allow 16MB of RDRAM,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/621,https://github.com/fzurita,4,https://github.com/mupen64plus/mupen64plus-core/pull/621#issuecomment-462079820,So allegedly the N64 allowed for up to expansions paks of 16MB. I modified the code to allow that. @bsmiles32 Does everything look right?,"Do you mean for older versions of the program to be able to load newer save states?
I did test loading older save states after this change and it works ok.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,621,2019-02-09T01:38:45Z,2019-03-18T03:50:49Z,2019-03-18T03:51:04Z,CLOSED,False,92,18,6,https://github.com/fzurita,Allow 16MB of RDRAM,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/621,https://github.com/fzurita,5,https://github.com/mupen64plus/mupen64plus-core/pull/621#issuecomment-462080042,So allegedly the N64 allowed for up to expansions paks of 16MB. I modified the code to allow that. @bsmiles32 Does everything look right?,"Also, if you think the save state modification is too much before the next release. I'll make another pull request that will fix some crashes I'm seeing without allowing the user to select 16MB of RDRAM or modifying save states.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,621,2019-02-09T01:38:45Z,2019-03-18T03:50:49Z,2019-03-18T03:51:04Z,CLOSED,False,92,18,6,https://github.com/fzurita,Allow 16MB of RDRAM,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/621,https://github.com/richard42,6,https://github.com/mupen64plus/mupen64plus-core/pull/621#issuecomment-462080183,So allegedly the N64 allowed for up to expansions paks of 16MB. I modified the code to allow that. @bsmiles32 Does everything look right?,I'm okay with a pull request to fix crashes. Are there any games or homebrew software which uses 16MB of RAM?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,621,2019-02-09T01:38:45Z,2019-03-18T03:50:49Z,2019-03-18T03:51:04Z,CLOSED,False,92,18,6,https://github.com/fzurita,Allow 16MB of RDRAM,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/621,https://github.com/fzurita,7,https://github.com/mupen64plus/mupen64plus-core/pull/621#issuecomment-462080888,So allegedly the N64 allowed for up to expansions paks of 16MB. I modified the code to allow that. @bsmiles32 Does everything look right?,"The only homebrew that I'm aware of is Super Mario 64 online, there may be others though. This pull request was only made because I saw the opportunity to allow 16MB of RDRAM while debugging some crash reports I got for my app in the Google Play store, Like this one: #606 (comment) and see the follow up post as to how it could crash.
I will create another pull request that I think will fix crashing.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,621,2019-02-09T01:38:45Z,2019-03-18T03:50:49Z,2019-03-18T03:51:04Z,CLOSED,False,92,18,6,https://github.com/fzurita,Allow 16MB of RDRAM,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/621,https://github.com/fzurita,8,https://github.com/mupen64plus/mupen64plus-core/pull/621#issuecomment-462084418,So allegedly the N64 allowed for up to expansions paks of 16MB. I modified the code to allow that. @bsmiles32 Does everything look right?,I think this will better protect against times when a save state is created when the core is running with 8MB of RDRAM and then it's loaded when the core is running with 4MB of RDRAM.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,621,2019-02-09T01:38:45Z,2019-03-18T03:50:49Z,2019-03-18T03:51:04Z,CLOSED,False,92,18,6,https://github.com/fzurita,Allow 16MB of RDRAM,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/621,https://github.com/fzurita,9,https://github.com/mupen64plus/mupen64plus-core/pull/621#issuecomment-473760829,So allegedly the N64 allowed for up to expansions paks of 16MB. I modified the code to allow that. @bsmiles32 Does everything look right?,Will redo this once the other pull request is accepted,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,623,2019-02-09T21:54:08Z,2020-11-14T13:44:08Z,2020-11-14T13:44:08Z,CLOSED,False,56,12,5,https://github.com/fzurita,Always allocate 16MB RDRAM even though only 8MB is supported,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/623,https://github.com/fzurita,1,https://github.com/mupen64plus/mupen64plus-core/pull/623,"Also, correctly check RDRAM size when saving and loading save states.
I think this will fix the crash that was reported here:
#606 (comment)","Also, correctly check RDRAM size when saving and loading save states.
I think this will fix the crash that was reported here:
#606 (comment)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,623,2019-02-09T21:54:08Z,2020-11-14T13:44:08Z,2020-11-14T13:44:08Z,CLOSED,False,56,12,5,https://github.com/fzurita,Always allocate 16MB RDRAM even though only 8MB is supported,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/623,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/623#issuecomment-462084017,"Also, correctly check RDRAM size when saving and loading save states.
I think this will fix the crash that was reported here:
#606 (comment)",@bsmiles32 Is this ok with you? I touched some of the areas you modified recently.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,623,2019-02-09T21:54:08Z,2020-11-14T13:44:08Z,2020-11-14T13:44:08Z,CLOSED,False,56,12,5,https://github.com/fzurita,Always allocate 16MB RDRAM even though only 8MB is supported,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/623,https://github.com/fzurita,3,https://github.com/mupen64plus/mupen64plus-core/pull/623#issuecomment-473760928,"Also, correctly check RDRAM size when saving and loading save states.
I think this will fix the crash that was reported here:
#606 (comment)","There is something wrong here, it causes South Park to not boot.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,623,2019-02-09T21:54:08Z,2020-11-14T13:44:08Z,2020-11-14T13:44:08Z,CLOSED,False,56,12,5,https://github.com/fzurita,Always allocate 16MB RDRAM even though only 8MB is supported,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/623,https://github.com/fzurita,4,https://github.com/mupen64plus/mupen64plus-core/pull/623#issuecomment-473761573,"Also, correctly check RDRAM size when saving and loading save states.
I think this will fix the crash that was reported here:
#606 (comment)","Ok, fixed.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,623,2019-02-09T21:54:08Z,2020-11-14T13:44:08Z,2020-11-14T13:44:08Z,CLOSED,False,56,12,5,https://github.com/fzurita,Always allocate 16MB RDRAM even though only 8MB is supported,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/623,https://github.com/Dolphin2Point1,5,https://github.com/mupen64plus/mupen64plus-core/pull/623#issuecomment-493283517,"Also, correctly check RDRAM size when saving and loading save states.
I think this will fix the crash that was reported here:
#606 (comment)",Wouldn't it just be much better to just select 16MB of ram? Why force it?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,623,2019-02-09T21:54:08Z,2020-11-14T13:44:08Z,2020-11-14T13:44:08Z,CLOSED,False,56,12,5,https://github.com/fzurita,Always allocate 16MB RDRAM even though only 8MB is supported,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/623,https://github.com/Dolphin2Point1,6,https://github.com/mupen64plus/mupen64plus-core/pull/623#issuecomment-493283611,"Also, correctly check RDRAM size when saving and loading save states.
I think this will fix the crash that was reported here:
#606 (comment)","It won't fix all games,  just a select few, so why the globalization?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,623,2019-02-09T21:54:08Z,2020-11-14T13:44:08Z,2020-11-14T13:44:08Z,CLOSED,False,56,12,5,https://github.com/fzurita,Always allocate 16MB RDRAM even though only 8MB is supported,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/623,https://github.com/fzurita,7,https://github.com/mupen64plus/mupen64plus-core/pull/623#issuecomment-493285941,"Also, correctly check RDRAM size when saving and loading save states.
I think this will fix the crash that was reported here:
#606 (comment)",I was only following the pattern of the 8MB implemention. Everything you say also applies to 8MB as well.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,623,2019-02-09T21:54:08Z,2020-11-14T13:44:08Z,2020-11-14T13:44:08Z,CLOSED,False,56,12,5,https://github.com/fzurita,Always allocate 16MB RDRAM even though only 8MB is supported,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/623,https://github.com/Dolphin2Point1,8,https://github.com/mupen64plus/mupen64plus-core/pull/623#issuecomment-493781990,"Also, correctly check RDRAM size when saving and loading save states.
I think this will fix the crash that was reported here:
#606 (comment)",hmmm,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,632,2019-02-20T02:22:37Z,2019-02-22T05:43:34Z,2019-02-22T05:43:34Z,MERGED,True,8,0,1,None,Add ppc64le support,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/632,None,1,https://github.com/mupen64plus/mupen64plus-core/pull/632,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,649,2019-05-24T09:46:10Z,,2020-12-30T21:15:53Z,OPEN,False,168,19,16,https://github.com/hissingshark,Build option to disable 64 Disk Drive support,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/649,https://github.com/hissingshark,1,https://github.com/mupen64plus/mupen64plus-core/pull/649,"There is a longstanding issue  since the addition of the 64 Disk Drive support.  This is causing some ARM devices to segfault at emulator start.
This commit adds a build option 64DISKDRIVE.
It defaults to 64DISKDRIVE=1 as I expect most devices are unaffected.
Those platforms vulnerable to it can use 64DISKDRIVE=0.
Many Thanks","There is a longstanding issue  since the addition of the 64 Disk Drive support.  This is causing some ARM devices to segfault at emulator start.
This commit adds a build option 64DISKDRIVE.
It defaults to 64DISKDRIVE=1 as I expect most devices are unaffected.
Those platforms vulnerable to it can use 64DISKDRIVE=0.
Many Thanks",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,649,2019-05-24T09:46:10Z,,2020-12-30T21:15:53Z,OPEN,False,168,19,16,https://github.com/hissingshark,Build option to disable 64 Disk Drive support,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/649,https://github.com/hissingshark,2,https://github.com/mupen64plus/mupen64plus-core/pull/649#issuecomment-495887344,"There is a longstanding issue  since the addition of the 64 Disk Drive support.  This is causing some ARM devices to segfault at emulator start.
This commit adds a build option 64DISKDRIVE.
It defaults to 64DISKDRIVE=1 as I expect most devices are unaffected.
Those platforms vulnerable to it can use 64DISKDRIVE=0.
Many Thanks","Ah, sorry forgot about the Visual C++ files:

mupen64plus-core.vcxproj
mupen64plus-core.vcxproj.filters

I think those explain the AppVeyor build fail.  Not familiar with configuring those and no way to test locally (no Windows box here) so will need to read up.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,649,2019-05-24T09:46:10Z,,2020-12-30T21:15:53Z,OPEN,False,168,19,16,https://github.com/hissingshark,Build option to disable 64 Disk Drive support,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/649,https://github.com/hissingshark,3,https://github.com/mupen64plus/mupen64plus-core/pull/649#issuecomment-497265720,"There is a longstanding issue  since the addition of the 64 Disk Drive support.  This is causing some ARM devices to segfault at emulator start.
This commit adds a build option 64DISKDRIVE.
It defaults to 64DISKDRIVE=1 as I expect most devices are unaffected.
Those platforms vulnerable to it can use 64DISKDRIVE=0.
Many Thanks","It seemed like there was a problem with the checks for desktop builds because the Makefile wasn't setting the pre-processor macro, but now I'm not so sure.
Regardless I've started again and made this a ""disable feature"" build option.  Now checking successfully.
NO_64DD=1      == build without 64 Disk Drive support
I hope this feature is acceptable.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,649,2019-05-24T09:46:10Z,,2020-12-30T21:15:53Z,OPEN,False,168,19,16,https://github.com/hissingshark,Build option to disable 64 Disk Drive support,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/649,https://github.com/richard42,4,https://github.com/mupen64plus/mupen64plus-core/pull/649#issuecomment-617458696,"There is a longstanding issue  since the addition of the 64 Disk Drive support.  This is causing some ARM devices to segfault at emulator start.
This commit adds a build option 64DISKDRIVE.
It defaults to 64DISKDRIVE=1 as I expect most devices are unaffected.
Those platforms vulnerable to it can use 64DISKDRIVE=0.
Many Thanks","I'm okay with this capability in general (being able to disable 64DD support at build time) but I have a problem with this implementation. There are 50 new #ifdef macro blocks in this merge request (that's a lot), and the function interfaces (internal API) are different depending upon whether or not this macro is defined.
There must be a simpler way to achieve this with fewer #ifdefs, like setting the dd_controller pointer to NULL if it's not supported, and keeping the existing internal API.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,649,2019-05-24T09:46:10Z,,2020-12-30T21:15:53Z,OPEN,False,168,19,16,https://github.com/hissingshark,Build option to disable 64 Disk Drive support,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/649,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/649#issuecomment-617460063,"There is a longstanding issue  since the addition of the 64 Disk Drive support.  This is causing some ARM devices to segfault at emulator start.
This commit adds a build option 64DISKDRIVE.
It defaults to 64DISKDRIVE=1 as I expect most devices are unaffected.
Those platforms vulnerable to it can use 64DISKDRIVE=0.
Many Thanks","I think it would be a lot better to figure out why the new dynarec crashes with 64DD support, there shouldn't really be a reason to remove DD support like this",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,649,2019-05-24T09:46:10Z,,2020-12-30T21:15:53Z,OPEN,False,168,19,16,https://github.com/hissingshark,Build option to disable 64 Disk Drive support,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/649,https://github.com/fzurita,6,https://github.com/mupen64plus/mupen64plus-core/pull/649#issuecomment-752760859,"There is a longstanding issue  since the addition of the 64 Disk Drive support.  This is causing some ARM devices to segfault at emulator start.
This commit adds a build option 64DISKDRIVE.
It defaults to 64DISKDRIVE=1 as I expect most devices are unaffected.
Those platforms vulnerable to it can use 64DISKDRIVE=0.
Many Thanks","Also, Android does not appear to have this problem. I agree with @loganmc10, if @hissingshark could provide a backtrace to the core dump, I'm sure the issue could be figured out.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,662,2019-07-12T13:44:13Z,2019-07-20T13:06:59Z,2019-07-20T13:06:59Z,CLOSED,False,3,0,1,https://github.com/dankcushions,Log error when VSync set fails.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/662,https://github.com/dankcushions,1,https://github.com/mupen64plus/mupen64plus-core/pull/662,This helped me track down ricrpi/mupen64plus-video-gles2n64#27,This helped me track down ricrpi/mupen64plus-video-gles2n64#27,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,662,2019-07-12T13:44:13Z,2019-07-20T13:06:59Z,2019-07-20T13:06:59Z,CLOSED,False,3,0,1,https://github.com/dankcushions,Log error when VSync set fails.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/662,https://github.com/dankcushions,2,https://github.com/mupen64plus/mupen64plus-core/pull/662#issuecomment-513466139,This helped me track down ricrpi/mupen64plus-video-gles2n64#27,Replaced by #670,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,666,2019-07-16T17:20:18Z,,2020-04-22T00:15:34Z,OPEN,False,23,0,3,https://github.com/mountainflaw,"Add speed limiter toggle, reintroduce SDL_PumpEvents for non-android platforms",2,[],https://github.com/mupen64plus/mupen64plus-core/pull/666,https://github.com/mountainflaw,1,https://github.com/mupen64plus/mupen64plus-core/pull/666,"The SDL_PumpEvents change fixes #646 , and is also required for the speed limiter toggle to not cause the emulator to hang.","The SDL_PumpEvents change fixes #646 , and is also required for the speed limiter toggle to not cause the emulator to hang.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,666,2019-07-16T17:20:18Z,,2020-04-22T00:15:34Z,OPEN,False,23,0,3,https://github.com/mountainflaw,"Add speed limiter toggle, reintroduce SDL_PumpEvents for non-android platforms",2,[],https://github.com/mupen64plus/mupen64plus-core/pull/666,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/666#issuecomment-572273142,"The SDL_PumpEvents change fixes #646 , and is also required for the speed limiter toggle to not cause the emulator to hang.","Android is stubbing out SDL now, so SDL_PumpEvents() can be safely introduced back without the ANDROID guard.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,670,2019-07-20T13:06:41Z,2019-11-07T15:32:45Z,2019-11-08T13:18:02Z,MERGED,True,15,6,1,https://github.com/dankcushions,Set VSync (SDL_GL_SetSwapInterval) after GL context is available,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/670,https://github.com/dankcushions,1,https://github.com/mupen64plus/mupen64plus-core/pull/670,"This fixes #663
In my case, before this fix VSync was always ON in linux and standalone commandline (--noosd) mupen64plus.","This fixes #663
In my case, before this fix VSync was always ON in linux and standalone commandline (--noosd) mupen64plus.",True,{'THUMBS_UP': ['https://github.com/hhromic']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,670,2019-07-20T13:06:41Z,2019-11-07T15:32:45Z,2019-11-08T13:18:02Z,MERGED,True,15,6,1,https://github.com/dankcushions,Set VSync (SDL_GL_SetSwapInterval) after GL context is available,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/670,https://github.com/dankcushions,2,https://github.com/mupen64plus/mupen64plus-core/pull/670#issuecomment-513719601,"This fixes #663
In my case, before this fix VSync was always ON in linux and standalone commandline (--noosd) mupen64plus.",the sdl 2 ifdefs are wrong now. will fix soon!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,670,2019-07-20T13:06:41Z,2019-11-07T15:32:45Z,2019-11-08T13:18:02Z,MERGED,True,15,6,1,https://github.com/dankcushions,Set VSync (SDL_GL_SetSwapInterval) after GL context is available,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/670,https://github.com/dankcushions,3,https://github.com/mupen64plus/mupen64plus-core/pull/670#issuecomment-513846139,"This fixes #663
In my case, before this fix VSync was always ON in linux and standalone commandline (--noosd) mupen64plus.",Building properly on non-SDL 2.0.0. now. Good to go!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,670,2019-07-20T13:06:41Z,2019-11-07T15:32:45Z,2019-11-08T13:18:02Z,MERGED,True,15,6,1,https://github.com/dankcushions,Set VSync (SDL_GL_SetSwapInterval) after GL context is available,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/670,https://github.com/dankcushions,4,https://github.com/mupen64plus/mupen64plus-core/pull/670#issuecomment-534639492,"This fixes #663
In my case, before this fix VSync was always ON in linux and standalone commandline (--noosd) mupen64plus.",Anything I can do to get this over the line? Seems to have gone a little quiet around here 👀,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,670,2019-07-20T13:06:41Z,2019-11-07T15:32:45Z,2019-11-08T13:18:02Z,MERGED,True,15,6,1,https://github.com/dankcushions,Set VSync (SDL_GL_SetSwapInterval) after GL context is available,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/670,https://github.com/psyke83,5,https://github.com/mupen64plus/mupen64plus-core/pull/670#issuecomment-537311873,"This fixes #663
In my case, before this fix VSync was always ON in linux and standalone commandline (--noosd) mupen64plus.","This appears to break mupen64plus on RPI4 when launched via an Xorg context. No window will appear, and In the log, I see Core Error: SDL swap interval (VSync) set failed: That operation is not supported, followed by an application hang.
It's late here, so I'll try to provide more detail after I've had more time to check it out. Presumably the solution is to omit the return M64ERR_SYSTEM_FAIL; entirely when the swap interval is not successfully changed, as it shouldn't be a fatal error. I'm not certain why the function is failing in the first place, though.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,670,2019-07-20T13:06:41Z,2019-11-07T15:32:45Z,2019-11-08T13:18:02Z,MERGED,True,15,6,1,https://github.com/dankcushions,Set VSync (SDL_GL_SetSwapInterval) after GL context is available,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/670,https://github.com/psyke83,6,https://github.com/mupen64plus/mupen64plus-core/pull/670#issuecomment-538161450,"This fixes #663
In my case, before this fix VSync was always ON in linux and standalone commandline (--noosd) mupen64plus.","Please disregard my last post - apologies. I didn't notice that my Xorg session was using the llvmpipe software render driver, which doesn't support setting the swap interval. After fixing that, the PR works fine, and fixes vsync with both the kmsdrm and x11 SDL2 drivers.
Without this PR, SDL_GL_SetSwapInterval returns the No OpenGL context has been made current SDL error. In a case such as this, the swap interval will depend on whatever default the internal driver sets... x11 and rpi is either 1 or -1 (adaptive sync), and kmsdrm defaults to 0. So this change is highly recommended to guarantee the user setting is applied correctly and consistently.",True,{'HOORAY': ['https://github.com/hhromic']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,670,2019-07-20T13:06:41Z,2019-11-07T15:32:45Z,2019-11-08T13:18:02Z,MERGED,True,15,6,1,https://github.com/dankcushions,Set VSync (SDL_GL_SetSwapInterval) after GL context is available,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/670,https://github.com/Gillou68310,7,https://github.com/mupen64plus/mupen64plus-core/pull/670#issuecomment-551119256,"This fixes #663
In my case, before this fix VSync was always ON in linux and standalone commandline (--noosd) mupen64plus.","@dankcushions I want to merge this, could you rebase and squash to one commit?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,670,2019-07-20T13:06:41Z,2019-11-07T15:32:45Z,2019-11-08T13:18:02Z,MERGED,True,15,6,1,https://github.com/dankcushions,Set VSync (SDL_GL_SetSwapInterval) after GL context is available,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/670,https://github.com/dankcushions,8,https://github.com/mupen64plus/mupen64plus-core/pull/670#issuecomment-551127131,"This fixes #663
In my case, before this fix VSync was always ON in linux and standalone commandline (--noosd) mupen64plus.",@Gillou68310 done!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,670,2019-07-20T13:06:41Z,2019-11-07T15:32:45Z,2019-11-08T13:18:02Z,MERGED,True,15,6,1,https://github.com/dankcushions,Set VSync (SDL_GL_SetSwapInterval) after GL context is available,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/670,https://github.com/Gillou68310,9,https://github.com/mupen64plus/mupen64plus-core/pull/670#issuecomment-551130980,"This fixes #663
In my case, before this fix VSync was always ON in linux and standalone commandline (--noosd) mupen64plus.",thanks,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,677,2019-09-22T08:22:01Z,2020-04-04T15:31:17Z,2020-04-05T07:28:26Z,CLOSED,False,8,0,1,https://github.com/flagrama,fix hard reset: reassign r4300_pc_struct after poweron call,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/677,https://github.com/flagrama,1,https://github.com/mupen64plus/mupen64plus-core/pull/677,"Fixes trying to assign to a null pointer on hard reset
Should fix #639","Fixes trying to assign to a null pointer on hard reset
Should fix #639",True,{'THUMBS_UP': ['https://github.com/hhromic']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,677,2019-09-22T08:22:01Z,2020-04-04T15:31:17Z,2020-04-05T07:28:26Z,CLOSED,False,8,0,1,https://github.com/flagrama,fix hard reset: reassign r4300_pc_struct after poweron call,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/677,https://github.com/hhromic,2,https://github.com/mupen64plus/mupen64plus-core/pull/677#issuecomment-536749017,"Fixes trying to assign to a null pointer on hard reset
Should fix #639","Hi, thanks for your PR. I'm one of the early reporters of the segfault-on-reset in the libretro version.
I tested your fix and unfortunately doesn't work for me. It still crashes when doing a hard-reset.
Therefore it doesn't fix #639
For what is worth, the libretro version solved the issue by doing a soft-reset instead:
libretro/mupen64plus-libretro-nx@76612f1
This solution have been working fine so far.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,677,2019-09-22T08:22:01Z,2020-04-04T15:31:17Z,2020-04-05T07:28:26Z,CLOSED,False,8,0,1,https://github.com/flagrama,fix hard reset: reassign r4300_pc_struct after poweron call,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/677,https://github.com/flagrama,3,https://github.com/mupen64plus/mupen64plus-core/pull/677#issuecomment-536807244,"Fixes trying to assign to a null pointer on hard reset
Should fix #639","Interesting. Both dynamic recompiler and pure interpreter hard reset fine for me with this change. I'm running it on Debian Linux but I'm not sure that should be an issue here. What OS did you try it on?
I've also been only building with the debugger functionality enabled, so I'm not sure if there is anything there that would change.
Just tried it on Windows x64 as well. Seems to work fine there too.

Actually I see you mention the libretro version which I haven't attempted anything with. I'll try to take a look at that.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,677,2019-09-22T08:22:01Z,2020-04-04T15:31:17Z,2020-04-05T07:28:26Z,CLOSED,False,8,0,1,https://github.com/flagrama,fix hard reset: reassign r4300_pc_struct after poweron call,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/677,https://github.com/flagrama,4,https://github.com/mupen64plus/mupen64plus-core/pull/677#issuecomment-536820745,"Fixes trying to assign to a null pointer on hard reset
Should fix #639","It works fine on mupen64plus-libretro-nx master, crashes with the following on develop;
Starting program: /usr/bin/retroarch -L mupen64plus_next_libretro.so ~/Public/Emu/ROM/Legend\ of\ Zelda\,\ The\ -\ Ocarina\ of\ Time\ \(USA\).n64
[Thread debugging using libthread_db enabled]
Using host libthread_db library ""/lib/x86_64-linux-gnu/libthread_db.so.1"".
[New Thread 0x7fffec9bc700 (LWP 26320)]
[New Thread 0x7fffdbf9b700 (LWP 26321)]
[New Thread 0x7fffd9521700 (LWP 26322)]
[New Thread 0x7fffd8d20700 (LWP 26323)]
[New Thread 0x7fffd851f700 (LWP 26324)]
[New Thread 0x7fffb751f700 (LWP 26325)]
[New Thread 0x7fffb6d1e700 (LWP 26326)]
[New Thread 0x7fffb651d700 (LWP 26327)]
[New Thread 0x7fffb5d1c700 (LWP 26328)]
[New Thread 0x7fffb551b700 (LWP 26329)]
[New Thread 0x7fffb4d1a700 (LWP 26330)]
[New Thread 0x7fff7ffff700 (LWP 26333)]

Thread 1 ""retroarch"" received signal SIGSEGV, Segmentation fault.
0x00007fffdee1a7c0 in cached_interp_MTC0 () at mupen64plus-core/src/device/r4300/mips_instructions.def:1188
1188	        cp0_regs[CP0_INDEX_REG] = rrt32 & UINT32_C(0x8000003F);
(gdb) bt full
#0  0x00007fffdee1a7c0 in cached_interp_MTC0 () at mupen64plus-core/src/device/r4300/mips_instructions.def:1188
        r4300 = 0x7fffe86ec000 <g_dev>
        cp0_regs = 0x7fffeafed258 <g_dev+42996312>
        cp0_next_interrupt = 0x7fffeafed100 <g_dev+42995968>
        __PRETTY_FUNCTION__ = ""cached_interp_MTC0""
#1  0x00007fffdeea9dec in MTC0_new (copr=13, count=20622, diff=0, pcaddr=-1543503688) at mupen64plus-core/src/device/r4300/new_dynarec/new_dynarec.c:11187
        r4300 = 0x7fffe86ec000 <g_dev>
#2  0x00007fffe8fed7a5 in g_dev () at /home/vcunningham/Public/src/mupen64plus-libretro-nx/mupen64plus_next_libretro.so
#3  0xa40000b8ffffffff in  ()
#4  0x00007fffe86ec000 in g_dev () at /home/vcunningham/Public/src/mupen64plus-libretro-nx/mupen64plus_next_libretro.so
#5  0x0000555556cfc340 in  ()
#6  0x0000080000000800 in  ()
#7  0x00007fffddd23e20 in  ()
#8  0x00007fffdee79240 in dyna_linkerPython Exception <class 'gdb.MemoryError'> Cannot access memory at address 0xffffffffffffffc8: 
(gdb) info threads
 (src=  Id   Target Id                                          Frame 
* 1    Thread 0x7fffec9f2ec0 (LWP 26319) ""retroarch""      0x00007fffdee1a7c0 in cached_interp_MTC0 () at mupen64plus-core/src/device/r4300/mips_instructions.def:1188
  2    Thread 0x7fffec9bc700 (LWP 26320) ""retroarch""      futex_wait_cancelable (private=0, expected=0, futex_word=0x555555a678bc) at ../sysdeps/unix/sysv/linux/futex-internal.h:88
  3    Thread 0x7fffdbf9b700 (LWP 26321) ""retroarch:cs0""  futex_wait_cancelable (private=0, expected=0, futex_word=0x555555f9affc) at ../sysdeps/unix/sysv/linux/futex-internal.h:88
  4    Thread 0x7fffd9521700 (LWP 26322) ""retroar:disk$0"" futex_wait_cancelable (private=0, expected=0, futex_word=0x555555f9f158) at ../sysdeps/unix/sysv/linux/futex-internal.h:88
  5    Thread 0x7fffd8d20700 (LWP 26323) ""retroarch:sh0""  futex_wait_cancelable (private=0, expected=0, futex_word=0x555555f9c3e4) at ../sysdeps/unix/sysv/linux/futex-internal.h:88
  6    Thread 0x7fffd851f700 (LWP 26324) ""retroarch:sh1""  futex_wait_cancelable (private=0, expected=0, futex_word=0x555555f9c3e0) at ../sysdeps/unix/sysv/linux/futex-internal.h:88
  7    Thread 0x7fffb751f700 (LWP 26325) ""retroarch:sh2""  futex_wait_cancelable (private=0, expected=0, futex_word=0x555555f9c3e4) at ../sysdeps/unix/sysv/linux/futex-internal.h:88
  8    Thread 0x7fffb6d1e700 (LWP 26326) ""retroarch:sh3""  futex_wait_cancelable (private=0, expected=0, futex_word=0x555555f9c3e0) at ../sysdeps/unix/sysv/linux/futex-internal.h:88
  9    Thread 0x7fffb651d700 (LWP 26327) ""retroarc:shlo0"" futex_wait_cancelable (private=0, expected=0, futex_word=0x555555f9c960) at ../sysdeps/unix/sysv/linux/futex-internal.h:88
  10   Thread 0x7fffb5d1c700 (LWP 26328) ""retroarc:shlo1"" futex_wait_cancelable (private=0, expected=0, futex_word=0x555555f9c960) at ../sysdeps/unix/sysv/linux/futex-internal.h:88
  11   Thread 0x7fffb551b700 (LWP 26329) ""retroarc:shlo2"" futex_wait_cancelable (private=0, expected=0, futex_word=0x555555f9c960) at ../sysdeps/unix/sysv/linux/futex-internal.h:88
  12   Thread 0x7fffb4d1a700 (LWP 26330) ""retroarc:gdrv0"" futex_wait_cancelable (private=0, expected=0, futex_word=0x5555562ab2ec) at ../sysdeps/unix/sysv/linux/futex-internal.h:88
  13   Thread 0x7fff7ffff700 (LWP 26333) ""threaded-ml""    0x00007ffff4391edf in __GI___poll (fds=0x7fff78007180, nfds=3, timeout=-1) at ../sysdeps/unix/sysv/linux/poll.c:29
(gdb)```",True,{'THUMBS_UP': ['https://github.com/hhromic']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,677,2019-09-22T08:22:01Z,2020-04-04T15:31:17Z,2020-04-05T07:28:26Z,CLOSED,False,8,0,1,https://github.com/flagrama,fix hard reset: reassign r4300_pc_struct after poweron call,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/677,https://github.com/hhromic,5,https://github.com/mupen64plus/mupen64plus-core/pull/677#issuecomment-536926331,"Fixes trying to assign to a null pointer on hard reset
Should fix #639","Thanks for testing!
I'm using Raspbian Stretch on a Raspberry Pi 3B+.
Yes I should have mention more details of my testing setup. Indeed I'm using mupen64plus-next from the develop branch (the active dev branch) and not master.
Indeed interesting that it crashes with the develop branch and not master. Let me know if you need any further test or debugging output from my side to help.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,677,2019-09-22T08:22:01Z,2020-04-04T15:31:17Z,2020-04-05T07:28:26Z,CLOSED,False,8,0,1,https://github.com/flagrama,fix hard reset: reassign r4300_pc_struct after poweron call,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/677,https://github.com/flagrama,6,https://github.com/mupen64plus/mupen64plus-core/pull/677#issuecomment-537266156,"Fixes trying to assign to a null pointer on hard reset
Should fix #639","It seems that this fixes hard reset on the pure interpreter. It is very likely I had set this when I tried to reset on master.
The master and develop branches seem to crash the same way when using the dynamic recompiler. I'm still not running into this particular issue when building the normal mupen64plus-core built from this repo. It seems to restart properly even using dynarec, though other issues do still crop up for me after a hard reset with dynarec enabled. These might just be an issue with the GUI I'm using though.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,677,2019-09-22T08:22:01Z,2020-04-04T15:31:17Z,2020-04-05T07:28:26Z,CLOSED,False,8,0,1,https://github.com/flagrama,fix hard reset: reassign r4300_pc_struct after poweron call,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/677,https://github.com/flagrama,7,https://github.com/mupen64plus/mupen64plus-core/pull/677#issuecomment-537641764,"Fixes trying to assign to a null pointer on hard reset
Should fix #639","Seems like there was a lot more than just a null pointer going on. Going by how the initial run code happens, it seems to use this run_device function that hard_reset wasn't doing. Adding this call to the hard_reset handler seems to have fixed hard reset in all three emulation modes for me now.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,677,2019-09-22T08:22:01Z,2020-04-04T15:31:17Z,2020-04-05T07:28:26Z,CLOSED,False,8,0,1,https://github.com/flagrama,fix hard reset: reassign r4300_pc_struct after poweron call,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/677,https://github.com/hhromic,8,https://github.com/mupen64plus/mupen64plus-core/pull/677#issuecomment-537671333,"Fixes trying to assign to a null pointer on hard reset
Should fix #639",Ah nice! I'll try it asap on the mupen-next libretro core (develop branch) and report back! Thanks!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,677,2019-09-22T08:22:01Z,2020-04-04T15:31:17Z,2020-04-05T07:28:26Z,CLOSED,False,8,0,1,https://github.com/flagrama,fix hard reset: reassign r4300_pc_struct after poweron call,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/677,https://github.com/flagrama,9,https://github.com/mupen64plus/mupen64plus-core/pull/677#issuecomment-537735859,"Fixes trying to assign to a null pointer on hard reset
Should fix #639","The previous code seemed to be creating another instance of the emulator each time hard reset was used, so RAM usage would just continue to grow after each hard reset. These small changes seem to actually solve most of the problems.
The only thing I seem to actually be running into an issue with is what I assume would be ""old dynarec"" where after a hard reset closing the ROM just results in an endless loop of Core Warning: Instruction pointer is 0 at dyna_stop(). The three other emumodes work fine though it seems.",True,{'ROCKET': ['https://github.com/hhromic']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,677,2019-09-22T08:22:01Z,2020-04-04T15:31:17Z,2020-04-05T07:28:26Z,CLOSED,False,8,0,1,https://github.com/flagrama,fix hard reset: reassign r4300_pc_struct after poweron call,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/677,https://github.com/hhromic,10,https://github.com/mupen64plus/mupen64plus-core/pull/677#issuecomment-538065909,"Fixes trying to assign to a null pointer on hard reset
Should fix #639","Thanks for your work on this!
I had the chance to test now. Indeed the changes you did couple of days ago didn't work very well (games segfault after reset) but the recent changes you did yesterday seem to be working fine now with the libretro version!
I tested the dynarec, pure interpreter and cached interpreter emulation modes and the hard reset function is working as expected in all of them for me. So far I tested with couple of games and I don't notice issues.
I also tested closing the ROM and found no issues (the mupen next libretro version by default uses the new dynarec).
So in summary, thanks again for fixing this long-standing bug.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,677,2019-09-22T08:22:01Z,2020-04-04T15:31:17Z,2020-04-05T07:28:26Z,CLOSED,False,8,0,1,https://github.com/flagrama,fix hard reset: reassign r4300_pc_struct after poweron call,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/677,https://github.com/flagrama,11,https://github.com/mupen64plus/mupen64plus-core/pull/677#issuecomment-538219243,"Fixes trying to assign to a null pointer on hard reset
Should fix #639","Good to know this seems to be at least ""good enough.""
Through some more experimentation it seems that the following code will also get old dynarec to play along. Unfortunately I have no idea what these variables actually are and if persisting them over a hard reset defeats the purpose of a hard reset or not. As such I won't be adding them to this PR currently.
    long long save_rsp = r4300->recomp.save_rsp;
    long long save_rip = r4300->recomp.save_rip;

    poweron_device(dev);
/* snip */
    if(r4300->emumode >= 2)
    {
#ifdef NEW_DYNAREC
        new_dynarec_cleanup();
        new_dynarec_init();
#else
        r4300->recomp.save_rsp = save_rsp;
        r4300->recomp.save_rip = save_rip;
#endif
    }",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,677,2019-09-22T08:22:01Z,2020-04-04T15:31:17Z,2020-04-05T07:28:26Z,CLOSED,False,8,0,1,https://github.com/flagrama,fix hard reset: reassign r4300_pc_struct after poweron call,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/677,https://github.com/bsmiles32,12,https://github.com/mupen64plus/mupen64plus-core/pull/677#issuecomment-609045575,"Fixes trying to assign to a null pointer on hard reset
Should fix #639","Merged via PR #746 which includes the save_rsp, save_rip bits.
Thanks to all involved !",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,677,2019-09-22T08:22:01Z,2020-04-04T15:31:17Z,2020-04-05T07:28:26Z,CLOSED,False,8,0,1,https://github.com/flagrama,fix hard reset: reassign r4300_pc_struct after poweron call,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/677,None,13,https://github.com/mupen64plus/mupen64plus-core/pull/677#issuecomment-609372328,"Fixes trying to assign to a null pointer on hard reset
Should fix #639","This is completely wrong for non-x86-64. Here is the definition from src/device/r4300/r4300_core.h
127 #if defined(__x86_64__)
128         long long save_rsp;
129         long long save_rip;
130 
131         /* that's where the dynarec will restart when going back from a C function */
132         unsigned long long* return_address;
133 #else
134         long save_ebp;
135         long save_ebx;
136         long save_esi;
137         long save_edi;
138         long save_esp;
139         long save_eip;
140 
141         /* that's where the dynarec will restart when going back from a C function */
142         unsigned long* return_address;
143 #endif",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,682,2019-10-21T10:02:35Z,2019-12-27T11:40:46Z,2019-12-29T20:02:01Z,MERGED,True,1,2,1,https://github.com/Nabile-Rahmani,MPAL's refresh rate is 60 Hz,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/682,https://github.com/Nabile-Rahmani,1,https://github.com/mupen64plus/mupen64plus-core/pull/682,"See: https://en.wikipedia.org/wiki/PAL-M

It is unique among analog TV systems in that it combines the 525-line 30 frames-per-second System M with the PAL colour encoding system (using very nearly the NTSC colour subcarrier frequency), unlike all other countries which pair PAL with 625-line systems and NTSC with 525-line systems.","See: https://en.wikipedia.org/wiki/PAL-M

It is unique among analog TV systems in that it combines the 525-line 30 frames-per-second System M with the PAL colour encoding system (using very nearly the NTSC colour subcarrier frequency), unlike all other countries which pair PAL with 625-line systems and NTSC with 525-line systems.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,682,2019-10-21T10:02:35Z,2019-12-27T11:40:46Z,2019-12-29T20:02:01Z,MERGED,True,1,2,1,https://github.com/Nabile-Rahmani,MPAL's refresh rate is 60 Hz,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/682,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/682#issuecomment-569252650,"See: https://en.wikipedia.org/wiki/PAL-M

It is unique among analog TV systems in that it combines the 525-line 30 frames-per-second System M with the PAL colour encoding system (using very nearly the NTSC colour subcarrier frequency), unlike all other countries which pair PAL with 625-line systems and NTSC with 525-line systems.",Looks OK to me.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,685,2019-10-27T14:30:23Z,2019-10-27T14:47:18Z,2019-12-29T20:26:38Z,CLOSED,False,2,2,2,https://github.com/fzurita,Allow carts of up to 240 MB,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/685,https://github.com/fzurita,1,https://github.com/mupen64plus/mupen64plus-core/pull/685,"From some discord conversations, some ROMs that are greater than 64MB are causing the core to crash. These ROMs run on the real console, so it's definitely an issue in the core. Making the below two changes allows these ROMs to run with no perceived issues. From discord conversations, the maximum allowed ROM is 240 MB.
Also, searching through the code, there are a number of other places where 0x3FFFFFF is being used as a mask. It's hard to tell how many of these places refer to ROM address offsets. So this change may allow data to be stored past 64MB, but game code past that point may still have issues.","From some discord conversations, some ROMs that are greater than 64MB are causing the core to crash. These ROMs run on the real console, so it's definitely an issue in the core. Making the below two changes allows these ROMs to run with no perceived issues. From discord conversations, the maximum allowed ROM is 240 MB.
Also, searching through the code, there are a number of other places where 0x3FFFFFF is being used as a mask. It's hard to tell how many of these places refer to ROM address offsets. So this change may allow data to be stored past 64MB, but game code past that point may still have issues.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,685,2019-10-27T14:30:23Z,2019-10-27T14:47:18Z,2019-12-29T20:26:38Z,CLOSED,False,2,2,2,https://github.com/fzurita,Allow carts of up to 240 MB,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/685,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/685#issuecomment-546700919,"From some discord conversations, some ROMs that are greater than 64MB are causing the core to crash. These ROMs run on the real console, so it's definitely an issue in the core. Making the below two changes allows these ROMs to run with no perceived issues. From discord conversations, the maximum allowed ROM is 240 MB.
Also, searching through the code, there are a number of other places where 0x3FFFFFF is being used as a mask. It's hard to tell how many of these places refer to ROM address offsets. So this change may allow data to be stored past 64MB, but game code past that point may still have issues.","These are a few other places where the code may need to be updated as well, but I'm not 100% sure:
https://github.com/mupen64plus/mupen64plus-core/blob/master/src/device/r4300/new_dynarec/arm64/assem_arm64.c#L302
https://github.com/mupen64plus/mupen64plus-core/blob/master/src/device/r4300/new_dynarec/arm64/assem_arm64.c#L960
https://github.com/mupen64plus/mupen64plus-core/blob/master/src/device/r4300/new_dynarec/arm64/assem_arm64.c#L5171
https://github.com/mupen64plus/mupen64plus-core/blob/master/src/device/r4300/cached_interp.c#L406
https://github.com/mupen64plus/mupen64plus-core/blob/master/src/device/r4300/idec.c#L68
https://github.com/mupen64plus/mupen64plus-core/blob/master/src/device/r4300/pure_interp.c#L102",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,685,2019-10-27T14:30:23Z,2019-10-27T14:47:18Z,2019-12-29T20:26:38Z,CLOSED,False,2,2,2,https://github.com/fzurita,Allow carts of up to 240 MB,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/685,https://github.com/fzurita,3,https://github.com/mupen64plus/mupen64plus-core/pull/685#issuecomment-546700990,"From some discord conversations, some ROMs that are greater than 64MB are causing the core to crash. These ROMs run on the real console, so it's definitely an issue in the core. Making the below two changes allows these ROMs to run with no perceived issues. From discord conversations, the maximum allowed ROM is 240 MB.
Also, searching through the code, there are a number of other places where 0x3FFFFFF is being used as a mask. It's hard to tell how many of these places refer to ROM address offsets. So this change may allow data to be stored past 64MB, but game code past that point may still have issues.",@Gillou68310 Do you agree with those other places?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,685,2019-10-27T14:30:23Z,2019-10-27T14:47:18Z,2019-12-29T20:26:38Z,CLOSED,False,2,2,2,https://github.com/fzurita,Allow carts of up to 240 MB,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/685,https://github.com/fzurita,4,https://github.com/mupen64plus/mupen64plus-core/pull/685#issuecomment-546701460,"From some discord conversations, some ROMs that are greater than 64MB are causing the core to crash. These ROMs run on the real console, so it's definitely an issue in the core. Making the below two changes allows these ROMs to run with no perceived issues. From discord conversations, the maximum allowed ROM is 240 MB.
Also, searching through the code, there are a number of other places where 0x3FFFFFF is being used as a mask. It's hard to tell how many of these places refer to ROM address offsets. So this change may allow data to be stored past 64MB, but game code past that point may still have issues.","Never mind, CBFD crashes when the ROM mask is changed.... I'll look more into it.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,685,2019-10-27T14:30:23Z,2019-10-27T14:47:18Z,2019-12-29T20:26:38Z,CLOSED,False,2,2,2,https://github.com/fzurita,Allow carts of up to 240 MB,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/685,https://github.com/Gillou68310,5,https://github.com/mupen64plus/mupen64plus-core/pull/685#issuecomment-546718557,"From some discord conversations, some ROMs that are greater than 64MB are causing the core to crash. These ROMs run on the real console, so it's definitely an issue in the core. Making the below two changes allows these ROMs to run with no perceived issues. From discord conversations, the maximum allowed ROM is 240 MB.
Also, searching through the code, there are a number of other places where 0x3FFFFFF is being used as a mask. It's hard to tell how many of these places refer to ROM address offsets. So this change may allow data to be stored past 64MB, but game code past that point may still have issues.",The changes in assem_arm64 are wrong for sure. Not sure about the others I can't check in details rn,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,685,2019-10-27T14:30:23Z,2019-10-27T14:47:18Z,2019-12-29T20:26:38Z,CLOSED,False,2,2,2,https://github.com/fzurita,Allow carts of up to 240 MB,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/685,https://github.com/fzurita,6,https://github.com/mupen64plus/mupen64plus-core/pull/685#issuecomment-546719277,"From some discord conversations, some ROMs that are greater than 64MB are causing the core to crash. These ROMs run on the real console, so it's definitely an issue in the core. Making the below two changes allows these ROMs to run with no perceived issues. From discord conversations, the maximum allowed ROM is 240 MB.
Also, searching through the code, there are a number of other places where 0x3FFFFFF is being used as a mask. It's hard to tell how many of these places refer to ROM address offsets. So this change may allow data to be stored past 64MB, but game code past that point may still have issues.","Ok, thanks for checking.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,685,2019-10-27T14:30:23Z,2019-10-27T14:47:18Z,2019-12-29T20:26:38Z,CLOSED,False,2,2,2,https://github.com/fzurita,Allow carts of up to 240 MB,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/685,https://github.com/Nabile-Rahmani,7,https://github.com/mupen64plus/mupen64plus-core/pull/685#issuecomment-569537738,"From some discord conversations, some ROMs that are greater than 64MB are causing the core to crash. These ROMs run on the real console, so it's definitely an issue in the core. Making the below two changes allows these ROMs to run with no perceived issues. From discord conversations, the maximum allowed ROM is 240 MB.
Also, searching through the code, there are a number of other places where 0x3FFFFFF is being used as a mask. It's hard to tell how many of these places refer to ROM address offsets. So this change may allow data to be stored past 64MB, but game code past that point may still have issues.","@fzurita fpganugga mentioned in the 64drive documentation that due to limitations in the real parallel interface, some parts of the highest cartridge map isn't available, hence his decision to cap the ROM size to 240 MB and use the rest for MMIO, but without going in-depth in the explanation.
But technically, the cartridge space spans a whopping 252 MB (0x10000000 to 0x1FBFFFFF).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,685,2019-10-27T14:30:23Z,2019-10-27T14:47:18Z,2019-12-29T20:26:38Z,CLOSED,False,2,2,2,https://github.com/fzurita,Allow carts of up to 240 MB,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/685,https://github.com/fzurita,8,https://github.com/mupen64plus/mupen64plus-core/pull/685#issuecomment-569539016,"From some discord conversations, some ROMs that are greater than 64MB are causing the core to crash. These ROMs run on the real console, so it's definitely an issue in the core. Making the below two changes allows these ROMs to run with no perceived issues. From discord conversations, the maximum allowed ROM is 240 MB.
Also, searching through the code, there are a number of other places where 0x3FFFFFF is being used as a mask. It's hard to tell how many of these places refer to ROM address offsets. So this change may allow data to be stored past 64MB, but game code past that point may still have issues.","Gotcha, yeah, I couldn't get this to work in the end. This at the very least allows carts bigger than 64MB to not crash, but I couldn't get a test ROM that was provided to me from working as expected.",True,{'THUMBS_UP': ['https://github.com/Nabile-Rahmani']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,687,2019-11-17T17:25:42Z,2020-02-05T19:41:48Z,2020-02-09T14:52:23Z,MERGED,True,459,131,1,https://github.com/Mastergatto,Database updates,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/687,https://github.com/Mastergatto,1,https://github.com/mupen64plus/mupen64plus-core/pull/687,"By comparing with No-Intro database (see #599 ), I have corrected some errors according to No-Intro, because IMHO No-Intro is more trustworthy than GoodSet. I have also added new iQue games and manuals, some previously undumped revisions and some new prototypes.
Advices are welcome.","By comparing with No-Intro database (see #599 ), I have corrected some errors according to No-Intro, because IMHO No-Intro is more trustworthy than GoodSet. I have also added new iQue games and manuals, some previously undumped revisions and some new prototypes.
Advices are welcome.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,687,2019-11-17T17:25:42Z,2020-02-05T19:41:48Z,2020-02-09T14:52:23Z,MERGED,True,459,131,1,https://github.com/Mastergatto,Database updates,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/687,https://github.com/Mastergatto,2,https://github.com/mupen64plus/mupen64plus-core/pull/687#issuecomment-555078870,"By comparing with No-Intro database (see #599 ), I have corrected some errors according to No-Intro, because IMHO No-Intro is more trustworthy than GoodSet. I have also added new iQue games and manuals, some previously undumped revisions and some new prototypes.
Advices are welcome.","I have commited those changes as you have recommended, @Jj0YzL5nvJ . Is there anything other that can I do? I'll squash all changes into single commit if needed.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,687,2019-11-17T17:25:42Z,2020-02-05T19:41:48Z,2020-02-09T14:52:23Z,MERGED,True,459,131,1,https://github.com/Mastergatto,Database updates,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/687,https://github.com/Jj0YzL5nvJ,3,https://github.com/mupen64plus/mupen64plus-core/pull/687#issuecomment-558523563,"By comparing with No-Intro database (see #599 ), I have corrected some errors according to No-Intro, because IMHO No-Intro is more trustworthy than GoodSet. I have also added new iQue games and manuals, some previously undumped revisions and some new prototypes.
Advices are welcome.","With:

Replace 'Players', 'SaveType', 'Mempak' and 'Rumble' for: RefMD5=279EC83BD60A3CCE69A1DB22B0A5C318

I was referring to all beta versions... but that's enough, this file has too many redundancies.

Is there anything other that can I do? I'll squash all changes into single commit if needed.

Do that, that always pleases most devs.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,687,2019-11-17T17:25:42Z,2020-02-05T19:41:48Z,2020-02-09T14:52:23Z,MERGED,True,459,131,1,https://github.com/Mastergatto,Database updates,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/687,https://github.com/Mastergatto,4,https://github.com/mupen64plus/mupen64plus-core/pull/687#issuecomment-558597042,"By comparing with No-Intro database (see #599 ), I have corrected some errors according to No-Intro, because IMHO No-Intro is more trustworthy than GoodSet. I have also added new iQue games and manuals, some previously undumped revisions and some new prototypes.
Advices are welcome.","It should be all good now, I have even replaced these entries with RefMD5. As for these missing CRCs, someone should investigate why mupen64plus is unable to generate them for those ROMs.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,687,2019-11-17T17:25:42Z,2020-02-05T19:41:48Z,2020-02-09T14:52:23Z,MERGED,True,459,131,1,https://github.com/Mastergatto,Database updates,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/687,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/687#issuecomment-582218185,"By comparing with No-Intro database (see #599 ), I have corrected some errors according to No-Intro, because IMHO No-Intro is more trustworthy than GoodSet. I have also added new iQue games and manuals, some previously undumped revisions and some new prototypes.
Advices are welcome.",@Jj0YzL5nvJ you're good with this? It seems like you reviewed it. If you're happy with I'd say we merge it,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,687,2019-11-17T17:25:42Z,2020-02-05T19:41:48Z,2020-02-09T14:52:23Z,MERGED,True,459,131,1,https://github.com/Mastergatto,Database updates,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/687,https://github.com/Jj0YzL5nvJ,6,https://github.com/mupen64plus/mupen64plus-core/pull/687#issuecomment-582384994,"By comparing with No-Intro database (see #599 ), I have corrected some errors according to No-Intro, because IMHO No-Intro is more trustworthy than GoodSet. I have also added new iQue games and manuals, some previously undumped revisions and some new prototypes.
Advices are welcome.","I'm fine with this. But it is clear that the current DB is obsolete and has too many redundancies.
This needs a SHA1 and maybe others, differentiate between N64, Aleck64, 64DD, iQue, VC, etc. And differentiate the ROM and boot / save method based on such. The current method does not work with iQue.
The whole thing needs a new ""M64P_INICreater tool"" to revamp. Using GoodSet, No-Intro or / and any other, like MAME's hash.
But without new blood, that won't happen. So let's hotfix this.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,687,2019-11-17T17:25:42Z,2020-02-05T19:41:48Z,2020-02-09T14:52:23Z,MERGED,True,459,131,1,https://github.com/Mastergatto,Database updates,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/687,https://github.com/fzurita,7,https://github.com/mupen64plus/mupen64plus-core/pull/687#issuecomment-583770386,"By comparing with No-Intro database (see #599 ), I have corrected some errors according to No-Intro, because IMHO No-Intro is more trustworthy than GoodSet. I have also added new iQue games and manuals, some previously undumped revisions and some new prototypes.
Advices are welcome.",@Narann this has a problem. Section 31448B07CBC932018870F71D1254E317 is repeated twice.,True,{'EYES': ['https://github.com/Jj0YzL5nvJ']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,687,2019-11-17T17:25:42Z,2020-02-05T19:41:48Z,2020-02-09T14:52:23Z,MERGED,True,459,131,1,https://github.com/Mastergatto,Database updates,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/687,https://github.com/Narann,8,https://github.com/mupen64plus/mupen64plus-core/pull/687#issuecomment-583853855,"By comparing with No-Intro database (see #599 ), I have corrected some errors according to No-Intro, because IMHO No-Intro is more trustworthy than GoodSet. I have also added new iQue games and manuals, some previously undumped revisions and some new prototypes.
Advices are welcome.",Merged!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,690,2019-12-02T20:12:30Z,2020-02-24T10:03:01Z,2020-02-24T10:03:01Z,CLOSED,False,23154,1524,99,https://github.com/npaladin2000,Trace jit experimental,16,[],https://github.com/mupen64plus/mupen64plus-core/pull/690,https://github.com/npaladin2000,1,https://github.com/mupen64plus/mupen64plus-core/pull/690,Pull to RGH repo,Pull to RGH repo,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,691,2019-12-17T06:21:52Z,2020-04-04T10:57:14Z,2020-04-04T10:57:15Z,CLOSED,False,120,19,7,https://github.com/MrCheeze,Implemented additional trap opcodes,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/691,https://github.com/MrCheeze,1,https://github.com/mupen64plus/mupen64plus-core/pull/691,"As far as I know, these instructions aren't used in retail roms, but they exist on real hardware and need to work for the purpose of an OoT ACE project that is currently in the works.
It's worth mentioning that I'm not sure the existing TEQ implementation is strictly correct, given that it just stops rather than follow what the N64 would do in that situation (crash screen)? Regardless I've made the implementation here exactly analogous to what what currently exists for TEQ.
For reference, see also a similar PR by krimtonz to projec64 earlier today:
project64/project64#1684","As far as I know, these instructions aren't used in retail roms, but they exist on real hardware and need to work for the purpose of an OoT ACE project that is currently in the works.
It's worth mentioning that I'm not sure the existing TEQ implementation is strictly correct, given that it just stops rather than follow what the N64 would do in that situation (crash screen)? Regardless I've made the implementation here exactly analogous to what what currently exists for TEQ.
For reference, see also a similar PR by krimtonz to projec64 earlier today:
project64/project64#1684",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,691,2019-12-17T06:21:52Z,2020-04-04T10:57:14Z,2020-04-04T10:57:15Z,CLOSED,False,120,19,7,https://github.com/MrCheeze,Implemented additional trap opcodes,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/691,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/691#issuecomment-566481197,"As far as I know, these instructions aren't used in retail roms, but they exist on real hardware and need to work for the purpose of an OoT ACE project that is currently in the works.
It's worth mentioning that I'm not sure the existing TEQ implementation is strictly correct, given that it just stops rather than follow what the N64 would do in that situation (crash screen)? Regardless I've made the implementation here exactly analogous to what what currently exists for TEQ.
For reference, see also a similar PR by krimtonz to projec64 earlier today:
project64/project64#1684",Have you anything to share to reproduce the problem ?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,691,2019-12-17T06:21:52Z,2020-04-04T10:57:14Z,2020-04-04T10:57:15Z,CLOSED,False,120,19,7,https://github.com/MrCheeze,Implemented additional trap opcodes,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/691,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/691#issuecomment-590577320,"As far as I know, these instructions aren't used in retail roms, but they exist on real hardware and need to work for the purpose of an OoT ACE project that is currently in the works.
It's worth mentioning that I'm not sure the existing TEQ implementation is strictly correct, given that it just stops rather than follow what the N64 would do in that situation (crash screen)? Regardless I've made the implementation here exactly analogous to what what currently exists for TEQ.
For reference, see also a similar PR by krimtonz to projec64 earlier today:
project64/project64#1684","This isn't really the same as the PJ64 PR. This will just stop the emulator when these opcodes are executed, it won't generate any kind of exception.
It would be good to have some kind of test ROM that we could test the trap opcode with to make sure it gets implemented correctly",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,691,2019-12-17T06:21:52Z,2020-04-04T10:57:14Z,2020-04-04T10:57:15Z,CLOSED,False,120,19,7,https://github.com/MrCheeze,Implemented additional trap opcodes,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/691,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/691#issuecomment-590584590,"As far as I know, these instructions aren't used in retail roms, but they exist on real hardware and need to work for the purpose of an OoT ACE project that is currently in the works.
It's worth mentioning that I'm not sure the existing TEQ implementation is strictly correct, given that it just stops rather than follow what the N64 would do in that situation (crash screen)? Regardless I've made the implementation here exactly analogous to what what currently exists for TEQ.
For reference, see also a similar PR by krimtonz to projec64 earlier today:
project64/project64#1684","I'm guessing the right thing to do, instead of stopping the emulator, would be:
uint32_t* cp0_regs = r4300_cp0_regs(&r4300->cp0);
cp0_regs[CP0_CAUSE_REG] = CP0_CAUSE_EXCCODE_TR;
exception_general(r4300);",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,691,2019-12-17T06:21:52Z,2020-04-04T10:57:14Z,2020-04-04T10:57:15Z,CLOSED,False,120,19,7,https://github.com/MrCheeze,Implemented additional trap opcodes,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/691,https://github.com/bsmiles32,5,https://github.com/mupen64plus/mupen64plus-core/pull/691#issuecomment-609011321,"As far as I know, these instructions aren't used in retail roms, but they exist on real hardware and need to work for the purpose of an OoT ACE project that is currently in the works.
It's worth mentioning that I'm not sure the existing TEQ implementation is strictly correct, given that it just stops rather than follow what the N64 would do in that situation (crash screen)? Regardless I've made the implementation here exactly analogous to what what currently exists for TEQ.
For reference, see also a similar PR by krimtonz to projec64 earlier today:
project64/project64#1684",Replaced by PR #745 . Continue discussion there.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,692,2019-12-22T13:01:39Z,2020-02-05T20:07:38Z,2020-02-20T16:34:09Z,MERGED,True,14,7,2,https://github.com/Zapeth,Fix VI interrupt not being called in certain cases,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/692,https://github.com/Zapeth,1,https://github.com/mupen64plus/mupen64plus-core/pull/692,"Not sure if this affects any commercial roms, but it at least enables certain homebrew roms to display something (like some of these test roms)","Not sure if this affects any commercial roms, but it at least enables certain homebrew roms to display something (like some of these test roms)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,692,2019-12-22T13:01:39Z,2020-02-05T20:07:38Z,2020-02-20T16:34:09Z,MERGED,True,14,7,2,https://github.com/Zapeth,Fix VI interrupt not being called in certain cases,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/692,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/692#issuecomment-572055914,"Not sure if this affects any commercial roms, but it at least enables certain homebrew roms to display something (like some of these test roms)",There should be a lot of testing if this is going to be merged. Calling a VI interrupt at the wrong time can break a lot of games,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,692,2019-12-22T13:01:39Z,2020-02-05T20:07:38Z,2020-02-20T16:34:09Z,MERGED,True,14,7,2,https://github.com/Zapeth,Fix VI interrupt not being called in certain cases,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/692,https://github.com/Zapeth,3,https://github.com/mupen64plus/mupen64plus-core/pull/692#issuecomment-572236714,"Not sure if this affects any commercial roms, but it at least enables certain homebrew roms to display something (like some of these test roms)","I haven't done extensive testing (and I'm not planning to), but I haven't noticed any issues with other roms that I have been using so far.
In theory this change shouldn't cause issues since it would only apply to cases where a VI interrupt is set up on MI but hasn't been registered at cp0 due to vi->regs[VI_V_INTR_REG] < vi->regs[VI_V_SYNC_REG] condition not holding (which is essentially what happens with these particular test roms).
Not to mention that these roms have reportedly been tested on real hardware, so in that regards the current behavior is incorrect anyway.
edit: I just noticed that it might erroneously set up a VI interrupt when onlyVI_V_SYNC_REG is written to but not VI_V_INTR_REG.
However there isn't really an easy way to check when writing to VI_V_SYNC_REG whether VI_V_INTR_REG was written to earlier or not (might require a dedicated variable), but I'm open to suggestions.
edit2: Actually scratch that last edit, these changes should be fine the way they are (I feel like this would much less of an issue if interrupts were implemented in a more conventional way).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,692,2019-12-22T13:01:39Z,2020-02-05T20:07:38Z,2020-02-20T16:34:09Z,MERGED,True,14,7,2,https://github.com/Zapeth,Fix VI interrupt not being called in certain cases,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/692,https://github.com/Zapeth,4,https://github.com/mupen64plus/mupen64plus-core/pull/692#issuecomment-573299580,"Not sure if this affects any commercial roms, but it at least enables certain homebrew roms to display something (like some of these test roms)","Another issue with the current implementation is that the event count of a VI_INT remains the same when VI_V_SYNC_REG changes.
Though this might not have any (noticable) effect on games, especially since the overall emulation is far from accurate anyway.
Best way to fix this would probably require something like an update_interrupt_event_count function in interrupt.c, but thats neither in the scope of this PR nor is it something I want to spend my time with.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,692,2019-12-22T13:01:39Z,2020-02-05T20:07:38Z,2020-02-20T16:34:09Z,MERGED,True,14,7,2,https://github.com/Zapeth,Fix VI interrupt not being called in certain cases,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/692,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/692#issuecomment-582217331,"Not sure if this affects any commercial roms, but it at least enables certain homebrew roms to display something (like some of these test roms)","I'll test this out tomorrow, you are right that it should be a pretty safe change, and it would be good to get those test ROMs working better",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,692,2019-12-22T13:01:39Z,2020-02-05T20:07:38Z,2020-02-20T16:34:09Z,MERGED,True,14,7,2,https://github.com/Zapeth,Fix VI interrupt not being called in certain cases,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/692,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/692#issuecomment-582455979,"Not sure if this affects any commercial roms, but it at least enables certain homebrew roms to display something (like some of these test roms)","I think this is OK to merge, I tested a good number of commercial games and didn't see any issues. The way it is written should make it pretty harmless as well",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,693,2019-12-22T13:19:03Z,2019-12-25T14:11:39Z,2019-12-25T14:12:26Z,CLOSED,False,1,1,1,https://github.com/Zapeth,Fix appveyor VS project path,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/693,https://github.com/Zapeth,1,https://github.com/mupen64plus/mupen64plus-core/pull/693,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,693,2019-12-22T13:19:03Z,2019-12-25T14:11:39Z,2019-12-25T14:12:26Z,CLOSED,False,1,1,1,https://github.com/Zapeth,Fix appveyor VS project path,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/693,https://github.com/Zapeth,2,https://github.com/mupen64plus/mupen64plus-core/pull/693#issuecomment-568903750,,Closed in favor of #694,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,694,2019-12-23T11:33:50Z,2020-01-25T17:24:21Z,2020-02-07T23:46:12Z,MERGED,True,62,49,3,https://github.com/Jj0YzL5nvJ,Let MSBuild do its job and implement a proper AppVeyor with artifact packaging,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/694,https://github.com/Jj0YzL5nvJ,1,https://github.com/mupen64plus/mupen64plus-core/pull/694,"P.S: Stop pleasing the human sacrifices and goats bleeding demanded by the horrendous VS2017 IDE. MSBuild is intelligent enough to understand which is the most appropriate SDK agnostically in base of ""DefaultPlatformToolset"" and ""PropertySheets"".
Hack for WindowsTargetPlatformVersion extracted from here.","P.S: Stop pleasing the human sacrifices and goats bleeding demanded by the horrendous VS2017 IDE. MSBuild is intelligent enough to understand which is the most appropriate SDK agnostically in base of ""DefaultPlatformToolset"" and ""PropertySheets"".
Hack for WindowsTargetPlatformVersion extracted from here.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,694,2019-12-23T11:33:50Z,2020-01-25T17:24:21Z,2020-02-07T23:46:12Z,MERGED,True,62,49,3,https://github.com/Jj0YzL5nvJ,Let MSBuild do its job and implement a proper AppVeyor with artifact packaging,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/694,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/694#issuecomment-578190597,"P.S: Stop pleasing the human sacrifices and goats bleeding demanded by the horrendous VS2017 IDE. MSBuild is intelligent enough to understand which is the most appropriate SDK agnostically in base of ""DefaultPlatformToolset"" and ""PropertySheets"".
Hack for WindowsTargetPlatformVersion extracted from here.","I’ve opened a PR to the win32-deps repo so we could remove the NASM downloading. :)
mupen64plus/mupen64plus-win32-deps#8",True,{'THUMBS_UP': ['https://github.com/Jj0YzL5nvJ']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,694,2019-12-23T11:33:50Z,2020-01-25T17:24:21Z,2020-02-07T23:46:12Z,MERGED,True,62,49,3,https://github.com/Jj0YzL5nvJ,Let MSBuild do its job and implement a proper AppVeyor with artifact packaging,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/694,https://github.com/Narann,3,https://github.com/mupen64plus/mupen64plus-core/pull/694#issuecomment-578414181,"P.S: Stop pleasing the human sacrifices and goats bleeding demanded by the horrendous VS2017 IDE. MSBuild is intelligent enough to understand which is the most appropriate SDK agnostically in base of ""DefaultPlatformToolset"" and ""PropertySheets"".
Hack for WindowsTargetPlatformVersion extracted from here.",@Jj0YzL5nvJ It's done! Please update the appveyor file and rebase on master. Then we should be able to merge!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,694,2019-12-23T11:33:50Z,2020-01-25T17:24:21Z,2020-02-07T23:46:12Z,MERGED,True,62,49,3,https://github.com/Jj0YzL5nvJ,Let MSBuild do its job and implement a proper AppVeyor with artifact packaging,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/694,https://github.com/Jj0YzL5nvJ,4,https://github.com/mupen64plus/mupen64plus-core/pull/694#issuecomment-578421858,"P.S: Stop pleasing the human sacrifices and goats bleeding demanded by the horrendous VS2017 IDE. MSBuild is intelligent enough to understand which is the most appropriate SDK agnostically in base of ""DefaultPlatformToolset"" and ""PropertySheets"".
Hack for WindowsTargetPlatformVersion extracted from here.","It's done, this time I kept the original logic.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,694,2019-12-23T11:33:50Z,2020-01-25T17:24:21Z,2020-02-07T23:46:12Z,MERGED,True,62,49,3,https://github.com/Jj0YzL5nvJ,Let MSBuild do its job and implement a proper AppVeyor with artifact packaging,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/694,https://github.com/Narann,5,https://github.com/mupen64plus/mupen64plus-core/pull/694#issuecomment-578424847,"P.S: Stop pleasing the human sacrifices and goats bleeding demanded by the horrendous VS2017 IDE. MSBuild is intelligent enough to understand which is the most appropriate SDK agnostically in base of ""DefaultPlatformToolset"" and ""PropertySheets"".
Hack for WindowsTargetPlatformVersion extracted from here.",Looks OK to me.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,694,2019-12-23T11:33:50Z,2020-01-25T17:24:21Z,2020-02-07T23:46:12Z,MERGED,True,62,49,3,https://github.com/Jj0YzL5nvJ,Let MSBuild do its job and implement a proper AppVeyor with artifact packaging,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/694,https://github.com/Narann,6,https://github.com/mupen64plus/mupen64plus-core/pull/694#issuecomment-583014476,"P.S: Stop pleasing the human sacrifices and goats bleeding demanded by the horrendous VS2017 IDE. MSBuild is intelligent enough to understand which is the most appropriate SDK agnostically in base of ""DefaultPlatformToolset"" and ""PropertySheets"".
Hack for WindowsTargetPlatformVersion extracted from here.","Good catch, I didn't think about it. I don't think it's mandatory for appveyor.
@Jj0YzL5nvJ do you have any rationals about renaming the Visual Project folder name?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,694,2019-12-23T11:33:50Z,2020-01-25T17:24:21Z,2020-02-07T23:46:12Z,MERGED,True,62,49,3,https://github.com/Jj0YzL5nvJ,Let MSBuild do its job and implement a proper AppVeyor with artifact packaging,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/694,https://github.com/Jj0YzL5nvJ,7,https://github.com/mupen64plus/mupen64plus-core/pull/694#issuecomment-583166712,"P.S: Stop pleasing the human sacrifices and goats bleeding demanded by the horrendous VS2017 IDE. MSBuild is intelligent enough to understand which is the most appropriate SDK agnostically in base of ""DefaultPlatformToolset"" and ""PropertySheets"".
Hack for WindowsTargetPlatformVersion extracted from here.","I changed the name because now the project files are more generic, they are no longer limited to Visual Studio 2017.
In fact, it's necessary to make similar changes in related projects to be consistent. I will do that shortly...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,694,2019-12-23T11:33:50Z,2020-01-25T17:24:21Z,2020-02-07T23:46:12Z,MERGED,True,62,49,3,https://github.com/Jj0YzL5nvJ,Let MSBuild do its job and implement a proper AppVeyor with artifact packaging,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/694,https://github.com/Jj0YzL5nvJ,8,https://github.com/mupen64plus/mupen64plus-core/pull/694#issuecomment-583349572,"P.S: Stop pleasing the human sacrifices and goats bleeding demanded by the horrendous VS2017 IDE. MSBuild is intelligent enough to understand which is the most appropriate SDK agnostically in base of ""DefaultPlatformToolset"" and ""PropertySheets"".
Hack for WindowsTargetPlatformVersion extracted from here.",It's done.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,694,2019-12-23T11:33:50Z,2020-01-25T17:24:21Z,2020-02-07T23:46:12Z,MERGED,True,62,49,3,https://github.com/Jj0YzL5nvJ,Let MSBuild do its job and implement a proper AppVeyor with artifact packaging,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/694,https://github.com/Gillou68310,9,https://github.com/mupen64plus/mupen64plus-core/pull/694#issuecomment-583351003,"P.S: Stop pleasing the human sacrifices and goats bleeding demanded by the horrendous VS2017 IDE. MSBuild is intelligent enough to understand which is the most appropriate SDK agnostically in base of ""DefaultPlatformToolset"" and ""PropertySheets"".
Hack for WindowsTargetPlatformVersion extracted from here.","Thanks @Jj0YzL5nvJ ;-)
Did you see my above comment on the Configuration thing?
I'm personnaly switching configurations quite often and I don't want to manually copy the core dll to mupen64plus-console.exe folder every time I recompile.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,694,2019-12-23T11:33:50Z,2020-01-25T17:24:21Z,2020-02-07T23:46:12Z,MERGED,True,62,49,3,https://github.com/Jj0YzL5nvJ,Let MSBuild do its job and implement a proper AppVeyor with artifact packaging,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/694,https://github.com/Jj0YzL5nvJ,10,https://github.com/mupen64plus/mupen64plus-core/pull/694#issuecomment-583366592,"P.S: Stop pleasing the human sacrifices and goats bleeding demanded by the horrendous VS2017 IDE. MSBuild is intelligent enough to understand which is the most appropriate SDK agnostically in base of ""DefaultPlatformToolset"" and ""PropertySheets"".
Hack for WindowsTargetPlatformVersion extracted from here.","Did you see my above comment on the Configuration thing?

What I understood were the references in mupen64plus-ui-console.sln

I'm personnaly switching configurations quite often and I don't want to manually copy the core dll to mupen64plus-console.exe folder every time I recompile.

I'm currently blind (without a Windows machine), and I don't know exactly what the mupen64plus-ui-console.sln file does. Seeing the code does not make it clear to me where the results of the slave projects end.
Personally, I prefer my own scripts than being putting commands into project files... the order of someone is the disorder of someone else. Look at this little monstrosity.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,694,2019-12-23T11:33:50Z,2020-01-25T17:24:21Z,2020-02-07T23:46:12Z,MERGED,True,62,49,3,https://github.com/Jj0YzL5nvJ,Let MSBuild do its job and implement a proper AppVeyor with artifact packaging,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/694,https://github.com/Gillou68310,11,https://github.com/mupen64plus/mupen64plus-core/pull/694#issuecomment-583376708,"P.S: Stop pleasing the human sacrifices and goats bleeding demanded by the horrendous VS2017 IDE. MSBuild is intelligent enough to understand which is the most appropriate SDK agnostically in base of ""DefaultPlatformToolset"" and ""PropertySheets"".
Hack for WindowsTargetPlatformVersion extracted from here.","mupen64plus-ui-console.sln embeds all vcxproj from ui, core and other plugins
From the mupen64plus-ui-console.sln config manager you can select a specific config for every vcxproj.
They usually all only have Debug and Release config, but the core have an additional debug and release config for the new_dynarec.
If I build debug for x86 all plugin dlls and ui executable will end up in mupen64plus-ui-console\projects\VisualStudio2017\Win32\Debug directory.
With your change if I decide to build with new dynarec support, the core dll will end up in mupen64plus-ui-console\projects\VisualStudio2017\Win32\New_Dynarec_Debug directory.
Thus I need to manually copy the dll into the Debug directory.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,694,2019-12-23T11:33:50Z,2020-01-25T17:24:21Z,2020-02-07T23:46:12Z,MERGED,True,62,49,3,https://github.com/Jj0YzL5nvJ,Let MSBuild do its job and implement a proper AppVeyor with artifact packaging,4,[],https://github.com/mupen64plus/mupen64plus-core/pull/694,https://github.com/Jj0YzL5nvJ,12,https://github.com/mupen64plus/mupen64plus-core/pull/694#issuecomment-583663277,"P.S: Stop pleasing the human sacrifices and goats bleeding demanded by the horrendous VS2017 IDE. MSBuild is intelligent enough to understand which is the most appropriate SDK agnostically in base of ""DefaultPlatformToolset"" and ""PropertySheets"".
Hack for WindowsTargetPlatformVersion extracted from here.","Okay, it currently makes more sense to build the New_Dynarec individually.
mupen64plus/mupen64plus-ui-console#56",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,696,2020-01-13T00:41:13Z,2020-03-23T09:28:39Z,2020-03-23T09:28:39Z,MERGED,True,20,4,1,https://github.com/dankcushions,"if config parameter already exists, add help text if missing, before returning successfully",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/696,https://github.com/dankcushions,1,https://github.com/mupen64plus/mupen64plus-core/pull/696,"This keeps the mupen64plus.cfg config file documented when setting the defaults.
Useful for Retropie (and similar) that has a scripted install for mupen64plus, setting a bunch of defaults. Since config help text does not get populated until the first time mupen64plus is run successfully, it led to these defaults being forever undocumented in the .cfg.","This keeps the mupen64plus.cfg config file documented when setting the defaults.
Useful for Retropie (and similar) that has a scripted install for mupen64plus, setting a bunch of defaults. Since config help text does not get populated until the first time mupen64plus is run successfully, it led to these defaults being forever undocumented in the .cfg.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,697,2020-02-03T20:46:04Z,2020-02-04T23:50:28Z,2021-06-20T20:43:36Z,MERGED,True,2501,548,3,https://github.com/loganmc10,Update xxHash to 0.7.2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/697,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/697,"Previous version was 0.6.5, changelog can be found here:
https://github.com/Cyan4973/xxHash/releases","Previous version was 0.6.5, changelog can be found here:
https://github.com/Cyan4973/xxHash/releases",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,697,2020-02-03T20:46:04Z,2020-02-04T23:50:28Z,2021-06-20T20:43:36Z,MERGED,True,2501,548,3,https://github.com/loganmc10,Update xxHash to 0.7.2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/697,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/697#issuecomment-581690427,"Previous version was 0.6.5, changelog can be found here:
https://github.com/Cyan4973/xxHash/releases",Can we squash your two commits in one please?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,697,2020-02-03T20:46:04Z,2020-02-04T23:50:28Z,2021-06-20T20:43:36Z,MERGED,True,2501,548,3,https://github.com/loganmc10,Update xxHash to 0.7.2,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/697,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/697#issuecomment-582119393,"Previous version was 0.6.5, changelog can be found here:
https://github.com/Cyan4973/xxHash/releases",Sure. done,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,698,2020-02-05T04:57:24Z,2020-02-05T19:56:03Z,2021-06-20T20:43:46Z,MERGED,True,0,2,1,https://github.com/loganmc10,Don't set DPC_STATUS_START/END_VALID bits,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/698,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/698,"As noted here:
libretro/mupen64plus-libretro-nx@8c87b43
DPC_STATUS_START_VALID and DPC_STATUS_END_VALID are never cleared, causing problems with some LLE RSP plugins","As noted here:
libretro/mupen64plus-libretro-nx@8c87b43
DPC_STATUS_START_VALID and DPC_STATUS_END_VALID are never cleared, causing problems with some LLE RSP plugins",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,698,2020-02-05T04:57:24Z,2020-02-05T19:56:03Z,2021-06-20T20:43:46Z,MERGED,True,0,2,1,https://github.com/loganmc10,Don't set DPC_STATUS_START/END_VALID bits,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/698,https://github.com/m4xw,2,https://github.com/mupen64plus/mupen64plus-core/pull/698#issuecomment-582321202,"As noted here:
libretro/mupen64plus-libretro-nx@8c87b43
DPC_STATUS_START_VALID and DPC_STATUS_END_VALID are never cleared, causing problems with some LLE RSP plugins","I'd suggest adding a comment that the value is (supposedly?) cleared by hw.
Do you want to wait for the merge until we confirmed the proper hw behavior for this?
I still think transaction_start/end should be the name of the bits, see my added comment, but if anyone knows for sure... let me know please.
Edit: Seems according to docs its CMD_START and CMD_END which then sets START_VALID/END_VALID",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,698,2020-02-05T04:57:24Z,2020-02-05T19:56:03Z,2021-06-20T20:43:46Z,MERGED,True,0,2,1,https://github.com/loganmc10,Don't set DPC_STATUS_START/END_VALID bits,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/698,https://github.com/Narann,3,https://github.com/mupen64plus/mupen64plus-core/pull/698#issuecomment-582368659,"As noted here:
libretro/mupen64plus-libretro-nx@8c87b43
DPC_STATUS_START_VALID and DPC_STATUS_END_VALID are never cleared, causing problems with some LLE RSP plugins","I'd suggest adding a comment that the value is (supposedly?) cleared by hw.

If subtle, answerable things are confirmed by hw, I’m always in favor of one line comment for knowledge purpose.
About the flag name, I will let @bsmiles32 settles.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,698,2020-02-05T04:57:24Z,2020-02-05T19:56:03Z,2021-06-20T20:43:46Z,MERGED,True,0,2,1,https://github.com/loganmc10,Don't set DPC_STATUS_START/END_VALID bits,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/698,https://github.com/Gillou68310,4,https://github.com/mupen64plus/mupen64plus-core/pull/698#issuecomment-582371320,"As noted here:
libretro/mupen64plus-libretro-nx@8c87b43
DPC_STATUS_START_VALID and DPC_STATUS_END_VALID are never cleared, causing problems with some LLE RSP plugins",,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,698,2020-02-05T04:57:24Z,2020-02-05T19:56:03Z,2021-06-20T20:43:46Z,MERGED,True,0,2,1,https://github.com/loganmc10,Don't set DPC_STATUS_START/END_VALID bits,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/698,https://github.com/m4xw,5,https://github.com/mupen64plus/mupen64plus-core/pull/698#issuecomment-582373617,"As noted here:
libretro/mupen64plus-libretro-nx@8c87b43
DPC_STATUS_START_VALID and DPC_STATUS_END_VALID are never cleared, causing problems with some LLE RSP plugins","If subtle, answerable things are confirmed by hw, I’m always in favor of one line comment for knowledge purpose.

Yea, fully agree, but well the docs that Gillou quoted are weirdly written and I am not sure if this is supposed to be set by a asynchronous task or by hw..
I've seen chips where actually reading the bit will unset it by hw and simliar weird stuff.
Don't think I get around some hw tests to rule all concerns out.
Also I want to throw a dry baguette at the person that wrote that document as well as picked the bit names..
Anyway, in the case of KI Gold it seems to wait for the bus to enter idle state before starting the next transfer.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,698,2020-02-05T04:57:24Z,2020-02-05T19:56:03Z,2021-06-20T20:43:46Z,MERGED,True,0,2,1,https://github.com/loganmc10,Don't set DPC_STATUS_START/END_VALID bits,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/698,https://github.com/Gillou68310,6,https://github.com/mupen64plus/mupen64plus-core/pull/698#issuecomment-582374509,"As noted here:
libretro/mupen64plus-libretro-nx@8c87b43
DPC_STATUS_START_VALID and DPC_STATUS_END_VALID are never cleared, causing problems with some LLE RSP plugins","From what I understand those flags are used to avoid a new RDP command transfer while another is still in progress. It's not very clear when those flags are going to be cleared.
Since m64p is not doing asynchronous transfer between CPU, RSP and RDP I think it's actually safer to ignore those flags.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,698,2020-02-05T04:57:24Z,2020-02-05T19:56:03Z,2021-06-20T20:43:46Z,MERGED,True,0,2,1,https://github.com/loganmc10,Don't set DPC_STATUS_START/END_VALID bits,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/698,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/698#issuecomment-582382403,"As noted here:
libretro/mupen64plus-libretro-nx@8c87b43
DPC_STATUS_START_VALID and DPC_STATUS_END_VALID are never cleared, causing problems with some LLE RSP plugins","If I had to guess, the proper way to do it would be to set START_VALID at DPC_START_REG and clear it at DPC_END_REG, and do the opposite for END_VALID.
I'm going to update the PR to work that way and do some testing",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,698,2020-02-05T04:57:24Z,2020-02-05T19:56:03Z,2021-06-20T20:43:46Z,MERGED,True,0,2,1,https://github.com/loganmc10,Don't set DPC_STATUS_START/END_VALID bits,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/698,https://github.com/m4xw,8,https://github.com/mupen64plus/mupen64plus-core/pull/698#issuecomment-582384459,"As noted here:
libretro/mupen64plus-libretro-nx@8c87b43
DPC_STATUS_START_VALID and DPC_STATUS_END_VALID are never cleared, causing problems with some LLE RSP plugins","If I had to guess, the proper way to do it would be to set START_VALID at DPC_START_REG and clear it at DPC_END_REG, and do the opposite for END_VALID.
I'm going to update the PR to work that way and do some testing

Yea I thought so too at first, however I didn't end up trying it because from our discussion it was spinning so i wouldnt know how the emu will write that flag, if it isnt handled via a interrupt.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,698,2020-02-05T04:57:24Z,2020-02-05T19:56:03Z,2021-06-20T20:43:46Z,MERGED,True,0,2,1,https://github.com/loganmc10,Don't set DPC_STATUS_START/END_VALID bits,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/698,https://github.com/loganmc10,9,https://github.com/mupen64plus/mupen64plus-core/pull/698#issuecomment-582386990,"As noted here:
libretro/mupen64plus-libretro-nx@8c87b43
DPC_STATUS_START_VALID and DPC_STATUS_END_VALID are never cleared, causing problems with some LLE RSP plugins",@m4xw can you share what code in the rsp plugin is hanging? That will help me understand what the RSP plugin expects these bits to be,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,698,2020-02-05T04:57:24Z,2020-02-05T19:56:03Z,2021-06-20T20:43:46Z,MERGED,True,0,2,1,https://github.com/loganmc10,Don't set DPC_STATUS_START/END_VALID bits,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/698,https://github.com/m4xw,10,https://github.com/mupen64plus/mupen64plus-core/pull/698#issuecomment-582387356,"As noted here:
libretro/mupen64plus-libretro-nx@8c87b43
DPC_STATUS_START_VALID and DPC_STATUS_END_VALID are never cleared, causing problems with some LLE RSP plugins","@loganmc10 am at work rn, can do so in 5-6h, i dont remember.
I can quote this from Gillou and mine chatlog tho:
Gillou68310
for KI
0400118C: mfc0   r19, DPC_STATUS
          DPC_STATUS : 00000609
          r19': 00000609

04001190: andi   r19, r19, $0400
          r19 : 00000609
          r19': 00000400

04001194: bne    r19, 0, $0400118C
           r0 : 00000000
          r19 : 00000400

04001198: mfc0   r19, DPC_CURRENT
          DPC_CURRENT : 00001000
          r19': 00001000
it's waiting for !DPC_STATUS_START_VALID
in DPC_STATUS reg",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,698,2020-02-05T04:57:24Z,2020-02-05T19:56:03Z,2021-06-20T20:43:46Z,MERGED,True,0,2,1,https://github.com/loganmc10,Don't set DPC_STATUS_START/END_VALID bits,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/698,https://github.com/Gillou68310,11,https://github.com/mupen64plus/mupen64plus-core/pull/698#issuecomment-582388706,"As noted here:
libretro/mupen64plus-libretro-nx@8c87b43
DPC_STATUS_START_VALID and DPC_STATUS_END_VALID are never cleared, causing problems with some LLE RSP plugins","If I should guess I would say START_VALID=1 and END_VALID=1 until CMD_CURRENT == CMD_END
Here's a use case:
#ifdef OUTPUT_DRAM
	# reset output pointers
		lw	outp, OS_TASK_OFF_OUTBUFF($1)
		lw	$3, OS_TASK_OFF_OUTBUFF_SZ($1)
		sw	outp, RSP_STATE_DRAM_OUTP(rsp_state)
		sw	$3, RSP_STATE_DRAM_OUT_LENP(rsp_state)

		addi	$4, zero, DPC_CLR_XBUS_DMEM_DMA
		mtc0	$4, CMD_STATUS
 		addi	outp, zero, RSP_OUTPUT_OFFSET

#else
#ifdef OUTPUT_FIFO
.name	bufend, $3
	# reset output pointers
		lw	outp, OS_TASK_OFF_OUTBUFF($1)
		lw	bufend, OS_TASK_OFF_OUTBUFF_SZ($1)
		sw	outp, RSP_STATE_FIFO_BUF_TOP(rsp_state)
		sw	bufend, RSP_STATE_FIFO_BUF_END(rsp_state)

		mfc0	$4, CMD_STATUS
		andi	$4, $4, DPC_STATUS_XBUS_DMEM_DMA
		bne	$4, zero, restart_fifo
		mfc0	$4, CMD_END
		sub	outp, outp, $4
		bgtz	outp, restart_fifo

	mfc0	$5, CMD_CURRENT
	beq	$5, zero, restart_fifo
	nop
	beq	$5, $4, restart_fifo
	

		nop
		j	set_fifo
		ori	bufend, $4, 0

restart_fifo:
		mfc0	$4, CMD_STATUS
		andi	$4, $4, DPC_STATUS_START_VALID
		bne	$4, zero, restart_fifo
		addi	$4, zero, DPC_CLR_XBUS_DMEM_DMA
 ### LOOP TO restart_fifo: UNTIL START_VALID=0
		mtc0	$4, CMD_STATUS
		mtc0	bufend, CMD_START
		mtc0	bufend, CMD_END
set_fifo:
		sw	bufend, RSP_STATE_FIFO_OUTP(rsp_state)
 		addi	outp, zero, RSP_OUTPUT_OFFSET
.unname	bufend",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,698,2020-02-05T04:57:24Z,2020-02-05T19:56:03Z,2021-06-20T20:43:46Z,MERGED,True,0,2,1,https://github.com/loganmc10,Don't set DPC_STATUS_START/END_VALID bits,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/698,https://github.com/Gillou68310,12,https://github.com/mupen64plus/mupen64plus-core/pull/698#issuecomment-582389854,"As noted here:
libretro/mupen64plus-libretro-nx@8c87b43
DPC_STATUS_START_VALID and DPC_STATUS_END_VALID are never cleared, causing problems with some LLE RSP plugins",BTW @loganmc10 is the original commit supposed to fix any issue?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,698,2020-02-05T04:57:24Z,2020-02-05T19:56:03Z,2021-06-20T20:43:46Z,MERGED,True,0,2,1,https://github.com/loganmc10,Don't set DPC_STATUS_START/END_VALID bits,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/698,https://github.com/loganmc10,13,https://github.com/mupen64plus/mupen64plus-core/pull/698#issuecomment-582394600,"As noted here:
libretro/mupen64plus-libretro-nx@8c87b43
DPC_STATUS_START_VALID and DPC_STATUS_END_VALID are never cleared, causing problems with some LLE RSP plugins","@Gillou68310 no, not that I know of, it was just an attempt at improving accuracy. Given that we don't do asynchronous transfers like you say, it probably is safer to just leave the bits at 0",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,698,2020-02-05T04:57:24Z,2020-02-05T19:56:03Z,2021-06-20T20:43:46Z,MERGED,True,0,2,1,https://github.com/loganmc10,Don't set DPC_STATUS_START/END_VALID bits,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/698,https://github.com/Gillou68310,14,https://github.com/mupen64plus/mupen64plus-core/pull/698#issuecomment-582402533,"As noted here:
libretro/mupen64plus-libretro-nx@8c87b43
DPC_STATUS_START_VALID and DPC_STATUS_END_VALID are never cleared, causing problems with some LLE RSP plugins",I think it's best indeed,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,698,2020-02-05T04:57:24Z,2020-02-05T19:56:03Z,2021-06-20T20:43:46Z,MERGED,True,0,2,1,https://github.com/loganmc10,Don't set DPC_STATUS_START/END_VALID bits,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/698,https://github.com/loganmc10,15,https://github.com/mupen64plus/mupen64plus-core/pull/698#issuecomment-582403132,"As noted here:
libretro/mupen64plus-libretro-nx@8c87b43
DPC_STATUS_START_VALID and DPC_STATUS_END_VALID are never cleared, causing problems with some LLE RSP plugins","Ok I've updated the PR to just stop setting these bits, I agree with @Gillou68310 that it's the best option in this case",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,698,2020-02-05T04:57:24Z,2020-02-05T19:56:03Z,2021-06-20T20:43:46Z,MERGED,True,0,2,1,https://github.com/loganmc10,Don't set DPC_STATUS_START/END_VALID bits,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/698,https://github.com/m4xw,16,https://github.com/mupen64plus/mupen64plus-core/pull/698#issuecomment-582407128,"As noted here:
libretro/mupen64plus-libretro-nx@8c87b43
DPC_STATUS_START_VALID and DPC_STATUS_END_VALID are never cleared, causing problems with some LLE RSP plugins","Sounds sufficient for now, but ideally this should be implemented if hw behavior gets documented.
I'd at least leave it commented for now.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,698,2020-02-05T04:57:24Z,2020-02-05T19:56:03Z,2021-06-20T20:43:46Z,MERGED,True,0,2,1,https://github.com/loganmc10,Don't set DPC_STATUS_START/END_VALID bits,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/698,https://github.com/loganmc10,17,https://github.com/mupen64plus/mupen64plus-core/pull/698#issuecomment-582417027,"As noted here:
libretro/mupen64plus-libretro-nx@8c87b43
DPC_STATUS_START_VALID and DPC_STATUS_END_VALID are never cleared, causing problems with some LLE RSP plugins","In real hardware the RDP and CPU run asynchronously, so it's probably not something that can be properly emulated in mupen64plus",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,698,2020-02-05T04:57:24Z,2020-02-05T19:56:03Z,2021-06-20T20:43:46Z,MERGED,True,0,2,1,https://github.com/loganmc10,Don't set DPC_STATUS_START/END_VALID bits,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/698,https://github.com/loganmc10,18,https://github.com/mupen64plus/mupen64plus-core/pull/698#issuecomment-582419470,"As noted here:
libretro/mupen64plus-libretro-nx@8c87b43
DPC_STATUS_START_VALID and DPC_STATUS_END_VALID are never cleared, causing problems with some LLE RSP plugins","Actually, now that I think about it, clearing both bits inside rdp_interrupt_event() may be the proper thing to do, but I think the current PR is good, just leaving them at 0 doesn't seem to cause any issues",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,699,2020-02-08T14:58:16Z,2020-02-08T15:40:09Z,2021-06-20T20:43:47Z,MERGED,True,1,0,1,https://github.com/loganmc10,"Revert ""Don't call SDL_PumpEvents() in core""",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/699,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/699,"This caused more problems than it solved, and it sounds like mupen64plus-ae has stubbed out SDL anyway
This reverts commit 87b1946.
#550","This caused more problems than it solved, and it sounds like mupen64plus-ae has stubbed out SDL anyway
This reverts commit 87b1946.
#550",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,700,2020-02-09T10:52:18Z,2020-02-09T14:51:42Z,2020-02-23T04:18:20Z,MERGED,True,2,5,1,https://github.com/Jj0YzL5nvJ,Whoops,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/700,https://github.com/Jj0YzL5nvJ,1,https://github.com/mupen64plus/mupen64plus-core/pull/700,#687 (comment),#687 (comment),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,700,2020-02-09T10:52:18Z,2020-02-09T14:51:42Z,2020-02-23T04:18:20Z,MERGED,True,2,5,1,https://github.com/Jj0YzL5nvJ,Whoops,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/700,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/700#issuecomment-583837778,#687 (comment),@fzurita Is this good for you?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,700,2020-02-09T10:52:18Z,2020-02-09T14:51:42Z,2020-02-23T04:18:20Z,MERGED,True,2,5,1,https://github.com/Jj0YzL5nvJ,Whoops,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/700,https://github.com/fzurita,3,https://github.com/mupen64plus/mupen64plus-core/pull/700#issuecomment-583845590,#687 (comment),"That's good with me, it doesn't repeat any more.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/701,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused","There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-584223216,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused","@Gillou68310 @bsmiles32 maybe you can answer this for me, is CP0_COUNT_REG a signed int? I always assumed it was unsigned and rolled over at 0xFFFFFFFF, but looking at the code, and doing some testing, it seems that it might be a signed int, that is expected to roll over at 0x80000000, is that right?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-584229570,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused",cp0_count is unsigned and roll over when reaching 2^32-1.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-584234821,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused","@bsmiles32 are you 100% sure though, look at this:

And the current interrupt handler has code like this:
if (cp0_regs[CP0_COUNT_REG] > UINT32_C(0x80000000)) {
    cp0->special_done = 0;
}",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-584235995,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused","Actually I guess ""sign extended"" is supposed to mean that it preserves the sign while still using all 32 bits somehow?
The reason I suspect this, is that DK64 is freezing for me right when COUNT_REG (and COMPARE_REG) get larger than 0x80000000",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/bsmiles32,6,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-584240170,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused","6.3.3 Count Register (9)
The read/write Count register acts as a timer, incrementing at a constant rate—half
the PClock speed—whether or not instructions are being executed. This register
is a free-running type. When the register reaches all ones, it rolls over to zero and
continues counting. This register can be used for diagnostic purposes, system
initialization or synchronization between the processes.
From User’s Manual U10504EJ7V0UM00 p164",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-584252231,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused","I feel like there is something missing, even in PJ64 I see this:
https://github.com/project64/project64/blob/f20dca31fdc43e71fd50c4c0888352e4c78a36c2/Source/Project64-core/N64System/Mips/SystemTiming.cpp#L270-L282
They don't let ""NextCompare"" get any larger than 2^31-1",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-584297369,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused","@bsmiles32 I pushed the change to wrap CP0_COUNT_REG around at 2^31-1 in a separate commit:
d266a5d
This does fix the freeze in DK64 (Indiana Jones also froze when starting a new game without this change).
I'm really not too sure on this, it would maybe help if someone had some way to test on a real N64 what happens when cp0_count exceeds 2^31-1?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/m4xw,9,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-584774970,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused","I'm really not too sure on this, it would maybe help if someone had some way to test on a real N64 what happens when cp0_count exceeds 2^31-1?

This should be 2^32-1, shouldnt it?

When the register reaches all ones

As per bsmiles quote.
Pretty sure this should be treated as uint32 since according to some datasheets it uses the full 32bits for counting.
I would consider the possibility that this might trigger another bug if implemented properly, maybe register endianess breaking something when bitcounting reaches a certain pattern or stuff like that.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/loganmc10,10,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-584788596,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused","I'm not really sure, the way this PR is written currently, I don't see any bugs, I've tested quite a few games.
It would be a really easy thing for somebody that had experience writing test ROMs could check, just  keep reading CP0_COUNT_REG and see what it does when it exceeds 0x7fffffff. The other thing to test would be to write a value greater than 0x7fffffff to CP0_COMPARE_REG, and then read it back, and see what the value is",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/Gillou68310,11,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-585667253,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused","It's actually clear from the docs that the count register roll over when reaching 2^32-1.
I'll try to take time this afternoon to review your 1st commit on this PR.",True,{'THUMBS_UP': ['https://github.com/m4xw']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/loganmc10,12,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-585765940,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused","Thanks @Gillou68310 . I've read the same document and I totally agree about what it says. With the first commit, DK64 freezes when the count register exceeds 0x80000000. Everything seems to work perfectly when I roll the counter over at that point",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/Gillou68310,13,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-585769252,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused","I started looking at the code and I'm not sure the COMPARE_INT event is generated correctly
I would do something like that for the handler:
void compare_int_handler(void* opaque)
{
    struct r4300_core* r4300 = (struct r4300_core*)opaque;
    uint32_t* cp0_regs = r4300_cp0_regs(&r4300->cp0);
    uint64_t* cp0_count = r4300_cp0_get_count(&r4300->cp0);
	
    uint32_t delay = cp0_regs[CP0_COMPARE_REG] - (cp0_regs[CP0_COUNT_REG] + r4300->cp0.count_per_op);
    *cp0_count += r4300->cp0.count_per_op;
    add_interrupt_event(&r4300->cp0, COMPARE_INT, delay);
    *cp0_count -= r4300->cp0.count_per_op;

    raise_maskable_interrupt(r4300, CP0_CAUSE_IP7);
}

translate_event_queue and DECLARE_INSTRUCTION(MTC0) needs to be adapted too",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/Gillou68310,14,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-585770245,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused",Adding r4300->cp0.count_per_op to the count is necessary in the case cp0_regs[CP0_COMPARE_REG] == cp0_regs[CP0_COUNT_REG] to have a delay of 0x100000000 instead of 0,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/Gillou68310,15,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-585771885,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused","translate_event_queue would be:
void translate_event_queue(struct r4300_core* r4300, unsigned int base)
{
    struct node* e;
    struct cp0* cp0 = &r4300->cp0;
    uint32_t* cp0_regs = r4300_cp0_regs(cp0);
    uint64_t* cp0_count = r4300_cp0_get_count(cp0);

    remove_event(&cp0->q, COMPARE_INT);

    for (e = cp0->q.first; e != NULL; e = e->next)
    {
        e->data.count = (e->data.count - *cp0_count) + base;
    }

    uint32_t delay = cp0_regs[CP0_COMPARE_REG] - (base + cp0->count_per_op);
    *cp0_count = base + cp0->count_per_op;
    add_interrupt_event(cp0, COMPARE_INT, delay);
    *cp0_count -= cp0->count_per_op;
}

I removed the VI thing, I think this should be in another PR",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/Gillou68310,16,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-585772564,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused","And MTC0
    case CP0_COMPARE_REG:
        cp0_update_count(r4300);
        remove_event(&r4300->cp0.q, COMPARE_INT);
        uint32_t delay = rrt32 - (cp0_regs[CP0_COUNT_REG] + r4300->cp0.count_per_op);
        *cp0_count += r4300->cp0.count_per_op;
        add_interrupt_event(&r4300->cp0, COMPARE_INT, delay);
        *cp0_count -= r4300->cp0.count_per_op;
        cp0_regs[CP0_COMPARE_REG] = rrt32;
        cp0_regs[CP0_CAUSE_REG] &= ~CP0_CAUSE_IP7;
        break;",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/loganmc10,17,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-585773067,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused","uint32_t delay = cp0_regs[CP0_COMPARE_REG] - (cp0_regs[CP0_COUNT_REG] + r4300->cp0.count_per_op

I don't think this is right, picture a scenario where COMPARE_REG == 0. We just interrupted, so COUNT_REG is also 0. The result of that equation would be -2",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/Gillou68310,18,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-585773430,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused",unsigned so 0xFFFFFFFE actually,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/Gillou68310,19,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-585773842,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused",scheduling the compare interrupt at 0x100000000,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/Gillou68310,20,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-585775602,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused",Regarding the VI thing I think the next_vi variable should just be removed all together. As far as I know we can get the next VI event at any time using the get_event function.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/loganmc10,21,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-585775721,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused","Ok makes sense, I'll try it in a bit, but then why do:
cp0_count += r4300->cp0.count_per_op;
cp0_count -= r4300->cp0.count_per_op;

As well, isn't that doing the same thing?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/loganmc10,22,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-585777074,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused","I think the next_vi variable existed to provide precision timing. The VI_INT handler could be called a few cycles after next_vi, so if you just add vi_delay and schedule it again in the handler, the distance between the 2 interrupts would actually be slightly greater than next_vi. That was my understanding anyway",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/Gillou68310,23,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-585777260,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused","it's to revert the effect of adding count_per_op to uint32_t delay = rrt32 - (cp0_regs[CP0_COUNT_REG] + r4300->cp0.count_per_op);
cp0_count  is used in add_interrupt_event BTW",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/Gillou68310,24,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-585777767,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused","I think the next_vi variable existed to provide precision timing. The VI_INT handler could be called a few cycles after next_vi, so if you just add vi_delay and schedule it again in the handler, the distance between the 2 interrupts would actually be slightly greater than next_vi. That was my understanding anyway

Ok let's discuss that later in another PR, I didn't look in detail rn",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/Gillou68310,25,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-585811056,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused",@loganmc10 Had time to test what we talked about?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/loganmc10,26,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-585818186,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused","Yes, sorry it's early here. I tried out your changes and it does work, for some reason I can't wrap my head around what the difference is, but I'll update the PR with the new logic and wrapping around at 2^32-1 and do some more testing",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/Gillou68310,27,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-585819034,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused","Sorry no pressure here, I was just wondering if my logic was correct ;-)
Nice to hear it works!",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/loganmc10,28,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-585831883,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused","Ok I've updated the PR with the new logic, I left the next_vi stuff in there for now, I can remove it I suppose, but it's needed to make translate_event_queue work properly.
Everything seems to be working normally. One minor thing that actually seems fixed in this PR, in Twisted Edge snowboarding, with the current master, about halfway through a race I usually got an earful of static for about a second. That problem seems to be resolved in this PR.
I've got savestates working as well, I think I've written it in a way that still allows save states to be forward and backward compatible.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/Gillou68310,29,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-585837579,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused","I don't have time to look at the savestate thing rn, I'll do that tomorrow!
Thanks for your work @loganmc10",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/Gillou68310,30,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-586312173,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused",Storing/loading next_interrupt in savestate is actually not necessary since it's overwritten by load_eventqueue_infos. It makes even less sense now since having only the low 32bits part doesn't mean anything.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/Gillou68310,31,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-586312972,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused","PUTDATA(curr, uint32_t, get_event(&dev->r4300.cp0.q, VI_INT) - cp0_regs[CP0_COUNT_REG]); // vi_timer
needs to be updated with 64bits count in savestates_save_pj64",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/Gillou68310,32,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-586338964,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused",BTW we need to increment version since newer savestates won't work on older core.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/loganmc10,33,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-586598480,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused","@Gillou68310 ok I've rebased the PR and incorporated your feedback. The one question I had was:

We should probably also need to re-schedule the COMPARE_INT here

I don't quite understand that, the event queue should have a pending COMPARE_INT inside when it is loaded from the save state",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/Gillou68310,34,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-586724230,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused","@loganmc10 I was just thinking out loud, I wasn't sure the COMPARE_INT event from older savestate are going to be 100% compatible with the new core",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/loganmc10,35,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-586724782,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused","Oh ok, it should be fine, I tested loading a few old save states. It shouldn't need any special reordering in a load, it operates the same as the other interrupts",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,701,2020-02-10T02:00:22Z,2020-02-19T16:06:02Z,2021-06-20T20:44:19Z,CLOSED,False,104,143,13,https://github.com/loganmc10,Remove special_int (DO NOT MERGE),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/701,https://github.com/loganmc10,36,https://github.com/mupen64plus/mupen64plus-core/pull/701#issuecomment-588297467,"There was some discussion about removing SPECIAL_INT in this PR:
#444
The most reasonable solution proposed (in my mind) is to make the counter a 64 bit register, and use the lower 32 bits for COUNT_REG.
I have tested this PR with both interpreters.
Left to be done:

Dynarecs -> I'm really not great at assembly, I'm hoping someone else can take on this task

I tested a number of games, including ones that I know are sensitive to timing and interrupt changes, I didn't notice any regressions. In fact, this PR fixes #689
I think this change is worthwhile, it simplifies the interrupt code, and hopefully might remove any bugs that the SPECIAL_INT ""hack"" (for lack of a better term) might have caused",closed in favour of #708,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,702,2020-02-14T13:18:28Z,2020-02-15T10:49:17Z,2020-02-16T16:21:28Z,MERGED,True,13,15,5,https://github.com/Gillou68310,Remove next_vi,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/702,https://github.com/Gillou68310,1,https://github.com/mupen64plus/mupen64plus-core/pull/702,Should fix #554,Should fix #554,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,702,2020-02-14T13:18:28Z,2020-02-15T10:49:17Z,2020-02-16T16:21:28Z,MERGED,True,13,15,5,https://github.com/Gillou68310,Remove next_vi,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/702,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/702#issuecomment-586335877,Should fix #554,"I still don't really see the benefit. It doesn't really simplify the code, and:
uint32_t next_vi = get_event(&vi->mi->r4300->cp0.q, VI_INT) + vi->delay;

Will need to be reworked when get_event returns a 64 bit value (probably not a big deal)
It's just sort of a different way of doing the same thing",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,702,2020-02-14T13:18:28Z,2020-02-15T10:49:17Z,2020-02-16T16:21:28Z,MERGED,True,13,15,5,https://github.com/Gillou68310,Remove next_vi,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/702,https://github.com/Gillou68310,3,https://github.com/mupen64plus/mupen64plus-core/pull/702#issuecomment-586337673,Should fix #554,"Sure it is, but cleaner IMO. And yes it simplify the code because you don't need to update next_vi all over the place.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,702,2020-02-14T13:18:28Z,2020-02-15T10:49:17Z,2020-02-16T16:21:28Z,MERGED,True,13,15,5,https://github.com/Gillou68310,Remove next_vi,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/702,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/702#issuecomment-586553074,Should fix #554,"OK, I doubled check that there were no regressions by diff'ing the interrupt timings between the current master and this PR. No issues, all interrupts are timed the same, so this is OK to be merged by me.
I'll update my PR once this is merged",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,705,2020-02-16T03:17:33Z,2020-02-19T07:45:41Z,2021-06-20T20:44:27Z,MERGED,True,2,2,1,https://github.com/loganmc10,Only align cart address in PI DMA,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/705,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/705,"This PR fixes:
#600
Cart and DRAM addresses were aligned to fix an issue in Taz Express:
#541
However, this broke saving in Command & Conquer. I tried a couple things, like just aligned PI DMA Writes, Command & Conquer wouldn't boot at all then.
The thing that makes both games (Taz and C&C) work is just aligning the cart addresses.
I'll admit that I don't really understand why, the documentation says:

We summarize restrictions on DMA transfers as follows:

RDRAM address must be 8-byte aligned---the three least significant bits of address
must be zeroes.
BSD address must be 2-byte aligned---the least significant bit of address must be zero.
Length of DMA must be a multiple of 8 bytes (specified as the byte count - 1)---the
three least significant bits of the length register should always be ones.
Maximum transfer size is 16 MByte.","This PR fixes:
#600
Cart and DRAM addresses were aligned to fix an issue in Taz Express:
#541
However, this broke saving in Command & Conquer. I tried a couple things, like just aligned PI DMA Writes, Command & Conquer wouldn't boot at all then.
The thing that makes both games (Taz and C&C) work is just aligning the cart addresses.
I'll admit that I don't really understand why, the documentation says:

We summarize restrictions on DMA transfers as follows:

RDRAM address must be 8-byte aligned---the three least significant bits of address
must be zeroes.
BSD address must be 2-byte aligned---the least significant bit of address must be zero.
Length of DMA must be a multiple of 8 bytes (specified as the byte count - 1)---the
three least significant bits of the length register should always be ones.
Maximum transfer size is 16 MByte.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,705,2020-02-16T03:17:33Z,2020-02-19T07:45:41Z,2021-06-20T20:44:27Z,MERGED,True,2,2,1,https://github.com/loganmc10,Only align cart address in PI DMA,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/705,https://github.com/Gillou68310,2,https://github.com/mupen64plus/mupen64plus-core/pull/705#issuecomment-587587306,"This PR fixes:
#600
Cart and DRAM addresses were aligned to fix an issue in Taz Express:
#541
However, this broke saving in Command & Conquer. I tried a couple things, like just aligned PI DMA Writes, Command & Conquer wouldn't boot at all then.
The thing that makes both games (Taz and C&C) work is just aligning the cart addresses.
I'll admit that I don't really understand why, the documentation says:

We summarize restrictions on DMA transfers as follows:

RDRAM address must be 8-byte aligned---the three least significant bits of address
must be zeroes.
BSD address must be 2-byte aligned---the least significant bit of address must be zero.
Length of DMA must be a multiple of 8 bytes (specified as the byte count - 1)---the
three least significant bits of the length register should always be ones.
Maximum transfer size is 16 MByte.","Well from the docs RDRAM address must be 8-byte aligned, not sure what to say here...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,705,2020-02-16T03:17:33Z,2020-02-19T07:45:41Z,2021-06-20T20:44:27Z,MERGED,True,2,2,1,https://github.com/loganmc10,Only align cart address in PI DMA,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/705,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/705#issuecomment-587593299,"This PR fixes:
#600
Cart and DRAM addresses were aligned to fix an issue in Taz Express:
#541
However, this broke saving in Command & Conquer. I tried a couple things, like just aligned PI DMA Writes, Command & Conquer wouldn't boot at all then.
The thing that makes both games (Taz and C&C) work is just aligning the cart addresses.
I'll admit that I don't really understand why, the documentation says:

We summarize restrictions on DMA transfers as follows:

RDRAM address must be 8-byte aligned---the three least significant bits of address
must be zeroes.
BSD address must be 2-byte aligned---the least significant bit of address must be zero.
Length of DMA must be a multiple of 8 bytes (specified as the byte count - 1)---the
three least significant bits of the length register should always be ones.
Maximum transfer size is 16 MByte.","Yes this is where hardware tests are useful, the docs say that, but it doesn't define what the behavior is when you violate that instruction.
For what it's worth, when cen64 implemented this fix, they only aligned the cart address, not the DRAM address:
n64dev/cen64#123",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,705,2020-02-16T03:17:33Z,2020-02-19T07:45:41Z,2021-06-20T20:44:27Z,MERGED,True,2,2,1,https://github.com/loganmc10,Only align cart address in PI DMA,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/705,https://github.com/m4xw,4,https://github.com/mupen64plus/mupen64plus-core/pull/705#issuecomment-587596015,"This PR fixes:
#600
Cart and DRAM addresses were aligned to fix an issue in Taz Express:
#541
However, this broke saving in Command & Conquer. I tried a couple things, like just aligned PI DMA Writes, Command & Conquer wouldn't boot at all then.
The thing that makes both games (Taz and C&C) work is just aligning the cart addresses.
I'll admit that I don't really understand why, the documentation says:

We summarize restrictions on DMA transfers as follows:

RDRAM address must be 8-byte aligned---the three least significant bits of address
must be zeroes.
BSD address must be 2-byte aligned---the least significant bit of address must be zero.
Length of DMA must be a multiple of 8 bytes (specified as the byte count - 1)---the
three least significant bits of the length register should always be ones.
Maximum transfer size is 16 MByte.","The whole forcing alignments on the side of hw seems problematic for me.
These are limitations imposed by the silicone, so shouldn't the requests be dropped instead of forcing the alignment?
Usually if u do unaligned dma where it's not supported these chips just hang or set a error bit.
Would be weird if real hw would align it down..",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,705,2020-02-16T03:17:33Z,2020-02-19T07:45:41Z,2021-06-20T20:44:27Z,MERGED,True,2,2,1,https://github.com/loganmc10,Only align cart address in PI DMA,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/705,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/705#issuecomment-587597185,"This PR fixes:
#600
Cart and DRAM addresses were aligned to fix an issue in Taz Express:
#541
However, this broke saving in Command & Conquer. I tried a couple things, like just aligned PI DMA Writes, Command & Conquer wouldn't boot at all then.
The thing that makes both games (Taz and C&C) work is just aligning the cart addresses.
I'll admit that I don't really understand why, the documentation says:

We summarize restrictions on DMA transfers as follows:

RDRAM address must be 8-byte aligned---the three least significant bits of address
must be zeroes.
BSD address must be 2-byte aligned---the least significant bit of address must be zero.
Length of DMA must be a multiple of 8 bytes (specified as the byte count - 1)---the
three least significant bits of the length register should always be ones.
Maximum transfer size is 16 MByte.","@m4xw the N64 does that, in a lot of the docs you'll read things like ""the least 3 significant bits are assumed to be 0"", so it aligns the DMAs by basically not caring what you write into certain bits.
The CEN64 folks did some actual hardware tests as well to verify the cart address alignment behavior: n64dev/cen64#86",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,705,2020-02-16T03:17:33Z,2020-02-19T07:45:41Z,2021-06-20T20:44:27Z,MERGED,True,2,2,1,https://github.com/loganmc10,Only align cart address in PI DMA,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/705,https://github.com/m4xw,6,https://github.com/mupen64plus/mupen64plus-core/pull/705#issuecomment-587600731,"This PR fixes:
#600
Cart and DRAM addresses were aligned to fix an issue in Taz Express:
#541
However, this broke saving in Command & Conquer. I tried a couple things, like just aligned PI DMA Writes, Command & Conquer wouldn't boot at all then.
The thing that makes both games (Taz and C&C) work is just aligning the cart addresses.
I'll admit that I don't really understand why, the documentation says:

We summarize restrictions on DMA transfers as follows:

RDRAM address must be 8-byte aligned---the three least significant bits of address
must be zeroes.
BSD address must be 2-byte aligned---the least significant bit of address must be zero.
Length of DMA must be a multiple of 8 bytes (specified as the byte count - 1)---the
three least significant bits of the length register should always be ones.
Maximum transfer size is 16 MByte.","What the actual fuck.
They should state that then, I don't wanna know how many cycles were wasted back in the day just masking lower bits..
Some engineer is screaming in his grave rn at the guy that wrote the technical documentation..",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,706,2020-02-16T20:17:27Z,2020-02-24T08:56:12Z,2020-02-24T08:56:12Z,MERGED,True,1,0,1,https://github.com/fzurita,Enable transferpak write,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/706,https://github.com/fzurita,1,https://github.com/mupen64plus/mupen64plus-core/pull/706,"Is there any reason why transfer pak writes are disabled? As far as I can tell, it's as simple as the change I did in this pull request.
I can understand why 64DD writes are disabled, but I think we could write it when emulation stops instead of writing the whole file every single write.
With this change, I was able to load a game boy RAM file, make some changes in pokemon stadium 2, save the changes, load the RAM file in a gamebody emulator in Pokemon Gold and I checked that the changes were applied.","Is there any reason why transfer pak writes are disabled? As far as I can tell, it's as simple as the change I did in this pull request.
I can understand why 64DD writes are disabled, but I think we could write it when emulation stops instead of writing the whole file every single write.
With this change, I was able to load a game boy RAM file, make some changes in pokemon stadium 2, save the changes, load the RAM file in a gamebody emulator in Pokemon Gold and I checked that the changes were applied.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,706,2020-02-16T20:17:27Z,2020-02-24T08:56:12Z,2020-02-24T08:56:12Z,MERGED,True,1,0,1,https://github.com/fzurita,Enable transferpak write,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/706,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/706#issuecomment-587415990,"Is there any reason why transfer pak writes are disabled? As far as I can tell, it's as simple as the change I did in this pull request.
I can understand why 64DD writes are disabled, but I think we could write it when emulation stops instead of writing the whole file every single write.
With this change, I was able to load a game boy RAM file, make some changes in pokemon stadium 2, save the changes, load the RAM file in a gamebody emulator in Pokemon Gold and I checked that the changes were applied.",@bsmiles32 Any thoughts? This should be very quick.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,706,2020-02-16T20:17:27Z,2020-02-24T08:56:12Z,2020-02-24T08:56:12Z,MERGED,True,1,0,1,https://github.com/fzurita,Enable transferpak write,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/706,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/706#issuecomment-588419980,"Is there any reason why transfer pak writes are disabled? As far as I can tell, it's as simple as the change I did in this pull request.
I can understand why 64DD writes are disabled, but I think we could write it when emulation stops instead of writing the whole file every single write.
With this change, I was able to load a game boy RAM file, make some changes in pokemon stadium 2, save the changes, load the RAM file in a gamebody emulator in Pokemon Gold and I checked that the changes were applied.","It does seem like it was maybe an oversight? All the other save types (flashram, etc..) save to disk after a write",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,706,2020-02-16T20:17:27Z,2020-02-24T08:56:12Z,2020-02-24T08:56:12Z,MERGED,True,1,0,1,https://github.com/fzurita,Enable transferpak write,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/706,https://github.com/bsmiles32,4,https://github.com/mupen64plus/mupen64plus-core/pull/706#issuecomment-588881892,"Is there any reason why transfer pak writes are disabled? As far as I can tell, it's as simple as the change I did in this pull request.
I can understand why 64DD writes are disabled, but I think we could write it when emulation stops instead of writing the whole file every single write.
With this change, I was able to load a game boy RAM file, make some changes in pokemon stadium 2, save the changes, load the RAM file in a gamebody emulator in Pokemon Gold and I checked that the changes were applied.",Lgtm,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,706,2020-02-16T20:17:27Z,2020-02-24T08:56:12Z,2020-02-24T08:56:12Z,MERGED,True,1,0,1,https://github.com/fzurita,Enable transferpak write,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/706,https://github.com/fzurita,5,https://github.com/mupen64plus/mupen64plus-core/pull/706#issuecomment-589870350,"Is there any reason why transfer pak writes are disabled? As far as I can tell, it's as simple as the change I did in this pull request.
I can understand why 64DD writes are disabled, but I think we could write it when emulation stops instead of writing the whole file every single write.
With this change, I was able to load a game boy RAM file, make some changes in pokemon stadium 2, save the changes, load the RAM file in a gamebody emulator in Pokemon Gold and I checked that the changes were applied.",Can this be merged since bsmiles32 is ok with it?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,707,2020-02-17T14:45:45Z,2020-03-23T09:39:12Z,2021-06-20T20:45:29Z,MERGED,True,53,24,8,https://github.com/loganmc10,Implement cart ROM writes as described by Jan Goldacker,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/707,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/707,"Fixes #609
@jago85 did some investigation on how cart ROM writes are handled a while ago (#511 (comment))
The basic gist I got from that is that our current ""rom_written"" code should only happen if the game tries to read back the value when PI_STATUS_IO_BUSY is set, otherwise it should just read the regular value.
It does seem to work that way, this change fixes WCW Backstage Assault, and other games that depend on this code (A Bug's Life, Toy Story 2) still work.
A big thanks to @jago85, there is no way we would have figured this out without those actual hardware tests.","Fixes #609
@jago85 did some investigation on how cart ROM writes are handled a while ago (#511 (comment))
The basic gist I got from that is that our current ""rom_written"" code should only happen if the game tries to read back the value when PI_STATUS_IO_BUSY is set, otherwise it should just read the regular value.
It does seem to work that way, this change fixes WCW Backstage Assault, and other games that depend on this code (A Bug's Life, Toy Story 2) still work.
A big thanks to @jago85, there is no way we would have figured this out without those actual hardware tests.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,707,2020-02-17T14:45:45Z,2020-03-23T09:39:12Z,2021-06-20T20:45:29Z,MERGED,True,53,24,8,https://github.com/loganmc10,Implement cart ROM writes as described by Jan Goldacker,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/707,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/707#issuecomment-590469931,"Fixes #609
@jago85 did some investigation on how cart ROM writes are handled a while ago (#511 (comment))
The basic gist I got from that is that our current ""rom_written"" code should only happen if the game tries to read back the value when PI_STATUS_IO_BUSY is set, otherwise it should just read the regular value.
It does seem to work that way, this change fixes WCW Backstage Assault, and other games that depend on this code (A Bug's Life, Toy Story 2) still work.
A big thanks to @jago85, there is no way we would have figured this out without those actual hardware tests.","I'm not sure why AppVeyor isn't happy, but it doesn't seem related to this change. I've tested all the games that I know of that attempt to write to the cartridge ROM, I haven't found any regressions",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,707,2020-02-17T14:45:45Z,2020-03-23T09:39:12Z,2021-06-20T20:45:29Z,MERGED,True,53,24,8,https://github.com/loganmc10,Implement cart ROM writes as described by Jan Goldacker,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/707,https://github.com/Jj0YzL5nvJ,3,https://github.com/mupen64plus/mupen64plus-core/pull/707#issuecomment-590559765,"Fixes #609
@jago85 did some investigation on how cart ROM writes are handled a while ago (#511 (comment))
The basic gist I got from that is that our current ""rom_written"" code should only happen if the game tries to read back the value when PI_STATUS_IO_BUSY is set, otherwise it should just read the regular value.
It does seem to work that way, this change fixes WCW Backstage Assault, and other games that depend on this code (A Bug's Life, Toy Story 2) still work.
A big thanks to @jago85, there is no way we would have figured this out without those actual hardware tests.","Yeah, AppVeyor has been having very weird issues lately.
All configurations are being compiled properly on my machine.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,707,2020-02-17T14:45:45Z,2020-03-23T09:39:12Z,2021-06-20T20:45:29Z,MERGED,True,53,24,8,https://github.com/loganmc10,Implement cart ROM writes as described by Jan Goldacker,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/707,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/707#issuecomment-594460359,"Fixes #609
@jago85 did some investigation on how cart ROM writes are handled a while ago (#511 (comment))
The basic gist I got from that is that our current ""rom_written"" code should only happen if the game tries to read back the value when PI_STATUS_IO_BUSY is set, otherwise it should just read the regular value.
It does seem to work that way, this change fixes WCW Backstage Assault, and other games that depend on this code (A Bug's Life, Toy Story 2) still work.
A big thanks to @jago85, there is no way we would have figured this out without those actual hardware tests.","Hi all, any thoughts on this?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,707,2020-02-17T14:45:45Z,2020-03-23T09:39:12Z,2021-06-20T20:45:29Z,MERGED,True,53,24,8,https://github.com/loganmc10,Implement cart ROM writes as described by Jan Goldacker,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/707,https://github.com/Jj0YzL5nvJ,5,https://github.com/mupen64plus/mupen64plus-core/pull/707#issuecomment-594461599,"Fixes #609
@jago85 did some investigation on how cart ROM writes are handled a while ago (#511 (comment))
The basic gist I got from that is that our current ""rom_written"" code should only happen if the game tries to read back the value when PI_STATUS_IO_BUSY is set, otherwise it should just read the regular value.
It does seem to work that way, this change fixes WCW Backstage Assault, and other games that depend on this code (A Bug's Life, Toy Story 2) still work.
A big thanks to @jago85, there is no way we would have figured this out without those actual hardware tests.",See #729,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,707,2020-02-17T14:45:45Z,2020-03-23T09:39:12Z,2021-06-20T20:45:29Z,MERGED,True,53,24,8,https://github.com/loganmc10,Implement cart ROM writes as described by Jan Goldacker,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/707,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/707#issuecomment-594654076,"Fixes #609
@jago85 did some investigation on how cart ROM writes are handled a while ago (#511 (comment))
The basic gist I got from that is that our current ""rom_written"" code should only happen if the game tries to read back the value when PI_STATUS_IO_BUSY is set, otherwise it should just read the regular value.
It does seem to work that way, this change fixes WCW Backstage Assault, and other games that depend on this code (A Bug's Life, Toy Story 2) still work.
A big thanks to @jago85, there is no way we would have figured this out without those actual hardware tests.","Sorry I meant specifically related to this PR, I trust the AppVeyor issues will get sorted out",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,707,2020-02-17T14:45:45Z,2020-03-23T09:39:12Z,2021-06-20T20:45:29Z,MERGED,True,53,24,8,https://github.com/loganmc10,Implement cart ROM writes as described by Jan Goldacker,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/707,https://github.com/bsmiles32,7,https://github.com/mupen64plus/mupen64plus-core/pull/707#issuecomment-602485100,"Fixes #609
@jago85 did some investigation on how cart ROM writes are handled a while ago (#511 (comment))
The basic gist I got from that is that our current ""rom_written"" code should only happen if the game tries to read back the value when PI_STATUS_IO_BUSY is set, otherwise it should just read the regular value.
It does seem to work that way, this change fixes WCW Backstage Assault, and other games that depend on this code (A Bug's Life, Toy Story 2) still work.
A big thanks to @jago85, there is no way we would have figured this out without those actual hardware tests.","Also tested said games and found no obvious regression.
I still think with some refactoring, we could move this IO_BUSY logic inside the PI instead of spreading it in cart/cart_rom. It would also probably best reflect how the hardware works. But for now it is better than what we have and fixes real issues. So merging this work.
Thanks to all involved especially to @jago85 for the hardware investigation.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,708,2020-02-17T15:47:25Z,2020-02-23T17:44:05Z,2020-02-24T10:14:15Z,MERGED,True,334,228,14,https://github.com/Gillou68310,Rework interrupt scheduling,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/708,https://github.com/Gillou68310,1,https://github.com/mupen64plus/mupen64plus-core/pull/708,"@loganmc10
I didn't realized it at first but #701 is breaking the new dynarec very badly.
The main limitation is that the number of cycles between current cycle count and next interrupt event cannot exceed 2^31
I reworked interrupt scheduling a bit:


cp0_next_interrupt is now a negative number representing the
number of cycles left until next interrupt is taken.
Next interrupt is taken whether cp0_next_interrupt value is positive or null


Special interrupt is now a fake interrupt which porpose is
to ensure the number of cycles between current cycle count
and next interrupt will never exceed 2^31


I still need to fix both dynarecs.
In the meantime this PR needs to be tested to see if there's no regression","@loganmc10
I didn't realized it at first but #701 is breaking the new dynarec very badly.
The main limitation is that the number of cycles between current cycle count and next interrupt event cannot exceed 2^31
I reworked interrupt scheduling a bit:


cp0_next_interrupt is now a negative number representing the
number of cycles left until next interrupt is taken.
Next interrupt is taken whether cp0_next_interrupt value is positive or null


Special interrupt is now a fake interrupt which porpose is
to ensure the number of cycles between current cycle count
and next interrupt will never exceed 2^31


I still need to fix both dynarecs.
In the meantime this PR needs to be tested to see if there's no regression",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,708,2020-02-17T15:47:25Z,2020-02-23T17:44:05Z,2020-02-24T10:14:15Z,MERGED,True,334,228,14,https://github.com/Gillou68310,Rework interrupt scheduling,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/708,https://github.com/Gillou68310,2,https://github.com/mupen64plus/mupen64plus-core/pull/708#issuecomment-587056019,"@loganmc10
I didn't realized it at first but #701 is breaking the new dynarec very badly.
The main limitation is that the number of cycles between current cycle count and next interrupt event cannot exceed 2^31
I reworked interrupt scheduling a bit:


cp0_next_interrupt is now a negative number representing the
number of cycles left until next interrupt is taken.
Next interrupt is taken whether cp0_next_interrupt value is positive or null


Special interrupt is now a fake interrupt which porpose is
to ensure the number of cycles between current cycle count
and next interrupt will never exceed 2^31


I still need to fix both dynarecs.
In the meantime this PR needs to be tested to see if there's no regression",@loganmc10 sorry for wasting your time on the other PR BTW,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,708,2020-02-17T15:47:25Z,2020-02-23T17:44:05Z,2020-02-24T10:14:15Z,MERGED,True,334,228,14,https://github.com/Gillou68310,Rework interrupt scheduling,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/708,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/708#issuecomment-587061255,"@loganmc10
I didn't realized it at first but #701 is breaking the new dynarec very badly.
The main limitation is that the number of cycles between current cycle count and next interrupt event cannot exceed 2^31
I reworked interrupt scheduling a bit:


cp0_next_interrupt is now a negative number representing the
number of cycles left until next interrupt is taken.
Next interrupt is taken whether cp0_next_interrupt value is positive or null


Special interrupt is now a fake interrupt which porpose is
to ensure the number of cycles between current cycle count
and next interrupt will never exceed 2^31


I still need to fix both dynarecs.
In the meantime this PR needs to be tested to see if there's no regression","No problem, I'll take a look and do some testing. Just so I understand

The main limitation is that the number of cycles between current cycle count and next interrupt event cannot exceed 2^31

You mean this is a limitation of the new dynarec? It still doesn't seem great to me, the SPECIAL_INT is still a sort of hack in this PR, even if it is more harmless now",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,708,2020-02-17T15:47:25Z,2020-02-23T17:44:05Z,2020-02-24T10:14:15Z,MERGED,True,334,228,14,https://github.com/Gillou68310,Rework interrupt scheduling,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/708,https://github.com/Gillou68310,4,https://github.com/mupen64plus/mupen64plus-core/pull/708#issuecomment-587064136,"@loganmc10
I didn't realized it at first but #701 is breaking the new dynarec very badly.
The main limitation is that the number of cycles between current cycle count and next interrupt event cannot exceed 2^31
I reworked interrupt scheduling a bit:


cp0_next_interrupt is now a negative number representing the
number of cycles left until next interrupt is taken.
Next interrupt is taken whether cp0_next_interrupt value is positive or null


Special interrupt is now a fake interrupt which porpose is
to ensure the number of cycles between current cycle count
and next interrupt will never exceed 2^31


I still need to fix both dynarecs.
In the meantime this PR needs to be tested to see if there's no regression","You mean this is a limitation of the new dynarec?

Yes mainly. It's also a limitation with the new design here if we want to keep next_interrupt as 32bits.

It still doesn't seem great to me, the SPECIAL_INT is still a sort of hack in this PR, even if it is more harmless now

I agree but like I said, without it, it means drop support for 32bits new_dynarec rn.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,708,2020-02-17T15:47:25Z,2020-02-23T17:44:05Z,2020-02-24T10:14:15Z,MERGED,True,334,228,14,https://github.com/Gillou68310,Rework interrupt scheduling,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/708,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/708#issuecomment-587065877,"@loganmc10
I didn't realized it at first but #701 is breaking the new dynarec very badly.
The main limitation is that the number of cycles between current cycle count and next interrupt event cannot exceed 2^31
I reworked interrupt scheduling a bit:


cp0_next_interrupt is now a negative number representing the
number of cycles left until next interrupt is taken.
Next interrupt is taken whether cp0_next_interrupt value is positive or null


Special interrupt is now a fake interrupt which porpose is
to ensure the number of cycles between current cycle count
and next interrupt will never exceed 2^31


I still need to fix both dynarecs.
In the meantime this PR needs to be tested to see if there's no regression",Ok I'll take a look. IMO we have way too much dynarec going on as-is. I would drop the old dynarec and the x86 new dynarec completely. Most half decent android devices support arm64 as well. It's so much code to maintain and you are probably the only person who understands how it works.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,708,2020-02-17T15:47:25Z,2020-02-23T17:44:05Z,2020-02-24T10:14:15Z,MERGED,True,334,228,14,https://github.com/Gillou68310,Rework interrupt scheduling,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/708,https://github.com/Gillou68310,6,https://github.com/mupen64plus/mupen64plus-core/pull/708#issuecomment-587067905,"@loganmc10
I didn't realized it at first but #701 is breaking the new dynarec very badly.
The main limitation is that the number of cycles between current cycle count and next interrupt event cannot exceed 2^31
I reworked interrupt scheduling a bit:


cp0_next_interrupt is now a negative number representing the
number of cycles left until next interrupt is taken.
Next interrupt is taken whether cp0_next_interrupt value is positive or null


Special interrupt is now a fake interrupt which porpose is
to ensure the number of cycles between current cycle count
and next interrupt will never exceed 2^31


I still need to fix both dynarecs.
In the meantime this PR needs to be tested to see if there's no regression",If only new dynarec was perfect ;-),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,708,2020-02-17T15:47:25Z,2020-02-23T17:44:05Z,2020-02-24T10:14:15Z,MERGED,True,334,228,14,https://github.com/Gillou68310,Rework interrupt scheduling,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/708,https://github.com/Gillou68310,7,https://github.com/mupen64plus/mupen64plus-core/pull/708#issuecomment-587077823,"@loganmc10
I didn't realized it at first but #701 is breaking the new dynarec very badly.
The main limitation is that the number of cycles between current cycle count and next interrupt event cannot exceed 2^31
I reworked interrupt scheduling a bit:


cp0_next_interrupt is now a negative number representing the
number of cycles left until next interrupt is taken.
Next interrupt is taken whether cp0_next_interrupt value is positive or null


Special interrupt is now a fake interrupt which porpose is
to ensure the number of cycles between current cycle count
and next interrupt will never exceed 2^31


I still need to fix both dynarecs.
In the meantime this PR needs to be tested to see if there's no regression",Added support for Hacktarux dynarecs,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,708,2020-02-17T15:47:25Z,2020-02-23T17:44:05Z,2020-02-24T10:14:15Z,MERGED,True,334,228,14,https://github.com/Gillou68310,Rework interrupt scheduling,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/708,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/708#issuecomment-587090812,"@loganmc10
I didn't realized it at first but #701 is breaking the new dynarec very badly.
The main limitation is that the number of cycles between current cycle count and next interrupt event cannot exceed 2^31
I reworked interrupt scheduling a bit:


cp0_next_interrupt is now a negative number representing the
number of cycles left until next interrupt is taken.
Next interrupt is taken whether cp0_next_interrupt value is positive or null


Special interrupt is now a fake interrupt which porpose is
to ensure the number of cycles between current cycle count
and next interrupt will never exceed 2^31


I still need to fix both dynarecs.
In the meantime this PR needs to be tested to see if there's no regression",Just did a bit of testing with the Cached Interpreter. Twisted Edge Extreme Snowboarding freezes right as the race is starting with this PR.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,708,2020-02-17T15:47:25Z,2020-02-23T17:44:05Z,2020-02-24T10:14:15Z,MERGED,True,334,228,14,https://github.com/Gillou68310,Rework interrupt scheduling,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/708,https://github.com/Gillou68310,9,https://github.com/mupen64plus/mupen64plus-core/pull/708#issuecomment-587099313,"@loganmc10
I didn't realized it at first but #701 is breaking the new dynarec very badly.
The main limitation is that the number of cycles between current cycle count and next interrupt event cannot exceed 2^31
I reworked interrupt scheduling a bit:


cp0_next_interrupt is now a negative number representing the
number of cycles left until next interrupt is taken.
Next interrupt is taken whether cp0_next_interrupt value is positive or null


Special interrupt is now a fake interrupt which porpose is
to ensure the number of cycles between current cycle count
and next interrupt will never exceed 2^31


I still need to fix both dynarecs.
In the meantime this PR needs to be tested to see if there's no regression","Just did a bit of testing with the Cached Interpreter. Twisted Edge Extreme Snowboarding freezes right as the race is starting with this PR.

I guess it's not with freezing with #701?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,708,2020-02-17T15:47:25Z,2020-02-23T17:44:05Z,2020-02-24T10:14:15Z,MERGED,True,334,228,14,https://github.com/Gillou68310,Rework interrupt scheduling,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/708,https://github.com/loganmc10,10,https://github.com/mupen64plus/mupen64plus-core/pull/708#issuecomment-587100542,"@loganmc10
I didn't realized it at first but #701 is breaking the new dynarec very badly.
The main limitation is that the number of cycles between current cycle count and next interrupt event cannot exceed 2^31
I reworked interrupt scheduling a bit:


cp0_next_interrupt is now a negative number representing the
number of cycles left until next interrupt is taken.
Next interrupt is taken whether cp0_next_interrupt value is positive or null


Special interrupt is now a fake interrupt which porpose is
to ensure the number of cycles between current cycle count
and next interrupt will never exceed 2^31


I still need to fix both dynarecs.
In the meantime this PR needs to be tested to see if there's no regression","Correct, as far as I could tell, there is even some improvement with #701, perhaps you could verify.
With the current master, if you just run through a race (click A through the menu and complete a race), about halfway through the race, the audio usually glitches out for about a second, and it goes all static.
With #701 I've never experienced that. The game appears to use the COMPARE_INT to time the audio, when I was working on #701, when it wasn't quite working right, the audio in Twisted Edge actually cut out completely part way through the race.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,708,2020-02-17T15:47:25Z,2020-02-23T17:44:05Z,2020-02-24T10:14:15Z,MERGED,True,334,228,14,https://github.com/Gillou68310,Rework interrupt scheduling,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/708,https://github.com/loganmc10,11,https://github.com/mupen64plus/mupen64plus-core/pull/708#issuecomment-587105828,"@loganmc10
I didn't realized it at first but #701 is breaking the new dynarec very badly.
The main limitation is that the number of cycles between current cycle count and next interrupt event cannot exceed 2^31
I reworked interrupt scheduling a bit:


cp0_next_interrupt is now a negative number representing the
number of cycles left until next interrupt is taken.
Next interrupt is taken whether cp0_next_interrupt value is positive or null


Special interrupt is now a fake interrupt which porpose is
to ensure the number of cycles between current cycle count
and next interrupt will never exceed 2^31


I still need to fix both dynarecs.
In the meantime this PR needs to be tested to see if there's no regression","It's probably common to BOSS games, World Driver Championship appears to freeze as well. It froze for me when trying to start a race, and once just when I hit start for the first time",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,708,2020-02-17T15:47:25Z,2020-02-23T17:44:05Z,2020-02-24T10:14:15Z,MERGED,True,334,228,14,https://github.com/Gillou68310,Rework interrupt scheduling,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/708,https://github.com/Gillou68310,12,https://github.com/mupen64plus/mupen64plus-core/pull/708#issuecomment-587112366,"@loganmc10
I didn't realized it at first but #701 is breaking the new dynarec very badly.
The main limitation is that the number of cycles between current cycle count and next interrupt event cannot exceed 2^31
I reworked interrupt scheduling a bit:


cp0_next_interrupt is now a negative number representing the
number of cycles left until next interrupt is taken.
Next interrupt is taken whether cp0_next_interrupt value is positive or null


Special interrupt is now a fake interrupt which porpose is
to ensure the number of cycles between current cycle count
and next interrupt will never exceed 2^31


I still need to fix both dynarecs.
In the meantime this PR needs to be tested to see if there's no regression",Weird I cannot reproduce the freeze,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,708,2020-02-17T15:47:25Z,2020-02-23T17:44:05Z,2020-02-24T10:14:15Z,MERGED,True,334,228,14,https://github.com/Gillou68310,Rework interrupt scheduling,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/708,https://github.com/loganmc10,13,https://github.com/mupen64plus/mupen64plus-core/pull/708#issuecomment-587113054,"@loganmc10
I didn't realized it at first but #701 is breaking the new dynarec very badly.
The main limitation is that the number of cycles between current cycle count and next interrupt event cannot exceed 2^31
I reworked interrupt scheduling a bit:


cp0_next_interrupt is now a negative number representing the
number of cycles left until next interrupt is taken.
Next interrupt is taken whether cp0_next_interrupt value is positive or null


Special interrupt is now a fake interrupt which porpose is
to ensure the number of cycles between current cycle count
and next interrupt will never exceed 2^31


I still need to fix both dynarecs.
In the meantime this PR needs to be tested to see if there's no regression",U version with the cshced interpreter?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,708,2020-02-17T15:47:25Z,2020-02-23T17:44:05Z,2020-02-24T10:14:15Z,MERGED,True,334,228,14,https://github.com/Gillou68310,Rework interrupt scheduling,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/708,https://github.com/Gillou68310,14,https://github.com/mupen64plus/mupen64plus-core/pull/708#issuecomment-587376879,"@loganmc10
I didn't realized it at first but #701 is breaking the new dynarec very badly.
The main limitation is that the number of cycles between current cycle count and next interrupt event cannot exceed 2^31
I reworked interrupt scheduling a bit:


cp0_next_interrupt is now a negative number representing the
number of cycles left until next interrupt is taken.
Next interrupt is taken whether cp0_next_interrupt value is positive or null


Special interrupt is now a fake interrupt which porpose is
to ensure the number of cycles between current cycle count
and next interrupt will never exceed 2^31


I still need to fix both dynarecs.
In the meantime this PR needs to be tested to see if there's no regression",Nevermind I was able to reproduce. I pushed a fix for the issue.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,708,2020-02-17T15:47:25Z,2020-02-23T17:44:05Z,2020-02-24T10:14:15Z,MERGED,True,334,228,14,https://github.com/Gillou68310,Rework interrupt scheduling,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/708,https://github.com/Gillou68310,15,https://github.com/mupen64plus/mupen64plus-core/pull/708#issuecomment-587562948,"@loganmc10
I didn't realized it at first but #701 is breaking the new dynarec very badly.
The main limitation is that the number of cycles between current cycle count and next interrupt event cannot exceed 2^31
I reworked interrupt scheduling a bit:


cp0_next_interrupt is now a negative number representing the
number of cycles left until next interrupt is taken.
Next interrupt is taken whether cp0_next_interrupt value is positive or null


Special interrupt is now a fake interrupt which porpose is
to ensure the number of cycles between current cycle count
and next interrupt will never exceed 2^31


I still need to fix both dynarecs.
In the meantime this PR needs to be tested to see if there's no regression","@loganmc10 @m4xw I update the PR, all dynarecs should work now.
Please test and report any regression.",True,{'THUMBS_UP': ['https://github.com/m4xw']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,708,2020-02-17T15:47:25Z,2020-02-23T17:44:05Z,2020-02-24T10:14:15Z,MERGED,True,334,228,14,https://github.com/Gillou68310,Rework interrupt scheduling,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/708,https://github.com/loganmc10,16,https://github.com/mupen64plus/mupen64plus-core/pull/708#issuecomment-587956942,"@loganmc10
I didn't realized it at first but #701 is breaking the new dynarec very badly.
The main limitation is that the number of cycles between current cycle count and next interrupt event cannot exceed 2^31
I reworked interrupt scheduling a bit:


cp0_next_interrupt is now a negative number representing the
number of cycles left until next interrupt is taken.
Next interrupt is taken whether cp0_next_interrupt value is positive or null


Special interrupt is now a fake interrupt which porpose is
to ensure the number of cycles between current cycle count
and next interrupt will never exceed 2^31


I still need to fix both dynarecs.
In the meantime this PR needs to be tested to see if there's no regression","I could have done something wrong, but it seems like Conkers doesn't boot (tested with cached interpreter). This could also be me (or my computer) as well, but I still get the big static sound halfway through a race in Twisted Edge, something that appears to be fixed in 701
This still seems like the wrong approach to me, the goal of removing the special int was to simplify the interrupt code and make the interrupt timing more precise/correct.
There must be some way to do 64 bit math using 32 bit ASM? I assume using 2 registers? I'm not really sure why the dynarecs are involved with interrupt timing/incrementing the count register, could that not be left to the regular cp0_update_count function?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,708,2020-02-17T15:47:25Z,2020-02-23T17:44:05Z,2020-02-24T10:14:15Z,MERGED,True,334,228,14,https://github.com/Gillou68310,Rework interrupt scheduling,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/708,https://github.com/Gillou68310,17,https://github.com/mupen64plus/mupen64plus-core/pull/708#issuecomment-588153879,"@loganmc10
I didn't realized it at first but #701 is breaking the new dynarec very badly.
The main limitation is that the number of cycles between current cycle count and next interrupt event cannot exceed 2^31
I reworked interrupt scheduling a bit:


cp0_next_interrupt is now a negative number representing the
number of cycles left until next interrupt is taken.
Next interrupt is taken whether cp0_next_interrupt value is positive or null


Special interrupt is now a fake interrupt which porpose is
to ensure the number of cycles between current cycle count
and next interrupt will never exceed 2^31


I still need to fix both dynarecs.
In the meantime this PR needs to be tested to see if there's no regression","I indeed broke Conkers, I will fix that.
I'm pretty sure the audio issue in twisted edge is caused by :
if (next_ai_event <= cp0_regs[CP0_COUNT_REG])
    return 0;

this should actually be :
if ((int)(cp0_regs[CP0_COUNT_REG] - next_ai_event) >= 0)
    return 0;


This still seems like the wrong approach to me, the goal of removing the special int was to simplify the interrupt code and make the interrupt timing more precise/correct.

I understand that the special int looks hacky and it actually was in the old design. Now it's pretty clear what it is used for. Having 64 count does simplify the code but does not make interrupt timing more precise/correct in any way so I'm not sure it's worth it.

There must be some way to do 64 bit math using 32 bit ASM? I assume using 2 registers?

ofc we can, but that's actually the issue with the new_dynarec, I need one additional register for cycle count and I don't have one.

I'm not really sure why the dynarecs are involved with interrupt timing/incrementing the count register, could that not be left to the regular cp0_update_count function?

Calling C function from recompiled code involve saving currently used register to stack and restore on function return. Dynarecs usally try to avoid doing that for speed. For this and a few other reasons cycle count update is done via recompiled code.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,708,2020-02-17T15:47:25Z,2020-02-23T17:44:05Z,2020-02-24T10:14:15Z,MERGED,True,334,228,14,https://github.com/Gillou68310,Rework interrupt scheduling,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/708,https://github.com/Gillou68310,18,https://github.com/mupen64plus/mupen64plus-core/pull/708#issuecomment-588160101,"@loganmc10
I didn't realized it at first but #701 is breaking the new dynarec very badly.
The main limitation is that the number of cycles between current cycle count and next interrupt event cannot exceed 2^31
I reworked interrupt scheduling a bit:


cp0_next_interrupt is now a negative number representing the
number of cycles left until next interrupt is taken.
Next interrupt is taken whether cp0_next_interrupt value is positive or null


Special interrupt is now a fake interrupt which porpose is
to ensure the number of cycles between current cycle count
and next interrupt will never exceed 2^31


I still need to fix both dynarecs.
In the meantime this PR needs to be tested to see if there's no regression","@loganmc10 I pushed a few fixes, could you test again?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,708,2020-02-17T15:47:25Z,2020-02-23T17:44:05Z,2020-02-24T10:14:15Z,MERGED,True,334,228,14,https://github.com/Gillou68310,Rework interrupt scheduling,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/708,https://github.com/loganmc10,19,https://github.com/mupen64plus/mupen64plus-core/pull/708#issuecomment-588286619,"@loganmc10
I didn't realized it at first but #701 is breaking the new dynarec very badly.
The main limitation is that the number of cycles between current cycle count and next interrupt event cannot exceed 2^31
I reworked interrupt scheduling a bit:


cp0_next_interrupt is now a negative number representing the
number of cycles left until next interrupt is taken.
Next interrupt is taken whether cp0_next_interrupt value is positive or null


Special interrupt is now a fake interrupt which porpose is
to ensure the number of cycles between current cycle count
and next interrupt will never exceed 2^31


I still need to fix both dynarecs.
In the meantime this PR needs to be tested to see if there's no regression","Alright you've alleviated my fears lol. Everything is looking pretty good, Twisted Edge audio seems fixed, Conkers boots. There are a couple new compiler warnings:
../../src/device/r4300/interrupt.c: In function 'translate_event_queue':
../../src/device/r4300/interrupt.c:281:75: warning: suggest parentheses around arithmetic in operand of '^' [-Wparentheses]
  281 |     add_interrupt_event_count(cp0, SPECIAL_INT, ((cp0_regs[CP0_COUNT_REG] & UINT32_C(0x80000000) ^ UINT32_C(0x80000000))));
      |                                                                           ^
../../src/device/r4300/interrupt.c: In function 'load_eventqueue_infos':
../../src/device/r4300/interrupt.c:327:75: warning: suggest parentheses around arithmetic in operand of '^' [-Wparentheses]
  327 |     add_interrupt_event_count(cp0, SPECIAL_INT, ((cp0_regs[CP0_COUNT_REG] & UINT32_C(0x80000000) ^ UINT32_C(0x80000000))));
      |                                                                           ^
../../src/device/r4300/interrupt.c: In function 'special_int_handler':
../../src/device/r4300/interrupt.c:430:75: warning: suggest parentheses around arithmetic in operand of '^' [-Wparentheses]
  430 |     add_interrupt_event_count(cp0, SPECIAL_INT, ((cp0_regs[CP0_COUNT_REG] & UINT32_C(0x80000000) ^ UINT32_C(0x80000000))));
      |                                                                           ^
    CC  _obj/device/rcp/ai/ai_controller.o
    CC  _obj/device/rcp/mi/mi_controller.o
../../src/device/rcp/mi/mi_controller.c: In function 'write_mi_regs':
../../src/device/rcp/mi/mi_controller.c:94:15: warning: unused variable 'cp0_regs' [-Wunused-variable]
   94 |     uint32_t* cp0_regs = r4300_cp0_regs(&mi->r4300->cp0);


And there are a few places where you've used tabs instead of spaces for the indenting. Besides that I think it looks all good",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,708,2020-02-17T15:47:25Z,2020-02-23T17:44:05Z,2020-02-24T10:14:15Z,MERGED,True,334,228,14,https://github.com/Gillou68310,Rework interrupt scheduling,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/708,https://github.com/Gillou68310,20,https://github.com/mupen64plus/mupen64plus-core/pull/708#issuecomment-588305519,"@loganmc10
I didn't realized it at first but #701 is breaking the new dynarec very badly.
The main limitation is that the number of cycles between current cycle count and next interrupt event cannot exceed 2^31
I reworked interrupt scheduling a bit:


cp0_next_interrupt is now a negative number representing the
number of cycles left until next interrupt is taken.
Next interrupt is taken whether cp0_next_interrupt value is positive or null


Special interrupt is now a fake interrupt which porpose is
to ensure the number of cycles between current cycle count
and next interrupt will never exceed 2^31


I still need to fix both dynarecs.
In the meantime this PR needs to be tested to see if there's no regression","Thanks for the feedback! I rebased, fixed the warnings and remove tabs.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,708,2020-02-17T15:47:25Z,2020-02-23T17:44:05Z,2020-02-24T10:14:15Z,MERGED,True,334,228,14,https://github.com/Gillou68310,Rework interrupt scheduling,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/708,https://github.com/loganmc10,21,https://github.com/mupen64plus/mupen64plus-core/pull/708#issuecomment-588402002,"@loganmc10
I didn't realized it at first but #701 is breaking the new dynarec very badly.
The main limitation is that the number of cycles between current cycle count and next interrupt event cannot exceed 2^31
I reworked interrupt scheduling a bit:


cp0_next_interrupt is now a negative number representing the
number of cycles left until next interrupt is taken.
Next interrupt is taken whether cp0_next_interrupt value is positive or null


Special interrupt is now a fake interrupt which porpose is
to ensure the number of cycles between current cycle count
and next interrupt will never exceed 2^31


I still need to fix both dynarecs.
In the meantime this PR needs to be tested to see if there's no regression","I think it looks good, I would still probably wait for a review from @bsmiles32 if possible before merging, it touches a fairly significant portion of the code",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,708,2020-02-17T15:47:25Z,2020-02-23T17:44:05Z,2020-02-24T10:14:15Z,MERGED,True,334,228,14,https://github.com/Gillou68310,Rework interrupt scheduling,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/708,https://github.com/Gillou68310,22,https://github.com/mupen64plus/mupen64plus-core/pull/708#issuecomment-588885670,"@loganmc10
I didn't realized it at first but #701 is breaking the new dynarec very badly.
The main limitation is that the number of cycles between current cycle count and next interrupt event cannot exceed 2^31
I reworked interrupt scheduling a bit:


cp0_next_interrupt is now a negative number representing the
number of cycles left until next interrupt is taken.
Next interrupt is taken whether cp0_next_interrupt value is positive or null


Special interrupt is now a fake interrupt which porpose is
to ensure the number of cycles between current cycle count
and next interrupt will never exceed 2^31


I still need to fix both dynarecs.
In the meantime this PR needs to be tested to see if there's no regression",Ok I fixed the indentation,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,708,2020-02-17T15:47:25Z,2020-02-23T17:44:05Z,2020-02-24T10:14:15Z,MERGED,True,334,228,14,https://github.com/Gillou68310,Rework interrupt scheduling,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/708,https://github.com/loganmc10,23,https://github.com/mupen64plus/mupen64plus-core/pull/708#issuecomment-590090701,"@loganmc10
I didn't realized it at first but #701 is breaking the new dynarec very badly.
The main limitation is that the number of cycles between current cycle count and next interrupt event cannot exceed 2^31
I reworked interrupt scheduling a bit:


cp0_next_interrupt is now a negative number representing the
number of cycles left until next interrupt is taken.
Next interrupt is taken whether cp0_next_interrupt value is positive or null


Special interrupt is now a fake interrupt which porpose is
to ensure the number of cycles between current cycle count
and next interrupt will never exceed 2^31


I still need to fix both dynarecs.
In the meantime this PR needs to be tested to see if there's no regression","Unless someone else is intending on reviewing this I would say it should be merged. I've tested a decent number of games, I don't see any regressions. This will hopefully fix some random freezing that the current SPECIAL_INT causes",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,709,2020-02-18T14:58:40Z,2020-02-19T08:07:03Z,2021-06-20T20:44:40Z,MERGED,True,40,8,1,https://github.com/loganmc10,Proper handling of divide by zero,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/709,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/709,"I was testing these test ROMs:
https://github.com/PeterLemon/N64/tree/master/CPUTest
We pass all the CPU tests except for division.
I took this implementation from n64dev/cen64#79. So credit to @sp1187 for this code.
After this PR, all the division test ROMs pass. The only commercial game that I know of that consistently tries to do division by zero is Toy Story 2 (it currently spits out a bunch of ""DIV by zero"" warnings). I tested that game and it still seems to work fine.
rrs32 == INT32_MIN && rrt32 == -1 is a special case, the result of that equation is actually an integer overflow, which was crashing the emulator, so it needs to be dealt with in an if statement, same as the cen64 implementation.","I was testing these test ROMs:
https://github.com/PeterLemon/N64/tree/master/CPUTest
We pass all the CPU tests except for division.
I took this implementation from n64dev/cen64#79. So credit to @sp1187 for this code.
After this PR, all the division test ROMs pass. The only commercial game that I know of that consistently tries to do division by zero is Toy Story 2 (it currently spits out a bunch of ""DIV by zero"" warnings). I tested that game and it still seems to work fine.
rrs32 == INT32_MIN && rrt32 == -1 is a special case, the result of that equation is actually an integer overflow, which was crashing the emulator, so it needs to be dealt with in an if statement, same as the cen64 implementation.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,709,2020-02-18T14:58:40Z,2020-02-19T08:07:03Z,2021-06-20T20:44:40Z,MERGED,True,40,8,1,https://github.com/loganmc10,Proper handling of divide by zero,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/709,https://github.com/Gillou68310,2,https://github.com/mupen64plus/mupen64plus-core/pull/709#issuecomment-587576833,"I was testing these test ROMs:
https://github.com/PeterLemon/N64/tree/master/CPUTest
We pass all the CPU tests except for division.
I took this implementation from n64dev/cen64#79. So credit to @sp1187 for this code.
After this PR, all the division test ROMs pass. The only commercial game that I know of that consistently tries to do division by zero is Toy Story 2 (it currently spits out a bunch of ""DIV by zero"" warnings). I tested that game and it still seems to work fine.
rrs32 == INT32_MIN && rrt32 == -1 is a special case, the result of that equation is actually an integer overflow, which was crashing the emulator, so it needs to be dealt with in an if statement, same as the cen64 implementation.","The DIV/DIVU implem does not match cen's one, why is that?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,709,2020-02-18T14:58:40Z,2020-02-19T08:07:03Z,2021-06-20T20:44:40Z,MERGED,True,40,8,1,https://github.com/loganmc10,Proper handling of divide by zero,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/709,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/709#issuecomment-587596003,"I was testing these test ROMs:
https://github.com/PeterLemon/N64/tree/master/CPUTest
We pass all the CPU tests except for division.
I took this implementation from n64dev/cen64#79. So credit to @sp1187 for this code.
After this PR, all the division test ROMs pass. The only commercial game that I know of that consistently tries to do division by zero is Toy Story 2 (it currently spits out a bunch of ""DIV by zero"" warnings). I tested that game and it still seems to work fine.
rrs32 == INT32_MIN && rrt32 == -1 is a special case, the result of that equation is actually an integer overflow, which was crashing the emulator, so it needs to be dealt with in an if statement, same as the cen64 implementation.","I assume you mean:
rrs32 == INT32_MIN && rrt32 == -1 in DIV
cen64 does this for DDIV (using INT64_MIN), but not DIV. I'm not really sure why that was omitted, the test ROM includes the case of INT32_MIN/-1, which causes an integer overflow, so it's a valid case for DIV as well.
I'm not sure what other differences you mean, CEN64 combines DIV and DIVU into one function, so the test:
div = rs < 0 ? 1 : -1; is always -1 for DIVU, since rs must be positive.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,709,2020-02-18T14:58:40Z,2020-02-19T08:07:03Z,2021-06-20T20:44:40Z,MERGED,True,40,8,1,https://github.com/loganmc10,Proper handling of divide by zero,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/709,https://github.com/Gillou68310,4,https://github.com/mupen64plus/mupen64plus-core/pull/709#issuecomment-587598273,"I was testing these test ROMs:
https://github.com/PeterLemon/N64/tree/master/CPUTest
We pass all the CPU tests except for division.
I took this implementation from n64dev/cen64#79. So credit to @sp1187 for this code.
After this PR, all the division test ROMs pass. The only commercial game that I know of that consistently tries to do division by zero is Toy Story 2 (it currently spits out a bunch of ""DIV by zero"" warnings). I tested that game and it still seems to work fine.
rrs32 == INT32_MIN && rrt32 == -1 is a special case, the result of that equation is actually an integer overflow, which was crashing the emulator, so it needs to be dealt with in an if statement, same as the cen64 implementation.","rrs32 == INT32_MIN && rrt32 == -1 in DIV

I was talking about that indeed, anyway if the test ROM pass, I guess the implementation is correct",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,709,2020-02-18T14:58:40Z,2020-02-19T08:07:03Z,2021-06-20T20:44:40Z,MERGED,True,40,8,1,https://github.com/loganmc10,Proper handling of divide by zero,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/709,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/709#issuecomment-587598797,"I was testing these test ROMs:
https://github.com/PeterLemon/N64/tree/master/CPUTest
We pass all the CPU tests except for division.
I took this implementation from n64dev/cen64#79. So credit to @sp1187 for this code.
After this PR, all the division test ROMs pass. The only commercial game that I know of that consistently tries to do division by zero is Toy Story 2 (it currently spits out a bunch of ""DIV by zero"" warnings). I tested that game and it still seems to work fine.
rrs32 == INT32_MIN && rrt32 == -1 is a special case, the result of that equation is actually an integer overflow, which was crashing the emulator, so it needs to be dealt with in an if statement, same as the cen64 implementation.","Yes, without that the emulator crashes when running the test ROM because of the integer overflow, I'm not aware of any game that actually attempts that equation besides this test ROM though",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,709,2020-02-18T14:58:40Z,2020-02-19T08:07:03Z,2021-06-20T20:44:40Z,MERGED,True,40,8,1,https://github.com/loganmc10,Proper handling of divide by zero,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/709,https://github.com/sp1187,6,https://github.com/mupen64plus/mupen64plus-core/pull/709#issuecomment-587600181,"I was testing these test ROMs:
https://github.com/PeterLemon/N64/tree/master/CPUTest
We pass all the CPU tests except for division.
I took this implementation from n64dev/cen64#79. So credit to @sp1187 for this code.
After this PR, all the division test ROMs pass. The only commercial game that I know of that consistently tries to do division by zero is Toy Story 2 (it currently spits out a bunch of ""DIV by zero"" warnings). I tested that game and it still seems to work fine.
rrs32 == INT32_MIN && rrt32 == -1 is a special case, the result of that equation is actually an integer overflow, which was crashing the emulator, so it needs to be dealt with in an if statement, same as the cen64 implementation.","If I remember correctly the fix wasn't necessary for DIV since the actual division operation performed by the emulator is 64-bit, therefore there can not be an overflow in this case. (see n64dev/cen64@65b5a08#diff-ceb3e456120f6dff3fc50512d81546a5R711). If you're doing a 32-bit operation for DIV, you will of course need it there too.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,709,2020-02-18T14:58:40Z,2020-02-19T08:07:03Z,2021-06-20T20:44:40Z,MERGED,True,40,8,1,https://github.com/loganmc10,Proper handling of divide by zero,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/709,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/709#issuecomment-587611272,"I was testing these test ROMs:
https://github.com/PeterLemon/N64/tree/master/CPUTest
We pass all the CPU tests except for division.
I took this implementation from n64dev/cen64#79. So credit to @sp1187 for this code.
After this PR, all the division test ROMs pass. The only commercial game that I know of that consistently tries to do division by zero is Toy Story 2 (it currently spits out a bunch of ""DIV by zero"" warnings). I tested that game and it still seems to work fine.
rrs32 == INT32_MIN && rrt32 == -1 is a special case, the result of that equation is actually an integer overflow, which was crashing the emulator, so it needs to be dealt with in an if statement, same as the cen64 implementation.","Yes in our case rrs32 is an int32_t, which I guess explains why I needed it",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,710,2020-02-19T19:34:58Z,2020-03-02T00:13:48Z,2021-06-20T20:45:03Z,MERGED,True,2,1,1,https://github.com/loganmc10,Disable FBInfo support for dynarecs,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/710,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/710,"Right now FBInfo doesn't work properly on either dynarec, see:
#493
#214
It's better to not advertise support for FBInfo at all if it isn't working, since plugins like GLideN64 have it enabled by default for certain games.
From my testing it works pretty reliably with the interpreters","Right now FBInfo doesn't work properly on either dynarec, see:
#493
#214
It's better to not advertise support for FBInfo at all if it isn't working, since plugins like GLideN64 have it enabled by default for certain games.
From my testing it works pretty reliably with the interpreters",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,710,2020-02-19T19:34:58Z,2020-03-02T00:13:48Z,2021-06-20T20:45:03Z,MERGED,True,2,1,1,https://github.com/loganmc10,Disable FBInfo support for dynarecs,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/710,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/710#issuecomment-588573563,"Right now FBInfo doesn't work properly on either dynarec, see:
#493
#214
It's better to not advertise support for FBInfo at all if it isn't working, since plugins like GLideN64 have it enabled by default for certain games.
From my testing it works pretty reliably with the interpreters","I agree that FB Info doesn't work the dynarecs. Looks good time. This allows not having to manually turn off FB Info in the graphics plugin when running with the dynarecs.
If FB Info does start working with the dynarecs, we will have to remember to disable the checks.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,710,2020-02-19T19:34:58Z,2020-03-02T00:13:48Z,2021-06-20T20:45:03Z,MERGED,True,2,1,1,https://github.com/loganmc10,Disable FBInfo support for dynarecs,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/710,https://github.com/fzurita,3,https://github.com/mupen64plus/mupen64plus-core/pull/710#issuecomment-588577297,"Right now FBInfo doesn't work properly on either dynarec, see:
#493
#214
It's better to not advertise support for FBInfo at all if it isn't working, since plugins like GLideN64 have it enabled by default for certain games.
From my testing it works pretty reliably with the interpreters","Even better, the check is in only one place now.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,710,2020-02-19T19:34:58Z,2020-03-02T00:13:48Z,2021-06-20T20:45:03Z,MERGED,True,2,1,1,https://github.com/loganmc10,Disable FBInfo support for dynarecs,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/710,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/710#issuecomment-588580574,"Right now FBInfo doesn't work properly on either dynarec, see:
#493
#214
It's better to not advertise support for FBInfo at all if it isn't working, since plugins like GLideN64 have it enabled by default for certain games.
From my testing it works pretty reliably with the interpreters","Yeah I realized what I was doing was redundant, hopefully it can get sorted out in the dynarecs one day and this can be removed, it's a pretty cool feature",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,710,2020-02-19T19:34:58Z,2020-03-02T00:13:48Z,2021-06-20T20:45:03Z,MERGED,True,2,1,1,https://github.com/loganmc10,Disable FBInfo support for dynarecs,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/710,https://github.com/bsmiles32,5,https://github.com/mupen64plus/mupen64plus-core/pull/710#issuecomment-588886233,"Right now FBInfo doesn't work properly on either dynarec, see:
#493
#214
It's better to not advertise support for FBInfo at all if it isn't working, since plugins like GLideN64 have it enabled by default for certain games.
From my testing it works pretty reliably with the interpreters",Please add a comment in the code to explain why it is disabled for dynarec.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,710,2020-02-19T19:34:58Z,2020-03-02T00:13:48Z,2021-06-20T20:45:03Z,MERGED,True,2,1,1,https://github.com/loganmc10,Disable FBInfo support for dynarecs,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/710,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/710#issuecomment-589180782,"Right now FBInfo doesn't work properly on either dynarec, see:
#493
#214
It's better to not advertise support for FBInfo at all if it isn't working, since plugins like GLideN64 have it enabled by default for certain games.
From my testing it works pretty reliably with the interpreters",done,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,710,2020-02-19T19:34:58Z,2020-03-02T00:13:48Z,2021-06-20T20:45:03Z,MERGED,True,2,1,1,https://github.com/loganmc10,Disable FBInfo support for dynarecs,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/710,https://github.com/Gillou68310,7,https://github.com/mupen64plus/mupen64plus-core/pull/710#issuecomment-591381632,"Right now FBInfo doesn't work properly on either dynarec, see:
#493
#214
It's better to not advertise support for FBInfo at all if it isn't working, since plugins like GLideN64 have it enabled by default for certain games.
From my testing it works pretty reliably with the interpreters","I have an idea to fix FB Info with dynarecs using exceptions, but in the meantime this should be acceptable.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,714,2020-02-21T04:57:56Z,2020-02-24T08:54:43Z,2021-06-20T20:45:11Z,MERGED,True,4,0,1,https://github.com/loganmc10,Use cheat code to allow Rat Attack to boot,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/714,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/714,"Thanks to @m4xw for helping me track down the correct memory addresses.
Obviously not the correct fix, but at least this won't dirty up the main emulation code. Tested with the U and E versions","Thanks to @m4xw for helping me track down the correct memory addresses.
Obviously not the correct fix, but at least this won't dirty up the main emulation code. Tested with the U and E versions",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,714,2020-02-21T04:57:56Z,2020-02-24T08:54:43Z,2021-06-20T20:45:11Z,MERGED,True,4,0,1,https://github.com/loganmc10,Use cheat code to allow Rat Attack to boot,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/714,https://github.com/m4xw,2,https://github.com/mupen64plus/mupen64plus-core/pull/714#issuecomment-589648147,"Thanks to @m4xw for helping me track down the correct memory addresses.
Obviously not the correct fix, but at least this won't dirty up the main emulation code. Tested with the U and E versions","@loganmc10 can you please remove the ""@"" from the commit?
Everytime I rebase my stuff it will ping myself, that isnt the first time, heh.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,714,2020-02-21T04:57:56Z,2020-02-24T08:54:43Z,2021-06-20T20:45:11Z,MERGED,True,4,0,1,https://github.com/loganmc10,Use cheat code to allow Rat Attack to boot,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/714,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/714#issuecomment-589713985,"Thanks to @m4xw for helping me track down the correct memory addresses.
Obviously not the correct fix, but at least this won't dirty up the main emulation code. Tested with the U and E versions","sure thing, done",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,715,2020-02-22T01:43:59Z,2020-12-01T17:24:45Z,2020-12-01T17:24:45Z,CLOSED,False,111,52,8,https://github.com/fzurita,Save 64DD data to SRAM folder in a zip file on emulation end,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/715,https://github.com/fzurita,1,https://github.com/mupen64plus/mupen64plus-core/pull/715,"This adds support for saving and loading 64DD data from a compressed zip file instead of the original image. The compressed zip file is stored in the SRAM folder like other save data but only once emulation finishes. The save file will be extracted and loaded when emulation starts up again for a disk with the same file name.
I tried using bsdiff before compressing the file, but that turned out to be way too slow. Creating a patch for a ~60MB 64DD image in my relatively high end phone took about 2 minutes to run, so it did not seem like an acceptable option to use bsdiff.
Also, I did not test the get_filename_from_path function I added for windows or MacOs, I'm hopefully someone else can test that.","This adds support for saving and loading 64DD data from a compressed zip file instead of the original image. The compressed zip file is stored in the SRAM folder like other save data but only once emulation finishes. The save file will be extracted and loaded when emulation starts up again for a disk with the same file name.
I tried using bsdiff before compressing the file, but that turned out to be way too slow. Creating a patch for a ~60MB 64DD image in my relatively high end phone took about 2 minutes to run, so it did not seem like an acceptable option to use bsdiff.
Also, I did not test the get_filename_from_path function I added for windows or MacOs, I'm hopefully someone else can test that.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,715,2020-02-22T01:43:59Z,2020-12-01T17:24:45Z,2020-12-01T17:24:45Z,CLOSED,False,111,52,8,https://github.com/fzurita,Save 64DD data to SRAM folder in a zip file on emulation end,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/715,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/715#issuecomment-590135089,"This adds support for saving and loading 64DD data from a compressed zip file instead of the original image. The compressed zip file is stored in the SRAM folder like other save data but only once emulation finishes. The save file will be extracted and loaded when emulation starts up again for a disk with the same file name.
I tried using bsdiff before compressing the file, but that turned out to be way too slow. Creating a patch for a ~60MB 64DD image in my relatively high end phone took about 2 minutes to run, so it did not seem like an acceptable option to use bsdiff.
Also, I did not test the get_filename_from_path function I added for windows or MacOs, I'm hopefully someone else can test that.",@bsmiles32 are you ok with this?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,715,2020-02-22T01:43:59Z,2020-12-01T17:24:45Z,2020-12-01T17:24:45Z,CLOSED,False,111,52,8,https://github.com/fzurita,Save 64DD data to SRAM folder in a zip file on emulation end,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/715,https://github.com/fzurita,3,https://github.com/mupen64plus/mupen64plus-core/pull/715#issuecomment-736700097,"This adds support for saving and loading 64DD data from a compressed zip file instead of the original image. The compressed zip file is stored in the SRAM folder like other save data but only once emulation finishes. The save file will be extracted and loaded when emulation starts up again for a disk with the same file name.
I tried using bsdiff before compressing the file, but that turned out to be way too slow. Creating a patch for a ~60MB 64DD image in my relatively high end phone took about 2 minutes to run, so it did not seem like an acceptable option to use bsdiff.
Also, I did not test the get_filename_from_path function I added for windows or MacOs, I'm hopefully someone else can test that.",Closing in favor of the work from @LuigiBlood,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,716,2020-02-22T20:39:43Z,2020-02-22T22:11:14Z,2021-06-20T20:45:18Z,MERGED,True,8,8,1,https://github.com/loganmc10,Change some DD logging to only happen in verbose mode,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/716,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/716,"Excessive logging can really kill performance (depending on the frontend).
The DD controller is currently printing out a lot of logs just for things like DMA reads and writes. This converts the logs to ""verbose"" mode, so they'll only print out if you have verbose mode enabled","Excessive logging can really kill performance (depending on the frontend).
The DD controller is currently printing out a lot of logs just for things like DMA reads and writes. This converts the logs to ""verbose"" mode, so they'll only print out if you have verbose mode enabled",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,716,2020-02-22T20:39:43Z,2020-02-22T22:11:14Z,2021-06-20T20:45:18Z,MERGED,True,8,8,1,https://github.com/loganmc10,Change some DD logging to only happen in verbose mode,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/716,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/716#issuecomment-590003270,"Excessive logging can really kill performance (depending on the frontend).
The DD controller is currently printing out a lot of logs just for things like DMA reads and writes. This converts the logs to ""verbose"" mode, so they'll only print out if you have verbose mode enabled",Looks simple enough.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,717,2020-02-23T17:31:34Z,2020-02-25T09:20:41Z,2021-06-20T20:45:59Z,MERGED,True,26,23,5,https://github.com/loganmc10,Don't check event count to test if event is pending,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/717,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/717,"Right now we use the ""count"" of the next event to check if that type of event is pending.
This could lead to the (admittedly rare) situation where the next event is scheduled at COUNT_REG 0, and get_event() would return the incorrect answer.","Right now we use the ""count"" of the next event to check if that type of event is pending.
This could lead to the (admittedly rare) situation where the next event is scheduled at COUNT_REG 0, and get_event() would return the incorrect answer.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,717,2020-02-23T17:31:34Z,2020-02-25T09:20:41Z,2021-06-20T20:45:59Z,MERGED,True,26,23,5,https://github.com/loganmc10,Don't check event count to test if event is pending,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/717,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/717#issuecomment-590098278,"Right now we use the ""count"" of the next event to check if that type of event is pending.
This could lead to the (admittedly rare) situation where the next event is scheduled at COUNT_REG 0, and get_event() would return the incorrect answer.",rebased against master and simplified a bit,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,717,2020-02-23T17:31:34Z,2020-02-25T09:20:41Z,2021-06-20T20:45:59Z,MERGED,True,26,23,5,https://github.com/loganmc10,Don't check event count to test if event is pending,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/717,https://github.com/Gillou68310,3,https://github.com/mupen64plus/mupen64plus-core/pull/717#issuecomment-590100699,"Right now we use the ""count"" of the next event to check if that type of event is pending.
This could lead to the (admittedly rare) situation where the next event is scheduled at COUNT_REG 0, and get_event() would return the incorrect answer.","I would rather return a pointer to either node  or interrupt_event instead.
If pointer is not null just get the count from it, otherwise it means no event of coresponding type in event list.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,717,2020-02-23T17:31:34Z,2020-02-25T09:20:41Z,2021-06-20T20:45:59Z,MERGED,True,26,23,5,https://github.com/loganmc10,Don't check event count to test if event is pending,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/717,https://github.com/Gillou68310,4,https://github.com/mupen64plus/mupen64plus-core/pull/717#issuecomment-590101129,"Right now we use the ""count"" of the next event to check if that type of event is pending.
This could lead to the (admittedly rare) situation where the next event is scheduled at COUNT_REG 0, and get_event() would return the incorrect answer.",Rare situation indeed but nice catch ;-),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,717,2020-02-23T17:31:34Z,2020-02-25T09:20:41Z,2021-06-20T20:45:59Z,MERGED,True,26,23,5,https://github.com/loganmc10,Don't check event count to test if event is pending,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/717,https://github.com/Gillou68310,5,https://github.com/mupen64plus/mupen64plus-core/pull/717#issuecomment-590101415,"Right now we use the ""count"" of the next event to check if that type of event is pending.
This could lead to the (admittedly rare) situation where the next event is scheduled at COUNT_REG 0, and get_event() would return the incorrect answer.",Well on a second thought just return a pointer unsigned int,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,717,2020-02-23T17:31:34Z,2020-02-25T09:20:41Z,2021-06-20T20:45:59Z,MERGED,True,26,23,5,https://github.com/loganmc10,Don't check event count to test if event is pending,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/717,https://github.com/Gillou68310,6,https://github.com/mupen64plus/mupen64plus-core/pull/717#issuecomment-590101582,"Right now we use the ""count"" of the next event to check if that type of event is pending.
This could lead to the (admittedly rare) situation where the next event is scheduled at COUNT_REG 0, and get_event() would return the incorrect answer.","unsigned int* get_event(const struct interrupt_queue* q, int type)
{
    const struct node* e = q->first;

    if (e == NULL) {
        return NULL;
    }

    if (e->data.type == type) {
        return &e->data.count;
    }

    for (; e->next != NULL && e->next->data.type != type; e = e->next);

    return (e->next != NULL)
        ? &e->next->data.count
        : NULL;
}",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,717,2020-02-23T17:31:34Z,2020-02-25T09:20:41Z,2021-06-20T20:45:59Z,MERGED,True,26,23,5,https://github.com/loganmc10,Don't check event count to test if event is pending,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/717,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/717#issuecomment-590128670,"Right now we use the ""count"" of the next event to check if that type of event is pending.
This could lead to the (admittedly rare) situation where the next event is scheduled at COUNT_REG 0, and get_event() would return the incorrect answer.","Good suggestion, I've updated the PR",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,717,2020-02-23T17:31:34Z,2020-02-25T09:20:41Z,2021-06-20T20:45:59Z,MERGED,True,26,23,5,https://github.com/loganmc10,Don't check event count to test if event is pending,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/717,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/717#issuecomment-590374598,"Right now we use the ""count"" of the next event to check if that type of event is pending.
This could lead to the (admittedly rare) situation where the next event is scheduled at COUNT_REG 0, and get_event() would return the incorrect answer.","Good suggestions, I've updated the PR",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,718,2020-02-24T03:33:38Z,2020-03-23T10:24:14Z,2021-06-20T20:44:31Z,MERGED,True,5,5,1,https://github.com/loganmc10,Adjust DD DMA timing,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/718,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/718,"I believe the formula for DD DMA timing (length * 63 / 25) was taken from MAME:
https://github.com/mamedev/mame/blob/master/src/mame/machine/n64.cpp#L1573
They say ""Measured as between 2.53 cycles per byte and 2.55 cycles per byte"". 63/25 is 2.52.
We time our interrupts using the COUNT register, which increments at 1/2 the clock speed. To me this means we should be using 63/50.
This change allows F-Zero DD expansion to boot, before it was just sitting on the ""DD Loading"" screen. The only other game I have tested it the ""Dawn to Dusk"" Zelda OoT homebrew that was recently released.
The rest of the DD games should be tested to make sure there aren't regressions, I haven't found a really good way to boot them because of the requirement for a cartridge ROM. Maybe someone that knows how to get all those games booted can give this PR a try? I wouldn't merge this until the rest of the DD games can be tested for regressions","I believe the formula for DD DMA timing (length * 63 / 25) was taken from MAME:
https://github.com/mamedev/mame/blob/master/src/mame/machine/n64.cpp#L1573
They say ""Measured as between 2.53 cycles per byte and 2.55 cycles per byte"". 63/25 is 2.52.
We time our interrupts using the COUNT register, which increments at 1/2 the clock speed. To me this means we should be using 63/50.
This change allows F-Zero DD expansion to boot, before it was just sitting on the ""DD Loading"" screen. The only other game I have tested it the ""Dawn to Dusk"" Zelda OoT homebrew that was recently released.
The rest of the DD games should be tested to make sure there aren't regressions, I haven't found a really good way to boot them because of the requirement for a cartridge ROM. Maybe someone that knows how to get all those games booted can give this PR a try? I wouldn't merge this until the rest of the DD games can be tested for regressions",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,718,2020-02-24T03:33:38Z,2020-03-23T10:24:14Z,2021-06-20T20:44:31Z,MERGED,True,5,5,1,https://github.com/loganmc10,Adjust DD DMA timing,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/718,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/718#issuecomment-590158521,"I believe the formula for DD DMA timing (length * 63 / 25) was taken from MAME:
https://github.com/mamedev/mame/blob/master/src/mame/machine/n64.cpp#L1573
They say ""Measured as between 2.53 cycles per byte and 2.55 cycles per byte"". 63/25 is 2.52.
We time our interrupts using the COUNT register, which increments at 1/2 the clock speed. To me this means we should be using 63/50.
This change allows F-Zero DD expansion to boot, before it was just sitting on the ""DD Loading"" screen. The only other game I have tested it the ""Dawn to Dusk"" Zelda OoT homebrew that was recently released.
The rest of the DD games should be tested to make sure there aren't regressions, I haven't found a really good way to boot them because of the requirement for a cartridge ROM. Maybe someone that knows how to get all those games booted can give this PR a try? I wouldn't merge this until the rest of the DD games can be tested for regressions","I guess I should say to: I tested using the cached interpreter. F-Zero already worked with the dynarec for some reason, but not the interpreter. This change appears to make the same work in both modes. I'm still not 100% sure if that was just a fluke, or as the result of more accurate timing though.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,718,2020-02-24T03:33:38Z,2020-03-23T10:24:14Z,2021-06-20T20:44:31Z,MERGED,True,5,5,1,https://github.com/loganmc10,Adjust DD DMA timing,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/718,https://github.com/fzurita,3,https://github.com/mupen64plus/mupen64plus-core/pull/718#issuecomment-590269398,"I believe the formula for DD DMA timing (length * 63 / 25) was taken from MAME:
https://github.com/mamedev/mame/blob/master/src/mame/machine/n64.cpp#L1573
They say ""Measured as between 2.53 cycles per byte and 2.55 cycles per byte"". 63/25 is 2.52.
We time our interrupts using the COUNT register, which increments at 1/2 the clock speed. To me this means we should be using 63/50.
This change allows F-Zero DD expansion to boot, before it was just sitting on the ""DD Loading"" screen. The only other game I have tested it the ""Dawn to Dusk"" Zelda OoT homebrew that was recently released.
The rest of the DD games should be tested to make sure there aren't regressions, I haven't found a really good way to boot them because of the requirement for a cartridge ROM. Maybe someone that knows how to get all those games booted can give this PR a try? I wouldn't merge this until the rest of the DD games can be tested for regressions","Ok, I will test soon.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,718,2020-02-24T03:33:38Z,2020-03-23T10:24:14Z,2021-06-20T20:44:31Z,MERGED,True,5,5,1,https://github.com/loganmc10,Adjust DD DMA timing,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/718,https://github.com/bsmiles32,4,https://github.com/mupen64plus/mupen64plus-core/pull/718#issuecomment-602507284,"I believe the formula for DD DMA timing (length * 63 / 25) was taken from MAME:
https://github.com/mamedev/mame/blob/master/src/mame/machine/n64.cpp#L1573
They say ""Measured as between 2.53 cycles per byte and 2.55 cycles per byte"". 63/25 is 2.52.
We time our interrupts using the COUNT register, which increments at 1/2 the clock speed. To me this means we should be using 63/50.
This change allows F-Zero DD expansion to boot, before it was just sitting on the ""DD Loading"" screen. The only other game I have tested it the ""Dawn to Dusk"" Zelda OoT homebrew that was recently released.
The rest of the DD games should be tested to make sure there aren't regressions, I haven't found a really good way to boot them because of the requirement for a cartridge ROM. Maybe someone that knows how to get all those games booted can give this PR a try? I wouldn't merge this until the rest of the DD games can be tested for regressions","Note: To test non-combo disks, just put a regular japanese cart rom (which will be ""ignored""). If you put a non japanese game, country check may fail.
So I tested most of DD disk and there are some improvements such as DPGJ that now works and EFZJ that works with pure interpreter, cached interpreter, dynarec.
Some new warnings are emitted with DKDJ, DKIJ, DKKJ, DRDJ about unaligned dword reads which is a bit surprising. And they don't really boot. But they didn't work much better before, so I guess we can merge this.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,721,2020-02-25T03:33:44Z,2020-06-29T03:31:33Z,2021-06-20T20:45:43Z,MERGED,True,135,39,7,https://github.com/loganmc10,Emulate RSP DMA FIFO queue,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/721,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/721,"I modelled the FIFO queue after the AI FIFO queue. There is not actually an interrupt that happens at the end of the DMA, but I've used the interrupt/event queue to schedule the end of the DMA, since that is the most convenient way.
I haven't noticed any difference in any game, either an improvement or a regression. As suggested, most games just check DMA_BUSY to see if the DMA is complete, since we never set that bit in our current code, games probably just assume the DMA was really fast. This should get us a little closer to timing accuracy, since the games will wait a bit for the DMA to complete, like on a real N64","I modelled the FIFO queue after the AI FIFO queue. There is not actually an interrupt that happens at the end of the DMA, but I've used the interrupt/event queue to schedule the end of the DMA, since that is the most convenient way.
I haven't noticed any difference in any game, either an improvement or a regression. As suggested, most games just check DMA_BUSY to see if the DMA is complete, since we never set that bit in our current code, games probably just assume the DMA was really fast. This should get us a little closer to timing accuracy, since the games will wait a bit for the DMA to complete, like on a real N64",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,721,2020-02-25T03:33:44Z,2020-06-29T03:31:33Z,2021-06-20T20:45:43Z,MERGED,True,135,39,7,https://github.com/loganmc10,Emulate RSP DMA FIFO queue,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/721,https://github.com/Gillou68310,2,https://github.com/mupen64plus/mupen64plus-core/pull/721#issuecomment-590810678,"I modelled the FIFO queue after the AI FIFO queue. There is not actually an interrupt that happens at the end of the DMA, but I've used the interrupt/event queue to schedule the end of the DMA, since that is the most convenient way.
I haven't noticed any difference in any game, either an improvement or a regression. As suggested, most games just check DMA_BUSY to see if the DMA is complete, since we never set that bit in our current code, games probably just assume the DMA was really fast. This should get us a little closer to timing accuracy, since the games will wait a bit for the DMA to complete, like on a real N64","I'm not sure to understand the point of having a new fake interrupt here. Like you said DMA completion is triggered by a flag, this is usually done via idle loops eg:
04001478 mfc0   r2, SP_DMA_FULL
0400147C bne    r2, 0, $0400147C
04001480 mfc0   r2, SP_DMA_FULL

Idle loops are skiped in the emulator, which means cycle count is set to the next interrupt value.
So rsp_end_of_dma_event purpose is just to delay the count?
Cycle count is a big hack that is really far from accuracy (see count_per_op).
It's just my opinion but this is more likely to introduce new regressions than help timing accuracy.
It's even more true if there's no issue in the first place.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,721,2020-02-25T03:33:44Z,2020-06-29T03:31:33Z,2021-06-20T20:45:43Z,MERGED,True,135,39,7,https://github.com/loganmc10,Emulate RSP DMA FIFO queue,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/721,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/721#issuecomment-590971646,"I modelled the FIFO queue after the AI FIFO queue. There is not actually an interrupt that happens at the end of the DMA, but I've used the interrupt/event queue to schedule the end of the DMA, since that is the most convenient way.
I haven't noticed any difference in any game, either an improvement or a regression. As suggested, most games just check DMA_BUSY to see if the DMA is complete, since we never set that bit in our current code, games probably just assume the DMA was really fast. This should get us a little closer to timing accuracy, since the games will wait a bit for the DMA to complete, like on a real N64","It's just an attempt to make the emulator more accurate. It's very clear in the documentation that this is how the DMAs are supposed to be treated.
You're right that right now we don't emulate the count register very accurately, but we might one day, and even with what we do now, games still read the count register and look at compare interrupts for timing. Right now we basically emulate an RSP DMA as taking 0 cycles. This should bring it a lot closer to accuracy.
I've actually tested quite a few games with this, and I haven't found a single game that actually double buffers an RSP DMA (they don't start a new DMA when DMA_BUSY is set), so you are correct that every game I've seen probably spins at an idle loop waiting for DMA_BUSY to clear. But that doesn't mean there isn't some game out there that does something differently.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,721,2020-02-25T03:33:44Z,2020-06-29T03:31:33Z,2021-06-20T20:45:43Z,MERGED,True,135,39,7,https://github.com/loganmc10,Emulate RSP DMA FIFO queue,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/721,https://github.com/Gillou68310,4,https://github.com/mupen64plus/mupen64plus-core/pull/721#issuecomment-591380328,"I modelled the FIFO queue after the AI FIFO queue. There is not actually an interrupt that happens at the end of the DMA, but I've used the interrupt/event queue to schedule the end of the DMA, since that is the most convenient way.
I haven't noticed any difference in any game, either an improvement or a regression. As suggested, most games just check DMA_BUSY to see if the DMA is complete, since we never set that bit in our current code, games probably just assume the DMA was really fast. This should get us a little closer to timing accuracy, since the games will wait a bit for the DMA to complete, like on a real N64","You're right that right now we don't emulate the count register very accurately, but we might one day

This day will probably never happen! We already have a cycle accurate N64 emulator.
IMO mupen's purpose is not cycle accuracy, it's more a trade of between compatibility and speed.
While your implementation seems correct, it'll cost a bit more (probably negligible) than what we have rn.
I'm not questioning your implementation but is it really worth the overhead?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,721,2020-02-25T03:33:44Z,2020-06-29T03:31:33Z,2021-06-20T20:45:43Z,MERGED,True,135,39,7,https://github.com/loganmc10,Emulate RSP DMA FIFO queue,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/721,https://github.com/Gillou68310,5,https://github.com/mupen64plus/mupen64plus-core/pull/721#issuecomment-591380492,"I modelled the FIFO queue after the AI FIFO queue. There is not actually an interrupt that happens at the end of the DMA, but I've used the interrupt/event queue to schedule the end of the DMA, since that is the most convenient way.
I haven't noticed any difference in any game, either an improvement or a regression. As suggested, most games just check DMA_BUSY to see if the DMA is complete, since we never set that bit in our current code, games probably just assume the DMA was really fast. This should get us a little closer to timing accuracy, since the games will wait a bit for the DMA to complete, like on a real N64","I'm not questioning your implementation but is it really worth the overhead?

This is an open question BTW ;-)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,721,2020-02-25T03:33:44Z,2020-06-29T03:31:33Z,2021-06-20T20:45:43Z,MERGED,True,135,39,7,https://github.com/loganmc10,Emulate RSP DMA FIFO queue,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/721,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/721#issuecomment-591562679,"I modelled the FIFO queue after the AI FIFO queue. There is not actually an interrupt that happens at the end of the DMA, but I've used the interrupt/event queue to schedule the end of the DMA, since that is the most convenient way.
I haven't noticed any difference in any game, either an improvement or a regression. As suggested, most games just check DMA_BUSY to see if the DMA is complete, since we never set that bit in our current code, games probably just assume the DMA was really fast. This should get us a little closer to timing accuracy, since the games will wait a bit for the DMA to complete, like on a real N64","Yes this isn't urgent, and I wouldn't mind hearing the opinions of others.
Like you say, I think the performance impact of this would be minimal, since idle loops are basically skipped like you say. I think it's still important for accuracy, picture this scenario:
A game writes to SP_RD_LEN_REG/SP_DRAM_ADDR_REG twice to queue up 2 DMAs. It knows that it's impossible for the 2nd DMA to happen right away, so the DRAM contents at SP_DRAM_ADDR_REG for the 2nd DMA aren't quite right yet, but they will be in 4 cycles when the game executes some other instruction. This would be ""risky"" behaviour by a game developer, since you are counting on the speed of the DMA to be predictable, however I think it would be possible.
Like I said, I haven't come across a game that does something like that, but there are a lot of games out there, I think it's possible that at least a couple might try something like that.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,721,2020-02-25T03:33:44Z,2020-06-29T03:31:33Z,2021-06-20T20:45:43Z,MERGED,True,135,39,7,https://github.com/loganmc10,Emulate RSP DMA FIFO queue,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/721,https://github.com/Gillou68310,7,https://github.com/mupen64plus/mupen64plus-core/pull/721#issuecomment-591862407,"I modelled the FIFO queue after the AI FIFO queue. There is not actually an interrupt that happens at the end of the DMA, but I've used the interrupt/event queue to schedule the end of the DMA, since that is the most convenient way.
I haven't noticed any difference in any game, either an improvement or a regression. As suggested, most games just check DMA_BUSY to see if the DMA is complete, since we never set that bit in our current code, games probably just assume the DMA was really fast. This should get us a little closer to timing accuracy, since the games will wait a bit for the DMA to complete, like on a real N64","A game writes to SP_RD_LEN_REG/SP_DRAM_ADDR_REG twice to queue up 2 DMAs. It knows that it's impossible for the 2nd DMA to happen right away, so the DRAM contents at SP_DRAM_ADDR_REG for the 2nd DMA aren't quite right yet, but they will be in 4 cycles when the game executes some other instruction. This would be ""risky"" behaviour by a game developer, since you are counting on the speed of the DMA to be predictable, however I think it would be possible.

Scheduling a DMA transfert while the DRAM data to be transfered is not in the correct state is just nonsense, nobody will ever do that!",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,721,2020-02-25T03:33:44Z,2020-06-29T03:31:33Z,2021-06-20T20:45:43Z,MERGED,True,135,39,7,https://github.com/loganmc10,Emulate RSP DMA FIFO queue,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/721,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/721#issuecomment-591980528,"I modelled the FIFO queue after the AI FIFO queue. There is not actually an interrupt that happens at the end of the DMA, but I've used the interrupt/event queue to schedule the end of the DMA, since that is the most convenient way.
I haven't noticed any difference in any game, either an improvement or a regression. As suggested, most games just check DMA_BUSY to see if the DMA is complete, since we never set that bit in our current code, games probably just assume the DMA was really fast. This should get us a little closer to timing accuracy, since the games will wait a bit for the DMA to complete, like on a real N64","BOSS games doing something similar for AI DMAs (you can read my explanation from a while back here: #200 (comment))
They only use 1 DRAM address for audio DMAs, and they modify the contents of the DRAM at that location while the DMA is happening. It's not exactly the same thing, it's safer because the game reads AI_LEN_REG to determine what point in the DMA the game is at, thus knowing which areas of DRAM are safe to modify.
Plus, I would argue that

nobody will ever do that

May be true, we wouldn't know for sure without testing every game, but they can do that. There is always the possibility that somebody creates a homebrew game that does this, that would work on a real N64, but not mupen64plus",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,721,2020-02-25T03:33:44Z,2020-06-29T03:31:33Z,2021-06-20T20:45:43Z,MERGED,True,135,39,7,https://github.com/loganmc10,Emulate RSP DMA FIFO queue,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/721,https://github.com/loganmc10,9,https://github.com/mupen64plus/mupen64plus-core/pull/721#issuecomment-609105646,"I modelled the FIFO queue after the AI FIFO queue. There is not actually an interrupt that happens at the end of the DMA, but I've used the interrupt/event queue to schedule the end of the DMA, since that is the most convenient way.
I haven't noticed any difference in any game, either an improvement or a regression. As suggested, most games just check DMA_BUSY to see if the DMA is complete, since we never set that bit in our current code, games probably just assume the DMA was really fast. This should get us a little closer to timing accuracy, since the games will wait a bit for the DMA to complete, like on a real N64","Alright I believe I incorported all the feedback, I also renamed it from ""RSP_DMA_INT"" to ""RSP_DMA_EVT"", since it's more of an ""event"" than an actual interrupt",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,721,2020-02-25T03:33:44Z,2020-06-29T03:31:33Z,2021-06-20T20:45:43Z,MERGED,True,135,39,7,https://github.com/loganmc10,Emulate RSP DMA FIFO queue,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/721,https://github.com/loganmc10,10,https://github.com/mupen64plus/mupen64plus-core/pull/721#issuecomment-609417880,"I modelled the FIFO queue after the AI FIFO queue. There is not actually an interrupt that happens at the end of the DMA, but I've used the interrupt/event queue to schedule the end of the DMA, since that is the most convenient way.
I haven't noticed any difference in any game, either an improvement or a regression. As suggested, most games just check DMA_BUSY to see if the DMA is complete, since we never set that bit in our current code, games probably just assume the DMA was really fast. This should get us a little closer to timing accuracy, since the games will wait a bit for the DMA to complete, like on a real N64","OK I've incorporated the further feedback, I removed NO_DMA, and I've memset the structs to 0 in savestate load if the version is < 1.7",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,721,2020-02-25T03:33:44Z,2020-06-29T03:31:33Z,2021-06-20T20:45:43Z,MERGED,True,135,39,7,https://github.com/loganmc10,Emulate RSP DMA FIFO queue,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/721,https://github.com/loganmc10,11,https://github.com/mupen64plus/mupen64plus-core/pull/721#issuecomment-650806677,"I modelled the FIFO queue after the AI FIFO queue. There is not actually an interrupt that happens at the end of the DMA, but I've used the interrupt/event queue to schedule the end of the DMA, since that is the most convenient way.
I haven't noticed any difference in any game, either an improvement or a regression. As suggested, most games just check DMA_BUSY to see if the DMA is complete, since we never set that bit in our current code, games probably just assume the DMA was really fast. This should get us a little closer to timing accuracy, since the games will wait a bit for the DMA to complete, like on a real N64","I think I've incorporated all the suggested feedback into this PR. It's been included in https://m64p.github.io for months now, I haven't heard of any issues, I think it is good to be merged. It has a merge conflict with #743, so it would be good to merge this so that #743 can be updated to be mergable",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,725,2020-02-27T07:25:29Z,2020-10-10T00:30:40Z,2021-06-20T20:45:42Z,MERGED,True,25,14,5,https://github.com/loganmc10,Implement PIF write flags properly,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/725,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/725,"Here is another DMA flag fix, similar to #721 . As is the case with that PR, I haven't actually come across a game that does a CPU write to PIF RAM, but the documentation is clear:
dma_busy indicates a DMA is in progress (or an IO write operation)
dma_busy is set for all dma and io write operations
DMA and IO writes generate an si_interrupt upon completion to inform host software that the operation has concluded.
I would really love to find a game that does this so I can verify this behaviour, I'll probably keep trying to find an example, unless somebody has a way to search through game ASM code for SW operations to the PIF RAM address.","Here is another DMA flag fix, similar to #721 . As is the case with that PR, I haven't actually come across a game that does a CPU write to PIF RAM, but the documentation is clear:
dma_busy indicates a DMA is in progress (or an IO write operation)
dma_busy is set for all dma and io write operations
DMA and IO writes generate an si_interrupt upon completion to inform host software that the operation has concluded.
I would really love to find a game that does this so I can verify this behaviour, I'll probably keep trying to find an example, unless somebody has a way to search through game ASM code for SW operations to the PIF RAM address.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,725,2020-02-27T07:25:29Z,2020-10-10T00:30:40Z,2021-06-20T20:45:42Z,MERGED,True,25,14,5,https://github.com/loganmc10,Implement PIF write flags properly,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/725,https://github.com/Gillou68310,2,https://github.com/mupen64plus/mupen64plus-core/pull/725#issuecomment-591903078,"Here is another DMA flag fix, similar to #721 . As is the case with that PR, I haven't actually come across a game that does a CPU write to PIF RAM, but the documentation is clear:
dma_busy indicates a DMA is in progress (or an IO write operation)
dma_busy is set for all dma and io write operations
DMA and IO writes generate an si_interrupt upon completion to inform host software that the operation has concluded.
I would really love to find a game that does this so I can verify this behaviour, I'll probably keep trying to find an example, unless somebody has a way to search through game ASM code for SW operations to the PIF RAM address.","I think you misinterpreted write to PIF RAM here. PIF RAM is not the actual PIF chip RAM it's a classic write to RDRAM.
You then need to write to SI_PIF_ADDR_RD64B_REG or SI_PIF_ADDR_WR64B_REG to actualy start a DMA transfer between RDRAM and PIF chip RAM.
So this implementation is wrong IMO.
However calling process_pif_ram from write_pif_ram does not makes sense.
@bsmiles32 maybe you're more familiar with PIF than I am?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,725,2020-02-27T07:25:29Z,2020-10-10T00:30:40Z,2021-06-20T20:45:42Z,MERGED,True,25,14,5,https://github.com/loganmc10,Implement PIF write flags properly,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/725,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/725#issuecomment-591984745,"Here is another DMA flag fix, similar to #721 . As is the case with that PR, I haven't actually come across a game that does a CPU write to PIF RAM, but the documentation is clear:
dma_busy indicates a DMA is in progress (or an IO write operation)
dma_busy is set for all dma and io write operations
DMA and IO writes generate an si_interrupt upon completion to inform host software that the operation has concluded.
I would really love to find a game that does this so I can verify this behaviour, I'll probably keep trying to find an example, unless somebody has a way to search through game ASM code for SW operations to the PIF RAM address.","I don't think so, for everything connected to the PI (cartridge ROM, flash, sram), you have 2 ways to access to them. You can do a DMA, or you can do a CPU/IO read or write. The IO read/write allows you to access a single word (maybe dword?) See here: https://github.com/mupen64plus/mupen64plus-core/blob/master/src/device/cart/cart.c
That's why there is a write_cart_dom2 and a cart_dom2_dma_write function for example. The same goes for the SI/PIF. For instance the SI documentation shows:

The write_pif_ram function is that IO Write. It is a bit odd that dma_busy is set for an IO/CPU write, but that's what the documentation states should happen.
write_pif_ram gets mapped based on address space here: https://github.com/mupen64plus/mupen64plus-core/blob/master/src/device/device.c#L152",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,725,2020-02-27T07:25:29Z,2020-10-10T00:30:40Z,2021-06-20T20:45:42Z,MERGED,True,25,14,5,https://github.com/loganmc10,Implement PIF write flags properly,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/725,https://github.com/Gillou68310,4,https://github.com/mupen64plus/mupen64plus-core/pull/725#issuecomment-592009378,"Here is another DMA flag fix, similar to #721 . As is the case with that PR, I haven't actually come across a game that does a CPU write to PIF RAM, but the documentation is clear:
dma_busy indicates a DMA is in progress (or an IO write operation)
dma_busy is set for all dma and io write operations
DMA and IO writes generate an si_interrupt upon completion to inform host software that the operation has concluded.
I would really love to find a game that does this so I can verify this behaviour, I'll probably keep trying to find an example, unless somebody has a way to search through game ASM code for SW operations to the PIF RAM address.","Actually you're right I read the SI specification carefully this time and it looks like your implementation reflects what the specification describes.
Mario 64 is doing a write_pif_ram BTW",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,725,2020-02-27T07:25:29Z,2020-10-10T00:30:40Z,2021-06-20T20:45:42Z,MERGED,True,25,14,5,https://github.com/loganmc10,Implement PIF write flags properly,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/725,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/725#issuecomment-592011122,"Here is another DMA flag fix, similar to #721 . As is the case with that PR, I haven't actually come across a game that does a CPU write to PIF RAM, but the documentation is clear:
dma_busy indicates a DMA is in progress (or an IO write operation)
dma_busy is set for all dma and io write operations
DMA and IO writes generate an si_interrupt upon completion to inform host software that the operation has concluded.
I would really love to find a game that does this so I can verify this behaviour, I'll probably keep trying to find an example, unless somebody has a way to search through game ASM code for SW operations to the PIF RAM address.",All games seem to do it a single time right at the beginning. I haven't found one yet that does it after that though,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,725,2020-02-27T07:25:29Z,2020-10-10T00:30:40Z,2021-06-20T20:45:42Z,MERGED,True,25,14,5,https://github.com/loganmc10,Implement PIF write flags properly,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/725,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/725#issuecomment-706446311,"Here is another DMA flag fix, similar to #721 . As is the case with that PR, I haven't actually come across a game that does a CPU write to PIF RAM, but the documentation is clear:
dma_busy indicates a DMA is in progress (or an IO write operation)
dma_busy is set for all dma and io write operations
DMA and IO writes generate an si_interrupt upon completion to inform host software that the operation has concluded.
I would really love to find a game that does this so I can verify this behaviour, I'll probably keep trying to find an example, unless somebody has a way to search through game ASM code for SW operations to the PIF RAM address.","@richard42 I've included this PR in my build since early this year and haven't had any reports of issues, I think it is safe to be merged",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,727,2020-02-28T17:36:09Z,2020-03-02T00:15:32Z,2021-06-20T20:46:07Z,MERGED,True,1,0,1,https://github.com/loganmc10,CountPerOp=1 for Elmo's Letter Adventure,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/727,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/727,"Fixes #636
Won't someone please think of the children and merge this PR","Fixes #636
Won't someone please think of the children and merge this PR",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,727,2020-02-28T17:36:09Z,2020-03-02T00:15:32Z,2021-06-20T20:46:07Z,MERGED,True,1,0,1,https://github.com/loganmc10,CountPerOp=1 for Elmo's Letter Adventure,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/727,https://github.com/quicksilver7837,2,https://github.com/mupen64plus/mupen64plus-core/pull/727#issuecomment-592992169,"Fixes #636
Won't someone please think of the children and merge this PR",My son gets pissed everytime he gets to this level. He avoids Ernie like the plague now. Thank you for this!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,728,2020-02-28T22:52:34Z,2020-03-01T10:21:11Z,2020-03-02T13:20:02Z,CLOSED,False,66,28,8,https://github.com/Jj0YzL5nvJ,Trying to understand how GAWK breaks (DO NOT MERGE),4,[],https://github.com/mupen64plus/mupen64plus-core/pull/728,https://github.com/Jj0YzL5nvJ,1,https://github.com/mupen64plus/mupen64plus-core/pull/728,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,728,2020-02-28T22:52:34Z,2020-03-01T10:21:11Z,2020-03-02T13:20:02Z,CLOSED,False,66,28,8,https://github.com/Jj0YzL5nvJ,Trying to understand how GAWK breaks (DO NOT MERGE),4,[],https://github.com/mupen64plus/mupen64plus-core/pull/728,https://github.com/Jj0YzL5nvJ,2,https://github.com/mupen64plus/mupen64plus-core/pull/728#issuecomment-593079905,,"My conclusion with this series of tests was that something prevented the correct execution of gawk.exe after processing the files generated by cl.exe with Win32\Debug and/or Release configuration, and that such problem coincidentally affected the processing severely more on files generated by cl.exe with the configuration x64\Debug and/or Release.
The potential culprit should be in the reuse of a cache, buffer or a program bug, who knows.
In the end, in this case, gawk isn't indispensable and potentially neither is it on other platforms if the command shell is used creatively.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,728,2020-02-28T22:52:34Z,2020-03-01T10:21:11Z,2020-03-02T13:20:02Z,CLOSED,False,66,28,8,https://github.com/Jj0YzL5nvJ,Trying to understand how GAWK breaks (DO NOT MERGE),4,[],https://github.com/mupen64plus/mupen64plus-core/pull/728,https://github.com/Narann,3,https://github.com/mupen64plus/mupen64plus-core/pull/728#issuecomment-593397714,,Thanks for the investigations!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,729,2020-03-01T11:03:55Z,2020-03-31T08:16:08Z,2020-04-01T04:44:50Z,MERGED,True,58,15,4,https://github.com/Jj0YzL5nvJ,Improve glue code generation,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/729,https://github.com/Jj0YzL5nvJ,1,https://github.com/mupen64plus/mupen64plus-core/pull/729,"These changes make us independent of gawk in Windows, and avoid issues with AppVeyor listed in #722
More info in #728","These changes make us independent of gawk in Windows, and avoid issues with AppVeyor listed in #722
More info in #728",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,729,2020-03-01T11:03:55Z,2020-03-31T08:16:08Z,2020-04-01T04:44:50Z,MERGED,True,58,15,4,https://github.com/Jj0YzL5nvJ,Improve glue code generation,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/729,https://github.com/Gillou68310,2,https://github.com/mupen64plus/mupen64plus-core/pull/729#issuecomment-593102114,"These changes make us independent of gawk in Windows, and avoid issues with AppVeyor listed in #722
More info in #728",I like the idea of using a script for generating asm defines but batch really is an awfull scripting language IMO. Do you think we can use something that could be cross platform?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,729,2020-03-01T11:03:55Z,2020-03-31T08:16:08Z,2020-04-01T04:44:50Z,MERGED,True,58,15,4,https://github.com/Jj0YzL5nvJ,Improve glue code generation,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/729,https://github.com/Jj0YzL5nvJ,3,https://github.com/mupen64plus/mupen64plus-core/pull/729#issuecomment-593132386,"These changes make us independent of gawk in Windows, and avoid issues with AppVeyor listed in #722
More info in #728","Hmm... the Travis CI indicator has glitched. But it passed.

Do you think we can use something that could be cross platform?

Python, Lua, Perl, Ruby, JavaScript. Any language works, the task is stupidly easy.
Display an object as a list, look for the @ASM_DEFINE pattern, take element $2 and $3 on that line, print #define ""$2"" (""$3"") to asm_defines_gas.h and print %define ""$2"" (""$3"") to asm_defines_nasm.h, that's all.

but batch really is an awfull scripting language IMO

It's funny, we're literally using batch for AppVeyor building, not to mention that Visual Studio uses native functions for commands (by default CMD). Batch Inception.
P.S: Most of the code in my batch is an anchor ensuring the position of key elements.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,729,2020-03-01T11:03:55Z,2020-03-31T08:16:08Z,2020-04-01T04:44:50Z,MERGED,True,58,15,4,https://github.com/Jj0YzL5nvJ,Improve glue code generation,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/729,https://github.com/Gillou68310,4,https://github.com/mupen64plus/mupen64plus-core/pull/729#issuecomment-593135967,"These changes make us independent of gawk in Windows, and avoid issues with AppVeyor listed in #722
More info in #728","It's funny, we're literally using batch for AppVeyor building, not to mention that Visual Studio uses native functions for commands (by default CMD). Batch Inception.
P.S: Most of the code in my batch is an anchor ensuring the position of key elements.

I do not have control over those ;-)
If we can avoid having a batch script in core repo I would be a happy man.

Python, Lua, Perl, Ruby, JavaScript. Any language works, the task is stupidly easy.

I do like python, I know it's an easy task that's why I think the batch script looks complicated for the task.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,729,2020-03-01T11:03:55Z,2020-03-31T08:16:08Z,2020-04-01T04:44:50Z,MERGED,True,58,15,4,https://github.com/Jj0YzL5nvJ,Improve glue code generation,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/729,https://github.com/Jj0YzL5nvJ,5,https://github.com/mupen64plus/mupen64plus-core/pull/729#issuecomment-593139828,"These changes make us independent of gawk in Windows, and avoid issues with AppVeyor listed in #722
More info in #728","I prefer anything within VS commands that return a logical error code when they fail, that a mixture command string that returns random values. Or always 0 (like gawk in this case) o_O.

I do like python, I know it's an easy task that's why I think the batch script looks complicated for the task.

You're welcome, BTW... don't forget to use cp1252 if you detect a Windows OS, utf-8 is incorrect. But in this particular case, probably utf-8 is safe...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,729,2020-03-01T11:03:55Z,2020-03-31T08:16:08Z,2020-04-01T04:44:50Z,MERGED,True,58,15,4,https://github.com/Jj0YzL5nvJ,Improve glue code generation,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/729,https://github.com/Mastergatto,6,https://github.com/mupen64plus/mupen64plus-core/pull/729#issuecomment-593150166,"These changes make us independent of gawk in Windows, and avoid issues with AppVeyor listed in #722
More info in #728","I'm not sure if this is the case, probably I misunderstood this whole thing, but some time ago @bsmiles32 made an effort to migrate the code to meson, python-based build system (http://mesonbuild.com/)
#488",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,729,2020-03-01T11:03:55Z,2020-03-31T08:16:08Z,2020-04-01T04:44:50Z,MERGED,True,58,15,4,https://github.com/Jj0YzL5nvJ,Improve glue code generation,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/729,https://github.com/Jj0YzL5nvJ,7,https://github.com/mupen64plus/mupen64plus-core/pull/729#issuecomment-593161264,"These changes make us independent of gawk in Windows, and avoid issues with AppVeyor listed in #722
More info in #728","I think the batch script looks complicated for the task.

This is the code without security measures:
for /f ""tokens=1,2*"" %%A in ('echo %*') do set GAS_VS_ARG1=%%A& set GAS_VS_ARG2=%%B& set GAS_VS_ARG3TOINF=%%C
del %GAS_VS_ARG2%asm_defines_*
cl /c /Fo%GAS_VS_ARG1% %GAS_VS_ARG3TOINF% /I ..\..\src %GAS_VS_ARG2%asm_defines.c
for /f ""tokens=2,3"" %%J in ('type %GAS_VS_ARG1%asm_defines.obj ^| find ""@ASM_DEFINE""') do (
echo #define %%J ^(%%K^)>>%GAS_VS_ARG2%asm_defines_gas.h
echo %%define %%J ^(%%K^)>>%GAS_VS_ARG2%asm_defines_nasm.h
)

The proposed code contains the minimum security conditions ""for monkeys on the keyboard"".
@Mastergatto, Meson is another completely different beast.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,729,2020-03-01T11:03:55Z,2020-03-31T08:16:08Z,2020-04-01T04:44:50Z,MERGED,True,58,15,4,https://github.com/Jj0YzL5nvJ,Improve glue code generation,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/729,https://github.com/Narann,8,https://github.com/mupen64plus/mupen64plus-core/pull/729#issuecomment-593168709,"These changes make us independent of gawk in Windows, and avoid issues with AppVeyor listed in #722
More info in #728","That's a big job, but wow, it's not nice to read.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,729,2020-03-01T11:03:55Z,2020-03-31T08:16:08Z,2020-04-01T04:44:50Z,MERGED,True,58,15,4,https://github.com/Jj0YzL5nvJ,Improve glue code generation,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/729,https://github.com/Jj0YzL5nvJ,9,https://github.com/mupen64plus/mupen64plus-core/pull/729#issuecomment-593180391,"These changes make us independent of gawk in Windows, and avoid issues with AppVeyor listed in #722
More info in #728","I take that as a compliment, even knowing that it's not.
The part that requires a clear explanation even knowing the language is this:
set GAS_RPATH_COUNT=1
:ADD
set GAS_RPATH=
for /f ""tokens=%GAS_RPATH_COUNT% delims=\"" %%a in ('cd') do set GAS_RPATH=%%a
if ""%GAS_RPATH%"" NEQ """" set /a GAS_RPATH_COUNT=%GAS_RPATH_COUNT%+1& goto ADD
set /a GAS_RPATH_COUNT=%GAS_RPATH_COUNT%-2
if %GAS_RPATH_COUNT% LEQ 2 exit /b 22

Many programs in Windows inherit the open path of the program that invokes them, in this case VS. If VS launch the script from the shortest possible logical path x:\mupen64plus-core\projects\msvc\, then at the end of the directory count, we subtract the 2 unwanted, drive letter and the last count to destroy the GAS_RPATH, and the result can never be less than or equal to 2 (R1). With this test it's guaranteed that an erroneous relative route is not possible due to being unable to go backwards more for the current GAS_VS_ARG2 (..\..\src\asm_defines\) later.
Edit:
P.S: The new logic makes more sense.
P.S 2: Syntax conflict...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,729,2020-03-01T11:03:55Z,2020-03-31T08:16:08Z,2020-04-01T04:44:50Z,MERGED,True,58,15,4,https://github.com/Jj0YzL5nvJ,Improve glue code generation,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/729,https://github.com/Gillou68310,10,https://github.com/mupen64plus/mupen64plus-core/pull/729#issuecomment-593355120,"These changes make us independent of gawk in Windows, and avoid issues with AppVeyor listed in #722
More info in #728","Ok let's not add python dependency to core building. Even if batch is awfull to read, it does the job without external dependencies so that's a pretty strong point.",True,{'EYES': ['https://github.com/Jj0YzL5nvJ']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,729,2020-03-01T11:03:55Z,2020-03-31T08:16:08Z,2020-04-01T04:44:50Z,MERGED,True,58,15,4,https://github.com/Jj0YzL5nvJ,Improve glue code generation,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/729,https://github.com/Gillou68310,11,https://github.com/mupen64plus/mupen64plus-core/pull/729#issuecomment-593355477,"These changes make us independent of gawk in Windows, and avoid issues with AppVeyor listed in #722
More info in #728",If this is merged we can get rid of gawk in win32-deps!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,729,2020-03-01T11:03:55Z,2020-03-31T08:16:08Z,2020-04-01T04:44:50Z,MERGED,True,58,15,4,https://github.com/Jj0YzL5nvJ,Improve glue code generation,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/729,https://github.com/Jj0YzL5nvJ,12,https://github.com/mupen64plus/mupen64plus-core/pull/729#issuecomment-593675665,"These changes make us independent of gawk in Windows, and avoid issues with AppVeyor listed in #722
More info in #728","Well, I made the code a little more descriptive, I have the bad habit of wanting to make the code take up too little bytes... floppy mindset.
I hadn't noticed it, I barely noticed it when I woke up ^^u

Even if batch is awfull to read

And even more my batch =P
Edit: OMG, bilingual dyslexia... that new in myself.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,729,2020-03-01T11:03:55Z,2020-03-31T08:16:08Z,2020-04-01T04:44:50Z,MERGED,True,58,15,4,https://github.com/Jj0YzL5nvJ,Improve glue code generation,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/729,https://github.com/Narann,13,https://github.com/mupen64plus/mupen64plus-core/pull/729#issuecomment-593897645,"These changes make us independent of gawk in Windows, and avoid issues with AppVeyor listed in #722
More info in #728","TBH, I think one comment per line, starting from the for loop, wouldn't be too much.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,729,2020-03-01T11:03:55Z,2020-03-31T08:16:08Z,2020-04-01T04:44:50Z,MERGED,True,58,15,4,https://github.com/Jj0YzL5nvJ,Improve glue code generation,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/729,https://github.com/Jj0YzL5nvJ,14,https://github.com/mupen64plus/mupen64plus-core/pull/729#issuecomment-594400679,"These changes make us independent of gawk in Windows, and avoid issues with AppVeyor listed in #722
More info in #728","More syntax, more variables to mess up, new logic, more intricated code, more robust, more mindfuck, BETTER.
After this, I need to look for latent errors in my old scripts and add new optimizations.
／人◕ ‿‿ ◕人＼
The only way to understand the code is to play with it. This is already in ""debug"" mode, run this from CMD, change GAS_VS_ARG2 to whatever you want and move the script to different folder levels to see the differences, a USB is fine too. To see error codes, execute echo% errorlevel%.
Using pause after each command also works.
@echo on
setlocal enableextensions disabledelayedexpansion
:: Forced destruction of environment variables, these can also be modified to debug errors
set GAS_VS_ARG1=qwer\zxcv\
set GAS_VS_ARG2=..\..\Hi
set GAS_VS_ARG3TOINF=asdf
:: Adaptation of the parameters sent by VS to use them as variables, if an invalid parameter is sent (syntax conflict), this script will be closed and will not generate an error code for ERRORLEVEL
REM for /f ""tokens=1,2*"" %%A in ('echo %*') do set GAS_VS_ARG1=%%A& set GAS_VS_ARG2=%%B& set GAS_VS_ARG3TOINF=%%C
:: Making sure we are in the tools folder, it's not really necessary...
REM echo ""%~dp0"" | find /i ""\mupen64plus-core\tools\"" >nul
REM if errorlevel 1 exit /b 11
:: Initialized as 1 to execute ""tokens"", it will be subtracted later
set GAS_RPATH_COUNT=1
:: Initialized with the ABSOLUTE PATH of the VS project file as FIRST condition
set GAS_RPATH_CONDITION=%CD%
set GAS_RPATH_COUNT_SHADOW=0
set GAS_RPATH_MINUS_SHADOW=0
:ADD
:: Destroying GAS_RPATH in each loop because if it can't be reinitialized in 'for', it will return the last valid value
set GAS_RPATH=
for /f ""tokens=%GAS_RPATH_COUNT% delims=\"" %%a in ('echo %GAS_RPATH_CONDITION%') do set GAS_RPATH=%%a
:: The value '..' can ONLY come from GAS_RPATH_CONDITION = GAS_VS_ARG2, a RELATIVE PATH
if ""%GAS_RPATH%""=="".."" set /a GAS_RPATH_MINUS_SHADOW=%GAS_RPATH_MINUS_SHADOW%+1
:: Addition to GAS_RPATH_COUNT if GAS_RPATH is defined
if defined GAS_RPATH set /a GAS_RPATH_COUNT=%GAS_RPATH_COUNT%+1& goto ADD
:: Correcting GAS_RPATH_COUNT, 1 to execute ""tokens"" and another one of the last destruction of GAS_RPATH
set /a GAS_RPATH_COUNT=%GAS_RPATH_COUNT%-2
:: Single use loop... to set GAS_RPATH_COUNT_SHADOW, GAS_RPATH_MINUS_SHADOW and the GAS_RPATH_CONDITION's SECOND condition as RELATIVE PATH with GAS_VS_ARG2
if ""%GAS_RPATH_CONDITION%"" NEQ ""%GAS_VS_ARG2%"" set GAS_RPATH_COUNT_SHADOW=%GAS_RPATH_COUNT%& set GAS_RPATH_CONDITION=%GAS_VS_ARG2%& set GAS_RPATH_COUNT=1& goto ADD
:: Theoretical error... artificial too, this script ONLY counts folders
if %GAS_RPATH_COUNT_SHADOW% LEQ 0 exit /b 9999
set /a GAS_RPATH_COUNT=%GAS_RPATH_COUNT_SHADOW%-%GAS_RPATH_MINUS_SHADOW%
:: Logical check for ABSOLUTE PATH vs RELATIVE PATH, isn't a truly valid check
if %GAS_RPATH_COUNT% LEQ -1 exit /b 22
pause",True,{'EYES': ['https://github.com/Narann']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,729,2020-03-01T11:03:55Z,2020-03-31T08:16:08Z,2020-04-01T04:44:50Z,MERGED,True,58,15,4,https://github.com/Jj0YzL5nvJ,Improve glue code generation,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/729,https://github.com/Jj0YzL5nvJ,15,https://github.com/mupen64plus/mupen64plus-core/pull/729#issuecomment-594774049,"These changes make us independent of gawk in Windows, and avoid issues with AppVeyor listed in #722
More info in #728","Yeah... too complex, good for me, bad for everything else. Take the Lite version.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,729,2020-03-01T11:03:55Z,2020-03-31T08:16:08Z,2020-04-01T04:44:50Z,MERGED,True,58,15,4,https://github.com/Jj0YzL5nvJ,Improve glue code generation,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/729,https://github.com/Narann,16,https://github.com/mupen64plus/mupen64plus-core/pull/729#issuecomment-606173674,"These changes make us independent of gawk in Windows, and avoid issues with AppVeyor listed in #722
More info in #728","Does it make sense to add some comments in the current gen_asm_script.cmd, at leat to globally understand what it does?
If we can't add comments, I will merge it like this but a general explanation of the script would be great.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,729,2020-03-01T11:03:55Z,2020-03-31T08:16:08Z,2020-04-01T04:44:50Z,MERGED,True,58,15,4,https://github.com/Jj0YzL5nvJ,Improve glue code generation,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/729,https://github.com/Narann,17,https://github.com/mupen64plus/mupen64plus-core/pull/729#issuecomment-606472331,"These changes make us independent of gawk in Windows, and avoid issues with AppVeyor listed in #722
More info in #728","Thanks a lot @Jj0YzL5nvJ, it's perfect !",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/731,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-595569901,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","I should say, I haven't tested this with the new dynarec, the issue in Rayman/Donald Duck was also reported there. I'm not sure if the new dynarec uses fpu.h or not",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-595581515,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","The issue seems to possibly be related to comparing -0.0 to +0.0
In C, doing:
float float1 = 0.0f;
float float2= -0.0f;
if (float1 == float2)

Will return true, however doing a memcmp will return false. It would good to know the N64's behaviour when comparing -0.0 and +0.0, whether it is doing a bitwise compare of the registers, or IEEE 754 compare of floating point values. It seems based on my tests that it is doing a bitwise comparison (memcmp)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/Gillou68310,4,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-595623167,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","I recently discover a bug in CFC1, value is stored in 32bits register (rrt32) instead of sign extending to 64bits using rrt. Maybe this is related to the collision issue?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/Gillou68310,5,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-595625185,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","Dynarec's are using fucomip for floating point compare.
https://www.felixcloutier.com/x86/fcomi:fcomip:fucomi:fucomip
From the docs +0.0 should be equal to -0.0",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/Zapeth,6,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-595649177,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","Will return true, however doing a memcmp will return false. It would good to know the N64's behaviour when comparing -0.0 and +0.0, whether it is doing a bitwise compare of the registers, or IEEE 754 compare of floating point values. It seems based on my tests that it is doing a bitwise comparison (memcmp)

I'm a bit confused why memcmp gives a different result for you, IEEE 754 floats include the sign in their encoding, so doing a bitwise comparison should still return a non-equal result (a quick test in C confirms this indicates that it should behave exactly the other way around, +0.0 == -0.0 returns 1 (equal) while memcmp(&(+0.0), &(-0.0), sizeof(float)) also returns 1 (non-equal) for me).
Nevermind, I misread the original results from your comment. However can you give examples for which values are erroneously compared (preferably the ones that fail in the game)? Or is it really just +0.0 that gets compared with -0.0?
@Gillou68310 is correct though, docs say that -0.0 should equal to +0.0, so it would be weird if a bitwise comparison is the correct way to do it (not to mention that it should also fail with the Dynarecs in that case since fucomip also ignore the sign for zero comparison).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-595744849,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","I'll admit that every document I read seems to say that -0 should =0, so I'm not really sure why the memcmp works, we'll have to do some more investigation, so don't anyone merge this yet",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/Zapeth,8,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-595751632,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","I did some more testing and I think the issue lies elsewhere. In terms of results, CEN64 seems to return the same values as mupen64 (tested with modified test roms for eq, lt and le instructions), yet there are no issues in the mentioned games when playing.
I assume the (incorrect) results of the memcpy operation just happen to mask the bug that would otherwise occur on mupen64 with the interpreter.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/loganmc10,9,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-595846161,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","I just tested mupen64 0.5.1 and the issue doesn't seem to exist there, so it must be a regression somewhere, I'll try and bisect it, it must be pretty old though, I think I tested back to 2017 before and the issue existed then in mupen64plus",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/loganmc10,10,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-595863692,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","I tested all the way back to May 3, 2014 (which is as far back as I can go before compiling gets complex), and the issue still exists then, very perplexing",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/Zapeth,11,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-595874981,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","Yet another reason to dislike the plugin system. Anyway, if there is a reason to assume that this is a regression from way back, then it might be worth at least checking the project's first github commit.
If the issue still exists then its probably not be worth going even further back, if it doesn't then it would be possible (albeit tedious) to bisect the issue.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/loganmc10,12,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-595884277,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","Actually I don't think this is a regression. It has something to do with the compiler. I just tested the released version of mupen64plus for Windows, and this bug doesn't exist there! I assume that is because it is compiled with Visual Studio
I always compile with gcc, even on Windows, but no messing around with the compiler flags seemed to fix this (debug, different -f flags for math optimizations).
I'm not really a compiler pro, can anyone think of something that would cause this issue with gcc? Also, I don't have Visual Studio on my computer, maybe someone could test using Visual Studio to confirm my suspicion?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/mackal,13,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-595888582,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed",What happens without fast-math?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/Gillou68310,14,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-595892474,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed",I can comfirm this issue is non existent with vs compiler.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/loganmc10,15,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-595893678,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","I tried removing fast-math and all other compiler optimizations. It may not be related to optimizations, it could be how the rounding functions behave or something",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/Gillou68310,16,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-595894818,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed",Vs compiler is using ucomiss instruction for what it's worth,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/m4xw,17,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-595982095,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","ucomiss lowers precision https://c9x.me/x86/html/file_module_x86_id_317.html
Performs and unordered compare of the single-precision floating-point values in the low doublewords
What mupen does and this pr, both are wrong for float comparisions and are affected by the fp precision of the host system, gcc generates the right behaviour IMO.
Did everyone forget how fp math works?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/loganmc10,18,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-595997711,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","I tried doing the comparison like return fabsf(a - b) < FLT_EPSILON; instead of a == b, didn't fix the issue. It's not necessarily the == that is the issue, it could be some previous rounding error (or something else) is passing the wrong float to == to begin with",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/loganmc10,19,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-596052277,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","I've done a bit more research, this seems to maybe be a 32-bit vs 64-bit problem (I assume the Virtual Studio builds are 32-bit). The problem is solved in 64-bit gcc by adding this compiler flag:
-mfpmath=387

I also tested 32-bit gcc in Windows, and the problem doesn't exist there at all.
I'm not a programmer by trade, so I'm not going to pretend to know the best way to solve this problem, but it does seem to be related to floating point precision in 64-bit/SSE mode.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/Zapeth,20,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-596057690,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","I also looked a bit deeper and wanted to share some results:

Dynarec path indeed uses x87 fpu instructions for floating point comparisons
in case of Donald Duck game, when running around in the actual world (with the stars in it), there are sometimes c_eq_s calls being made with fs=-2.592206E-39 and ft=0.0 which seems to be the reason for the issue (sse path returns true here, x87 false)
switching to x87 code only in c_eq_s fixes the issue in the interpreter
CEN64 uses sse instructions for c_eq_s too (comiss), however the issue is not present there

So while forcing more accurate floating point precision seems to be the immediate solution here, I don't think its the actual issue.
It might just be an inaccurate/incorrect implementation somewhere else that leads to these problematic c_eq_s calls. However tracing this back is tedious, so I'm not going to bother.
After doing a last test with CEN64 and a modified test rom it really seems to be an sse specific issue.
When switching the CEN64 inline assembly code to an intrinsic _mm_comieq_ss call (which one might assume to be equivalent to the inline assembly code) it also produces incorrect results.
Also interestingly, CEN64 originally used _mm_comieq_ss for the sse implementation, but switched to the inline assembly with commit message ""Simplify the floating point compare logic.""",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/Zapeth,21,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-596077634,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","This is bizarre: The same inline assembly from CEN64 doesn't work in mupen64.
The compiled assembly is practically the same (there are two more lines in mupen64's objdump, but I'm not sure if they are revelant to this issue), yet they return different values for the problematic comparison (fs=0x801c3a04, ft=0x00000000):

objdump of cen64 (returns 0)
objdump of mupen64 (returns 1)

If someone has an explanation for this, I'd love to hear it (its basically just a copy&paste from CEN64's fpu_cmp_eq_32 to mupen64's c_eq_s function).
As for now I'm pretty much done with investigating this issue.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/Gillou68310,22,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-596088028,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","Using -mfpmath=387 fixes donald's issue, I didn't tested rayman.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/Gillou68310,23,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-596090026,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","Lol @loganmc10 I missed your previous post!
To add to @Zapeth investigations fs=-2.592206E-39 has the suffix #DEN in visual studio which means the value is denormalized.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/loganmc10,24,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-596095449,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","I updated the PR to include the current ""best fix"". I'm not sure if it's really the best solution, my reading leads me to believe that using -mfpmath=387 could have performance impacts, it may be better to use inline assembly that works in fpu.h? Or somehow force the compiler to use x87 FPU instructions just inside the functions in fpu.h, maybe in the way the variables are declared?
Also I'm not really sure what the solution would be for ARM, the problem is present there as well, but I assume there isn't an option equivalent to x87 FPU there",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/loganmc10,25,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-596107383,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","It seems like gcc has a __float80 type that can force it use a 10-byte type.
I assume for that to work, the cp1 regs would need to be stored as __float80 (or double where that doesn't exist), and the logic for reading/writing to those register would have to be changed around to cast them to float/double when needed.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/Zapeth,26,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-596130361,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","Since the issue seems to basically be just about denormalized floating point values I think the better solution would be to just disable the CPUs DAZ mode.
I haven't done any performance analysis, but it should at least perform better than using x87 instructions since the CPU would still execute only sse instructions.
This also seems to be the reason why CEN64 behaves differently with the same code, though I haven't figured out where/how the MXCSR register is configured accordingly in their code (and whether it is set permanently or only toggled).
I actually already tested this with the problematic roms (Rayman too) and the issues are no longer present (even with -ffast-math).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/loganmc10,27,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-596134687,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed",@Zapeth yes excellent suggestion! I updated the PR,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/loganmc10,28,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-596154595,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","By the way, it sounds like the same thing can be achieved in ARM by doing:
__asm__ volatile(""vmrs r0, fpscr\n""
                     ""bic r0, $(1 << 24)\n""
                     ""vmsr fpscr, r0"" : : : ""r0"");

http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344k/Chdfafia.html
To set the FZ bit in FPSCR to 0, it sounds like the FZ bit controls FTZ and DAZ. I don't have an ARM device setup though, so I would look for someone that could test on ARM to submit that fix",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/loganmc10,29,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-596164875,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","@Zapeth Do you think FTZ should be disabled as well? The Intel documentation says:

DAZ and FTZ flags are not compatible with the IEEE 754 standard, and should only be enabled when compliance to the IEEE standard is not required.

It seems like DAZ and FTZ are enabled by default, but they are actually SSE optimizations that are not compliant with IEEE 754, which the N64 is supposed to follow",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/Zapeth,30,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-596177611,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","I don't know how big the (additional) performance penalty would be if its also disabled, so its hard to say.
There are some resources online that talk about the penalties, but in our case it heavily depends on the games that are emulated.
Are there any known games that use a lot of floating point operations? If so one could do a before/after test to see if there are any noticable/measurable performance hits (preferably on an older CPU and/or an AMD one).
Though looking at the N64 docs I guess the FTZ mode could be tied to the FS bit of the FCR31 register since it seems to serve the same purpose (except its always flushed to zero and not tied to the rounding mode)?
Fwiw, CEN64 seems to have both modes disabled.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/loganmc10,31,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-596205882,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","Yes it seems you are right again, this is what I found:

So it sounds like DAZ is disabled when the FS bit is set. I've updated the PR to do the same. FTZ seems a little more complicated, the behavior is tied to the rounding mode, I'm not sure exactly how to emulate that using SSE, or if it would be worth the performance impact",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/loganmc10,32,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-596206198,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","Also for FWIW, the games I've tested either seem to set the FS bit permanently, or quickly alternate with it on/off. I'm not sure if there is a performance impact of enabling/disabling DAZ like that, I haven't really benchmarked this",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/Zapeth,33,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-596790747,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","So it sounds like DAZ is disabled when the FS bit is set. I've updated the PR to do the same. FTZ seems a little more complicated, the behavior is tied to the rounding mode, I'm not sure exactly how to emulate that using SSE, or if it would be worth the performance impact

I don't think thats correct. DAZ only applies to explicit (i.e. existing) denormal values, FTZ applies to computed ones.
The FS bit seems to just affect computed values as well, hence my suggestion to bind FTZ mode to the FS bit.
It might not be completely equivalent in behavior in regards to rounding mode, but

its a better approximation than completely ignoring it
RN/RZ rounding modes are much more likely to be used than the other two anyway (assuming there are even any applications that rely on this)

Regarding quick alternation: thats again a topic where it highly depends on the application (how often is it alternated vs how many (denormalized) floating point operations are happening in between).
I haven't found any conclusive information about how ""expensive"" the mode switch is, but I don't think its much worse than a single (or a few) denormalized operation(s) (disclaimer: this is pure speculation).
As for DAZ mode: its probably safer to just leave it disabled permanently. If it turns out to be a big performance hit then it could always be made optional (as well as FTZ), especially since so far only two games turned out to be (noticably) relying on this behavior.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/loganmc10,34,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-596820750,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","That's not really how I understand it, it says that the FS bit controls ""whether a denormal number can be flashed"". That sounds like DAZ/input to me. It says that whether the result is flushed to zero or not depends on the rounding mode. Like you say, RN/RZ is the likely scenario anyway, so it is probably safe to just leave FTZ enabled, which is the default.
I think it's worth emulating DAZ correctly, from my limited testing I don't see any major performance impact. You never know what other problems this might fix. Some games may rely on DAZ being enabled, so I don't think it would be safe to just disable it permanently",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/loganmc10,35,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-597311034,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","Given the results of the test ROM you created, I'm inclined to believe you are correct. I've updated the PR to permanently disable DAZ mode, and only disable FTZ when the rounding mode is RP or RM, does that sound correct @Zapeth ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/Zapeth,36,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-598698026,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","I'm not the one who can decide whether to accept or reject this PR so my approval doesn't really matter here, but it sounds close enough to what I had in mind in terms of behavior.
The end result is what matters anyway, so as long as the issues in the problematic roms are no longer present and it causes no other noticable issues elsewhere it should be safe to include.
Though apart from the missing implementation for non-SSE platforms I'd also recommend to test this with other systems/compilers (are other compilers than gcc and msvc even supported?).
I don't know what your system setup is, but I'd suggest at least tests with an (older) AMD CPU and other OSs like 32-bit Windows, Linux and macOS (this test rom should give immediate results, but testing the games would be good too of course).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/loganmc10,37,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-599162665,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","I'm not the one who can decide whether to accept or reject this PR so my approval doesn't really matter here, but it sounds close enough to what I had in mind in terms of behavior.

mupen64plus is light on reviewers/maintainers, people come and go (myself included), you seem to understand the problem, so your opinion is valuable.
I've tested on WIndows/Linux 32 and 64 bit using GCC, I don't have MSVC to test (the only Windows machine I have is a work computer, and I will get a talking to from the licensing people if I install the community edition on it)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/Narann,38,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-633307839,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","@loganmc10 suggest this to be part of 2.6.0.
It's a quite intrusive PR. So if anyone have a better idea on how implement this properly, feel free to pop in the discussion.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/richard42,39,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-633315109,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","It looks okay to me.  But do we need to change the savestate file format, to support the new flush_mode member that you've added to cp1?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/loganmc10,40,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-633316038,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed","No I wouldn't think so, the struct isn't copied/read in it's entirety, the members are read one at a time, and update_x86_rounding_mode is called in the savestate loading code, and that function sets flush_mode.
PS the only thing this is missing is an ARM implementation, this solves the issue with the Interpreter, but someone would have to write something in ARM ASM to fix the issue there, I think this could still be merged either way though",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,731,2020-03-06T02:35:48Z,2020-05-25T08:47:23Z,2021-06-20T20:46:30Z,MERGED,True,46,1,5,https://github.com/loganmc10,Disable FTZ (flush to zero) mode for SSE when FS bit is set,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/731,https://github.com/Narann,41,https://github.com/mupen64plus/mupen64plus-core/pull/731#issuecomment-633457872,"Fixes (only for SSE, not ARM) #724
The c.eq functions are meant to compare 2 float (or double) values. Computers aren't very good at comparing floating numbers, and the emulator seems to return equal when the N64 expects the values to be not equal.
Using memcmp seems to work properly, the emulator still passes the PeterLemon/krom N64 test ROM for CP1 C EQ functions, and Rayman/Donald Duck collision detection is fixed",I've created a ticket for ARM implementation. I will merge for now but it could be great if we also fix this problem for ARM.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,734,2020-03-21T15:52:55Z,2020-03-23T15:57:29Z,2021-06-20T20:45:31Z,MERGED,True,10,0,1,https://github.com/loganmc10,Support FBWrites with a size of 3,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/734,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/734,"I noticed that Resident Evil 2 does this, triggering an ""Unknown mask"" warning","I noticed that Resident Evil 2 does this, triggering an ""Unknown mask"" warning",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,734,2020-03-21T15:52:55Z,2020-03-23T15:57:29Z,2021-06-20T20:45:31Z,MERGED,True,10,0,1,https://github.com/loganmc10,Support FBWrites with a size of 3,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/734,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/734#issuecomment-602515700,"I noticed that Resident Evil 2 does this, triggering an ""Unknown mask"" warning","Can't reproduce the warning on my end, while playing the first few minutes of the game.
Also a write of 3 bytes in a single transaction looks really odd to me as CPU only support byte, hword, word and dword memory operations.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,734,2020-03-21T15:52:55Z,2020-03-23T15:57:29Z,2021-06-20T20:45:31Z,MERGED,True,10,0,1,https://github.com/loganmc10,Support FBWrites with a size of 3,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/734,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/734#issuecomment-602645079,"I noticed that Resident Evil 2 does this, triggering an ""Unknown mask"" warning","Really? You're running it with the interpreter? This is the trace I get on the first occurance, it happens right after the N64 logo, even before the main menu:
#1  0x00007fffcaf1a3bf in write_rdram_fb (opaque=0x7fffcfe7da18 <g_dev+17830328>, address=6545928, value=197634, mask=16777215) at ../../src/device/rcp/rdp/fb.c:172
#2  0x00007fffcaf17dbf in mem_write32 (handler=0x7fffcfe7f058 <g_dev+17836024>, address=6545928, value=197634, mask=16777215) at ../../src/device/memory/memory.h:87
#3  0x00007fffcaf18543 in r4300_write_aligned_word (r4300=0x7fffced7c860 <g_dev>, address=6545928, value=197634, mask=16777215) at ../../src/device/r4300/r4300_core.c:353
#4  0x00007fffcaef45f7 in cached_interp_SWL () at ../../src/device/r4300/mips_instructions.def:369
#5  0x00007fffcaf05fae in run_cached_interpreter (r4300=0x7fffced7c860 <g_dev>) at ../../src/device/r4300/cached_interp.c:1009

You can see the mask value is 16777215/0xFFFFFF",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,734,2020-03-21T15:52:55Z,2020-03-23T15:57:29Z,2021-06-20T20:45:31Z,MERGED,True,10,0,1,https://github.com/loganmc10,Support FBWrites with a size of 3,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/734,https://github.com/bsmiles32,4,https://github.com/mupen64plus/mupen64plus-core/pull/734#issuecomment-602691991,"I noticed that Resident Evil 2 does this, triggering an ""Unknown mask"" warning","Sorry, I had DisableFBInfo = True in my config, that's why I didn't reproduce.
And indeed, I was also wrong about load/store sizes, because I had forgotten about SWL and other unaligned operations.
Tested and it works good :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,735,2020-03-22T18:52:08Z,2020-10-10T02:42:05Z,2021-06-20T20:45:47Z,MERGED,True,94,34,18,https://github.com/loganmc10,PIF binary boot rom support,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/735,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/735,"Fixes #730
This allows booting using a binary PIF ROM (pifdata.bin) instead of the HLE implementation.

Tested with old dynarec, and both interpreters. Not currently working with new dynarec. I'm not exactly sure how to get the new dynarec to start at 0xbfc00000 instead of 0xa4000040, or how to make that dynamic at runtime instead of a compiled address. @Gillou68310

@bsmiles32 given your previous work and study on the PIF, I would really like to get your input if possible","Fixes #730
This allows booting using a binary PIF ROM (pifdata.bin) instead of the HLE implementation.

Tested with old dynarec, and both interpreters. Not currently working with new dynarec. I'm not exactly sure how to get the new dynarec to start at 0xbfc00000 instead of 0xa4000040, or how to make that dynamic at runtime instead of a compiled address. @Gillou68310

@bsmiles32 given your previous work and study on the PIF, I would really like to get your input if possible",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,735,2020-03-22T18:52:08Z,2020-10-10T02:42:05Z,2021-06-20T20:45:47Z,MERGED,True,94,34,18,https://github.com/loganmc10,PIF binary boot rom support,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/735,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/735#issuecomment-602323620,"Fixes #730
This allows booting using a binary PIF ROM (pifdata.bin) instead of the HLE implementation.

Tested with old dynarec, and both interpreters. Not currently working with new dynarec. I'm not exactly sure how to get the new dynarec to start at 0xbfc00000 instead of 0xa4000040, or how to make that dynamic at runtime instead of a compiled address. @Gillou68310

@bsmiles32 given your previous work and study on the PIF, I would really like to get your input if possible",Here is the PR in ui-console that allows loading the PIF ROM file: mupen64plus/mupen64plus-ui-console#58,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,735,2020-03-22T18:52:08Z,2020-10-10T02:42:05Z,2021-06-20T20:45:47Z,MERGED,True,94,34,18,https://github.com/loganmc10,PIF binary boot rom support,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/735,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/735#issuecomment-611731722,"Fixes #730
This allows booting using a binary PIF ROM (pifdata.bin) instead of the HLE implementation.

Tested with old dynarec, and both interpreters. Not currently working with new dynarec. I'm not exactly sure how to get the new dynarec to start at 0xbfc00000 instead of 0xa4000040, or how to make that dynamic at runtime instead of a compiled address. @Gillou68310

@bsmiles32 given your previous work and study on the PIF, I would really like to get your input if possible","I think this would be OK to merge, it doesn't support the new dynarec, but it doesn't break it either, it's an optional new feature",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,735,2020-03-22T18:52:08Z,2020-10-10T02:42:05Z,2021-06-20T20:45:47Z,MERGED,True,94,34,18,https://github.com/loganmc10,PIF binary boot rom support,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/735,https://github.com/m4xw,4,https://github.com/mupen64plus/mupen64plus-core/pull/735#issuecomment-611944293,"Fixes #730
This allows booting using a binary PIF ROM (pifdata.bin) instead of the HLE implementation.

Tested with old dynarec, and both interpreters. Not currently working with new dynarec. I'm not exactly sure how to get the new dynarec to start at 0xbfc00000 instead of 0xa4000040, or how to make that dynamic at runtime instead of a compiled address. @Gillou68310

@bsmiles32 given your previous work and study on the PIF, I would really like to get your input if possible","@loganmc10 https://github.com/mupen64plus/mupen64plus-core/blob/master/src/device/r4300/new_dynarec/x64/linkage_x64.asm#L344
Same goes for the other Platforms.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,735,2020-03-22T18:52:08Z,2020-10-10T02:42:05Z,2021-06-20T20:45:47Z,MERGED,True,94,34,18,https://github.com/loganmc10,PIF binary boot rom support,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/735,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/735#issuecomment-706446977,"Fixes #730
This allows booting using a binary PIF ROM (pifdata.bin) instead of the HLE implementation.

Tested with old dynarec, and both interpreters. Not currently working with new dynarec. I'm not exactly sure how to get the new dynarec to start at 0xbfc00000 instead of 0xa4000040, or how to make that dynamic at runtime instead of a compiled address. @Gillou68310

@bsmiles32 given your previous work and study on the PIF, I would really like to get your input if possible","@richard42 this is another I've included for most of the year without issue. It doesn't change the default behavior, but does add an optional API function that allows booting from a binary PIF",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,735,2020-03-22T18:52:08Z,2020-10-10T02:42:05Z,2021-06-20T20:45:47Z,MERGED,True,94,34,18,https://github.com/loganmc10,PIF binary boot rom support,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/735,https://github.com/richard42,6,https://github.com/mupen64plus/mupen64plus-core/pull/735#issuecomment-706455259,"Fixes #730
This allows booting using a binary PIF ROM (pifdata.bin) instead of the HLE implementation.

Tested with old dynarec, and both interpreters. Not currently working with new dynarec. I'm not exactly sure how to get the new dynarec to start at 0xbfc00000 instead of 0xa4000040, or how to make that dynamic at runtime instead of a compiled address. @Gillou68310

@bsmiles32 given your previous work and study on the PIF, I would really like to get your input if possible",Ok that's cool. Can you add one more thing first though? We should bump up the core API point version number and update the API versioning document Mupen64Plus_v2.0_API_Versioning,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,735,2020-03-22T18:52:08Z,2020-10-10T02:42:05Z,2021-06-20T20:45:47Z,MERGED,True,94,34,18,https://github.com/loganmc10,PIF binary boot rom support,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/735,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/735#issuecomment-706462635,"Fixes #730
This allows booting using a binary PIF ROM (pifdata.bin) instead of the HLE implementation.

Tested with old dynarec, and both interpreters. Not currently working with new dynarec. I'm not exactly sure how to get the new dynarec to start at 0xbfc00000 instead of 0xa4000040, or how to make that dynamic at runtime instead of a compiled address. @Gillou68310

@bsmiles32 given your previous work and study on the PIF, I would really like to get your input if possible","@richard42 Just to make sure, do you mean FRONTEND_API_VERSION or MUPEN_CORE_VERSION. I assume it's FRONTEND_API_VERSION, since the only addition was another command that can be called from the frontend?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,735,2020-03-22T18:52:08Z,2020-10-10T02:42:05Z,2021-06-20T20:45:47Z,MERGED,True,94,34,18,https://github.com/loganmc10,PIF binary boot rom support,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/735,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/735#issuecomment-706463676,"Fixes #730
This allows booting using a binary PIF ROM (pifdata.bin) instead of the HLE implementation.

Tested with old dynarec, and both interpreters. Not currently working with new dynarec. I'm not exactly sure how to get the new dynarec to start at 0xbfc00000 instead of 0xa4000040, or how to make that dynamic at runtime instead of a compiled address. @Gillou68310

@bsmiles32 given your previous work and study on the PIF, I would really like to get your input if possible",Yes I'm pretty sure that's right. I've upped the FRONTEND_API_VERSION version.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,736,2020-03-23T17:20:10Z,2020-03-23T17:20:20Z,2021-02-01T11:22:28Z,MERGED,True,1,2,2,https://github.com/bsmiles32,Fix multiple definition errors,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/736,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/736,Fixes issue #712 reported by @mazes-80.,Fixes issue #712 reported by @mazes-80.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,737,2020-03-24T14:28:00Z,2020-03-31T08:27:33Z,2021-06-20T20:46:17Z,MERGED,True,2,1,1,https://github.com/loganmc10,BattleTanx (U) games need CountPerOp=3 to boot,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/737,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/737,"These games are very sensitive to interrupt timing, since 5a14915 they aren't booting.
I don't think it's really the fault of that PR, it's just that the interrupt timing changed a bit and now these games don't like it.
For whatever reason, the (E) version doesn't have this issue","These games are very sensitive to interrupt timing, since 5a14915 they aren't booting.
I don't think it's really the fault of that PR, it's just that the interrupt timing changed a bit and now these games don't like it.
For whatever reason, the (E) version doesn't have this issue",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,737,2020-03-24T14:28:00Z,2020-03-31T08:27:33Z,2021-06-20T20:46:17Z,MERGED,True,2,1,1,https://github.com/loganmc10,BattleTanx (U) games need CountPerOp=3 to boot,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/737,https://github.com/CallistoNTG,2,https://github.com/mupen64plus/mupen64plus-core/pull/737#issuecomment-604240679,"These games are very sensitive to interrupt timing, since 5a14915 they aren't booting.
I don't think it's really the fault of that PR, it's just that the interrupt timing changed a bit and now these games don't like it.
For whatever reason, the (E) version doesn't have this issue",I'm pretty sure setting CPO to 3 absolutely destroys performance in this game to basically unplayable levels. It becomes more evident in later missions.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,737,2020-03-24T14:28:00Z,2020-03-31T08:27:33Z,2021-06-20T20:46:17Z,MERGED,True,2,1,1,https://github.com/loganmc10,BattleTanx (U) games need CountPerOp=3 to boot,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/737,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/737#issuecomment-604389300,"These games are very sensitive to interrupt timing, since 5a14915 they aren't booting.
I don't think it's really the fault of that PR, it's just that the interrupt timing changed a bit and now these games don't like it.
For whatever reason, the (E) version doesn't have this issue",It's probably better than the game not booting at all though,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,739,2020-03-29T00:22:44Z,2020-03-29T12:21:20Z,2021-06-20T20:45:32Z,MERGED,True,2,6,1,https://github.com/loganmc10,IP0 and IP1 CAUSE bits are writeable,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/739,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/739,"See n64dev/cen64#116
Allows Donkey Kong 64 (U) [f2] (#732) to boot using Pure Interpreter + Angrylion. Game still doesn't work with Cached Interpreter","See n64dev/cen64#116
Allows Donkey Kong 64 (U) [f2] (#732) to boot using Pure Interpreter + Angrylion. Game still doesn't work with Cached Interpreter",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,740,2020-03-30T02:00:00Z,2020-03-31T08:28:25Z,2021-06-20T20:46:12Z,MERGED,True,2621,1884,8,https://github.com/loganmc10,Use XXH3 hashing (v0.7.3),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/740,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/740,"XXH3 is a new hashing algorithm, you can read about it here a bit: https://github.com/Cyan4973/xxHash/releases
This new version inlines everything, and is supposed to be much better for small inputs, which we are dealing with

In general, expect XXH3 to run about ~2x faster on large inputs, and >3x faster on small ones, though exact difference depend on platform.","XXH3 is a new hashing algorithm, you can read about it here a bit: https://github.com/Cyan4973/xxHash/releases
This new version inlines everything, and is supposed to be much better for small inputs, which we are dealing with

In general, expect XXH3 to run about ~2x faster on large inputs, and >3x faster on small ones, though exact difference depend on platform.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,741,2020-04-01T04:34:15Z,2020-04-04T08:40:26Z,2020-04-04T08:40:27Z,MERGED,True,12,12,1,https://github.com/chrontec,Fix path expansion when building with VisualStudio so directories with spaces will not cause the build to fail.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/741,https://github.com/chrontec,1,https://github.com/mupen64plus/mupen64plus-core/pull/741,"I was trying to build mupen64 with VisualStudio 2015 following the instructions for 'Compiling Mupen64Plus in Windows' found at https://mupen64plus.org/wiki/index.php?title=CompilingOnWindows.  The build works for everything, but was failing on building:
mupen64plus-github\mupen64plus-core\src\device\r4300\x86\dyna_start.asm
because the full path had spaces in it, when path expansion occurred the command to compile would complain that more than 1 input file was specified.  This fix just puts quotes around the %(FullPath) variables in the *.vcxproj file to ensure that this doesn't happen. After doing this, I was able to compile everything with no issues.","I was trying to build mupen64 with VisualStudio 2015 following the instructions for 'Compiling Mupen64Plus in Windows' found at https://mupen64plus.org/wiki/index.php?title=CompilingOnWindows.  The build works for everything, but was failing on building:
mupen64plus-github\mupen64plus-core\src\device\r4300\x86\dyna_start.asm
because the full path had spaces in it, when path expansion occurred the command to compile would complain that more than 1 input file was specified.  This fix just puts quotes around the %(FullPath) variables in the *.vcxproj file to ensure that this doesn't happen. After doing this, I was able to compile everything with no issues.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,743,2020-04-02T13:03:20Z,2020-12-06T21:41:57Z,2021-02-01T11:13:25Z,MERGED,True,174,110,4,https://github.com/bsmiles32,Rework flashram implementation,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/743,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/743,"By combining the following sources :

reverse engineering of Majoras Mask flashram functions [1]
@sanni's cart reader [2]
and MX29L1611 datasheet (""close enough"" flash memory from Macronix)

I was able to figure a better model for flashram than what we currently
have. As this new modeling of flashram doesn't match one-to-one with
old model, meaning it may possibly ""break"" older savestate (in fact it may break if the savestate has been taken during some flashram operation, otherwise it should be relatively safe),
I had to bump savestate version.
[1] pending PR in https://github.com/n64decomp/majora/
[2] https://github.com/sanni/cartreader/blob/master/Cart_Reader/N64.ino
I've tested mostly Majora's Mask, Jet Force Gemini and Derby Stallion and it seems to work OK.
If you want to test also, be sure to backup your fla saves first, so that you won't loose them, in case of a bug...
cc: @sanni. This work may (or may not) interest you. Feel free to comment or give suggestions if you want :)","By combining the following sources :

reverse engineering of Majoras Mask flashram functions [1]
@sanni's cart reader [2]
and MX29L1611 datasheet (""close enough"" flash memory from Macronix)

I was able to figure a better model for flashram than what we currently
have. As this new modeling of flashram doesn't match one-to-one with
old model, meaning it may possibly ""break"" older savestate (in fact it may break if the savestate has been taken during some flashram operation, otherwise it should be relatively safe),
I had to bump savestate version.
[1] pending PR in https://github.com/n64decomp/majora/
[2] https://github.com/sanni/cartreader/blob/master/Cart_Reader/N64.ino
I've tested mostly Majora's Mask, Jet Force Gemini and Derby Stallion and it seems to work OK.
If you want to test also, be sure to backup your fla saves first, so that you won't loose them, in case of a bug...
cc: @sanni. This work may (or may not) interest you. Feel free to comment or give suggestions if you want :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,743,2020-04-02T13:03:20Z,2020-12-06T21:41:57Z,2021-02-01T11:13:25Z,MERGED,True,174,110,4,https://github.com/bsmiles32,Rework flashram implementation,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/743,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/743#issuecomment-607983346,"By combining the following sources :

reverse engineering of Majoras Mask flashram functions [1]
@sanni's cart reader [2]
and MX29L1611 datasheet (""close enough"" flash memory from Macronix)

I was able to figure a better model for flashram than what we currently
have. As this new modeling of flashram doesn't match one-to-one with
old model, meaning it may possibly ""break"" older savestate (in fact it may break if the savestate has been taken during some flashram operation, otherwise it should be relatively safe),
I had to bump savestate version.
[1] pending PR in https://github.com/n64decomp/majora/
[2] https://github.com/sanni/cartreader/blob/master/Cart_Reader/N64.ino
I've tested mostly Majora's Mask, Jet Force Gemini and Derby Stallion and it seems to work OK.
If you want to test also, be sure to backup your fla saves first, so that you won't loose them, in case of a bug...
cc: @sanni. This work may (or may not) interest you. Feel free to comment or give suggestions if you want :)","Pretty cool, I tested Paper Mario and Command & Conquer and didn't see any obvious issues.
I also just wanted to point out that #721 is in the PR queue and also proproses a savestate version increase to 1.7",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,743,2020-04-02T13:03:20Z,2020-12-06T21:41:57Z,2021-02-01T11:13:25Z,MERGED,True,174,110,4,https://github.com/bsmiles32,Rework flashram implementation,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/743,https://github.com/i30817,3,https://github.com/mupen64plus/mupen64plus-core/pull/743#issuecomment-618486461,"By combining the following sources :

reverse engineering of Majoras Mask flashram functions [1]
@sanni's cart reader [2]
and MX29L1611 datasheet (""close enough"" flash memory from Macronix)

I was able to figure a better model for flashram than what we currently
have. As this new modeling of flashram doesn't match one-to-one with
old model, meaning it may possibly ""break"" older savestate (in fact it may break if the savestate has been taken during some flashram operation, otherwise it should be relatively safe),
I had to bump savestate version.
[1] pending PR in https://github.com/n64decomp/majora/
[2] https://github.com/sanni/cartreader/blob/master/Cart_Reader/N64.ino
I've tested mostly Majora's Mask, Jet Force Gemini and Derby Stallion and it seems to work OK.
If you want to test also, be sure to backup your fla saves first, so that you won't loose them, in case of a bug...
cc: @sanni. This work may (or may not) interest you. Feel free to comment or give suggestions if you want :)","Does this break runahead if started on boot, like happens in many other emulators if you can savestate on boot?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,743,2020-04-02T13:03:20Z,2020-12-06T21:41:57Z,2021-02-01T11:13:25Z,MERGED,True,174,110,4,https://github.com/bsmiles32,Rework flashram implementation,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/743,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/743#issuecomment-706446504,"By combining the following sources :

reverse engineering of Majoras Mask flashram functions [1]
@sanni's cart reader [2]
and MX29L1611 datasheet (""close enough"" flash memory from Macronix)

I was able to figure a better model for flashram than what we currently
have. As this new modeling of flashram doesn't match one-to-one with
old model, meaning it may possibly ""break"" older savestate (in fact it may break if the savestate has been taken during some flashram operation, otherwise it should be relatively safe),
I had to bump savestate version.
[1] pending PR in https://github.com/n64decomp/majora/
[2] https://github.com/sanni/cartreader/blob/master/Cart_Reader/N64.ino
I've tested mostly Majora's Mask, Jet Force Gemini and Derby Stallion and it seems to work OK.
If you want to test also, be sure to backup your fla saves first, so that you won't loose them, in case of a bug...
cc: @sanni. This work may (or may not) interest you. Feel free to comment or give suggestions if you want :)",@bsmiles32 I think this is really valuable work. I think if you can fix the merge conflict it should probably be merged,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,743,2020-04-02T13:03:20Z,2020-12-06T21:41:57Z,2021-02-01T11:13:25Z,MERGED,True,174,110,4,https://github.com/bsmiles32,Rework flashram implementation,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/743,https://github.com/bsmiles32,5,https://github.com/mupen64plus/mupen64plus-core/pull/743#issuecomment-720074235,"By combining the following sources :

reverse engineering of Majoras Mask flashram functions [1]
@sanni's cart reader [2]
and MX29L1611 datasheet (""close enough"" flash memory from Macronix)

I was able to figure a better model for flashram than what we currently
have. As this new modeling of flashram doesn't match one-to-one with
old model, meaning it may possibly ""break"" older savestate (in fact it may break if the savestate has been taken during some flashram operation, otherwise it should be relatively safe),
I had to bump savestate version.
[1] pending PR in https://github.com/n64decomp/majora/
[2] https://github.com/sanni/cartreader/blob/master/Cart_Reader/N64.ino
I've tested mostly Majora's Mask, Jet Force Gemini and Derby Stallion and it seems to work OK.
If you want to test also, be sure to backup your fla saves first, so that you won't loose them, in case of a bug...
cc: @sanni. This work may (or may not) interest you. Feel free to comment or give suggestions if you want :)",Rebased against master and resolved savestate conflicts as suggested by @loganmc10,True,{'THUMBS_UP': ['https://github.com/loganmc10']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,743,2020-04-02T13:03:20Z,2020-12-06T21:41:57Z,2021-02-01T11:13:25Z,MERGED,True,174,110,4,https://github.com/bsmiles32,Rework flashram implementation,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/743,https://github.com/bsmiles32,6,https://github.com/mupen64plus/mupen64plus-core/pull/743#issuecomment-722147594,"By combining the following sources :

reverse engineering of Majoras Mask flashram functions [1]
@sanni's cart reader [2]
and MX29L1611 datasheet (""close enough"" flash memory from Macronix)

I was able to figure a better model for flashram than what we currently
have. As this new modeling of flashram doesn't match one-to-one with
old model, meaning it may possibly ""break"" older savestate (in fact it may break if the savestate has been taken during some flashram operation, otherwise it should be relatively safe),
I had to bump savestate version.
[1] pending PR in https://github.com/n64decomp/majora/
[2] https://github.com/sanni/cartreader/blob/master/Cart_Reader/N64.ino
I've tested mostly Majora's Mask, Jet Force Gemini and Derby Stallion and it seems to work OK.
If you want to test also, be sure to backup your fla saves first, so that you won't loose them, in case of a bug...
cc: @sanni. This work may (or may not) interest you. Feel free to comment or give suggestions if you want :)","I'm not sure this PR should be merged now... I have doubts about page_buf belonging to flashram (not clear from the datasheet) and I suspect the buffer belongs to the PI which is known to have such 128 byte buffer. This 128 byte PI buffer is what causes the write_cart_rom issue we found earlier.
To be clear, I think the code works OK, but I'd like to revisit it and see if I should move page_buf to PI instead. This would avoid breaking/bumping savestate version later.
edit: Looking again at the datasheet and how flashram is programmed, I think in fact there is a page_buf inside the flashram which is different from the PI 128-byte buffer. So, PR is mergeable.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,743,2020-04-02T13:03:20Z,2020-12-06T21:41:57Z,2021-02-01T11:13:25Z,MERGED,True,174,110,4,https://github.com/bsmiles32,Rework flashram implementation,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/743,https://github.com/bsmiles32,7,https://github.com/mupen64plus/mupen64plus-core/pull/743#issuecomment-739495047,"By combining the following sources :

reverse engineering of Majoras Mask flashram functions [1]
@sanni's cart reader [2]
and MX29L1611 datasheet (""close enough"" flash memory from Macronix)

I was able to figure a better model for flashram than what we currently
have. As this new modeling of flashram doesn't match one-to-one with
old model, meaning it may possibly ""break"" older savestate (in fact it may break if the savestate has been taken during some flashram operation, otherwise it should be relatively safe),
I had to bump savestate version.
[1] pending PR in https://github.com/n64decomp/majora/
[2] https://github.com/sanni/cartreader/blob/master/Cart_Reader/N64.ino
I've tested mostly Majora's Mask, Jet Force Gemini and Derby Stallion and it seems to work OK.
If you want to test also, be sure to backup your fla saves first, so that you won't loose them, in case of a bug...
cc: @sanni. This work may (or may not) interest you. Feel free to comment or give suggestions if you want :)",@richard42 Are you OK to merge this ?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,743,2020-04-02T13:03:20Z,2020-12-06T21:41:57Z,2021-02-01T11:13:25Z,MERGED,True,174,110,4,https://github.com/bsmiles32,Rework flashram implementation,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/743,https://github.com/richard42,8,https://github.com/mupen64plus/mupen64plus-core/pull/743#issuecomment-739556721,"By combining the following sources :

reverse engineering of Majoras Mask flashram functions [1]
@sanni's cart reader [2]
and MX29L1611 datasheet (""close enough"" flash memory from Macronix)

I was able to figure a better model for flashram than what we currently
have. As this new modeling of flashram doesn't match one-to-one with
old model, meaning it may possibly ""break"" older savestate (in fact it may break if the savestate has been taken during some flashram operation, otherwise it should be relatively safe),
I had to bump savestate version.
[1] pending PR in https://github.com/n64decomp/majora/
[2] https://github.com/sanni/cartreader/blob/master/Cart_Reader/N64.ino
I've tested mostly Majora's Mask, Jet Force Gemini and Derby Stallion and it seems to work OK.
If you want to test also, be sure to backup your fla saves first, so that you won't loose them, in case of a bug...
cc: @sanni. This work may (or may not) interest you. Feel free to comment or give suggestions if you want :)","yes, please go ahead",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,744,2020-04-04T04:20:51Z,2020-04-04T08:38:51Z,2021-06-20T20:45:35Z,MERGED,True,2,0,1,https://github.com/loganmc10,CountPerOp=1 for Battle for Naboo,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/744,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/744,"Fixes #570
I went to play this game today, it froze (sound but a black screen) just when about to start the first level. Settings CountPerOp=1 fixed the issue, it also happens to fix #570, which is an old reported issue","Fixes #570
I went to play this game today, it froze (sound but a black screen) just when about to start the first level. Settings CountPerOp=1 fixed the issue, it also happens to fix #570, which is an old reported issue",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,745,2020-04-04T10:56:09Z,2020-04-04T16:09:29Z,2021-02-01T11:20:47Z,MERGED,True,177,53,7,https://github.com/bsmiles32,Implement trap instructions,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/745,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/745,"Replace PR #691 and implements trap instructions for Pure interpreter, Cached interpreter and old dynarec.
Since I'm not aware of any test ROM for these instructions, implementation has not been tested, and was just thrown together by reading the CPU doc.","Replace PR #691 and implements trap instructions for Pure interpreter, Cached interpreter and old dynarec.
Since I'm not aware of any test ROM for these instructions, implementation has not been tested, and was just thrown together by reading the CPU doc.",True,{'THUMBS_UP': ['https://github.com/loganmc10']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,746,2020-04-04T15:27:29Z,2020-04-04T15:29:33Z,2021-02-01T11:20:43Z,MERGED,True,16,0,1,https://github.com/bsmiles32,Fix hard reset crash,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/746,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/746,Integrate work done by @flagrama,Integrate work done by @flagrama,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,746,2020-04-04T15:27:29Z,2020-04-04T15:29:33Z,2021-02-01T11:20:43Z,MERGED,True,16,0,1,https://github.com/bsmiles32,Fix hard reset crash,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/746,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/746#issuecomment-609105756,Integrate work done by @flagrama,"@bsmiles32 we are now getting this AppVeyor failure:
..\..\src\device\r4300\interrupt.c(483): error C2039: 'save_rsp': is not a member of 'recomp' [

I think just on the Win32 build",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,747,2020-04-05T07:58:56Z,2020-04-05T08:13:55Z,2021-02-01T11:20:41Z,MERGED,True,18,0,1,https://github.com/bsmiles32,fix compilation on x86,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/747,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/747,Previous commit was incomplete and broke x86 compilation.,Previous commit was incomplete and broke x86 compilation.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,748,2020-04-06T03:29:46Z,2020-04-22T04:00:25Z,2021-06-20T20:45:36Z,MERGED,True,7,0,1,https://github.com/loganmc10,CountPerOp=1 for Top Gear Overdrive/Hyperbike,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/748,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/748,"These games perform much better with CountPerOp=1, it becomes very apparent if you listen to the audio during a race in both games (very choppy with CountPerOp=2)
Both games by the same developer, they behave very similarly.","These games perform much better with CountPerOp=1, it becomes very apparent if you listen to the audio during a race in both games (very choppy with CountPerOp=2)
Both games by the same developer, they behave very similarly.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,750,2020-04-13T00:33:02Z,2020-04-22T04:08:05Z,2020-04-22T04:08:05Z,MERGED,True,0,1,1,https://github.com/dankcushions,"Removed ""not officially supported"" for ARM",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/750,https://github.com/dankcushions,1,https://github.com/mupen64plus/mupen64plus-core/pull/750,I think we can safely remove this warning now - ARM is a well established target for mupen64plus. i note the same warning isn't there for aarch64.,I think we can safely remove this warning now - ARM is a well established target for mupen64plus. i note the same warning isn't there for aarch64.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,751,2020-04-16T02:16:29Z,2020-04-22T04:09:12Z,2021-06-20T20:45:38Z,MERGED,True,2,0,1,https://github.com/loganmc10,Enable FBInfo for CPU-RDP rendering,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/751,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/751,"Some games bypass the RSP, and use the CPU to send commands directly to the RDP. FlappyBird64 is an example. The current unprotect/protect FB code only occurs in RSP rendering, so FBInfo doesn't work with these types of games.
This change fixes that and allows FBInfo to work with FlappyBird64, which is required for it to render properly in GLideN64","Some games bypass the RSP, and use the CPU to send commands directly to the RDP. FlappyBird64 is an example. The current unprotect/protect FB code only occurs in RSP rendering, so FBInfo doesn't work with these types of games.
This change fixes that and allows FBInfo to work with FlappyBird64, which is required for it to render properly in GLideN64",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,752,2020-04-17T16:44:34Z,2020-04-22T04:10:41Z,2021-06-20T20:45:40Z,MERGED,True,2,2,1,https://github.com/loganmc10,Mask DRAM address in PI DMA,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/752,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/752,"Just like in the RSP DMA:
https://github.com/mupen64plus/mupen64plus-core/blob/master/src/device/rcp/rsp/rsp_core.c#L49
The dram address should be masked, I came across one of the PeterLemon test ROMs that attempts a PI DMA using an address that needs to be masked. I believe the reason for this is that the memory can be accessed via cached/un-cached paths, but the resulting address access should be the same","Just like in the RSP DMA:
https://github.com/mupen64plus/mupen64plus-core/blob/master/src/device/rcp/rsp/rsp_core.c#L49
The dram address should be masked, I came across one of the PeterLemon test ROMs that attempts a PI DMA using an address that needs to be masked. I believe the reason for this is that the memory can be accessed via cached/un-cached paths, but the resulting address access should be the same",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,753,2020-04-26T00:15:37Z,2020-06-28T17:40:35Z,2021-06-20T20:45:44Z,MERGED,True,1173,50,19,https://github.com/loganmc10,Netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/753,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/753,"For starters, you can see a demo here:
https://www.youtube.com/watch?v=bkW_SbxdsUo
Here is the code for the server I wrote, the intention is that the netplay server wouldn't be part of the mupen64plus project, but anyone could write one based on the spec:
https://github.com/loganmc10/m64p-netplay-server
Here are the changes I had to make to mupen64plus-gui:
https://github.com/m64p/mupen64plus-gui/tree/netplay
I am submitting this in a WIP state in the hopes that I can get comments on the API and code, and any other philosophical discussions about netplay that need to happen. I am on Discord (https://discord.gg/8XRuJ4F) in the #emu_mupen channel as well, which might be a better place for longer back and forth discussion.
Some principles of this design:

The server is the ""source of truth"", when Player 1 hits A, their local game does not register an A press, it sends that info to the server, and the server responds to all players with data on when to register an A press for player 1
Key inputs are not guaranteed to be received by the server (all data is transferred via UDP). This is to keep input latency low
The game will ""punish"" the player with a poor internet connection (they may experience higher input latency and missed input, but it won't affect the other players). I think this is an important principle in online gaming

The implementation was written in SDL_net, I haven't documented the all the packet formats, but I can do all that documentation work once there is a general consensus on the design
Responsibilities:

Core: sends and receives key inputs directly from the netplay server, keeps the game running in sync with other players
Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)
Netplay server: communicates with core and frontend to accomplish what was listed above

I'm sure I missed many details, please ask me any questions you'd like","For starters, you can see a demo here:
https://www.youtube.com/watch?v=bkW_SbxdsUo
Here is the code for the server I wrote, the intention is that the netplay server wouldn't be part of the mupen64plus project, but anyone could write one based on the spec:
https://github.com/loganmc10/m64p-netplay-server
Here are the changes I had to make to mupen64plus-gui:
https://github.com/m64p/mupen64plus-gui/tree/netplay
I am submitting this in a WIP state in the hopes that I can get comments on the API and code, and any other philosophical discussions about netplay that need to happen. I am on Discord (https://discord.gg/8XRuJ4F) in the #emu_mupen channel as well, which might be a better place for longer back and forth discussion.
Some principles of this design:

The server is the ""source of truth"", when Player 1 hits A, their local game does not register an A press, it sends that info to the server, and the server responds to all players with data on when to register an A press for player 1
Key inputs are not guaranteed to be received by the server (all data is transferred via UDP). This is to keep input latency low
The game will ""punish"" the player with a poor internet connection (they may experience higher input latency and missed input, but it won't affect the other players). I think this is an important principle in online gaming

The implementation was written in SDL_net, I haven't documented the all the packet formats, but I can do all that documentation work once there is a general consensus on the design
Responsibilities:

Core: sends and receives key inputs directly from the netplay server, keeps the game running in sync with other players
Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)
Netplay server: communicates with core and frontend to accomplish what was listed above

I'm sure I missed many details, please ask me any questions you'd like",True,"{'HOORAY': ['https://github.com/Mastergatto', 'https://github.com/misterhat', 'https://github.com/Narann', 'https://github.com/paradadf', 'https://github.com/sodomon2'], 'THUMBS_UP': ['https://github.com/misterhat', 'https://github.com/sodomon2', 'https://github.com/hopskipnfall', 'https://github.com/inukaze']}"
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,753,2020-04-26T00:15:37Z,2020-06-28T17:40:35Z,2021-06-20T20:45:44Z,MERGED,True,1173,50,19,https://github.com/loganmc10,Netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/753,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/753#issuecomment-620594484,"For starters, you can see a demo here:
https://www.youtube.com/watch?v=bkW_SbxdsUo
Here is the code for the server I wrote, the intention is that the netplay server wouldn't be part of the mupen64plus project, but anyone could write one based on the spec:
https://github.com/loganmc10/m64p-netplay-server
Here are the changes I had to make to mupen64plus-gui:
https://github.com/m64p/mupen64plus-gui/tree/netplay
I am submitting this in a WIP state in the hopes that I can get comments on the API and code, and any other philosophical discussions about netplay that need to happen. I am on Discord (https://discord.gg/8XRuJ4F) in the #emu_mupen channel as well, which might be a better place for longer back and forth discussion.
Some principles of this design:

The server is the ""source of truth"", when Player 1 hits A, their local game does not register an A press, it sends that info to the server, and the server responds to all players with data on when to register an A press for player 1
Key inputs are not guaranteed to be received by the server (all data is transferred via UDP). This is to keep input latency low
The game will ""punish"" the player with a poor internet connection (they may experience higher input latency and missed input, but it won't affect the other players). I think this is an important principle in online gaming

The implementation was written in SDL_net, I haven't documented the all the packet formats, but I can do all that documentation work once there is a general consensus on the design
Responsibilities:

Core: sends and receives key inputs directly from the netplay server, keeps the game running in sync with other players
Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)
Netplay server: communicates with core and frontend to accomplish what was listed above

I'm sure I missed many details, please ask me any questions you'd like","The code is pretty clean. There is still a lot of magic numbers, but as you say, it's not the purpose yet. Just the versioning query using GIT_VER looks weird to me.
I love your server to clients design.
Good job! This was a long time requested feature!",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,753,2020-04-26T00:15:37Z,2020-06-28T17:40:35Z,2021-06-20T20:45:44Z,MERGED,True,1173,50,19,https://github.com/loganmc10,Netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/753,https://github.com/Mastergatto,3,https://github.com/mupen64plus/mupen64plus-core/pull/753#issuecomment-620600582,"For starters, you can see a demo here:
https://www.youtube.com/watch?v=bkW_SbxdsUo
Here is the code for the server I wrote, the intention is that the netplay server wouldn't be part of the mupen64plus project, but anyone could write one based on the spec:
https://github.com/loganmc10/m64p-netplay-server
Here are the changes I had to make to mupen64plus-gui:
https://github.com/m64p/mupen64plus-gui/tree/netplay
I am submitting this in a WIP state in the hopes that I can get comments on the API and code, and any other philosophical discussions about netplay that need to happen. I am on Discord (https://discord.gg/8XRuJ4F) in the #emu_mupen channel as well, which might be a better place for longer back and forth discussion.
Some principles of this design:

The server is the ""source of truth"", when Player 1 hits A, their local game does not register an A press, it sends that info to the server, and the server responds to all players with data on when to register an A press for player 1
Key inputs are not guaranteed to be received by the server (all data is transferred via UDP). This is to keep input latency low
The game will ""punish"" the player with a poor internet connection (they may experience higher input latency and missed input, but it won't affect the other players). I think this is an important principle in online gaming

The implementation was written in SDL_net, I haven't documented the all the packet formats, but I can do all that documentation work once there is a general consensus on the design
Responsibilities:

Core: sends and receives key inputs directly from the netplay server, keeps the game running in sync with other players
Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)
Netplay server: communicates with core and frontend to accomplish what was listed above

I'm sure I missed many details, please ask me any questions you'd like","Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)

Don't forget the cheats! It would be annoying if one is able to use them while others don't. Thanks and keep up the good job!
Also, tracking #112",True,"{'THUMBS_UP': ['https://github.com/sodomon2', 'https://github.com/hopskipnfall']}"
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,753,2020-04-26T00:15:37Z,2020-06-28T17:40:35Z,2021-06-20T20:45:44Z,MERGED,True,1173,50,19,https://github.com/loganmc10,Netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/753,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/753#issuecomment-620954597,"For starters, you can see a demo here:
https://www.youtube.com/watch?v=bkW_SbxdsUo
Here is the code for the server I wrote, the intention is that the netplay server wouldn't be part of the mupen64plus project, but anyone could write one based on the spec:
https://github.com/loganmc10/m64p-netplay-server
Here are the changes I had to make to mupen64plus-gui:
https://github.com/m64p/mupen64plus-gui/tree/netplay
I am submitting this in a WIP state in the hopes that I can get comments on the API and code, and any other philosophical discussions about netplay that need to happen. I am on Discord (https://discord.gg/8XRuJ4F) in the #emu_mupen channel as well, which might be a better place for longer back and forth discussion.
Some principles of this design:

The server is the ""source of truth"", when Player 1 hits A, their local game does not register an A press, it sends that info to the server, and the server responds to all players with data on when to register an A press for player 1
Key inputs are not guaranteed to be received by the server (all data is transferred via UDP). This is to keep input latency low
The game will ""punish"" the player with a poor internet connection (they may experience higher input latency and missed input, but it won't affect the other players). I think this is an important principle in online gaming

The implementation was written in SDL_net, I haven't documented the all the packet formats, but I can do all that documentation work once there is a general consensus on the design
Responsibilities:

Core: sends and receives key inputs directly from the netplay server, keeps the game running in sync with other players
Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)
Netplay server: communicates with core and frontend to accomplish what was listed above

I'm sure I missed many details, please ask me any questions you'd like","I thought git version would be good because it's fairly automatic, even something like a change to mupen64plus.ini to change the default CountPerOp for a game would bring players out of sync if they are playing that game, so almost every PR would require an increment to the version number.
I think it would be better to do something like ""if GIT_VER"" and then fallback to MUPEN_CORE_VERSION if the compiler is unable to obtain the GIT_VER",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,753,2020-04-26T00:15:37Z,2020-06-28T17:40:35Z,2021-06-20T20:45:44Z,MERGED,True,1173,50,19,https://github.com/loganmc10,Netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/753,https://github.com/Narann,5,https://github.com/mupen64plus/mupen64plus-core/pull/753#issuecomment-621094266,"For starters, you can see a demo here:
https://www.youtube.com/watch?v=bkW_SbxdsUo
Here is the code for the server I wrote, the intention is that the netplay server wouldn't be part of the mupen64plus project, but anyone could write one based on the spec:
https://github.com/loganmc10/m64p-netplay-server
Here are the changes I had to make to mupen64plus-gui:
https://github.com/m64p/mupen64plus-gui/tree/netplay
I am submitting this in a WIP state in the hopes that I can get comments on the API and code, and any other philosophical discussions about netplay that need to happen. I am on Discord (https://discord.gg/8XRuJ4F) in the #emu_mupen channel as well, which might be a better place for longer back and forth discussion.
Some principles of this design:

The server is the ""source of truth"", when Player 1 hits A, their local game does not register an A press, it sends that info to the server, and the server responds to all players with data on when to register an A press for player 1
Key inputs are not guaranteed to be received by the server (all data is transferred via UDP). This is to keep input latency low
The game will ""punish"" the player with a poor internet connection (they may experience higher input latency and missed input, but it won't affect the other players). I think this is an important principle in online gaming

The implementation was written in SDL_net, I haven't documented the all the packet formats, but I can do all that documentation work once there is a general consensus on the design
Responsibilities:

Core: sends and receives key inputs directly from the netplay server, keeps the game running in sync with other players
Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)
Netplay server: communicates with core and frontend to accomplish what was listed above

I'm sure I missed many details, please ask me any questions you'd like","The git version does not provides guarantee mupen64plus.ini is the same.
If you need to rely on some information to avoid out of sync, a more robust system need to be found. My suggestion is to keep an internal netplay version for modifications that change the internal behavior (for server purpose), what you consider as changing the sync (core version, ROM hash, CountPerOp, etc), hash all of this and send the hash. If all players don't send the same hash to the server, it's over.
About cheaters: It's open source, anyone with some knowledge could beat the system anyway.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,753,2020-04-26T00:15:37Z,2020-06-28T17:40:35Z,2021-06-20T20:45:44Z,MERGED,True,1173,50,19,https://github.com/loganmc10,Netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/753,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/753#issuecomment-621207171,"For starters, you can see a demo here:
https://www.youtube.com/watch?v=bkW_SbxdsUo
Here is the code for the server I wrote, the intention is that the netplay server wouldn't be part of the mupen64plus project, but anyone could write one based on the spec:
https://github.com/loganmc10/m64p-netplay-server
Here are the changes I had to make to mupen64plus-gui:
https://github.com/m64p/mupen64plus-gui/tree/netplay
I am submitting this in a WIP state in the hopes that I can get comments on the API and code, and any other philosophical discussions about netplay that need to happen. I am on Discord (https://discord.gg/8XRuJ4F) in the #emu_mupen channel as well, which might be a better place for longer back and forth discussion.
Some principles of this design:

The server is the ""source of truth"", when Player 1 hits A, their local game does not register an A press, it sends that info to the server, and the server responds to all players with data on when to register an A press for player 1
Key inputs are not guaranteed to be received by the server (all data is transferred via UDP). This is to keep input latency low
The game will ""punish"" the player with a poor internet connection (they may experience higher input latency and missed input, but it won't affect the other players). I think this is an important principle in online gaming

The implementation was written in SDL_net, I haven't documented the all the packet formats, but I can do all that documentation work once there is a general consensus on the design
Responsibilities:

Core: sends and receives key inputs directly from the netplay server, keeps the game running in sync with other players
Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)
Netplay server: communicates with core and frontend to accomplish what was listed above

I'm sure I missed many details, please ask me any questions you'd like","Alright, I haven't put a ton of thought into keeping all the settings in sync yet, that's probably the last thing I'll work on (as it's the least exciting..). For now I've updated it to just use a ""netplay_core_version"" variable that can be incremented when changes to the core are made.
And you are correct about cheaters, it would be trivial to break this in any number of ways, it's just designed for casual friendly play",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,753,2020-04-26T00:15:37Z,2020-06-28T17:40:35Z,2021-06-20T20:45:44Z,MERGED,True,1173,50,19,https://github.com/loganmc10,Netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/753,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/753#issuecomment-628667283,"For starters, you can see a demo here:
https://www.youtube.com/watch?v=bkW_SbxdsUo
Here is the code for the server I wrote, the intention is that the netplay server wouldn't be part of the mupen64plus project, but anyone could write one based on the spec:
https://github.com/loganmc10/m64p-netplay-server
Here are the changes I had to make to mupen64plus-gui:
https://github.com/m64p/mupen64plus-gui/tree/netplay
I am submitting this in a WIP state in the hopes that I can get comments on the API and code, and any other philosophical discussions about netplay that need to happen. I am on Discord (https://discord.gg/8XRuJ4F) in the #emu_mupen channel as well, which might be a better place for longer back and forth discussion.
Some principles of this design:

The server is the ""source of truth"", when Player 1 hits A, their local game does not register an A press, it sends that info to the server, and the server responds to all players with data on when to register an A press for player 1
Key inputs are not guaranteed to be received by the server (all data is transferred via UDP). This is to keep input latency low
The game will ""punish"" the player with a poor internet connection (they may experience higher input latency and missed input, but it won't affect the other players). I think this is an important principle in online gaming

The implementation was written in SDL_net, I haven't documented the all the packet formats, but I can do all that documentation work once there is a general consensus on the design
Responsibilities:

Core: sends and receives key inputs directly from the netplay server, keeps the game running in sync with other players
Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)
Netplay server: communicates with core and frontend to accomplish what was listed above

I'm sure I missed many details, please ask me any questions you'd like","I've gotten it to a point where I think it can be tested, you can download a build here:
https://github.com/loganmc10/m64p/releases
Here is another demo showing some of the progress:
https://www.youtube.com/watch?v=XKehKifbK8U",True,"{'HEART': ['https://github.com/paradadf', 'https://github.com/Mastergatto', 'https://github.com/Narann', 'https://github.com/sodomon2', 'https://github.com/hopskipnfall']}"
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,753,2020-04-26T00:15:37Z,2020-06-28T17:40:35Z,2021-06-20T20:45:44Z,MERGED,True,1173,50,19,https://github.com/loganmc10,Netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/753,https://github.com/Narann,8,https://github.com/mupen64plus/mupen64plus-core/pull/753#issuecomment-628790638,"For starters, you can see a demo here:
https://www.youtube.com/watch?v=bkW_SbxdsUo
Here is the code for the server I wrote, the intention is that the netplay server wouldn't be part of the mupen64plus project, but anyone could write one based on the spec:
https://github.com/loganmc10/m64p-netplay-server
Here are the changes I had to make to mupen64plus-gui:
https://github.com/m64p/mupen64plus-gui/tree/netplay
I am submitting this in a WIP state in the hopes that I can get comments on the API and code, and any other philosophical discussions about netplay that need to happen. I am on Discord (https://discord.gg/8XRuJ4F) in the #emu_mupen channel as well, which might be a better place for longer back and forth discussion.
Some principles of this design:

The server is the ""source of truth"", when Player 1 hits A, their local game does not register an A press, it sends that info to the server, and the server responds to all players with data on when to register an A press for player 1
Key inputs are not guaranteed to be received by the server (all data is transferred via UDP). This is to keep input latency low
The game will ""punish"" the player with a poor internet connection (they may experience higher input latency and missed input, but it won't affect the other players). I think this is an important principle in online gaming

The implementation was written in SDL_net, I haven't documented the all the packet formats, but I can do all that documentation work once there is a general consensus on the design
Responsibilities:

Core: sends and receives key inputs directly from the netplay server, keeps the game running in sync with other players
Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)
Netplay server: communicates with core and frontend to accomplish what was listed above

I'm sure I missed many details, please ask me any questions you'd like","It's very nice ! I realize one PC seems to always beeing 1 frame before. I wonder if the system couldn't have a ""friendly delay"" option (aka, minimun delay of the other players / 2). So if you have this :

Player 1: 10 ms
Player 2: 50 ms
Player 3: 53 ms
Player 4: 75 ms

The best player (here, player 1) would be slighly delayed to better match the other best players ping : 50 - 10 = 40. 40 / 2 = 20:

Player 1: 30 ms (10ms + friendly delay: 20ms)
Player 2: 50 ms
Player 3: 53 ms
Player 4: 75 ms

As you say, better connection players should not be penalized instead of slow connection ones. I agree and it makes perfect sense for outside server (aka, both players connect to external server, like Steam).
But if, in practice, there is always the combo: Player 1 is both server and player, and player 2 (and 3, and 4) connects to player 1 PC. Player 1 will always have a better ping. This could ruin the game, even for player 1.
So here is my suggestion for a ""friendly delay"" option on server side : If one player is on the same network, its delay is compared with others and if it's better, he gets an delay to be a little bit consistent (aka, on par) with other players so everyone have fun.
Anyway it will always have a better delay than others, we just avoid a huge gap.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,753,2020-04-26T00:15:37Z,2020-06-28T17:40:35Z,2021-06-20T20:45:44Z,MERGED,True,1173,50,19,https://github.com/loganmc10,Netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/753,https://github.com/loganmc10,9,https://github.com/mupen64plus/mupen64plus-core/pull/753#issuecomment-629310102,"For starters, you can see a demo here:
https://www.youtube.com/watch?v=bkW_SbxdsUo
Here is the code for the server I wrote, the intention is that the netplay server wouldn't be part of the mupen64plus project, but anyone could write one based on the spec:
https://github.com/loganmc10/m64p-netplay-server
Here are the changes I had to make to mupen64plus-gui:
https://github.com/m64p/mupen64plus-gui/tree/netplay
I am submitting this in a WIP state in the hopes that I can get comments on the API and code, and any other philosophical discussions about netplay that need to happen. I am on Discord (https://discord.gg/8XRuJ4F) in the #emu_mupen channel as well, which might be a better place for longer back and forth discussion.
Some principles of this design:

The server is the ""source of truth"", when Player 1 hits A, their local game does not register an A press, it sends that info to the server, and the server responds to all players with data on when to register an A press for player 1
Key inputs are not guaranteed to be received by the server (all data is transferred via UDP). This is to keep input latency low
The game will ""punish"" the player with a poor internet connection (they may experience higher input latency and missed input, but it won't affect the other players). I think this is an important principle in online gaming

The implementation was written in SDL_net, I haven't documented the all the packet formats, but I can do all that documentation work once there is a general consensus on the design
Responsibilities:

Core: sends and receives key inputs directly from the netplay server, keeps the game running in sync with other players
Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)
Netplay server: communicates with core and frontend to accomplish what was listed above

I'm sure I missed many details, please ask me any questions you'd like","I spent all this time trying to reduce the latency and now you want me to put it back? 😛
In the initial testing I did with someone on Discord (not sure if he has a GitHub account), the latency differential didn't seem to negatively affect the gameplay. He had a ping of about 80-90ms and mine was about 35-40ms. We played a fairly long round of Perfect Dark, and some Mario Kart, the controls felt responsive for both of us.
I wouldn't rule it out completely, but I don't think it would be high on my list of things to implement, first I've got to iron out the bugs and do some work on syncing settings and such. To me, latency differentials are just a part of online gaming, a player with a higher latency would have a (small) disadvantage playing Call of Duty or other modern online games (if I understand how they work correctly)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,753,2020-04-26T00:15:37Z,2020-06-28T17:40:35Z,2021-06-20T20:45:44Z,MERGED,True,1173,50,19,https://github.com/loganmc10,Netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/753,https://github.com/loganmc10,10,https://github.com/mupen64plus/mupen64plus-core/pull/753#issuecomment-629313155,"For starters, you can see a demo here:
https://www.youtube.com/watch?v=bkW_SbxdsUo
Here is the code for the server I wrote, the intention is that the netplay server wouldn't be part of the mupen64plus project, but anyone could write one based on the spec:
https://github.com/loganmc10/m64p-netplay-server
Here are the changes I had to make to mupen64plus-gui:
https://github.com/m64p/mupen64plus-gui/tree/netplay
I am submitting this in a WIP state in the hopes that I can get comments on the API and code, and any other philosophical discussions about netplay that need to happen. I am on Discord (https://discord.gg/8XRuJ4F) in the #emu_mupen channel as well, which might be a better place for longer back and forth discussion.
Some principles of this design:

The server is the ""source of truth"", when Player 1 hits A, their local game does not register an A press, it sends that info to the server, and the server responds to all players with data on when to register an A press for player 1
Key inputs are not guaranteed to be received by the server (all data is transferred via UDP). This is to keep input latency low
The game will ""punish"" the player with a poor internet connection (they may experience higher input latency and missed input, but it won't affect the other players). I think this is an important principle in online gaming

The implementation was written in SDL_net, I haven't documented the all the packet formats, but I can do all that documentation work once there is a general consensus on the design
Responsibilities:

Core: sends and receives key inputs directly from the netplay server, keeps the game running in sync with other players
Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)
Netplay server: communicates with core and frontend to accomplish what was listed above

I'm sure I missed many details, please ask me any questions you'd like","Keep in mind, the way I've written this is very client -> server oriented, with the idea that the server would be running somewhere on the Internet.
If a player is running the server locally, you are correct that they will probably have fairly significant difference in input latency, but that difference is reduced quite a bit when all players are connected to an Internet hosted server that is in roughly the same region as the players",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,753,2020-04-26T00:15:37Z,2020-06-28T17:40:35Z,2021-06-20T20:45:44Z,MERGED,True,1173,50,19,https://github.com/loganmc10,Netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/753,https://github.com/Narann,11,https://github.com/mupen64plus/mupen64plus-core/pull/753#issuecomment-629360045,"For starters, you can see a demo here:
https://www.youtube.com/watch?v=bkW_SbxdsUo
Here is the code for the server I wrote, the intention is that the netplay server wouldn't be part of the mupen64plus project, but anyone could write one based on the spec:
https://github.com/loganmc10/m64p-netplay-server
Here are the changes I had to make to mupen64plus-gui:
https://github.com/m64p/mupen64plus-gui/tree/netplay
I am submitting this in a WIP state in the hopes that I can get comments on the API and code, and any other philosophical discussions about netplay that need to happen. I am on Discord (https://discord.gg/8XRuJ4F) in the #emu_mupen channel as well, which might be a better place for longer back and forth discussion.
Some principles of this design:

The server is the ""source of truth"", when Player 1 hits A, their local game does not register an A press, it sends that info to the server, and the server responds to all players with data on when to register an A press for player 1
Key inputs are not guaranteed to be received by the server (all data is transferred via UDP). This is to keep input latency low
The game will ""punish"" the player with a poor internet connection (they may experience higher input latency and missed input, but it won't affect the other players). I think this is an important principle in online gaming

The implementation was written in SDL_net, I haven't documented the all the packet formats, but I can do all that documentation work once there is a general consensus on the design
Responsibilities:

Core: sends and receives key inputs directly from the netplay server, keeps the game running in sync with other players
Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)
Netplay server: communicates with core and frontend to accomplish what was listed above

I'm sure I missed many details, please ask me any questions you'd like","Of course, my suggestion was only for ""local server"" that I thought it would be the most common use case, but maybe I'm just wrong.
EDIT: AppVeyor fail because missing files:
frontend.obj : error LNK2001: unresolved external symbol _netplay_start [C:\projects\mupen64plus-core\projects\msvc\mupen64plus-core.vcxproj]
frontend.obj : error LNK2001: unresolved external symbol _netplay_register_player [C:\projects\mupen64plus-core\projects\msvc\mupen64plus-core.vcxproj]
frontend.obj : error LNK2001: unresolved external symbol _netplay_set_controller [C:\projects\mupen64plus-core\projects\msvc\mupen64plus-core.vcxproj]
frontend.obj : error LNK2001: unresolved external symbol _netplay_stop [C:\projects\mupen64plus-core\projects\msvc\mupen64plus-core.vcxproj]
input_plugin_compat.obj : error LNK2001: unresolved external symbol _netplay_get_controller [C:\projects\mupen64plus-core\projects\msvc\mupen64plus-core.vcxproj]
input_plugin_compat.obj : error LNK2001: unresolved external symbol _netplay_lag [C:\projects\mupen64plus-core\projects\msvc\mupen64plus-core.vcxproj]
input_plugin_compat.obj : error LNK2001: unresolved external symbol _netplay_send_input [C:\projects\mupen64plus-core\projects\msvc\mupen64plus-core.vcxproj]
input_plugin_compat.obj : error LNK2001: unresolved external symbol _netplay_get_input [C:\projects\mupen64plus-core\projects\msvc\mupen64plus-core.vcxproj]
input_plugin_compat.obj : error LNK2001: unresolved external symbol _netplay_is_init [C:\projects\mupen64plus-core\projects\msvc\mupen64plus-core.vcxproj]
file_storage.obj : error LNK2001: unresolved external symbol _netplay_read_storage [C:\projects\mupen64plus-core\projects\msvc\mupen64plus-core.vcxproj]
main.obj : error LNK2001: unresolved external symbol _netplay_sync_settings [C:\projects\mupen64plus-core\projects\msvc\mupen64plus-core.vcxproj]
vi_controller.obj : error LNK2001: unresolved external symbol _netplay_check_sync [C:\projects\mupen64plus-core\projects\msvc\mupen64plus-core.vcxproj]
C:\projects\mupen64plus-core\projects\msvc\Win32\New_Dynarec_Release\mupen64plus.dll : fatal error LNK1120: 12 unresolved externals [C:\projects\mupen64plus-core\projects\msvc\mupen64plus-core.vcxproj]

Any hope to get the vcxproj file fixed?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,753,2020-04-26T00:15:37Z,2020-06-28T17:40:35Z,2021-06-20T20:45:44Z,MERGED,True,1173,50,19,https://github.com/loganmc10,Netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/753,https://github.com/loganmc10,12,https://github.com/mupen64plus/mupen64plus-core/pull/753#issuecomment-629423692,"For starters, you can see a demo here:
https://www.youtube.com/watch?v=bkW_SbxdsUo
Here is the code for the server I wrote, the intention is that the netplay server wouldn't be part of the mupen64plus project, but anyone could write one based on the spec:
https://github.com/loganmc10/m64p-netplay-server
Here are the changes I had to make to mupen64plus-gui:
https://github.com/m64p/mupen64plus-gui/tree/netplay
I am submitting this in a WIP state in the hopes that I can get comments on the API and code, and any other philosophical discussions about netplay that need to happen. I am on Discord (https://discord.gg/8XRuJ4F) in the #emu_mupen channel as well, which might be a better place for longer back and forth discussion.
Some principles of this design:

The server is the ""source of truth"", when Player 1 hits A, their local game does not register an A press, it sends that info to the server, and the server responds to all players with data on when to register an A press for player 1
Key inputs are not guaranteed to be received by the server (all data is transferred via UDP). This is to keep input latency low
The game will ""punish"" the player with a poor internet connection (they may experience higher input latency and missed input, but it won't affect the other players). I think this is an important principle in online gaming

The implementation was written in SDL_net, I haven't documented the all the packet formats, but I can do all that documentation work once there is a general consensus on the design
Responsibilities:

Core: sends and receives key inputs directly from the netplay server, keeps the game running in sync with other players
Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)
Netplay server: communicates with core and frontend to accomplish what was listed above

I'm sure I missed many details, please ask me any questions you'd like","Of course, my suggestion was only for ""local server"" that I thought it would be the most common use case, but maybe I'm just wrong.

No I'm sure it's valid, I guess what I would say is that the server implementation I'm writing at https://github.com/loganmc10/m64p-netplay-server is meant to be hosted on the Internet. Anyone else could write their own implementation, or integrate one into ui-console, and the API in the core should allow the server to delay players as required.

Any hope to get the vcxproj file fixed?

Yes for sure, the first step would be to add SDL2_net to win32-deps, are you able to merge this PR:
mupen64plus/mupen64plus-win32-deps#11",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,753,2020-04-26T00:15:37Z,2020-06-28T17:40:35Z,2021-06-20T20:45:44Z,MERGED,True,1173,50,19,https://github.com/loganmc10,Netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/753,https://github.com/Narann,13,https://github.com/mupen64plus/mupen64plus-core/pull/753#issuecomment-629623796,"For starters, you can see a demo here:
https://www.youtube.com/watch?v=bkW_SbxdsUo
Here is the code for the server I wrote, the intention is that the netplay server wouldn't be part of the mupen64plus project, but anyone could write one based on the spec:
https://github.com/loganmc10/m64p-netplay-server
Here are the changes I had to make to mupen64plus-gui:
https://github.com/m64p/mupen64plus-gui/tree/netplay
I am submitting this in a WIP state in the hopes that I can get comments on the API and code, and any other philosophical discussions about netplay that need to happen. I am on Discord (https://discord.gg/8XRuJ4F) in the #emu_mupen channel as well, which might be a better place for longer back and forth discussion.
Some principles of this design:

The server is the ""source of truth"", when Player 1 hits A, their local game does not register an A press, it sends that info to the server, and the server responds to all players with data on when to register an A press for player 1
Key inputs are not guaranteed to be received by the server (all data is transferred via UDP). This is to keep input latency low
The game will ""punish"" the player with a poor internet connection (they may experience higher input latency and missed input, but it won't affect the other players). I think this is an important principle in online gaming

The implementation was written in SDL_net, I haven't documented the all the packet formats, but I can do all that documentation work once there is a general consensus on the design
Responsibilities:

Core: sends and receives key inputs directly from the netplay server, keeps the game running in sync with other players
Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)
Netplay server: communicates with core and frontend to accomplish what was listed above

I'm sure I missed many details, please ask me any questions you'd like","I rebuild on AppVeyor and MSVC raises some errors:
..\..\src\main\netplay.c(372): error C2057: expected constant expression [C:\projects\mupen64plus-core\projects\msvc\mupen64plus-core.vcxproj]
..\..\src\main\netplay.c(372): error C2466: cannot allocate an array of constant size 0 [C:\projects\mupen64plus-core\projects\msvc\mupen64plus-core.vcxproj]
..\..\src\main\netplay.c(372): error C2133: 'output_data': unknown size [C:\projects\mupen64plus-core\projects\msvc\mupen64plus-core.vcxproj]
..\..\src\main\netplay.c(406): warning C4018: '<': signed/unsigned mismatch [C:\projects\mupen64plus-core\projects\msvc\mupen64plus-core.vcxproj]
..\..\src\main\netplay.c(407): error C2036: 'void *': unknown size [C:\projects\mupen64plus-core\projects\msvc\mupen64plus-core.vcxproj]
..\..\src\main\netplay.c(409): error C2057: expected constant expression [C:\projects\mupen64plus-core\projects\msvc\mupen64plus-core.vcxproj]
..\..\src\main\netplay.c(409): error C2466: cannot allocate an array of constant size 0 [C:\projects\mupen64plus-core\projects\msvc\mupen64plus-core.vcxproj]
..\..\src\main\netplay.c(409): error C2133: 'temp': unknown size [C:\projects\mupen64plus-core\projects\msvc\mupen64plus-core.vcxproj]",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,753,2020-04-26T00:15:37Z,2020-06-28T17:40:35Z,2021-06-20T20:45:44Z,MERGED,True,1173,50,19,https://github.com/loganmc10,Netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/753,https://github.com/loganmc10,14,https://github.com/mupen64plus/mupen64plus-core/pull/753#issuecomment-629860181,"For starters, you can see a demo here:
https://www.youtube.com/watch?v=bkW_SbxdsUo
Here is the code for the server I wrote, the intention is that the netplay server wouldn't be part of the mupen64plus project, but anyone could write one based on the spec:
https://github.com/loganmc10/m64p-netplay-server
Here are the changes I had to make to mupen64plus-gui:
https://github.com/m64p/mupen64plus-gui/tree/netplay
I am submitting this in a WIP state in the hopes that I can get comments on the API and code, and any other philosophical discussions about netplay that need to happen. I am on Discord (https://discord.gg/8XRuJ4F) in the #emu_mupen channel as well, which might be a better place for longer back and forth discussion.
Some principles of this design:

The server is the ""source of truth"", when Player 1 hits A, their local game does not register an A press, it sends that info to the server, and the server responds to all players with data on when to register an A press for player 1
Key inputs are not guaranteed to be received by the server (all data is transferred via UDP). This is to keep input latency low
The game will ""punish"" the player with a poor internet connection (they may experience higher input latency and missed input, but it won't affect the other players). I think this is an important principle in online gaming

The implementation was written in SDL_net, I haven't documented the all the packet formats, but I can do all that documentation work once there is a general consensus on the design
Responsibilities:

Core: sends and receives key inputs directly from the netplay server, keeps the game running in sync with other players
Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)
Netplay server: communicates with core and frontend to accomplish what was listed above

I'm sure I missed many details, please ask me any questions you'd like",Alright AppVeyor build is all fixed up :),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,753,2020-04-26T00:15:37Z,2020-06-28T17:40:35Z,2021-06-20T20:45:44Z,MERGED,True,1173,50,19,https://github.com/loganmc10,Netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/753,https://github.com/Narann,15,https://github.com/mupen64plus/mupen64plus-core/pull/753#issuecomment-630045593,"For starters, you can see a demo here:
https://www.youtube.com/watch?v=bkW_SbxdsUo
Here is the code for the server I wrote, the intention is that the netplay server wouldn't be part of the mupen64plus project, but anyone could write one based on the spec:
https://github.com/loganmc10/m64p-netplay-server
Here are the changes I had to make to mupen64plus-gui:
https://github.com/m64p/mupen64plus-gui/tree/netplay
I am submitting this in a WIP state in the hopes that I can get comments on the API and code, and any other philosophical discussions about netplay that need to happen. I am on Discord (https://discord.gg/8XRuJ4F) in the #emu_mupen channel as well, which might be a better place for longer back and forth discussion.
Some principles of this design:

The server is the ""source of truth"", when Player 1 hits A, their local game does not register an A press, it sends that info to the server, and the server responds to all players with data on when to register an A press for player 1
Key inputs are not guaranteed to be received by the server (all data is transferred via UDP). This is to keep input latency low
The game will ""punish"" the player with a poor internet connection (they may experience higher input latency and missed input, but it won't affect the other players). I think this is an important principle in online gaming

The implementation was written in SDL_net, I haven't documented the all the packet formats, but I can do all that documentation work once there is a general consensus on the design
Responsibilities:

Core: sends and receives key inputs directly from the netplay server, keeps the game running in sync with other players
Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)
Netplay server: communicates with core and frontend to accomplish what was listed above

I'm sure I missed many details, please ask me any questions you'd like","Thanks. I think we should use #define constants instead of magic numbers (for l_status member).
The other discussion would be: If we merge this, We should put the server repo under the mupen64plus organization. Should I open a dedicated issue on this repo to talk about it?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,753,2020-04-26T00:15:37Z,2020-06-28T17:40:35Z,2021-06-20T20:45:44Z,MERGED,True,1173,50,19,https://github.com/loganmc10,Netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/753,https://github.com/loganmc10,16,https://github.com/mupen64plus/mupen64plus-core/pull/753#issuecomment-630155949,"For starters, you can see a demo here:
https://www.youtube.com/watch?v=bkW_SbxdsUo
Here is the code for the server I wrote, the intention is that the netplay server wouldn't be part of the mupen64plus project, but anyone could write one based on the spec:
https://github.com/loganmc10/m64p-netplay-server
Here are the changes I had to make to mupen64plus-gui:
https://github.com/m64p/mupen64plus-gui/tree/netplay
I am submitting this in a WIP state in the hopes that I can get comments on the API and code, and any other philosophical discussions about netplay that need to happen. I am on Discord (https://discord.gg/8XRuJ4F) in the #emu_mupen channel as well, which might be a better place for longer back and forth discussion.
Some principles of this design:

The server is the ""source of truth"", when Player 1 hits A, their local game does not register an A press, it sends that info to the server, and the server responds to all players with data on when to register an A press for player 1
Key inputs are not guaranteed to be received by the server (all data is transferred via UDP). This is to keep input latency low
The game will ""punish"" the player with a poor internet connection (they may experience higher input latency and missed input, but it won't affect the other players). I think this is an important principle in online gaming

The implementation was written in SDL_net, I haven't documented the all the packet formats, but I can do all that documentation work once there is a general consensus on the design
Responsibilities:

Core: sends and receives key inputs directly from the netplay server, keeps the game running in sync with other players
Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)
Netplay server: communicates with core and frontend to accomplish what was listed above

I'm sure I missed many details, please ask me any questions you'd like","Yes my last step will be documentation and cleaning up the code (including defining the magic constants).
The server is written in Qt, and is designed to interact with https://github.com/m64p/mupen64plus-gui, which is also not part of mainstream mupen64plus. All the match making/lobby code is specific to that frontend. I think a proper ""upstream"" server would be written in C and designed to work with ui-console, it may be a bit simpler than the server I wrote.
Anyway I don't know if the server would really fit as an upstream project, but I'll definitely spend a good bit of time on documentation so if someone else wanted to write another server it wouldn't be too difficult",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,753,2020-04-26T00:15:37Z,2020-06-28T17:40:35Z,2021-06-20T20:45:44Z,MERGED,True,1173,50,19,https://github.com/loganmc10,Netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/753,https://github.com/loganmc10,17,https://github.com/mupen64plus/mupen64plus-core/pull/753#issuecomment-631819904,"For starters, you can see a demo here:
https://www.youtube.com/watch?v=bkW_SbxdsUo
Here is the code for the server I wrote, the intention is that the netplay server wouldn't be part of the mupen64plus project, but anyone could write one based on the spec:
https://github.com/loganmc10/m64p-netplay-server
Here are the changes I had to make to mupen64plus-gui:
https://github.com/m64p/mupen64plus-gui/tree/netplay
I am submitting this in a WIP state in the hopes that I can get comments on the API and code, and any other philosophical discussions about netplay that need to happen. I am on Discord (https://discord.gg/8XRuJ4F) in the #emu_mupen channel as well, which might be a better place for longer back and forth discussion.
Some principles of this design:

The server is the ""source of truth"", when Player 1 hits A, their local game does not register an A press, it sends that info to the server, and the server responds to all players with data on when to register an A press for player 1
Key inputs are not guaranteed to be received by the server (all data is transferred via UDP). This is to keep input latency low
The game will ""punish"" the player with a poor internet connection (they may experience higher input latency and missed input, but it won't affect the other players). I think this is an important principle in online gaming

The implementation was written in SDL_net, I haven't documented the all the packet formats, but I can do all that documentation work once there is a general consensus on the design
Responsibilities:

Core: sends and receives key inputs directly from the netplay server, keeps the game running in sync with other players
Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)
Netplay server: communicates with core and frontend to accomplish what was listed above

I'm sure I missed many details, please ask me any questions you'd like","It's getting to be fairly fully featured now, a reminder you can download it here:
https://github.com/loganmc10/m64p/releases
Some cool features it now supports: save syncing, core settings syncing, and raw input (Raphnet) support",True,"{'THUMBS_UP': ['https://github.com/Mastergatto', 'https://github.com/sodomon2']}"
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,753,2020-04-26T00:15:37Z,2020-06-28T17:40:35Z,2021-06-20T20:45:44Z,MERGED,True,1173,50,19,https://github.com/loganmc10,Netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/753,https://github.com/loganmc10,18,https://github.com/mupen64plus/mupen64plus-core/pull/753#issuecomment-632982971,"For starters, you can see a demo here:
https://www.youtube.com/watch?v=bkW_SbxdsUo
Here is the code for the server I wrote, the intention is that the netplay server wouldn't be part of the mupen64plus project, but anyone could write one based on the spec:
https://github.com/loganmc10/m64p-netplay-server
Here are the changes I had to make to mupen64plus-gui:
https://github.com/m64p/mupen64plus-gui/tree/netplay
I am submitting this in a WIP state in the hopes that I can get comments on the API and code, and any other philosophical discussions about netplay that need to happen. I am on Discord (https://discord.gg/8XRuJ4F) in the #emu_mupen channel as well, which might be a better place for longer back and forth discussion.
Some principles of this design:

The server is the ""source of truth"", when Player 1 hits A, their local game does not register an A press, it sends that info to the server, and the server responds to all players with data on when to register an A press for player 1
Key inputs are not guaranteed to be received by the server (all data is transferred via UDP). This is to keep input latency low
The game will ""punish"" the player with a poor internet connection (they may experience higher input latency and missed input, but it won't affect the other players). I think this is an important principle in online gaming

The implementation was written in SDL_net, I haven't documented the all the packet formats, but I can do all that documentation work once there is a general consensus on the design
Responsibilities:

Core: sends and receives key inputs directly from the netplay server, keeps the game running in sync with other players
Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)
Netplay server: communicates with core and frontend to accomplish what was listed above

I'm sure I missed many details, please ask me any questions you'd like","I've added comments in the code, and some documentation. I've been testing with a few people and the results have been quite promising. I think this is ready to start being considered for merging",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,753,2020-04-26T00:15:37Z,2020-06-28T17:40:35Z,2021-06-20T20:45:44Z,MERGED,True,1173,50,19,https://github.com/loganmc10,Netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/753,https://github.com/loganmc10,19,https://github.com/mupen64plus/mupen64plus-core/pull/753#issuecomment-633056038,"For starters, you can see a demo here:
https://www.youtube.com/watch?v=bkW_SbxdsUo
Here is the code for the server I wrote, the intention is that the netplay server wouldn't be part of the mupen64plus project, but anyone could write one based on the spec:
https://github.com/loganmc10/m64p-netplay-server
Here are the changes I had to make to mupen64plus-gui:
https://github.com/m64p/mupen64plus-gui/tree/netplay
I am submitting this in a WIP state in the hopes that I can get comments on the API and code, and any other philosophical discussions about netplay that need to happen. I am on Discord (https://discord.gg/8XRuJ4F) in the #emu_mupen channel as well, which might be a better place for longer back and forth discussion.
Some principles of this design:

The server is the ""source of truth"", when Player 1 hits A, their local game does not register an A press, it sends that info to the server, and the server responds to all players with data on when to register an A press for player 1
Key inputs are not guaranteed to be received by the server (all data is transferred via UDP). This is to keep input latency low
The game will ""punish"" the player with a poor internet connection (they may experience higher input latency and missed input, but it won't affect the other players). I think this is an important principle in online gaming

The implementation was written in SDL_net, I haven't documented the all the packet formats, but I can do all that documentation work once there is a general consensus on the design
Responsibilities:

Core: sends and receives key inputs directly from the netplay server, keeps the game running in sync with other players
Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)
Netplay server: communicates with core and frontend to accomplish what was listed above

I'm sure I missed many details, please ask me any questions you'd like","Yes good feedback, I've made those changes. I also made it so building with netplay is optional (enabled with NETPLAY=1), since I know the SDL2_net dependency would be a pain for some downstream projects",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,753,2020-04-26T00:15:37Z,2020-06-28T17:40:35Z,2021-06-20T20:45:44Z,MERGED,True,1173,50,19,https://github.com/loganmc10,Netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/753,https://github.com/Narann,20,https://github.com/mupen64plus/mupen64plus-core/pull/753#issuecomment-633074360,"For starters, you can see a demo here:
https://www.youtube.com/watch?v=bkW_SbxdsUo
Here is the code for the server I wrote, the intention is that the netplay server wouldn't be part of the mupen64plus project, but anyone could write one based on the spec:
https://github.com/loganmc10/m64p-netplay-server
Here are the changes I had to make to mupen64plus-gui:
https://github.com/m64p/mupen64plus-gui/tree/netplay
I am submitting this in a WIP state in the hopes that I can get comments on the API and code, and any other philosophical discussions about netplay that need to happen. I am on Discord (https://discord.gg/8XRuJ4F) in the #emu_mupen channel as well, which might be a better place for longer back and forth discussion.
Some principles of this design:

The server is the ""source of truth"", when Player 1 hits A, their local game does not register an A press, it sends that info to the server, and the server responds to all players with data on when to register an A press for player 1
Key inputs are not guaranteed to be received by the server (all data is transferred via UDP). This is to keep input latency low
The game will ""punish"" the player with a poor internet connection (they may experience higher input latency and missed input, but it won't affect the other players). I think this is an important principle in online gaming

The implementation was written in SDL_net, I haven't documented the all the packet formats, but I can do all that documentation work once there is a general consensus on the design
Responsibilities:

Core: sends and receives key inputs directly from the netplay server, keeps the game running in sync with other players
Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)
Netplay server: communicates with core and frontend to accomplish what was listed above

I'm sure I missed many details, please ask me any questions you'd like","I thinks it's nice. I wonder if packet sizes everywhere shouldn't use constants. Like char output_data[PACKET_SIZE_PLAYER_OUTPUT]. I've identified three or four of those size numbers in the code.
Buffer sizes are always sensitive variables that could benefit to be write once with a unique meaning.
For the rest, it looks OK to me.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,753,2020-04-26T00:15:37Z,2020-06-28T17:40:35Z,2021-06-20T20:45:44Z,MERGED,True,1173,50,19,https://github.com/loganmc10,Netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/753,https://github.com/loganmc10,21,https://github.com/mupen64plus/mupen64plus-core/pull/753#issuecomment-633088939,"For starters, you can see a demo here:
https://www.youtube.com/watch?v=bkW_SbxdsUo
Here is the code for the server I wrote, the intention is that the netplay server wouldn't be part of the mupen64plus project, but anyone could write one based on the spec:
https://github.com/loganmc10/m64p-netplay-server
Here are the changes I had to make to mupen64plus-gui:
https://github.com/m64p/mupen64plus-gui/tree/netplay
I am submitting this in a WIP state in the hopes that I can get comments on the API and code, and any other philosophical discussions about netplay that need to happen. I am on Discord (https://discord.gg/8XRuJ4F) in the #emu_mupen channel as well, which might be a better place for longer back and forth discussion.
Some principles of this design:

The server is the ""source of truth"", when Player 1 hits A, their local game does not register an A press, it sends that info to the server, and the server responds to all players with data on when to register an A press for player 1
Key inputs are not guaranteed to be received by the server (all data is transferred via UDP). This is to keep input latency low
The game will ""punish"" the player with a poor internet connection (they may experience higher input latency and missed input, but it won't affect the other players). I think this is an important principle in online gaming

The implementation was written in SDL_net, I haven't documented the all the packet formats, but I can do all that documentation work once there is a general consensus on the design
Responsibilities:

Core: sends and receives key inputs directly from the netplay server, keeps the game running in sync with other players
Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)
Netplay server: communicates with core and frontend to accomplish what was listed above

I'm sure I missed many details, please ask me any questions you'd like","I think the sizes are probably OK as is? I did write this document as well: https://github.com/mupen64plus/mupen64plus-core/blob/3d6a823082892aaf54230a8248c938fe5ef9af9b/doc/emuwiki-api-doc/Mupen64Plus-v2.0-Netplay-API.mediawiki
Which explains each packet, it's size, and what each byte is for",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,753,2020-04-26T00:15:37Z,2020-06-28T17:40:35Z,2021-06-20T20:45:44Z,MERGED,True,1173,50,19,https://github.com/loganmc10,Netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/753,https://github.com/Narann,22,https://github.com/mupen64plus/mupen64plus-core/pull/753#issuecomment-633134960,"For starters, you can see a demo here:
https://www.youtube.com/watch?v=bkW_SbxdsUo
Here is the code for the server I wrote, the intention is that the netplay server wouldn't be part of the mupen64plus project, but anyone could write one based on the spec:
https://github.com/loganmc10/m64p-netplay-server
Here are the changes I had to make to mupen64plus-gui:
https://github.com/m64p/mupen64plus-gui/tree/netplay
I am submitting this in a WIP state in the hopes that I can get comments on the API and code, and any other philosophical discussions about netplay that need to happen. I am on Discord (https://discord.gg/8XRuJ4F) in the #emu_mupen channel as well, which might be a better place for longer back and forth discussion.
Some principles of this design:

The server is the ""source of truth"", when Player 1 hits A, their local game does not register an A press, it sends that info to the server, and the server responds to all players with data on when to register an A press for player 1
Key inputs are not guaranteed to be received by the server (all data is transferred via UDP). This is to keep input latency low
The game will ""punish"" the player with a poor internet connection (they may experience higher input latency and missed input, but it won't affect the other players). I think this is an important principle in online gaming

The implementation was written in SDL_net, I haven't documented the all the packet formats, but I can do all that documentation work once there is a general consensus on the design
Responsibilities:

Core: sends and receives key inputs directly from the netplay server, keeps the game running in sync with other players
Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)
Netplay server: communicates with core and frontend to accomplish what was listed above

I'm sure I missed many details, please ask me any questions you'd like",@richard42 any idea?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,753,2020-04-26T00:15:37Z,2020-06-28T17:40:35Z,2021-06-20T20:45:44Z,MERGED,True,1173,50,19,https://github.com/loganmc10,Netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/753,https://github.com/richard42,23,https://github.com/mupen64plus/mupen64plus-core/pull/753#issuecomment-633185481,"For starters, you can see a demo here:
https://www.youtube.com/watch?v=bkW_SbxdsUo
Here is the code for the server I wrote, the intention is that the netplay server wouldn't be part of the mupen64plus project, but anyone could write one based on the spec:
https://github.com/loganmc10/m64p-netplay-server
Here are the changes I had to make to mupen64plus-gui:
https://github.com/m64p/mupen64plus-gui/tree/netplay
I am submitting this in a WIP state in the hopes that I can get comments on the API and code, and any other philosophical discussions about netplay that need to happen. I am on Discord (https://discord.gg/8XRuJ4F) in the #emu_mupen channel as well, which might be a better place for longer back and forth discussion.
Some principles of this design:

The server is the ""source of truth"", when Player 1 hits A, their local game does not register an A press, it sends that info to the server, and the server responds to all players with data on when to register an A press for player 1
Key inputs are not guaranteed to be received by the server (all data is transferred via UDP). This is to keep input latency low
The game will ""punish"" the player with a poor internet connection (they may experience higher input latency and missed input, but it won't affect the other players). I think this is an important principle in online gaming

The implementation was written in SDL_net, I haven't documented the all the packet formats, but I can do all that documentation work once there is a general consensus on the design
Responsibilities:

Core: sends and receives key inputs directly from the netplay server, keeps the game running in sync with other players
Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)
Netplay server: communicates with core and frontend to accomplish what was listed above

I'm sure I missed many details, please ask me any questions you'd like","I haven't really looked over the code super closely but I've been following the conversation and seeing the updates. I see that you're using a NETPLAY_API version number instead of relying on the git repo commit GUID. That's good, as we discussed previously. Going forward we will need to remember to bump that version number whenever anything with the core changes.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,753,2020-04-26T00:15:37Z,2020-06-28T17:40:35Z,2021-06-20T20:45:44Z,MERGED,True,1173,50,19,https://github.com/loganmc10,Netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/753,https://github.com/loganmc10,24,https://github.com/mupen64plus/mupen64plus-core/pull/753#issuecomment-636361622,"For starters, you can see a demo here:
https://www.youtube.com/watch?v=bkW_SbxdsUo
Here is the code for the server I wrote, the intention is that the netplay server wouldn't be part of the mupen64plus project, but anyone could write one based on the spec:
https://github.com/loganmc10/m64p-netplay-server
Here are the changes I had to make to mupen64plus-gui:
https://github.com/m64p/mupen64plus-gui/tree/netplay
I am submitting this in a WIP state in the hopes that I can get comments on the API and code, and any other philosophical discussions about netplay that need to happen. I am on Discord (https://discord.gg/8XRuJ4F) in the #emu_mupen channel as well, which might be a better place for longer back and forth discussion.
Some principles of this design:

The server is the ""source of truth"", when Player 1 hits A, their local game does not register an A press, it sends that info to the server, and the server responds to all players with data on when to register an A press for player 1
Key inputs are not guaranteed to be received by the server (all data is transferred via UDP). This is to keep input latency low
The game will ""punish"" the player with a poor internet connection (they may experience higher input latency and missed input, but it won't affect the other players). I think this is an important principle in online gaming

The implementation was written in SDL_net, I haven't documented the all the packet formats, but I can do all that documentation work once there is a general consensus on the design
Responsibilities:

Core: sends and receives key inputs directly from the netplay server, keeps the game running in sync with other players
Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)
Netplay server: communicates with core and frontend to accomplish what was listed above

I'm sure I missed many details, please ask me any questions you'd like","I just pushed the last change I was planning. From the testing I've seen and participated in, it seems to be working very well. I don't plan on making any further modifications, I think it is stable enough to be merged if everyone is happy with the code",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,753,2020-04-26T00:15:37Z,2020-06-28T17:40:35Z,2021-06-20T20:45:44Z,MERGED,True,1173,50,19,https://github.com/loganmc10,Netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/753,https://github.com/richard42,25,https://github.com/mupen64plus/mupen64plus-core/pull/753#issuecomment-650649352,"For starters, you can see a demo here:
https://www.youtube.com/watch?v=bkW_SbxdsUo
Here is the code for the server I wrote, the intention is that the netplay server wouldn't be part of the mupen64plus project, but anyone could write one based on the spec:
https://github.com/loganmc10/m64p-netplay-server
Here are the changes I had to make to mupen64plus-gui:
https://github.com/m64p/mupen64plus-gui/tree/netplay
I am submitting this in a WIP state in the hopes that I can get comments on the API and code, and any other philosophical discussions about netplay that need to happen. I am on Discord (https://discord.gg/8XRuJ4F) in the #emu_mupen channel as well, which might be a better place for longer back and forth discussion.
Some principles of this design:

The server is the ""source of truth"", when Player 1 hits A, their local game does not register an A press, it sends that info to the server, and the server responds to all players with data on when to register an A press for player 1
Key inputs are not guaranteed to be received by the server (all data is transferred via UDP). This is to keep input latency low
The game will ""punish"" the player with a poor internet connection (they may experience higher input latency and missed input, but it won't affect the other players). I think this is an important principle in online gaming

The implementation was written in SDL_net, I haven't documented the all the packet formats, but I can do all that documentation work once there is a general consensus on the design
Responsibilities:

Core: sends and receives key inputs directly from the netplay server, keeps the game running in sync with other players
Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)
Netplay server: communicates with core and frontend to accomplish what was listed above

I'm sure I missed many details, please ask me any questions you'd like","Okay @loganmc10 it looks pretty good.  If you can add documentation for the network protocol, then we'll merge it.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,753,2020-04-26T00:15:37Z,2020-06-28T17:40:35Z,2021-06-20T20:45:44Z,MERGED,True,1173,50,19,https://github.com/loganmc10,Netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/753,https://github.com/loganmc10,26,https://github.com/mupen64plus/mupen64plus-core/pull/753#issuecomment-650680215,"For starters, you can see a demo here:
https://www.youtube.com/watch?v=bkW_SbxdsUo
Here is the code for the server I wrote, the intention is that the netplay server wouldn't be part of the mupen64plus project, but anyone could write one based on the spec:
https://github.com/loganmc10/m64p-netplay-server
Here are the changes I had to make to mupen64plus-gui:
https://github.com/m64p/mupen64plus-gui/tree/netplay
I am submitting this in a WIP state in the hopes that I can get comments on the API and code, and any other philosophical discussions about netplay that need to happen. I am on Discord (https://discord.gg/8XRuJ4F) in the #emu_mupen channel as well, which might be a better place for longer back and forth discussion.
Some principles of this design:

The server is the ""source of truth"", when Player 1 hits A, their local game does not register an A press, it sends that info to the server, and the server responds to all players with data on when to register an A press for player 1
Key inputs are not guaranteed to be received by the server (all data is transferred via UDP). This is to keep input latency low
The game will ""punish"" the player with a poor internet connection (they may experience higher input latency and missed input, but it won't affect the other players). I think this is an important principle in online gaming

The implementation was written in SDL_net, I haven't documented the all the packet formats, but I can do all that documentation work once there is a general consensus on the design
Responsibilities:

Core: sends and receives key inputs directly from the netplay server, keeps the game running in sync with other players
Frontend: ensures that each player is running the same plugins/versions/settings via communication with the netplay server (I have not implemented this yet)
Netplay server: communicates with core and frontend to accomplish what was listed above

I'm sure I missed many details, please ask me any questions you'd like","@richard42 I think that is already done, unless I misunderstand what you're asking for, the packet formats are documented here:
https://github.com/loganmc10/mupen64plus-core/blob/netplay2/doc/emuwiki-api-doc/Mupen64Plus-v2.0-Netplay-API.mediawiki",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,756,2020-05-22T02:54:50Z,2020-05-22T19:12:28Z,2021-06-20T20:46:46Z,MERGED,True,7,4,1,https://github.com/loganmc10,NOT mempak checksum when pak is not present,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/756,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/756,"I was troubleshooting an issue with netplay raw input, and came across this discrepancy in the way mempak CRCs are calculated.
From http://hcs64.com/files/n64-hw.dox

when something is not plugged into the
mempack port, then the CRC is calculated the same way except the final
8-bit result is NOT'd. You might wonder why there would even be a CRC
when reading from the mempack port and nothing is plugged in.  Well
basically when nothing is plugged in, data is still read, but it is not
valid data. This data is usually all 0's. The data CRC algo is still
calculated but the result is of course NOT'd to let you know that the
data is erronous.

I have verified this behaviour against a ""raw"" controller using Raphnet's plugin","I was troubleshooting an issue with netplay raw input, and came across this discrepancy in the way mempak CRCs are calculated.
From http://hcs64.com/files/n64-hw.dox

when something is not plugged into the
mempack port, then the CRC is calculated the same way except the final
8-bit result is NOT'd. You might wonder why there would even be a CRC
when reading from the mempack port and nothing is plugged in.  Well
basically when nothing is plugged in, data is still read, but it is not
valid data. This data is usually all 0's. The data CRC algo is still
calculated but the result is of course NOT'd to let you know that the
data is erronous.

I have verified this behaviour against a ""raw"" controller using Raphnet's plugin",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,756,2020-05-22T02:54:50Z,2020-05-22T19:12:28Z,2021-06-20T20:46:46Z,MERGED,True,7,4,1,https://github.com/loganmc10,NOT mempak checksum when pak is not present,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/756,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/756#issuecomment-632866547,"I was troubleshooting an issue with netplay raw input, and came across this discrepancy in the way mempak CRCs are calculated.
From http://hcs64.com/files/n64-hw.dox

when something is not plugged into the
mempack port, then the CRC is calculated the same way except the final
8-bit result is NOT'd. You might wonder why there would even be a CRC
when reading from the mempack port and nothing is plugged in.  Well
basically when nothing is plugged in, data is still read, but it is not
valid data. This data is usually all 0's. The data CRC algo is still
calculated but the result is of course NOT'd to let you know that the
data is erronous.

I have verified this behaviour against a ""raw"" controller using Raphnet's plugin",Merged! Thanks!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,758,2020-05-23T17:16:31Z,2020-05-24T06:07:24Z,2020-05-24T06:07:24Z,MERGED,True,7,2,1,https://github.com/Henrik0x7F,Allow frontends to manage SDL's lifetime,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/758,https://github.com/Henrik0x7F,1,https://github.com/mupen64plus/mupen64plus-core/pull/758,"As already discussed at mupen64plus-input-sdl#91 it's currently not possible for the frontend to use SDL while Mupen64Plus is running. This is because CoreShutdown calls SDL_Quit resulting in segfaults if the frontend continues to call SDL functions.
SDL's documentation states that SDL_InitSubsystem() and SDL_QuitSubsystem() calls are reference counted (SDL_Init() is just an alias for SDL_InitSubsystem()). SDL_Quit() on the other hand does not care about the reference count and shuts everything down no matter what.
I added a check to CoreShutdown to only shutdown SDL if it wasn't already initialized at the time CoreStartup() was called. That way SDL cleanup is left to the frontend if it's using SDL. In any other case SDL is correctly shutdown by the core.","As already discussed at mupen64plus-input-sdl#91 it's currently not possible for the frontend to use SDL while Mupen64Plus is running. This is because CoreShutdown calls SDL_Quit resulting in segfaults if the frontend continues to call SDL functions.
SDL's documentation states that SDL_InitSubsystem() and SDL_QuitSubsystem() calls are reference counted (SDL_Init() is just an alias for SDL_InitSubsystem()). SDL_Quit() on the other hand does not care about the reference count and shuts everything down no matter what.
I added a check to CoreShutdown to only shutdown SDL if it wasn't already initialized at the time CoreStartup() was called. That way SDL cleanup is left to the frontend if it's using SDL. In any other case SDL is correctly shutdown by the core.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/LuigiBlood,1,https://github.com/mupen64plus/mupen64plus-core/pull/762,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup",True,"{'HEART': ['https://github.com/Mastergatto', 'https://github.com/Rosalie241', 'https://github.com/mkoterski']}"
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/LuigiBlood,2,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-644126141,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","It looks like Doshin The Giant 1 and expansion aren't working even without my changes.
Japan Pro Golf Tour 64 seems to work until gameplay where the problems are similar to when Project64 runs this game with Counter Factor = 2, which are the AI not really working well and controls responding sparingly.
Seems like 64DD games are still pushing mupen64plus quite a bit.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/LuigiBlood,3,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-644981856,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup",I now confirm there were changes in mupen64plus that completely broke some 64DD games.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/LuigiBlood,4,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-645028866,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","So the issue is timing, in which case CountPerOp=1 might be really imperative for games to work with 64DD.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/Narann,5,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-645221628,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","IIRC, @loganmc10 did the change, maybe he can review this part of the code.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/LuigiBlood,6,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-645289698,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","We already spoke about it on Discord. I've done some testing, and while / 50 is a good choice for F-Zero X, it's not for the rest of the games where it must be / 25 for some reason despite CountPerOp being 2 by default. It's honestly confusing timing at this point.
To fix F-Zero X Expansion Kit you need to add CountPerOp=1 to the settings of F-Zero X Japan and USA (since I made an english disk it might be worthwhile also).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-645295612,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup",Yeah I trust @LuigiBlood's judgement on this stuff,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/LuigiBlood,8,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-685173877,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","I have a question about this, is the code of this, so far, good?
I had done some serious changes, like how the disk file is not dependent on a format anymore, using code reverse engineered from libleo (the job was done before the gigaleak, easily verifiable in my 64dd repo), I did a change for file_storage.
My point is to make code that fits the project, because if it doesn't then I sorta wasted my time back then.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/LuigiBlood,9,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-735232318,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","@richard42 This is above all your project, I really want to finish this. I've done changes that may break some API stuff like file_storage because mupen64plus just isn't made for 64DD in mind.",True,"{'THUMBS_UP': ['https://github.com/Mastergatto', 'https://github.com/Rosalie241']}"
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/bsmiles32,10,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-735382724,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","Sorry it took so long to review your work.
I've made a PR (LuigiBlood#1) to your PR to change things that I felt necessary, most importantly I didn't really like the fact that you had to add the extra field to the storage_backend_interface.
The idea behind storage_backend_interface was to abstract storage accesses from emulation code. Emulation code should only care about reading/writing data like on normal hardware, not care about if I put data in memory, or into a file (or in a memory-mapped file). So adding ""format"" information at the storage_backend_interface felt wrong to me, that's why I've removed them from the interface and pass them as regular parameters to the dd_controller.
If you want we can go a little further and create a dd_disk struct to regroup all disk related stuff for instance:
struct dd_disk {
    void* storage;
    const struct storage_backend_interface* istorage;
    uint16_t lba_phys_table[0x10DC];
    uint8_t format;
    uint8_t development;
    size_t offset_sys;
    size_t offset_id;
};

This would maybe help readability.
In my PR I've also fixed some warnings (some pointer conversion, and printf formats).
What do you think ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/LuigiBlood,11,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-735383537,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","That's fine. I wanted to try my hand on doing what I've done for Project64 but I'm finally happy to finally have a response on my work. I'm satisfied with the pull request as it is :)
At this point what I need to deal with is the save process, because that's really a needed feature.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/LuigiBlood,12,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-735384227,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","We could make a dd_disk struct for clarity, yeah. (I forgot to answer about that.)
I need to get back to my toolchain on how to build this but I didn't see anything wrong so far.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/bsmiles32,13,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-735403168,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","@LuigiBlood Take a look at https://github.com/bsmiles32/mupen64plus-core/tree/diskupdate where I've reworked things to handle disk format differences through a specific backend. So you can access disk->format and other fileds inside the storage save method.
It has not been tested, but it should be good enough for now.",True,{'HEART': ['https://github.com/Mastergatto']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/LuigiBlood,14,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-735406850,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","That totally works for me.
What I intend to do after that when loading the save there are two formats:

*.ndr/*.d6r (basically a replacement file like you've supported, that said I like the *.save too...)
*.ram (only RAM Area content, SDK and D64 format only)

The first format I just basically try to load it instead of the main disk file (it is a bit weird but it works), and then the *.ram file I just load the file into the loaded disk file and replace the save data in it.
I would probably add a new configuration that says what format to save as overall.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/LuigiBlood,15,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-735423015,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup",It crashes upon loading and Visual Studio doesn't feel like loading the PDB file and I don't know why so I'm not sure where is the problem,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/bsmiles32,16,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-735435721,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","I've forced-pushed a fix to a crash I was having with my previous attempt.
I've tried to test with F-Zero (J) + DD disk and it gives loading errors I wasn't having before ?
Did you encountered such problems ?
edit: same branch (https://github.com/bsmiles32/mupen64plus-core/tree/diskupdate)
And typical error messages:
Core Error: Unknown DD dma read dram=0042e5f0  cart=05000580 length=00000040
Core Error: Unknown DD dma read dram=0042e5f0  cart=05000580 length=00000040
Core Error: Unknown DD dma read dram=0042e5f0  cart=05000580 length=00000040
Core Error: Unknown DD dma read dram=0042e5f0  cart=05000580 length=00000040
Core Warning: Sector size 208 set different than expected 232",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/bsmiles32,17,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-735437353,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","OK, seems like the issue with F-Zero is related to PI timings (I saw you changed cycles computation) and that's what makes F-Zero not load anymore. Other titles exhibit the same kind of warnings, but mostly run OK given the PI timing change.
Several monthes ago I was investigating the possibility of changing the way PI cycles are counted. I didn't succeed in obtaining accurate cycle counting, but at least it was a shot in the ""right"" direction. I'll try to gather what I had back then and publish some of that.
edit: Here is my incomplete WIP attempt at better PI timings:
https://github.com/bsmiles32/mupen64plus-core/tree/pi_timings",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/LuigiBlood,18,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-735437588,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","05000580 is the DD MSEQ RAM... it's pretty useless to emulate for the most part and could be ignored entirely
Sector size 208 set different than expected 232 maybe you used like a development disk in which case this kind of error may happen but it's normal
EDIT:
I'm fine getting rid of these useless warnings once 64DD is fully operational, about the PI timings, I dunno how to use Git properly so I probably will not try to test with this until the main code is done
EDIT2: Wait it's supposed to be Core Warning: Sector size 192 set different than expected 232 if it's a dev disk so that's indeed strange, maybe I moved this warning in a way that's not good
EDIT3: F-Zero X Expansion Kit works fine with CountPerOp=1, as I said before",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/LuigiBlood,19,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-736528594,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","Just to make sure it does actually notify: With the current code, F-Zero X Expansion Kit works fine if F-Zero X (J / U) have CountPerOp=1 in the database.
When it comes to the warnings like Sector size 208 set different than expected 232 I think those warnings are useless because I changed the way it manages sectors. I may have forgotten to move / delete those.
EDIT: I really want this to be stable soon. Feel free to do a pull request again to my repository.
I also want to deal with disk loading through the Open ROM but I think I'll do this through a seperate PR as it might change a lot of things and especially how we have to deal with the database to set up the emulator. This PR should focus on 64DD emulation itself.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/bsmiles32,20,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-736656247,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","OK I've made a PR on your PR so you can benefit from storage_backend rework.
Regarding F-Zero X, indeed, with CountPerOp=1 it loads fine. The thing is, DD games seems to be way more sensitive to timings and we know that that's not were mupen64plus shines... Anyway, the core issue here is that we need better PI and CPU timings. For PI timings, I have some preliminary work in the pi_timings branch, which is not perfect but should be better than what we currently have. For CPU timings, well, the CountPerOp Hack may or may not work and will always be error-prone, but for now that's all we have (and changing it would require massive effort especially with the dynarecs unfortunately).
For the sector size warnings, I'm not knowledgeable enough to tell if they're expected and/or useful. So I'll trust you on that.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/LuigiBlood,21,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-736710682,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","So it does not save yet but it can load disk save files depending on the added configuration of ""SaveDiskFormat"".
0 = Full Disk Copy (*.save), 1 = RAM Area Only (*.ram).
Tested on both NDD (SDK format) and D64 files. I admit to not really test much for MAME formats because it's genuinely not as practical.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/LuigiBlood,22,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-736735808,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","TODO: Saving support, refactor disk format stuff into disk.c",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/LuigiBlood,23,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-738162063,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","So there was a bit of a cleanup and refactoring that's nice.
Looking at the TODO list:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).

So the configuration exists, but the saving process is not.


Disk Seek Times

On Project64 I rely on really bad math and uses of timers to then issue a CART interrupt, I don't know how this could be managed on mupen64plus at the moment.


Disk Swapping

Requires API update for this? Can Media Loader have the ability to swap content?


Cleanup

That's being sorta done.



I may just add this question though:
About the ability to give information to plugins on what game is loaded...
To not break compatibility, in Project64, I've generated a N64 ROM header from the disk data and it takes priority from the N64 ROM (even if it's a combo load, so F-Zero X Expansion Kit disk info would be returned instead of F-Zero X ROM info).
Is it fine if I do exactly this?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/bsmiles32,24,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-738199568,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","Thanks for the summary and plan of action.
I think we should split your plan and try to merge stable bits as soon as they're stable.
For instance if you think this PR is stable enough, we should not wait too much to merge it.
This will allow to ease testing and reviewing (smaller PR are easier to handle).

Looking at the TODO list:
Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
    So the configuration exists, but the saving process is not.


What's missing here :

uncommenting the call to istorage->save in write_sector
implementing both saving options in the disk save method
?
Saving the full content of disk every time istorage->save is called (e.g. each time write_sector is called) is going to be problematic.
What we need is to extend the istorage->save method to also specify the offset/size of bytes to write. Can be something like :

void save(void* storage, unsigned int offset, size_t size)

Hopefully this should reduce the amount of data to write at write_sector.

Disk Seek Times
    On Project64 I rely on really bad math and uses of timers to then issue a CART interrupt, I don't know how this could be managed on mupen64plus at the moment.


Not really sure how to proceed here as I don't really know how it works at the hardware level. Does the drive emit a CART interrupt when the head has reached its target position ?
Will require more investigation.

Disk Swapping
    Requires API update for this? Can Media Loader have the ability to swap content?


The media loader allows you to ask the frontend for a new disk filename (just a filename).
Disk swapping is then done as follow:

unload current disk
ask frontend for new disk filename via media_loader API
load the new disk
resume execution

You may need to add a new key to the core to trigger such ""disk swap"" action.

Cleanup
    That's being sorta done.

I may just add this question though:
About the ability to give information to plugins on what game is loaded...
To not break compatibility, in Project64, I've generated a N64 ROM header from the disk data and it takes priority from the N64 ROM (even if it's a combo load, so F-Zero X Expansion Kit disk info would be returned instead of F-Zero X ROM info).
Is it fine if I do exactly this?

I guess this is a good enough solution.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/LuigiBlood,25,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-738232247,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","I think we should split your plan and try to merge stable bits as soon as they're stable.
For instance if you think this PR is stable enough, we should not wait too much to merge it.
This will allow to ease testing and reviewing (smaller PR are easier to handle).

I suggest doing the saving part properly and then merge this PR, and figure out the rest later (Seek Times, Swapping, and Plugin recognition).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/LuigiBlood,26,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-738355994,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup",Actually just merge this and we'll think about saving afterwards. I don't see any obvious issues.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/bsmiles32,27,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-738696886,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","OK for merging without the saving part as it needs a bit more work on the storage backend (I'll do the part to allow to save files in chunks in a latter PR).
But before merging I'd like to refactor/clean up the load_dd_disk function (move format specific parts inside disk.c) as it still causes some warnings on my compiler and is very big and difficult to read.
I hope to have that done and merged before the end of the week-end.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/LuigiBlood,28,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-738793509,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","Just as a short explanation of load_dd_disk():

Attempt to load *.save disk file first (if Disk Save Format is Full Copy [0])
Load the real disk file if it failed
Checking if the System Data info is valid on LBA 0, 1, 2, 3, 8, 9, 10, 11

Checks individual data if it's valid or not.
Checks if the format is not D64 that the System Data sector repeats 85 times.
This is in case the disk file is actually corrupted as the format does not say what blocks are unreadable or not.
If the data is valid, then don't check the next LBA because libleo will not attempt to read them.

So if LBA 0 (or 2 if dev disk) is valid, that's good enough.
The valid System Data LBA is also kept in memory so that the sector seek can actually return a read error if it ever attempts to read the bad ones.




If the format is MAME or SDK:

Check if Disk ID sector (LBA 14 & 15) repeats 85 times in case it is corrupted.
The valid Disk ID LBA is also kept in memory for the same reasons as the System Data.


If the format is D64:

We check if the filesize is correct as it can be calculated using the info in the System Data.
If correct, then expand the RAM Area to full capacity and change the System Data info accordingly.


Input the disk information in dd_disk variables.

offset_ram is not applicable in MAME format due to the ordering of the blocks themselves.


Attempt to load *.ram file (if Disk Save Format is RAM Area Only [1]) and replace the data of the RAM area with its contents.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/bsmiles32,29,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-739020637,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","Thanks for the detailed explanation !
Few questions/remarks :

I initially put the ""*.save""  extension, more as an easy way to prevent corrupting my dumps while working on the 64DD, but I didn't look what were the proper ""standard"" formats/extensions. I saw you mentioned *.ndr and *.d6r being extensions proper extension for ndd and d64 savefiles. Shouldn't we support that extensions instead  as they're more standard, or at least already in use with PJ64 ?
We currently don't put the savefile in the standard mupen64plus save file directory. I'll try to also update that part to look in standard mupen64plus save folder.

I'll keep you updated on my progress.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/LuigiBlood,30,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-739022784,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","*.ndr / *.d6r for Full Copy Disk saves, and *.ram for RAM Area Only (only applicable for SDK and D64).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/bsmiles32,31,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-739023553,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","Another quick question :

Do we have to handle byteswapped format ? Do such things exists in existing 64DD dumps ? Not sure and honestly I would prefer to to have to worry about that...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/LuigiBlood,32,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-739023849,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","Nope, byteswapped doesn't really exist.",True,{'THUMBS_UP': ['https://github.com/bsmiles32']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/LuigiBlood,33,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-739095205,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup",Works for me so far.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/LuigiBlood,34,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-739252717,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup",Actually a good idea to Generate LBA Table in load_dd_disk because I think swapping disks would have gone quite a bit wrong,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,762,2020-06-12T11:17:17Z,2020-12-06T09:53:13Z,2020-12-06T09:53:13Z,MERGED,True,1046,474,15,https://github.com/LuigiBlood,"[Disk] Major Disk Support Changes (not ready, design choice discussion)",41,[],https://github.com/mupen64plus/mupen64plus-core/pull/762,https://github.com/bsmiles32,35,https://github.com/mupen64plus/mupen64plus-core/pull/762#issuecomment-739479800,"This is more in line with Project64's 64DD support. This isn't quite clean just yet.

Change disk seek to support more formats without conversions

Added basic Disk library functions for calculating seek offset.


System Area heuristics for finding appropriate system formatting data to use as base.
Support Development Disks.
Support USA and DEV 64DD IPLs.
Do read errors for System Area / Disk ID if the first block doesn't work.
Support D64 disk file format.

Some design choices:

Added void* extra to file_storage struct to include file information, in this case, for extra_storage_disk struct.

I consider this information needs to be understood with very early on under the disk integrity check process and shouldn't be under dd_controller.
Considering I'm touching a pretty important backend, I don't expect it to break anything, but maybe save states are impacted? No idea.



EDIT: This was removed by @bsmiles32 as it is not its purpose to get format information.
TODO:

Support configuration for Full Disk Copy or RAM Only Save (only the RAM save area of the disk).
Disk Seek Times
Disk Swapping
Cleanup","Merging this as it provides some improvements over what currently exists.
To summarize, this PR:

support MAME, SDK and D64 format without needing to convert between them. Format complexity is handled in disk.c
support developement disk
support USA and DEV 64DD IPLs.
mimic access errors in known ""bad"" sectors
can load Full Disk Copy or RAM only saves

What will be addressed in later PR:

saving Full Disk Copy or RAM only (needs some prior work on the storage_backend)
implement disk seek times
disk swapping
pass information about what disk is loaded to plugin
support disk only case (no ROM)
proper PI timings",True,{'THUMBS_UP': ['https://github.com/Darknior']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,764,2020-07-01T16:54:34Z,2020-08-27T05:29:50Z,2020-09-30T21:44:09Z,MERGED,True,216,5,7,https://github.com/Rosalie241,Get/Set Refresh Rate,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/764,https://github.com/Rosalie241,1,https://github.com/mupen64plus/mupen64plus-core/pull/764,"This is still a Work-In-Progress, however I opened this PR early because I wanted some feedback/discussion per my planned changes.
I want to be able to set/get refresh rates using the mupen64plus API(for i.e GUIs, like m64p-gui), I also want to be able to 'properly' set a fullscreen mode with the refresh rate aswell,
I've also opened a GLideN64 PR gonetz/GLideN64#2297 because ultimately my goal is to use upstream GLideN64(with GLideNUI) & mupen64plus-core for m64p-gui(or maybe in the future other GUIs), however, to add the ability to set/get refresh rates, the spec needs to be modified to support such a thing, I see 2 ways of doing it that way

modify the existing VidExtFuncSetMode & m64p_2d_size & VidExt_ListFullscreenModes
create 2 new functions (i.e VidExtFuncSetMode2, int* VidExt_ListRefreshRates(m64p_2d_size input, int *count))

I'm not sure where to go from here so feedback is appreciated.","This is still a Work-In-Progress, however I opened this PR early because I wanted some feedback/discussion per my planned changes.
I want to be able to set/get refresh rates using the mupen64plus API(for i.e GUIs, like m64p-gui), I also want to be able to 'properly' set a fullscreen mode with the refresh rate aswell,
I've also opened a GLideN64 PR gonetz/GLideN64#2297 because ultimately my goal is to use upstream GLideN64(with GLideNUI) & mupen64plus-core for m64p-gui(or maybe in the future other GUIs), however, to add the ability to set/get refresh rates, the spec needs to be modified to support such a thing, I see 2 ways of doing it that way

modify the existing VidExtFuncSetMode & m64p_2d_size & VidExt_ListFullscreenModes
create 2 new functions (i.e VidExtFuncSetMode2, int* VidExt_ListRefreshRates(m64p_2d_size input, int *count))

I'm not sure where to go from here so feedback is appreciated.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,764,2020-07-01T16:54:34Z,2020-08-27T05:29:50Z,2020-09-30T21:44:09Z,MERGED,True,216,5,7,https://github.com/Rosalie241,Get/Set Refresh Rate,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/764,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/764#issuecomment-652975182,"This is still a Work-In-Progress, however I opened this PR early because I wanted some feedback/discussion per my planned changes.
I want to be able to set/get refresh rates using the mupen64plus API(for i.e GUIs, like m64p-gui), I also want to be able to 'properly' set a fullscreen mode with the refresh rate aswell,
I've also opened a GLideN64 PR gonetz/GLideN64#2297 because ultimately my goal is to use upstream GLideN64(with GLideNUI) & mupen64plus-core for m64p-gui(or maybe in the future other GUIs), however, to add the ability to set/get refresh rates, the spec needs to be modified to support such a thing, I see 2 ways of doing it that way

modify the existing VidExtFuncSetMode & m64p_2d_size & VidExt_ListFullscreenModes
create 2 new functions (i.e VidExtFuncSetMode2, int* VidExt_ListRefreshRates(m64p_2d_size input, int *count))

I'm not sure where to go from here so feedback is appreciated.",I’m not sure to understand: What would be stored in the 32 slots of the array?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,764,2020-07-01T16:54:34Z,2020-08-27T05:29:50Z,2020-09-30T21:44:09Z,MERGED,True,216,5,7,https://github.com/Rosalie241,Get/Set Refresh Rate,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/764,https://github.com/Rosalie241,3,https://github.com/mupen64plus/mupen64plus-core/pull/764#issuecomment-653157483,"This is still a Work-In-Progress, however I opened this PR early because I wanted some feedback/discussion per my planned changes.
I want to be able to set/get refresh rates using the mupen64plus API(for i.e GUIs, like m64p-gui), I also want to be able to 'properly' set a fullscreen mode with the refresh rate aswell,
I've also opened a GLideN64 PR gonetz/GLideN64#2297 because ultimately my goal is to use upstream GLideN64(with GLideNUI) & mupen64plus-core for m64p-gui(or maybe in the future other GUIs), however, to add the ability to set/get refresh rates, the spec needs to be modified to support such a thing, I see 2 ways of doing it that way

modify the existing VidExtFuncSetMode & m64p_2d_size & VidExt_ListFullscreenModes
create 2 new functions (i.e VidExtFuncSetMode2, int* VidExt_ListRefreshRates(m64p_2d_size input, int *count))

I'm not sure where to go from here so feedback is appreciated.","The refresh rates, each resolution can contain multiple refresh rates.
…
On July 2, 2020 2:26:05 PM GMT+02:00, Dorian Fevrier ***@***.***> wrote:
I’m not sure to understand: What would be stored in the 32 slots of the
array?>
>
-- >
You are receiving this because you authored the thread.>
Reply to this email directly or view it on GitHub:>
#764 (comment)


-- 
Sent from my Android device with K-9 Mail. Please excuse my brevity.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,764,2020-07-01T16:54:34Z,2020-08-27T05:29:50Z,2020-09-30T21:44:09Z,MERGED,True,216,5,7,https://github.com/Rosalie241,Get/Set Refresh Rate,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/764,https://github.com/Rosalie241,4,https://github.com/mupen64plus/mupen64plus-core/pull/764#issuecomment-660549224,"This is still a Work-In-Progress, however I opened this PR early because I wanted some feedback/discussion per my planned changes.
I want to be able to set/get refresh rates using the mupen64plus API(for i.e GUIs, like m64p-gui), I also want to be able to 'properly' set a fullscreen mode with the refresh rate aswell,
I've also opened a GLideN64 PR gonetz/GLideN64#2297 because ultimately my goal is to use upstream GLideN64(with GLideNUI) & mupen64plus-core for m64p-gui(or maybe in the future other GUIs), however, to add the ability to set/get refresh rates, the spec needs to be modified to support such a thing, I see 2 ways of doing it that way

modify the existing VidExtFuncSetMode & m64p_2d_size & VidExt_ListFullscreenModes
create 2 new functions (i.e VidExtFuncSetMode2, int* VidExt_ListRefreshRates(m64p_2d_size input, int *count))

I'm not sure where to go from here so feedback is appreciated.","I don't want to seem impatient but I'd like to get this work done, can anyone please read my proposal and give suggestions/feedback so that I can continue my work?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,764,2020-07-01T16:54:34Z,2020-08-27T05:29:50Z,2020-09-30T21:44:09Z,MERGED,True,216,5,7,https://github.com/Rosalie241,Get/Set Refresh Rate,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/764,https://github.com/Narann,5,https://github.com/mupen64plus/mupen64plus-core/pull/764#issuecomment-660657971,"This is still a Work-In-Progress, however I opened this PR early because I wanted some feedback/discussion per my planned changes.
I want to be able to set/get refresh rates using the mupen64plus API(for i.e GUIs, like m64p-gui), I also want to be able to 'properly' set a fullscreen mode with the refresh rate aswell,
I've also opened a GLideN64 PR gonetz/GLideN64#2297 because ultimately my goal is to use upstream GLideN64(with GLideNUI) & mupen64plus-core for m64p-gui(or maybe in the future other GUIs), however, to add the ability to set/get refresh rates, the spec needs to be modified to support such a thing, I see 2 ways of doing it that way

modify the existing VidExtFuncSetMode & m64p_2d_size & VidExt_ListFullscreenModes
create 2 new functions (i.e VidExtFuncSetMode2, int* VidExt_ListRefreshRates(m64p_2d_size input, int *count))

I'm not sure where to go from here so feedback is appreciated.","As it's an API modification, I think you can't modify function signature without breaking existing ecosystem.

The refresh rates, each resolution can contain multiple refresh rates.
I think having multiple similar resolution but with different refresh rate wouldn't be better :

640x480, 60
640x480, 59.9
...
Instead of 640x480, [59.9, 60].
typedef struct {
  unsigned int uiWidth;
  unsigned int uiHeight;
  unsigned int refreshRate;
} m64p_2d_size;

With refreshRate as unsigned int, how do you represent 59.9 Hz?
Last question: Who would get this refreshRate value? IIRC, SDL can't change the refresh rate, so let's say GlideN64 get the 59.9 value, what should it does with it?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,764,2020-07-01T16:54:34Z,2020-08-27T05:29:50Z,2020-09-30T21:44:09Z,MERGED,True,216,5,7,https://github.com/Rosalie241,Get/Set Refresh Rate,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/764,https://github.com/Rosalie241,6,https://github.com/mupen64plus/mupen64plus-core/pull/764#issuecomment-660660748,"This is still a Work-In-Progress, however I opened this PR early because I wanted some feedback/discussion per my planned changes.
I want to be able to set/get refresh rates using the mupen64plus API(for i.e GUIs, like m64p-gui), I also want to be able to 'properly' set a fullscreen mode with the refresh rate aswell,
I've also opened a GLideN64 PR gonetz/GLideN64#2297 because ultimately my goal is to use upstream GLideN64(with GLideNUI) & mupen64plus-core for m64p-gui(or maybe in the future other GUIs), however, to add the ability to set/get refresh rates, the spec needs to be modified to support such a thing, I see 2 ways of doing it that way

modify the existing VidExtFuncSetMode & m64p_2d_size & VidExt_ListFullscreenModes
create 2 new functions (i.e VidExtFuncSetMode2, int* VidExt_ListRefreshRates(m64p_2d_size input, int *count))

I'm not sure where to go from here so feedback is appreciated.","As it's an API modification, I think you can't modify function signature without breaking existing ecosystem.

that's alright, I can extend the API to add i.e VidExt_ListRefreshRates to not break everything.


The refresh rates, each resolution can contain multiple refresh rates.
I think having multiple similar resolution but with different refresh rate wouldn't be better :

640x480, 60
640x480, 59.9
...
Instead of 640x480, [59.9, 60].
typedef struct {
  unsigned int uiWidth;
  unsigned int uiHeight;
  unsigned int refreshRate;
} m64p_2d_size;

With refreshRate as unsigned int, how do you represent 59.9 Hz?

since I use SDL2 to fill that data, and SDL2 uses int for the refresh rate, you can't
https://wiki.libsdl.org/SDL_DisplayMode
https://wiki.libsdl.org/SDL_GetDisplayMode

Last question: Who would get this refreshRate value? IIRC, SDL can't change the refresh rate, so let's say GlideN64 get the 59.9 value, what should it does with it?

it'd work something like this:

GLideN64 requests a list of resolutions and refresh rates from the m64p API
the mupen core library fills a list with the resolutions and refresh rates (in this case, m64p-gui has it's own video extension functions, which I've modified to use SDL2 to do this)
when going fullscreen, GLideN64 sets the video mode using the m64p API with the refresh rate (in this case, my prototype m64p-gui implementation uses SDL2 to set the fullscreen mode)

SDL1 can't change refresh rates, that's right, SDL2 can though
https://wiki.libsdl.org/SDL_SetWindowDisplayMode",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,764,2020-07-01T16:54:34Z,2020-08-27T05:29:50Z,2020-09-30T21:44:09Z,MERGED,True,216,5,7,https://github.com/Rosalie241,Get/Set Refresh Rate,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/764,https://github.com/Jj0YzL5nvJ,7,https://github.com/mupen64plus/mupen64plus-core/pull/764#issuecomment-660703614,"This is still a Work-In-Progress, however I opened this PR early because I wanted some feedback/discussion per my planned changes.
I want to be able to set/get refresh rates using the mupen64plus API(for i.e GUIs, like m64p-gui), I also want to be able to 'properly' set a fullscreen mode with the refresh rate aswell,
I've also opened a GLideN64 PR gonetz/GLideN64#2297 because ultimately my goal is to use upstream GLideN64(with GLideNUI) & mupen64plus-core for m64p-gui(or maybe in the future other GUIs), however, to add the ability to set/get refresh rates, the spec needs to be modified to support such a thing, I see 2 ways of doing it that way

modify the existing VidExtFuncSetMode & m64p_2d_size & VidExt_ListFullscreenModes
create 2 new functions (i.e VidExtFuncSetMode2, int* VidExt_ListRefreshRates(m64p_2d_size input, int *count))

I'm not sure where to go from here so feedback is appreciated.","$ xrandr
Screen 0: minimum 320 x 200, current 1920 x 1080, maximum 16384 x 16384
DisplayPort-0 connected primary 1920x1080+0+0 (normal left inverted right x axis y axis) 531mm x 299mm
   1920x1080     60.00 + 144.00*  119.98    99.93    84.90    50.00    59.94  
   1680x1050     59.95  
   1280x1024     75.02    60.02  
   1440x900      59.89  
   1280x960      60.00  
   1280x800      59.81  
   1152x864      75.00  
   1280x720      60.00    50.00    59.94  
   1024x768      75.03    70.07    60.00  
   832x624       74.55  
   800x600       72.19    75.00    60.32    56.25  
   720x576       50.00  
   720x480       60.00    59.94  
   640x480       75.00    66.67    60.00    59.94  
   720x400       70.08  
HDMI-A-0 disconnected (normal left inverted right x axis y axis)
DVI-D-0 disconnected (normal left inverted right x axis y axis)

What happens if I connect a 144Hz monitor to DisplayPort-0, an 85Hz CRT to DVI-D-0 and a 30Hz HDTV to HDMI-A-0?
Will the settings on each screen be respected?
Exclusive mode, non-exclusive mode or both?
What would happen in case of using variable refresh rate (G-Sync, FreeSync, etc.)?
HDR10 support...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,764,2020-07-01T16:54:34Z,2020-08-27T05:29:50Z,2020-09-30T21:44:09Z,MERGED,True,216,5,7,https://github.com/Rosalie241,Get/Set Refresh Rate,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/764,https://github.com/Rosalie241,8,https://github.com/mupen64plus/mupen64plus-core/pull/764#issuecomment-660705739,"This is still a Work-In-Progress, however I opened this PR early because I wanted some feedback/discussion per my planned changes.
I want to be able to set/get refresh rates using the mupen64plus API(for i.e GUIs, like m64p-gui), I also want to be able to 'properly' set a fullscreen mode with the refresh rate aswell,
I've also opened a GLideN64 PR gonetz/GLideN64#2297 because ultimately my goal is to use upstream GLideN64(with GLideNUI) & mupen64plus-core for m64p-gui(or maybe in the future other GUIs), however, to add the ability to set/get refresh rates, the spec needs to be modified to support such a thing, I see 2 ways of doing it that way

modify the existing VidExtFuncSetMode & m64p_2d_size & VidExt_ListFullscreenModes
create 2 new functions (i.e VidExtFuncSetMode2, int* VidExt_ListRefreshRates(m64p_2d_size input, int *count))

I'm not sure where to go from here so feedback is appreciated.","What happens if I connect a 144Hz monitor to DisplayPort-0, an 85Hz CRT to DVI-D-0 and a 30Hz HDTV to HDMI-A-0?
Will the settings on each screen be respected?

it should just work, that is if SDL2 handles such a case nicely (which I presume it does)

Exclusive mode, non-exclusive mode or both?

exclusive mode only iirc (again, SDL2 will be doing everything)

What would happen in case of using variable refresh rate (G-Sync, FreeSync, etc.)?

I have no idea, I don't think that's upto SDL2 to handle, I think that's a video plugins' job (something like opengl's Adaptive Vsync I suppose?)

HDR10 support...

SDL2 is gonna handle everything so I don't know.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,764,2020-07-01T16:54:34Z,2020-08-27T05:29:50Z,2020-09-30T21:44:09Z,MERGED,True,216,5,7,https://github.com/Rosalie241,Get/Set Refresh Rate,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/764,https://github.com/Jj0YzL5nvJ,9,https://github.com/mupen64plus/mupen64plus-core/pull/764#issuecomment-660708413,"This is still a Work-In-Progress, however I opened this PR early because I wanted some feedback/discussion per my planned changes.
I want to be able to set/get refresh rates using the mupen64plus API(for i.e GUIs, like m64p-gui), I also want to be able to 'properly' set a fullscreen mode with the refresh rate aswell,
I've also opened a GLideN64 PR gonetz/GLideN64#2297 because ultimately my goal is to use upstream GLideN64(with GLideNUI) & mupen64plus-core for m64p-gui(or maybe in the future other GUIs), however, to add the ability to set/get refresh rates, the spec needs to be modified to support such a thing, I see 2 ways of doing it that way

modify the existing VidExtFuncSetMode & m64p_2d_size & VidExt_ListFullscreenModes
create 2 new functions (i.e VidExtFuncSetMode2, int* VidExt_ListRefreshRates(m64p_2d_size input, int *count))

I'm not sure where to go from here so feedback is appreciated.","exclusive mode only iirc (again, SDL2 will be doing everything)

That is exactly the direct path to disaster (multi-monitor support). I prefer the non-exclusive mode. Exclusive mode adds nothing to current support.
In any case, I suggest that the screen output is also saved/listed for possible use by the video plugin.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,764,2020-07-01T16:54:34Z,2020-08-27T05:29:50Z,2020-09-30T21:44:09Z,MERGED,True,216,5,7,https://github.com/Rosalie241,Get/Set Refresh Rate,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/764,https://github.com/Rosalie241,10,https://github.com/mupen64plus/mupen64plus-core/pull/764#issuecomment-660714006,"This is still a Work-In-Progress, however I opened this PR early because I wanted some feedback/discussion per my planned changes.
I want to be able to set/get refresh rates using the mupen64plus API(for i.e GUIs, like m64p-gui), I also want to be able to 'properly' set a fullscreen mode with the refresh rate aswell,
I've also opened a GLideN64 PR gonetz/GLideN64#2297 because ultimately my goal is to use upstream GLideN64(with GLideNUI) & mupen64plus-core for m64p-gui(or maybe in the future other GUIs), however, to add the ability to set/get refresh rates, the spec needs to be modified to support such a thing, I see 2 ways of doing it that way

modify the existing VidExtFuncSetMode & m64p_2d_size & VidExt_ListFullscreenModes
create 2 new functions (i.e VidExtFuncSetMode2, int* VidExt_ListRefreshRates(m64p_2d_size input, int *count))

I'm not sure where to go from here so feedback is appreciated.","@Narann I've made an alternative implementation of this PR(not fully finished yet, it's also untested), but would this be more sane?
https://gist.github.com/Rosalie241/4a8efb67d66f30863305bd1d6f1f16bf",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,764,2020-07-01T16:54:34Z,2020-08-27T05:29:50Z,2020-09-30T21:44:09Z,MERGED,True,216,5,7,https://github.com/Rosalie241,Get/Set Refresh Rate,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/764,https://github.com/richard42,11,https://github.com/mupen64plus/mupen64plus-core/pull/764#issuecomment-664758289,"This is still a Work-In-Progress, however I opened this PR early because I wanted some feedback/discussion per my planned changes.
I want to be able to set/get refresh rates using the mupen64plus API(for i.e GUIs, like m64p-gui), I also want to be able to 'properly' set a fullscreen mode with the refresh rate aswell,
I've also opened a GLideN64 PR gonetz/GLideN64#2297 because ultimately my goal is to use upstream GLideN64(with GLideNUI) & mupen64plus-core for m64p-gui(or maybe in the future other GUIs), however, to add the ability to set/get refresh rates, the spec needs to be modified to support such a thing, I see 2 ways of doing it that way

modify the existing VidExtFuncSetMode & m64p_2d_size & VidExt_ListFullscreenModes
create 2 new functions (i.e VidExtFuncSetMode2, int* VidExt_ListRefreshRates(m64p_2d_size input, int *count))

I'm not sure where to go from here so feedback is appreciated.","Looks pretty good to me. The only recommendation I have is to rename the function ""VidExt_SetVideoMode2"" to something more descriptive like ""VidExt_SetVideoModeWithRate""",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,764,2020-07-01T16:54:34Z,2020-08-27T05:29:50Z,2020-09-30T21:44:09Z,MERGED,True,216,5,7,https://github.com/Rosalie241,Get/Set Refresh Rate,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/764,https://github.com/Rosalie241,12,https://github.com/mupen64plus/mupen64plus-core/pull/764#issuecomment-665148416,"This is still a Work-In-Progress, however I opened this PR early because I wanted some feedback/discussion per my planned changes.
I want to be able to set/get refresh rates using the mupen64plus API(for i.e GUIs, like m64p-gui), I also want to be able to 'properly' set a fullscreen mode with the refresh rate aswell,
I've also opened a GLideN64 PR gonetz/GLideN64#2297 because ultimately my goal is to use upstream GLideN64(with GLideNUI) & mupen64plus-core for m64p-gui(or maybe in the future other GUIs), however, to add the ability to set/get refresh rates, the spec needs to be modified to support such a thing, I see 2 ways of doing it that way

modify the existing VidExtFuncSetMode & m64p_2d_size & VidExt_ListFullscreenModes
create 2 new functions (i.e VidExtFuncSetMode2, int* VidExt_ListRefreshRates(m64p_2d_size input, int *count))

I'm not sure where to go from here so feedback is appreciated.","Looks pretty good to me. The only recommendation I have is to rename the function ""VidExt_SetVideoMode2"" to something more descriptive like ""VidExt_SetVideoModeWithRate""

Alright, updated the patch",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,764,2020-07-01T16:54:34Z,2020-08-27T05:29:50Z,2020-09-30T21:44:09Z,MERGED,True,216,5,7,https://github.com/Rosalie241,Get/Set Refresh Rate,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/764,https://github.com/Rosalie241,13,https://github.com/mupen64plus/mupen64plus-core/pull/764#issuecomment-674390534,"This is still a Work-In-Progress, however I opened this PR early because I wanted some feedback/discussion per my planned changes.
I want to be able to set/get refresh rates using the mupen64plus API(for i.e GUIs, like m64p-gui), I also want to be able to 'properly' set a fullscreen mode with the refresh rate aswell,
I've also opened a GLideN64 PR gonetz/GLideN64#2297 because ultimately my goal is to use upstream GLideN64(with GLideNUI) & mupen64plus-core for m64p-gui(or maybe in the future other GUIs), however, to add the ability to set/get refresh rates, the spec needs to be modified to support such a thing, I see 2 ways of doing it that way

modify the existing VidExtFuncSetMode & m64p_2d_size & VidExt_ListFullscreenModes
create 2 new functions (i.e VidExtFuncSetMode2, int* VidExt_ListRefreshRates(m64p_2d_size input, int *count))

I'm not sure where to go from here so feedback is appreciated.","I forgot about the documentation, so I've updated the patch to include it, hopefully it's clear enough.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,764,2020-07-01T16:54:34Z,2020-08-27T05:29:50Z,2020-09-30T21:44:09Z,MERGED,True,216,5,7,https://github.com/Rosalie241,Get/Set Refresh Rate,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/764,https://github.com/richard42,14,https://github.com/mupen64plus/mupen64plus-core/pull/764#issuecomment-677275610,"This is still a Work-In-Progress, however I opened this PR early because I wanted some feedback/discussion per my planned changes.
I want to be able to set/get refresh rates using the mupen64plus API(for i.e GUIs, like m64p-gui), I also want to be able to 'properly' set a fullscreen mode with the refresh rate aswell,
I've also opened a GLideN64 PR gonetz/GLideN64#2297 because ultimately my goal is to use upstream GLideN64(with GLideNUI) & mupen64plus-core for m64p-gui(or maybe in the future other GUIs), however, to add the ability to set/get refresh rates, the spec needs to be modified to support such a thing, I see 2 ways of doing it that way

modify the existing VidExtFuncSetMode & m64p_2d_size & VidExt_ListFullscreenModes
create 2 new functions (i.e VidExtFuncSetMode2, int* VidExt_ListRefreshRates(m64p_2d_size input, int *count))

I'm not sure where to go from here so feedback is appreciated.","Okay this looks good. The only thing remaining is to advance the video extension API version number and update the API changelist. This is explained in this wiki page:
https://mupen64plus.org/wiki/index.php?title=Mupen64Plus_v2.0_API_Versioning",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,764,2020-07-01T16:54:34Z,2020-08-27T05:29:50Z,2020-09-30T21:44:09Z,MERGED,True,216,5,7,https://github.com/Rosalie241,Get/Set Refresh Rate,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/764,https://github.com/Rosalie241,15,https://github.com/mupen64plus/mupen64plus-core/pull/764#issuecomment-677425905,"This is still a Work-In-Progress, however I opened this PR early because I wanted some feedback/discussion per my planned changes.
I want to be able to set/get refresh rates using the mupen64plus API(for i.e GUIs, like m64p-gui), I also want to be able to 'properly' set a fullscreen mode with the refresh rate aswell,
I've also opened a GLideN64 PR gonetz/GLideN64#2297 because ultimately my goal is to use upstream GLideN64(with GLideNUI) & mupen64plus-core for m64p-gui(or maybe in the future other GUIs), however, to add the ability to set/get refresh rates, the spec needs to be modified to support such a thing, I see 2 ways of doing it that way

modify the existing VidExtFuncSetMode & m64p_2d_size & VidExt_ListFullscreenModes
create 2 new functions (i.e VidExtFuncSetMode2, int* VidExt_ListRefreshRates(m64p_2d_size input, int *count))

I'm not sure where to go from here so feedback is appreciated.","Okay this looks good. The only thing remaining is to advance the video extension API version number and update the API changelist. This is explained in this wiki page:
https://mupen64plus.org/wiki/index.php?title=Mupen64Plus_v2.0_API_Versioning

Alright, updated the patch",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,764,2020-07-01T16:54:34Z,2020-08-27T05:29:50Z,2020-09-30T21:44:09Z,MERGED,True,216,5,7,https://github.com/Rosalie241,Get/Set Refresh Rate,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/764,https://github.com/Rosalie241,16,https://github.com/mupen64plus/mupen64plus-core/pull/764#issuecomment-679111989,"This is still a Work-In-Progress, however I opened this PR early because I wanted some feedback/discussion per my planned changes.
I want to be able to set/get refresh rates using the mupen64plus API(for i.e GUIs, like m64p-gui), I also want to be able to 'properly' set a fullscreen mode with the refresh rate aswell,
I've also opened a GLideN64 PR gonetz/GLideN64#2297 because ultimately my goal is to use upstream GLideN64(with GLideNUI) & mupen64plus-core for m64p-gui(or maybe in the future other GUIs), however, to add the ability to set/get refresh rates, the spec needs to be modified to support such a thing, I see 2 ways of doing it that way

modify the existing VidExtFuncSetMode & m64p_2d_size & VidExt_ListFullscreenModes
create 2 new functions (i.e VidExtFuncSetMode2, int* VidExt_ListRefreshRates(m64p_2d_size input, int *count))

I'm not sure where to go from here so feedback is appreciated.","I slightly modified the implementation to verify that the input Width, Height and RefreshRate of VidExt_SetVideoModeWithRate are actually valid, this also allows the code to re-use the same SDL_DisplayMode structure",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,766,2020-08-13T05:09:24Z,2020-08-20T06:36:02Z,2020-08-23T01:41:48Z,MERGED,True,6,16,1,https://github.com/Jj0YzL5nvJ,Allow to set custom platform toolset from commands,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/766,https://github.com/Jj0YzL5nvJ,1,https://github.com/mupen64plus/mupen64plus-core/pull/766,"Example:
msbuild mupen64plus-core.vcxproj /p:Configuration=New_Dynarec_Debug;Platform=x64;PlatformToolset=ClangCL
Edit:

Don't set *TargetPlatformVersion if it's not strictly necessary, like in VS2015's case
Apparently PlatformToolset always initializes as v100 (VS2010). Initialization based on ToolsVersion value?","Example:
msbuild mupen64plus-core.vcxproj /p:Configuration=New_Dynarec_Debug;Platform=x64;PlatformToolset=ClangCL
Edit:

Don't set *TargetPlatformVersion if it's not strictly necessary, like in VS2015's case
Apparently PlatformToolset always initializes as v100 (VS2010). Initialization based on ToolsVersion value?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,767,2020-08-13T06:55:04Z,2020-08-13T07:01:50Z,2020-08-13T07:06:53Z,CLOSED,False,30,28,2,https://github.com/Jj0YzL5nvJ,Get info... (DO NOT MERGE),2,[],https://github.com/mupen64plus/mupen64plus-core/pull/767,https://github.com/Jj0YzL5nvJ,1,https://github.com/mupen64plus/mupen64plus-core/pull/767,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,768,2020-08-17T13:59:18Z,2020-08-20T06:16:13Z,2021-06-20T20:45:46Z,MERGED,True,1,0,1,https://github.com/loganmc10,CountPerOp=3 for Wave Race 64 - Shindou Edition,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/768,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/768,See m64p/m64p#57. CountPerOp=3 is needed for the game to get past the Nintendo logo,See m64p/m64p#57. CountPerOp=3 is needed for the game to get past the Nintendo logo,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,771,2020-08-24T18:58:15Z,2020-08-25T13:46:33Z,2020-08-25T14:56:35Z,MERGED,True,1,1,1,https://github.com/Rosalie241,"Makefile: add missing """,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/771,https://github.com/Rosalie241,1,https://github.com/mupen64plus/mupen64plus-core/pull/771,"This patch fixes:
/bin/sh: -c: line 0: unexpected EOF while looking for matching `""'
/bin/sh: -c: line 1: syntax error: unexpected end of file
make: *** [Makefile:726: targets] Error 1

when running make","This patch fixes:
/bin/sh: -c: line 0: unexpected EOF while looking for matching `""'
/bin/sh: -c: line 1: syntax error: unexpected end of file
make: *** [Makefile:726: targets] Error 1

when running make",True,{'THUMBS_UP': ['https://github.com/loganmc10']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,771,2020-08-24T18:58:15Z,2020-08-25T13:46:33Z,2020-08-25T14:56:35Z,MERGED,True,1,1,1,https://github.com/Rosalie241,"Makefile: add missing """,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/771,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/771#issuecomment-679306571,"This patch fixes:
/bin/sh: -c: line 0: unexpected EOF while looking for matching `""'
/bin/sh: -c: line 1: syntax error: unexpected end of file
make: *** [Makefile:726: targets] Error 1

when running make",Whoops good catch,True,{'HEART': ['https://github.com/Rosalie241']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,774,2020-08-26T11:30:20Z,2020-09-01T20:54:14Z,2020-09-02T14:36:23Z,CLOSED,False,19,0,2,https://github.com/Rosalie241,Allow plugins to have a configuration GUI,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/774,https://github.com/Rosalie241,1,https://github.com/mupen64plus/mupen64plus-core/pull/774,this patch modifies the spec to allow plugins to expose an optional PluginConfig function which can run a configuration GUI (like gliden64's glidenUI),this patch modifies the spec to allow plugins to expose an optional PluginConfig function which can run a configuration GUI (like gliden64's glidenUI),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,774,2020-08-26T11:30:20Z,2020-09-01T20:54:14Z,2020-09-02T14:36:23Z,CLOSED,False,19,0,2,https://github.com/Rosalie241,Allow plugins to have a configuration GUI,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/774,https://github.com/richard42,2,https://github.com/mupen64plus/mupen64plus-core/pull/774#issuecomment-681568986,this patch modifies the spec to allow plugins to expose an optional PluginConfig function which can run a configuration GUI (like gliden64's glidenUI),"I don't think you will be able to convince me to allow this change to the API.  The old Zilmar spec had a similar function, and I deliberately removed it in the 2.0 re-architecture because it is not a good design.  The plugins need to use the Config API to read and write their parameters. I want all of the GUI code to be centralized in the front-end application, and not scattered in a bunch of different modules.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,774,2020-08-26T11:30:20Z,2020-09-01T20:54:14Z,2020-09-02T14:36:23Z,CLOSED,False,19,0,2,https://github.com/Rosalie241,Allow plugins to have a configuration GUI,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/774,https://github.com/Rosalie241,3,https://github.com/mupen64plus/mupen64plus-core/pull/774#issuecomment-681678492,this patch modifies the spec to allow plugins to expose an optional PluginConfig function which can run a configuration GUI (like gliden64's glidenUI),"I want i.e something like GlideNUI for other plugins aswell, how should I make an actually usable & reasonably looking Configuration GUI without creating a different GUI per plugin in the front-end? In my opinion it'd make much more sense if the plugins would be allowed to make a front-end (optionally) so that not every GUI would need to create custom configuration GUIs for every different plugin.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,774,2020-08-26T11:30:20Z,2020-09-01T20:54:14Z,2020-09-02T14:36:23Z,CLOSED,False,19,0,2,https://github.com/Rosalie241,Allow plugins to have a configuration GUI,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/774,https://github.com/Rosalie241,4,https://github.com/mupen64plus/mupen64plus-core/pull/774#issuecomment-681902716,this patch modifies the spec to allow plugins to expose an optional PluginConfig function which can run a configuration GUI (like gliden64's glidenUI),"Another option would be to allow plugins to define how certain things are laid out in the GUI, however this'd require a lot of changes to the Config API, and I'm not sure if plugin devs would be very keen on such changes.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,774,2020-08-26T11:30:20Z,2020-09-01T20:54:14Z,2020-09-02T14:36:23Z,CLOSED,False,19,0,2,https://github.com/Rosalie241,Allow plugins to have a configuration GUI,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/774,https://github.com/Narann,5,https://github.com/mupen64plus/mupen64plus-core/pull/774#issuecomment-681995044,this patch modifies the spec to allow plugins to expose an optional PluginConfig function which can run a configuration GUI (like gliden64's glidenUI),"how should I make an actually usable & reasonably looking Configuration GUI without creating a different GUI per plugin in the front-end?

It's a freedom the API give you without restricting you on how parameters must be organized and which GUI toolkit to use. API simply expose parameters. It's up to the front end to get/set them and most importantly, organize them to provide the best UX way for your platform.

In my opinion it'd make much more sense if the plugins would be allowed to make a front-end (optionally) so that not every GUI would need to create custom configuration GUIs for every different plugin.

I politely disagree. This make sense from a desktop front end maintainer perspective, but not from what the core is supposed to do. Current API is simple, and that's the reason mupen64plus can run almost anywhere. What would make more sense is that every plugin provide some documentation on how parameters interact to help front end devs so it takes less time to them to write those GUIs.
I don't think it's up to the API to fix the UI layout problem, specially because this UI layout problem highly depends on the platform. TBH, current API could be even more simple if it wouldn't care about loading/saving config file and let the front end taking care of the parameters.
My 2 cts.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,774,2020-08-26T11:30:20Z,2020-09-01T20:54:14Z,2020-09-02T14:36:23Z,CLOSED,False,19,0,2,https://github.com/Rosalie241,Allow plugins to have a configuration GUI,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/774,https://github.com/richard42,6,https://github.com/mupen64plus/mupen64plus-core/pull/774#issuecomment-683513088,this patch modifies the spec to allow plugins to expose an optional PluginConfig function which can run a configuration GUI (like gliden64's glidenUI),"Before we re-designed the API, there was different GUI code, for multiple platforms, in all these different modules and it always seemed to be going out of date and it was very difficult to maintain.  One of the design goals of the new API is to put all of the GUI code in one module (the front-end application) so that it can be entirely owned and maintained by a single person or team. Regarding GUI layout for the configuration parameters, and front-end application could have a generic interface which presents the parameters in a table with controls for integers, floats, strings, etc and it will work fine.  For special plugins (such as the input plugin) which can benefit from custom code (ie, for testing joystick events, formatting the configuration strings, showing a graphical layout, etc) the front-end application author can decide to write custom dialogs for those plugins if he or she wishes.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,774,2020-08-26T11:30:20Z,2020-09-01T20:54:14Z,2020-09-02T14:36:23Z,CLOSED,False,19,0,2,https://github.com/Rosalie241,Allow plugins to have a configuration GUI,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/774,https://github.com/Rosalie241,7,https://github.com/mupen64plus/mupen64plus-core/pull/774#issuecomment-685126687,this patch modifies the spec to allow plugins to expose an optional PluginConfig function which can run a configuration GUI (like gliden64's glidenUI),"Fair enough, I'll have to break the spec then in my own plugins to achieve my personal goal, thank you for the information.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,775,2020-08-30T11:48:04Z,2020-08-31T01:52:51Z,2020-08-31T17:56:11Z,MERGED,True,94,48,4,https://github.com/Jj0YzL5nvJ,Improve compatibility on restrictive platforms and other minor changes,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/775,https://github.com/Jj0YzL5nvJ,1,https://github.com/mupen64plus/mupen64plus-core/pull/775,"Allow non-default compilers without resorting to symbolic links
Added a bash script, completely awk-free.
Batch script rewritten so that it does not depend on any *delayedexpansion behaviours.
Improve batch code read alignment when viewed with type.
Reflect some internals of the bash script and Makefile in the batch script.
Better explanation of what the batch is doing... or so I hope.","Allow non-default compilers without resorting to symbolic links
Added a bash script, completely awk-free.
Batch script rewritten so that it does not depend on any *delayedexpansion behaviours.
Improve batch code read alignment when viewed with type.
Reflect some internals of the bash script and Makefile in the batch script.
Better explanation of what the batch is doing... or so I hope.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,779,2020-10-04T02:18:49Z,2020-10-05T16:54:49Z,2020-10-05T16:54:56Z,MERGED,True,1,1,1,https://github.com/joeldenning,Fix typo in M64CMD_NETPLAY_INIT docs,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/779,https://github.com/joeldenning,1,https://github.com/mupen64plus/mupen64plus-core/pull/779,"Not the most substantive of changes :), but I've been reading through the recent netplay-related changes and noticed this typo.","Not the most substantive of changes :), but I've been reading through the recent netplay-related changes and noticed this typo.",True,{'THUMBS_UP': ['https://github.com/loganmc10']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,779,2020-10-04T02:18:49Z,2020-10-05T16:54:49Z,2020-10-05T16:54:56Z,MERGED,True,1,1,1,https://github.com/joeldenning,Fix typo in M64CMD_NETPLAY_INIT docs,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/779,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/779#issuecomment-703757666,"Not the most substantive of changes :), but I've been reading through the recent netplay-related changes and noticed this typo.",Thanks!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,782,2020-10-10T02:52:21Z,2020-10-11T10:28:09Z,2021-06-20T20:46:54Z,MERGED,True,3229,2515,3,https://github.com/loganmc10,Update xxHash to 0.8.0,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/782,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/782,"Just an update for xxHash from 0.7.3 to 0.8.0
Release notes can be seen here: https://github.com/Cyan4973/xxHash/releases","Just an update for xxHash from 0.7.3 to 0.8.0
Release notes can be seen here: https://github.com/Cyan4973/xxHash/releases",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,783,2020-10-11T14:21:59Z,2020-12-22T08:44:13Z,2020-12-22T08:44:17Z,CLOSED,False,11,18,1,https://github.com/Jj0YzL5nvJ,Small optimizations for CI/CD and make artifacts easier to handle...,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/783,https://github.com/Jj0YzL5nvJ,1,https://github.com/mupen64plus/mupen64plus-core/pull/783,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,784,2020-10-13T01:52:38Z,2020-10-14T03:16:52Z,2021-06-20T20:47:06Z,MERGED,True,13,0,1,https://github.com/loganmc10,CountPerOp=1 for Smash,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/784,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/784,"See a discussion here for the benefits of CountPerOp=1 for Smash: http://forum.pj64-emu.com/showthread.php?t=8856
It decreases input latency and I guess puts it more in line with a console, Smash players are really serious about input latency.
Also included Smash Remix (https://github.com/JSsixtyfour/smashremix/releases) in the INI file","See a discussion here for the benefits of CountPerOp=1 for Smash: http://forum.pj64-emu.com/showthread.php?t=8856
It decreases input latency and I guess puts it more in line with a console, Smash players are really serious about input latency.
Also included Smash Remix (https://github.com/JSsixtyfour/smashremix/releases) in the INI file",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,785,2020-10-16T16:25:43Z,2020-10-16T23:52:31Z,2021-06-20T20:47:08Z,MERGED,True,16,0,1,https://github.com/loganmc10,Tag outgoing UDP packets with EF DSCP,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/785,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/785,"You can read about DSCP/QoS here: https://en.wikipedia.org/wiki/Differentiated_services
This tags outgoing UDP packets with ""EF"" (Expedited Forwarding). This tells the local router that these packets are ""realtime"" packets and need to be given priority.
I verified that this is working as expected by looking at the traffic in Wireshark after implementing this change:

The effects of this would depend on the users home router. Most ""gaming"" routers from ASUS or Netgear support QoS based on DSCP tags. Most SMB routers (for instance I use a Ubiquiti EdgeRouter X) also support this.
Since most home Internet plans are quite light on upload speeds, QoS can be helpful to prioritize real time traffic (voice, gaming).","You can read about DSCP/QoS here: https://en.wikipedia.org/wiki/Differentiated_services
This tags outgoing UDP packets with ""EF"" (Expedited Forwarding). This tells the local router that these packets are ""realtime"" packets and need to be given priority.
I verified that this is working as expected by looking at the traffic in Wireshark after implementing this change:

The effects of this would depend on the users home router. Most ""gaming"" routers from ASUS or Netgear support QoS based on DSCP tags. Most SMB routers (for instance I use a Ubiquiti EdgeRouter X) also support this.
Since most home Internet plans are quite light on upload speeds, QoS can be helpful to prioritize real time traffic (voice, gaming).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,785,2020-10-16T16:25:43Z,2020-10-16T23:52:31Z,2021-06-20T20:47:08Z,MERGED,True,16,0,1,https://github.com/loganmc10,Tag outgoing UDP packets with EF DSCP,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/785,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/785#issuecomment-710212624,"You can read about DSCP/QoS here: https://en.wikipedia.org/wiki/Differentiated_services
This tags outgoing UDP packets with ""EF"" (Expedited Forwarding). This tells the local router that these packets are ""realtime"" packets and need to be given priority.
I verified that this is working as expected by looking at the traffic in Wireshark after implementing this change:

The effects of this would depend on the users home router. Most ""gaming"" routers from ASUS or Netgear support QoS based on DSCP tags. Most SMB routers (for instance I use a Ubiquiti EdgeRouter X) also support this.
Since most home Internet plans are quite light on upload speeds, QoS can be helpful to prioritize real time traffic (voice, gaming).","I guess Windows blocks directly changing the IP_TOS field, there is another API that needs to be used on Windows. I'll keep working on this",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,785,2020-10-16T16:25:43Z,2020-10-16T23:52:31Z,2021-06-20T20:47:08Z,MERGED,True,16,0,1,https://github.com/loganmc10,Tag outgoing UDP packets with EF DSCP,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/785,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/785#issuecomment-710529675,"You can read about DSCP/QoS here: https://en.wikipedia.org/wiki/Differentiated_services
This tags outgoing UDP packets with ""EF"" (Expedited Forwarding). This tells the local router that these packets are ""realtime"" packets and need to be given priority.
I verified that this is working as expected by looking at the traffic in Wireshark after implementing this change:

The effects of this would depend on the users home router. Most ""gaming"" routers from ASUS or Netgear support QoS based on DSCP tags. Most SMB routers (for instance I use a Ubiquiti EdgeRouter X) also support this.
Since most home Internet plans are quite light on upload speeds, QoS can be helpful to prioritize real time traffic (voice, gaming).","It seems like getting this to work on Windows using SDL2_net would be almost impossible. I've updated it to just tag packets in Linux.
I did write a guide for Windows on how to do it manually though: https://github.com/loganmc10/m64p/wiki/Quality-of-Service
I think this is ready to be merged.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,788,2020-10-22T21:22:15Z,2021-01-23T03:58:35Z,2021-01-23T03:58:35Z,MERGED,True,46,29,8,https://github.com/Rosalie241,Add M64CMD_ROM_SET_SETTINGS,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/788,https://github.com/Rosalie241,1,https://github.com/mupen64plus/mupen64plus-core/pull/788,"This PR allows a front-end to 'modify' game settings until the ROM is closed, this allows for per game settings like what Project64 has
imagine something like this:

Front-end has emulation running and provides a settings window, settings window provides per game options (i.e plugin selection, countperop, save type, etc)
Front-end saves those settings to i.e a third party configuration file
Next time front-end loads emulation, it'll execute M64CMD_ROM_SET_SETTINGS after the ROM has been opened & before emulation is launched","This PR allows a front-end to 'modify' game settings until the ROM is closed, this allows for per game settings like what Project64 has
imagine something like this:

Front-end has emulation running and provides a settings window, settings window provides per game options (i.e plugin selection, countperop, save type, etc)
Front-end saves those settings to i.e a third party configuration file
Next time front-end loads emulation, it'll execute M64CMD_ROM_SET_SETTINGS after the ROM has been opened & before emulation is launched",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,788,2020-10-22T21:22:15Z,2021-01-23T03:58:35Z,2021-01-23T03:58:35Z,MERGED,True,46,29,8,https://github.com/Rosalie241,Add M64CMD_ROM_SET_SETTINGS,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/788,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/788#issuecomment-714774006,"This PR allows a front-end to 'modify' game settings until the ROM is closed, this allows for per game settings like what Project64 has
imagine something like this:

Front-end has emulation running and provides a settings window, settings window provides per game options (i.e plugin selection, countperop, save type, etc)
Front-end saves those settings to i.e a third party configuration file
Next time front-end loads emulation, it'll execute M64CMD_ROM_SET_SETTINGS after the ROM has been opened & before emulation is launched","Sorry I must not understand, what is the difference in purpose between CoreSetRomSettings and M64CMD_ROM_SET_SETTINGS.
Wouldn't the front-end just call M64CMD_ROM_SET_SETTINGS before launching the game?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,788,2020-10-22T21:22:15Z,2021-01-23T03:58:35Z,2021-01-23T03:58:35Z,MERGED,True,46,29,8,https://github.com/Rosalie241,Add M64CMD_ROM_SET_SETTINGS,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/788,https://github.com/Rosalie241,3,https://github.com/mupen64plus/mupen64plus-core/pull/788#issuecomment-715216040,"This PR allows a front-end to 'modify' game settings until the ROM is closed, this allows for per game settings like what Project64 has
imagine something like this:

Front-end has emulation running and provides a settings window, settings window provides per game options (i.e plugin selection, countperop, save type, etc)
Front-end saves those settings to i.e a third party configuration file
Next time front-end loads emulation, it'll execute M64CMD_ROM_SET_SETTINGS after the ROM has been opened & before emulation is launched","Per discussion on Discord yesterday, I've removed the CoreSetRomSettings function",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,788,2020-10-22T21:22:15Z,2021-01-23T03:58:35Z,2021-01-23T03:58:35Z,MERGED,True,46,29,8,https://github.com/Rosalie241,Add M64CMD_ROM_SET_SETTINGS,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/788,https://github.com/Rosalie241,4,https://github.com/mupen64plus/mupen64plus-core/pull/788#issuecomment-718485428,"This PR allows a front-end to 'modify' game settings until the ROM is closed, this allows for per game settings like what Project64 has
imagine something like this:

Front-end has emulation running and provides a settings window, settings window provides per game options (i.e plugin selection, countperop, save type, etc)
Front-end saves those settings to i.e a third party configuration file
Next time front-end loads emulation, it'll execute M64CMD_ROM_SET_SETTINGS after the ROM has been opened & before emulation is launched","@richard42 this PR breaks existing front-ends, because M64CMD_EXECUTE has been moved +1, so now when existing front-ends call M64CMD_EXECUTE, they'll actually call M64CMD_ROM_SET_SETTINGS. That's why I changed the version number to 3.0.0",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,788,2020-10-22T21:22:15Z,2021-01-23T03:58:35Z,2021-01-23T03:58:35Z,MERGED,True,46,29,8,https://github.com/Rosalie241,Add M64CMD_ROM_SET_SETTINGS,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/788,https://github.com/Rosalie241,5,https://github.com/mupen64plus/mupen64plus-core/pull/788#issuecomment-718709054,"This PR allows a front-end to 'modify' game settings until the ROM is closed, this allows for per game settings like what Project64 has
imagine something like this:

Front-end has emulation running and provides a settings window, settings window provides per game options (i.e plugin selection, countperop, save type, etc)
Front-end saves those settings to i.e a third party configuration file
Next time front-end loads emulation, it'll execute M64CMD_ROM_SET_SETTINGS after the ROM has been opened & before emulation is launched","As a workaround to the issue explained above, I've moved M64CMD_ROM_SET_SETTINGS to the bottom of m64p_command and changed the version to 2.1.4",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,789,2020-10-23T05:33:27Z,2021-10-25T23:51:39Z,2021-10-26T03:29:38Z,MERGED,True,70,33,15,None,Add count factor overclock,19,[],https://github.com/mupen64plus/mupen64plus-core/pull/789,None,1,https://github.com/mupen64plus/mupen64plus-core/pull/789,"This hack reduces count accumulation (all core) by half. This improves performance in many titles such as GoldenEye, Perfect Dark, Re-Volt, Road Rash.
The overclock is mostly untested apart from the mentioned titles.","This hack reduces count accumulation (all core) by half. This improves performance in many titles such as GoldenEye, Perfect Dark, Re-Volt, Road Rash.
The overclock is mostly untested apart from the mentioned titles.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,789,2020-10-23T05:33:27Z,2021-10-25T23:51:39Z,2021-10-26T03:29:38Z,MERGED,True,70,33,15,None,Add count factor overclock,19,[],https://github.com/mupen64plus/mupen64plus-core/pull/789,https://github.com/m4xw,2,https://github.com/mupen64plus/mupen64plus-core/pull/789#issuecomment-715265871,"This hack reduces count accumulation (all core) by half. This improves performance in many titles such as GoldenEye, Perfect Dark, Re-Volt, Road Rash.
The overclock is mostly untested apart from the mentioned titles.","cc @Gillou68310 as discussed
@carnivoroussociety On a side note, you think its worth to expose the actual factor as a option?
Or has there been diminishing benefit with other values?
Also the netplay change needs a protocol version bump (cc @loganmc10 , thoughts on handling that?)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,789,2020-10-23T05:33:27Z,2021-10-25T23:51:39Z,2021-10-26T03:29:38Z,MERGED,True,70,33,15,None,Add count factor overclock,19,[],https://github.com/mupen64plus/mupen64plus-core/pull/789,None,3,https://github.com/mupen64plus/mupen64plus-core/pull/789#issuecomment-715273537,"This hack reduces count accumulation (all core) by half. This improves performance in many titles such as GoldenEye, Perfect Dark, Re-Volt, Road Rash.
The overclock is mostly untested apart from the mentioned titles.","The factor itself was picked because it was the most compatible, having a lower value showed major improvements in GoldenEye and Perfect Dark, but many other titles crashed before reaching the main menu. Speaking of, I've noticed that Indiana Jones and Conker both don't reach the menu when using the same constant rate value as the libretro fork (4), and when I used the new dynamic recompiler core, only Indiana Jones worked. Both of these games work in the libretro fork fork without issues.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,789,2020-10-23T05:33:27Z,2021-10-25T23:51:39Z,2021-10-26T03:29:38Z,MERGED,True,70,33,15,None,Add count factor overclock,19,[],https://github.com/mupen64plus/mupen64plus-core/pull/789,https://github.com/m4xw,4,https://github.com/mupen64plus/mupen64plus-core/pull/789#issuecomment-715276891,"This hack reduces count accumulation (all core) by half. This improves performance in many titles such as GoldenEye, Perfect Dark, Re-Volt, Road Rash.
The overclock is mostly untested apart from the mentioned titles.",Does it actually crash?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,789,2020-10-23T05:33:27Z,2021-10-25T23:51:39Z,2021-10-26T03:29:38Z,MERGED,True,70,33,15,None,Add count factor overclock,19,[],https://github.com/mupen64plus/mupen64plus-core/pull/789,None,5,https://github.com/mupen64plus/mupen64plus-core/pull/789#issuecomment-715280156,"This hack reduces count accumulation (all core) by half. This improves performance in many titles such as GoldenEye, Perfect Dark, Re-Volt, Road Rash.
The overclock is mostly untested apart from the mentioned titles.","Conker softlocks at the Nintendo logo, same thing happened in the libretro fork, 4 was the lowest value I could use before this would happen, and the lowest value I can use with this core is 6.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,789,2020-10-23T05:33:27Z,2021-10-25T23:51:39Z,2021-10-26T03:29:38Z,MERGED,True,70,33,15,None,Add count factor overclock,19,[],https://github.com/mupen64plus/mupen64plus-core/pull/789,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/789#issuecomment-715431611,"This hack reduces count accumulation (all core) by half. This improves performance in many titles such as GoldenEye, Perfect Dark, Re-Volt, Road Rash.
The overclock is mostly untested apart from the mentioned titles.","I'd be curious to hear @Gillou68310 or @bsmiles32 thoughts on this.
This is a really odd way to do this to be honest. This sort of emulates an unstable/variable clock rate. Adding 6 to CP0_COUNT every time cp0_update_count is executed is sort of arbitrary (it won't emulate a steady clock rate). I would suspect a lot of games would have stability issues, or issues with timers/clocks.
I think it would be better to just divide ((*r4300_pc(r4300) - cp0->last_addr) >> 2) by some factor, that way you'd get a (mostly) consistent emulated clock rate.
As for the netplay question, yes you just need to increment this: https://github.com/mupen64plus/mupen64plus-core/blob/master/src/main/netplay.h#L29 if there are changes made to the netplay code.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,789,2020-10-23T05:33:27Z,2021-10-25T23:51:39Z,2021-10-26T03:29:38Z,MERGED,True,70,33,15,None,Add count factor overclock,19,[],https://github.com/mupen64plus/mupen64plus-core/pull/789,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/789#issuecomment-715433432,"This hack reduces count accumulation (all core) by half. This improves performance in many titles such as GoldenEye, Perfect Dark, Re-Volt, Road Rash.
The overclock is mostly untested apart from the mentioned titles.","Actually sorry on the netplay question, this is what needs to be incremented:

  
    
      mupen64plus-core/src/main/version.h
    
    
         Line 34
      in
      6019724
    
  
  
    

        
          
           #define NETPLAY_API_VERSION  0x010000 
        
    
  


Since the packet format is changing, also https://github.com/mupen64plus/mupen64plus-core/blob/master/doc/emuwiki-api-doc/Mupen64Plus-v2.0-Netplay-API.mediawiki would need to be updated",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,789,2020-10-23T05:33:27Z,2021-10-25T23:51:39Z,2021-10-26T03:29:38Z,MERGED,True,70,33,15,None,Add count factor overclock,19,[],https://github.com/mupen64plus/mupen64plus-core/pull/789,None,8,https://github.com/mupen64plus/mupen64plus-core/pull/789#issuecomment-715449070,"This hack reduces count accumulation (all core) by half. This improves performance in many titles such as GoldenEye, Perfect Dark, Re-Volt, Road Rash.
The overclock is mostly untested apart from the mentioned titles.","This is a really odd way to do this to be honest. This sort of emulates an unstable/variable clock rate. Adding 6 to CP0_COUNT every time cp0_update_count is executed is sort of arbitrary (it won't emulate a steady clock rate). I would suspect a lot of games would have stability issues, or issues with timers/clocks.
I think it would be better to just divide ((*r4300_pc(r4300) - cp0->last_addr) >> 2) by some factor, that way you'd get a (mostly) consistent emulated clock rate.

I agree, it's a terrible hack that ended up working good enough for the more popular games. When I have time tomorrow I'll try out using a shift and addition instead of a constant rate. Thank you for the feedback!",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,789,2020-10-23T05:33:27Z,2021-10-25T23:51:39Z,2021-10-26T03:29:38Z,MERGED,True,70,33,15,None,Add count factor overclock,19,[],https://github.com/mupen64plus/mupen64plus-core/pull/789,None,9,https://github.com/mupen64plus/mupen64plus-core/pull/789#issuecomment-715655444,"This hack reduces count accumulation (all core) by half. This improves performance in many titles such as GoldenEye, Perfect Dark, Re-Volt, Road Rash.
The overclock is mostly untested apart from the mentioned titles.","I've changed the calculation to Logan's suggestion, testing confirms a lot more stable however Conker still softlocks (Indiana Jones is fine). If I increase shift to 4 Conker works however the speed difference compared to using count_per_op 1 is negligible. Interrupter and recompiler both use the same calculation and appear to work.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,789,2020-10-23T05:33:27Z,2021-10-25T23:51:39Z,2021-10-26T03:29:38Z,MERGED,True,70,33,15,None,Add count factor overclock,19,[],https://github.com/mupen64plus/mupen64plus-core/pull/789,None,10,https://github.com/mupen64plus/mupen64plus-core/pull/789#issuecomment-719887932,"This hack reduces count accumulation (all core) by half. This improves performance in many titles such as GoldenEye, Perfect Dark, Re-Volt, Road Rash.
The overclock is mostly untested apart from the mentioned titles.","@carnivoroussociety On a side note, you think its worth to expose the actual factor as a option?

EnableOverclock is now used as a overclock factor variable - from a brief test it appears to work quite well.
Setting EnableOverclock = 1 provides a 50% speed improvement over just using CountPerOp = 1, with each increase of EnableOverclock it will reduce count by half every time. I've set a hard limit to 50 as any higher gets diminishing returns with increased instability.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,789,2020-10-23T05:33:27Z,2021-10-25T23:51:39Z,2021-10-26T03:29:38Z,MERGED,True,70,33,15,None,Add count factor overclock,19,[],https://github.com/mupen64plus/mupen64plus-core/pull/789,https://github.com/bsmiles32,11,https://github.com/mupen64plus/mupen64plus-core/pull/789#issuecomment-739881440,"This hack reduces count accumulation (all core) by half. This improves performance in many titles such as GoldenEye, Perfect Dark, Re-Volt, Road Rash.
The overclock is mostly untested apart from the mentioned titles.","Not a huge fan of the current implementation (but this is just me and doesn't necessarily reflect other opinions).
If I understand well, your new computation of count update could be reduced to :
count = (delta PC) >> (2+oc_factor);

Since I don't really like having to maintain 2 separate way of doing the update count computation, if we were to merge the new computation we could instead do as follow:
count = (delta PC) >> 2;
count *= count_per_op;
count >>= oc_factor;

This would generalize the current count computation to allow ""count_per_op = N / (2^K)"", with N = current count_per_op value and K = oc_factor, without much added overhead/maintenance burden.
In such a case I would rather rename the oc_factor to something more meaningful (subjective) such as count_per_op_denom_pot (pot = Power Of Two).
Using a 2^K denominator provides some more flexibility regarding count_per_op, without much cost (single right shift), whereas an integer denominator  would require a division and would not be practical. So that's a good point. Also, setting K=0 will simplify to current behavior so that's another good point.
So maybe with the mentioned changes it would get better chances of getting merged.
What do you think ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,789,2020-10-23T05:33:27Z,2021-10-25T23:51:39Z,2021-10-26T03:29:38Z,MERGED,True,70,33,15,None,Add count factor overclock,19,[],https://github.com/mupen64plus/mupen64plus-core/pull/789,None,12,https://github.com/mupen64plus/mupen64plus-core/pull/789#issuecomment-739914262,"This hack reduces count accumulation (all core) by half. This improves performance in many titles such as GoldenEye, Perfect Dark, Re-Volt, Road Rash.
The overclock is mostly untested apart from the mentioned titles.","Thank you for the feedback. The hack works a little different than count = (delta PC) >> (2+oc_factor);. From testing I've found that shifting right using the overclock factor is unstable at the same overclock value, compared to shifting once on a loop. GoldenEye doesn't even make it to the logo using an overclock factor of 3, and crashes in-game with a value of 2. By using the loop it'll ensure count won't shift until zero. I could add a 1+ so it'll always be above zero, however that isn't much better than using the fixed count rate method I had originally. Perhaps I misinterpreted what you said and your described method is exposing a flaw in the hack itself.
I branched the stock/overclock update calculation as I wasn't sure if count_factor should be included, but I'll change it so there isn't a branch, thanks again for the feedback.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,789,2020-10-23T05:33:27Z,2021-10-25T23:51:39Z,2021-10-26T03:29:38Z,MERGED,True,70,33,15,None,Add count factor overclock,19,[],https://github.com/mupen64plus/mupen64plus-core/pull/789,https://github.com/bsmiles32,13,https://github.com/mupen64plus/mupen64plus-core/pull/789#issuecomment-740042393,"This hack reduces count accumulation (all core) by half. This improves performance in many titles such as GoldenEye, Perfect Dark, Re-Volt, Road Rash.
The overclock is mostly untested apart from the mentioned titles.","OK, I see my mistake here. You need division by 2^K but rounded up, not truncated.
You could do as follow then to avoid rounding to zero:
count = (delta PC) >> 2;
count *= count_per_op;
count += (1 << oc_factor) - 1
count >>= oc_factor;",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,789,2020-10-23T05:33:27Z,2021-10-25T23:51:39Z,2021-10-26T03:29:38Z,MERGED,True,70,33,15,None,Add count factor overclock,19,[],https://github.com/mupen64plus/mupen64plus-core/pull/789,None,14,https://github.com/mupen64plus/mupen64plus-core/pull/789#issuecomment-740096377,"This hack reduces count accumulation (all core) by half. This improves performance in many titles such as GoldenEye, Perfect Dark, Re-Volt, Road Rash.
The overclock is mostly untested apart from the mentioned titles.",That works perfectly thank you. I'll redo the adjustments along with renaming the overclock variable to your suggestion as it does make more sense.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,789,2020-10-23T05:33:27Z,2021-10-25T23:51:39Z,2021-10-26T03:29:38Z,MERGED,True,70,33,15,None,Add count factor overclock,19,[],https://github.com/mupen64plus/mupen64plus-core/pull/789,None,15,https://github.com/mupen64plus/mupen64plus-core/pull/789#issuecomment-802818304,"This hack reduces count accumulation (all core) by half. This improves performance in many titles such as GoldenEye, Perfect Dark, Re-Volt, Road Rash.
The overclock is mostly untested apart from the mentioned titles.","Any progress for this PR? I've incorporated the feedback given by logan and bsmiles, and OC works the same across all cores.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,789,2020-10-23T05:33:27Z,2021-10-25T23:51:39Z,2021-10-26T03:29:38Z,MERGED,True,70,33,15,None,Add count factor overclock,19,[],https://github.com/mupen64plus/mupen64plus-core/pull/789,https://github.com/Gillou68310,16,https://github.com/mupen64plus/mupen64plus-core/pull/789#issuecomment-802847044,"This hack reduces count accumulation (all core) by half. This improves performance in many titles such as GoldenEye, Perfect Dark, Re-Volt, Road Rash.
The overclock is mostly untested apart from the mentioned titles.",The implementation for the new dynarec is not complete rn. I can help fixing it but I got other things I'd like to merge to the new dynarec before we can consider merging this. Sorry for the delay...,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,789,2020-10-23T05:33:27Z,2021-10-25T23:51:39Z,2021-10-26T03:29:38Z,MERGED,True,70,33,15,None,Add count factor overclock,19,[],https://github.com/mupen64plus/mupen64plus-core/pull/789,https://github.com/loganmc10,17,https://github.com/mupen64plus/mupen64plus-core/pull/789#issuecomment-856371587,"This hack reduces count accumulation (all core) by half. This improves performance in many titles such as GoldenEye, Perfect Dark, Re-Volt, Road Rash.
The overclock is mostly untested apart from the mentioned titles.","My vote would be to merge this, it's off by default so there is no harm done to the new dynarec. If someone wants to submit a further PR to fix up the new dynarec they could.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,789,2020-10-23T05:33:27Z,2021-10-25T23:51:39Z,2021-10-26T03:29:38Z,MERGED,True,70,33,15,None,Add count factor overclock,19,[],https://github.com/mupen64plus/mupen64plus-core/pull/789,https://github.com/Gillou68310,18,https://github.com/mupen64plus/mupen64plus-core/pull/789#issuecomment-856633242,"This hack reduces count accumulation (all core) by half. This improves performance in many titles such as GoldenEye, Perfect Dark, Re-Volt, Road Rash.
The overclock is mostly untested apart from the mentioned titles.","I didn't look at the current implementation in detail, but what is the goal here? Add more granularity to the counter per ops? Like if counter per ops was actually a fractional number?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,789,2020-10-23T05:33:27Z,2021-10-25T23:51:39Z,2021-10-26T03:29:38Z,MERGED,True,70,33,15,None,Add count factor overclock,19,[],https://github.com/mupen64plus/mupen64plus-core/pull/789,None,19,https://github.com/mupen64plus/mupen64plus-core/pull/789#issuecomment-858209508,"This hack reduces count accumulation (all core) by half. This improves performance in many titles such as GoldenEye, Perfect Dark, Re-Volt, Road Rash.
The overclock is mostly untested apart from the mentioned titles.","Like if counter per ops was actually a fractional number?

Yes, so that greater count delta spikes are reduced while not breaking during DMA or critical timing segments in games - unlike the previous hack I implemented (constant count).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,789,2020-10-23T05:33:27Z,2021-10-25T23:51:39Z,2021-10-26T03:29:38Z,MERGED,True,70,33,15,None,Add count factor overclock,19,[],https://github.com/mupen64plus/mupen64plus-core/pull/789,None,20,https://github.com/mupen64plus/mupen64plus-core/pull/789#issuecomment-951525837,"This hack reduces count accumulation (all core) by half. This improves performance in many titles such as GoldenEye, Perfect Dark, Re-Volt, Road Rash.
The overclock is mostly untested apart from the mentioned titles.",Thank you!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,791,2020-10-26T17:10:12Z,2021-02-20T16:45:36Z,2021-02-20T16:45:36Z,MERGED,True,96,4,6,https://github.com/Rosalie241,Allow front-ends to override user paths ,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/791,https://github.com/Rosalie241,1,https://github.com/mupen64plus/mupen64plus-core/pull/791,"This PR introduces ConfigOverrideUserPaths, allowing a front-end to override the user paths returned by ConfigGetUserDataPath and ConfigGetUserCachePath","This PR introduces ConfigOverrideUserPaths, allowing a front-end to override the user paths returned by ConfigGetUserDataPath and ConfigGetUserCachePath",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,791,2020-10-26T17:10:12Z,2021-02-20T16:45:36Z,2021-02-20T16:45:36Z,MERGED,True,96,4,6,https://github.com/Rosalie241,Allow front-ends to override user paths ,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/791,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/791#issuecomment-716702994,"This PR introduces ConfigOverrideUserPaths, allowing a front-end to override the user paths returned by ConfigGetUserDataPath and ConfigGetUserCachePath","Unfortunately I don't think this is the right approach. Shared data is things like mupen64plus.ini, on a traditional Linux install this would be located at /use/share/mupen64plus (not user writable).
User data would be in the users home directory.
For instance with m64p I override the shared data to be in the same directory as the exe, but that's not where I want the user data",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,791,2020-10-26T17:10:12Z,2021-02-20T16:45:36Z,2021-02-20T16:45:36Z,MERGED,True,96,4,6,https://github.com/Rosalie241,Allow front-ends to override user paths ,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/791,https://github.com/Rosalie241,3,https://github.com/mupen64plus/mupen64plus-core/pull/791#issuecomment-716706270,"This PR introduces ConfigOverrideUserPaths, allowing a front-end to override the user paths returned by ConfigGetUserDataPath and ConfigGetUserCachePath",@loganmc10 do you propose I should modify the plugins to use the ConfigGetSharedDataFilepath instead?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,791,2020-10-26T17:10:12Z,2021-02-20T16:45:36Z,2021-02-20T16:45:36Z,MERGED,True,96,4,6,https://github.com/Rosalie241,Allow front-ends to override user paths ,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/791,https://github.com/Rosalie241,4,https://github.com/mupen64plus/mupen64plus-core/pull/791#issuecomment-716709471,"This PR introduces ConfigOverrideUserPaths, allowing a front-end to override the user paths returned by ConfigGetUserDataPath and ConfigGetUserCachePath","Another thing I'd like to note is that you can override the path for  ConfigGetUserConfigPath, so it seems kinda inconsistent if you can't override the path for ConfigGetUserDataPath and ConfigGetUserCachePath aswell in my opinion",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,791,2020-10-26T17:10:12Z,2021-02-20T16:45:36Z,2021-02-20T16:45:36Z,MERGED,True,96,4,6,https://github.com/Rosalie241,Allow front-ends to override user paths ,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/791,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/791#issuecomment-716723431,"This PR introduces ConfigOverrideUserPaths, allowing a front-end to override the user paths returned by ConfigGetUserDataPath and ConfigGetUserCachePath","I don't think you can count on ConfigGetSharedDataFilepath being writeable, so I wouldn't try to have plugins write there.
Adding an override path for ConfigGetUserDataPath makes the most sense to me.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,791,2020-10-26T17:10:12Z,2021-02-20T16:45:36Z,2021-02-20T16:45:36Z,MERGED,True,96,4,6,https://github.com/Rosalie241,Allow front-ends to override user paths ,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/791,https://github.com/Rosalie241,6,https://github.com/mupen64plus/mupen64plus-core/pull/791#issuecomment-716725657,"This PR introduces ConfigOverrideUserPaths, allowing a front-end to override the user paths returned by ConfigGetUserDataPath and ConfigGetUserCachePath","That's a good idea, but considering I have #792 open aswell, I think it'd be better to create a new function, i.e ConfigOverrideUserPaths(char *DataPath, char *CachePath) to avoid breaking the front-end API.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,791,2020-10-26T17:10:12Z,2021-02-20T16:45:36Z,2021-02-20T16:45:36Z,MERGED,True,96,4,6,https://github.com/Rosalie241,Allow front-ends to override user paths ,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/791,https://github.com/richard42,7,https://github.com/mupen64plus/mupen64plus-core/pull/791#issuecomment-718360146,"This PR introduces ConfigOverrideUserPaths, allowing a front-end to override the user paths returned by ConfigGetUserDataPath and ConfigGetUserCachePath","I kind of don't like having a separate function to supply override values for these two paths, but I agree with you that this is preferable to breaking the front-end API.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,791,2020-10-26T17:10:12Z,2021-02-20T16:45:36Z,2021-02-20T16:45:36Z,MERGED,True,96,4,6,https://github.com/Rosalie241,Allow front-ends to override user paths ,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/791,https://github.com/Rosalie241,8,https://github.com/mupen64plus/mupen64plus-core/pull/791#issuecomment-766142816,"This PR introduces ConfigOverrideUserPaths, allowing a front-end to override the user paths returned by ConfigGetUserDataPath and ConfigGetUserCachePath",@richard42 what do you think of this patch in it's current state?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,791,2020-10-26T17:10:12Z,2021-02-20T16:45:36Z,2021-02-20T16:45:36Z,MERGED,True,96,4,6,https://github.com/Rosalie241,Allow front-ends to override user paths ,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/791,https://github.com/richard42,9,https://github.com/mupen64plus/mupen64plus-core/pull/791#issuecomment-782551465,"This PR introduces ConfigOverrideUserPaths, allowing a front-end to override the user paths returned by ConfigGetUserDataPath and ConfigGetUserCachePath","Everything looks good except for one minor issue.  If the front-end calls this Override function twice in row with non-null path strings, then during the second call it will leak the memory that it allocated for the path string in the first call. Just a small fix for this in 2 places in the override function and I think it should be good to merge.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,791,2020-10-26T17:10:12Z,2021-02-20T16:45:36Z,2021-02-20T16:45:36Z,MERGED,True,96,4,6,https://github.com/Rosalie241,Allow front-ends to override user paths ,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/791,https://github.com/Rosalie241,10,https://github.com/mupen64plus/mupen64plus-core/pull/791#issuecomment-782596324,"This PR introduces ConfigOverrideUserPaths, allowing a front-end to override the user paths returned by ConfigGetUserDataPath and ConfigGetUserCachePath","Good catch, fixed!",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,792,2020-10-26T17:26:24Z,2020-10-29T12:30:23Z,2020-10-29T12:30:31Z,CLOSED,False,27,9,7,https://github.com/Rosalie241,Allow front-ends to specify cache directory,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/792,https://github.com/Rosalie241,1,https://github.com/mupen64plus/mupen64plus-core/pull/792,This PR allows front-ends to specify a cache directory,This PR allows front-ends to specify a cache directory,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,792,2020-10-26T17:26:24Z,2020-10-29T12:30:23Z,2020-10-29T12:30:31Z,CLOSED,False,27,9,7,https://github.com/Rosalie241,Allow front-ends to specify cache directory,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/792,https://github.com/Rosalie241,2,https://github.com/mupen64plus/mupen64plus-core/pull/792#issuecomment-718721568,This PR allows front-ends to specify a cache directory,see #791,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,793,2020-10-28T02:18:19Z,2020-10-29T05:09:58Z,2021-06-20T20:47:09Z,MERGED,True,4,3,2,https://github.com/loganmc10,Just stop frontend from enabling cheats during netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/793,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/793,"The current code blocks all cheats during netplay. This also includes hacks from mupen64plus.ini . mupen64plus.ini currently includes a hack to fix Mario Kart multiplayer timing.
This revision just blocks the frontend from enabling cheats, but allows hacks included in mupen64plus.ini to be applied. This is OK since it won't cause desyncs (every client will apply the same hack).","The current code blocks all cheats during netplay. This also includes hacks from mupen64plus.ini . mupen64plus.ini currently includes a hack to fix Mario Kart multiplayer timing.
This revision just blocks the frontend from enabling cheats, but allows hacks included in mupen64plus.ini to be applied. This is OK since it won't cause desyncs (every client will apply the same hack).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,794,2020-10-28T20:12:42Z,2020-10-29T05:11:36Z,2021-06-20T20:47:10Z,MERGED,True,12,0,1,https://github.com/loganmc10,Clean up netplay linked list,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/794,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/794,"When I wrote the netplay code I neglected to clean up the linked list used to store the local input buffer.
This just frees any items in the linked list when netplay is closed","When I wrote the netplay code I neglected to clean up the linked list used to store the local input buffer.
This just frees any items in the linked list when netplay is closed",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,796,2020-11-02T03:22:58Z,2021-02-26T16:10:05Z,2021-06-20T20:47:12Z,MERGED,True,19,2,1,https://github.com/loganmc10,Align memory for parallel-rdp,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/796,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/796,"Port from libretro/mupen64plus-libretro-nx@29ffb30#diff-bf40cfecf6b954a6a6074a40e19efbb0bdc1a4997ec7f014dce41647d8a9038a
@m4xw can you review this and let me know if it looks right? I believe this is sort of step 1 to allowing Parallel RDP to work upstream. If there is anything else that needs to happen in the core (besides a Vulkan interface) please let me know","Port from libretro/mupen64plus-libretro-nx@29ffb30#diff-bf40cfecf6b954a6a6074a40e19efbb0bdc1a4997ec7f014dce41647d8a9038a
@m4xw can you review this and let me know if it looks right? I believe this is sort of step 1 to allowing Parallel RDP to work upstream. If there is anything else that needs to happen in the core (besides a Vulkan interface) please let me know",True,{'EYES': ['https://github.com/Jj0YzL5nvJ']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,796,2020-11-02T03:22:58Z,2021-02-26T16:10:05Z,2021-06-20T20:47:12Z,MERGED,True,19,2,1,https://github.com/loganmc10,Align memory for parallel-rdp,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/796,https://github.com/m4xw,2,https://github.com/mupen64plus/mupen64plus-core/pull/796#issuecomment-786586062,"Port from libretro/mupen64plus-libretro-nx@29ffb30#diff-bf40cfecf6b954a6a6074a40e19efbb0bdc1a4997ec7f014dce41647d8a9038a
@m4xw can you review this and let me know if it looks right? I believe this is sort of step 1 to allowing Parallel RDP to work upstream. If there is anything else that needs to happen in the core (besides a Vulkan interface) please let me know","This was my original diff (for reference), so identical, other than not using the HAVE_PARALLEL_RDP define (which we discussed together with Gillou and chose to always align the memory since it has virtually no downside).
Lgtm.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,798,2020-11-11T19:48:24Z,2021-01-23T05:00:13Z,2021-01-23T05:00:13Z,MERGED,True,27,25,1,https://github.com/Rosalie241,Allow customizable save slot keybindings,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/798,https://github.com/Rosalie241,1,https://github.com/mupen64plus/mupen64plus-core/pull/798,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,798,2020-11-11T19:48:24Z,2021-01-23T05:00:13Z,2021-01-23T05:00:13Z,MERGED,True,27,25,1,https://github.com/Rosalie241,Allow customizable save slot keybindings,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/798,https://github.com/richard42,2,https://github.com/mupen64plus/mupen64plus-core/pull/798#issuecomment-765867669,,"This is great; I really like your attention to detail, and the fact that you fix up the code comments along with your changes.  The only other thing that's missing with this change is to add the new config parameters to the Mupen64Plus_Core_Parameters wiki page in the core repository.  If you can send a pull request for this change as well I will merge it too. Thanks!",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,799,2020-11-15T23:52:31Z,2020-11-16T17:43:31Z,2020-11-16T17:43:31Z,CLOSED,False,17,2,4,https://github.com/joeldenning,Add support for netplay input delay.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/799,https://github.com/joeldenning,1,https://github.com/mupen64plus/mupen64plus-core/pull/799,"This is my first substantive contribution to mupen64plus-core - I am working on a netplay implementation that uses client-side input delay and this change lets that happen. An alternative implementation is to implement input delay on the server side - I'm open to switching to that if you think that that approach is better.
Looking forward to any feedback on this - happy to discuss any of the particulars.","This is my first substantive contribution to mupen64plus-core - I am working on a netplay implementation that uses client-side input delay and this change lets that happen. An alternative implementation is to implement input delay on the server side - I'm open to switching to that if you think that that approach is better.
Looking forward to any feedback on this - happy to discuss any of the particulars.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,799,2020-11-15T23:52:31Z,2020-11-16T17:43:31Z,2020-11-16T17:43:31Z,CLOSED,False,17,2,4,https://github.com/joeldenning,Add support for netplay input delay.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/799,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/799#issuecomment-727708611,"This is my first substantive contribution to mupen64plus-core - I am working on a netplay implementation that uses client-side input delay and this change lets that happen. An alternative implementation is to implement input delay on the server side - I'm open to switching to that if you think that that approach is better.
Looking forward to any feedback on this - happy to discuss any of the particulars.","I think this would probably be easier to implement on the GUI/server side. For instance in m64p-netplay-server
https://github.com/m64p/m64p-netplay-server/blob/master/udpServer.cpp#L106
count = qFromBigEndian<quint32>(&incomingData.data()[2]);
count += input_delay;

Will accomplish the exact same thing, you can just add an option to the GUI and pass it to the server. You could even bundle it with your other change, where use_client_count represents the input delay (if it's 0 it's disabled, if it's a positive number, that is the input delay)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,799,2020-11-15T23:52:31Z,2020-11-16T17:43:31Z,2020-11-16T17:43:31Z,CLOSED,False,17,2,4,https://github.com/joeldenning,Add support for netplay input delay.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/799,https://github.com/joeldenning,3,https://github.com/mupen64plus/mupen64plus-core/pull/799#issuecomment-728218601,"This is my first substantive contribution to mupen64plus-core - I am working on a netplay implementation that uses client-side input delay and this change lets that happen. An alternative implementation is to implement input delay on the server side - I'm open to switching to that if you think that that approach is better.
Looking forward to any feedback on this - happy to discuss any of the particulars.",Fair enough - I'll close this in favor of implementing this server-side,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,801,2020-11-30T17:32:53Z,2020-12-01T17:22:20Z,2021-02-01T11:19:01Z,MERGED,True,14,6,2,https://github.com/bsmiles32,Fixes,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/801,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/801,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,801,2020-11-30T17:32:53Z,2020-12-01T17:22:20Z,2021-02-01T11:19:01Z,MERGED,True,14,6,2,https://github.com/bsmiles32,Fixes,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/801,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/801#issuecomment-736698716,,"Looks good to me, thanks!",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,802,2020-12-01T16:00:54Z,,2022-01-24T15:52:59Z,OPEN,False,88,41,6,https://github.com/Rosalie241,Allow 64DD disks to boot without N64 cart,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/802,https://github.com/Rosalie241,1,https://github.com/mupen64plus/mupen64plus-core/pull/802,"this PR is still WIP,
the main goal is to allow 64DD games to boot without requiring a N64 cart ROM.
I opened this PR early because I wanted some feedback on the changes I've made so far (mainly in open_rom & main_run)
the main things TODO are:

rework is_dd_rom
split load_dd_disk into separate functions,

note that this already functions as-is on ndd roms
cc @bsmiles32","this PR is still WIP,
the main goal is to allow 64DD games to boot without requiring a N64 cart ROM.
I opened this PR early because I wanted some feedback on the changes I've made so far (mainly in open_rom & main_run)
the main things TODO are:

rework is_dd_rom
split load_dd_disk into separate functions,

note that this already functions as-is on ndd roms
cc @bsmiles32",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,802,2020-12-01T16:00:54Z,,2022-01-24T15:52:59Z,OPEN,False,88,41,6,https://github.com/Rosalie241,Allow 64DD disks to boot without N64 cart,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/802,https://github.com/Mastergatto,2,https://github.com/mupen64plus/mupen64plus-core/pull/802#issuecomment-737196353,"this PR is still WIP,
the main goal is to allow 64DD games to boot without requiring a N64 cart ROM.
I opened this PR early because I wanted some feedback on the changes I've made so far (mainly in open_rom & main_run)
the main things TODO are:

rework is_dd_rom
split load_dd_disk into separate functions,

note that this already functions as-is on ndd roms
cc @bsmiles32","Not a dev here, but I'm asking you anyways this.
Is this PR compatible with #762? Did you have some coordination with @LuigiBlood on this? AFAIK he's currently working on 64DD too.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,802,2020-12-01T16:00:54Z,,2022-01-24T15:52:59Z,OPEN,False,88,41,6,https://github.com/Rosalie241,Allow 64DD disks to boot without N64 cart,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/802,https://github.com/Rosalie241,3,https://github.com/mupen64plus/mupen64plus-core/pull/802#issuecomment-737198861,"this PR is still WIP,
the main goal is to allow 64DD games to boot without requiring a N64 cart ROM.
I opened this PR early because I wanted some feedback on the changes I've made so far (mainly in open_rom & main_run)
the main things TODO are:

rework is_dd_rom
split load_dd_disk into separate functions,

note that this already functions as-is on ndd roms
cc @bsmiles32","Not a dev here, but I'm asking you anyways this.
Is this PR compatible with #762? Did you have some coordination with @LuigiBlood on this? AFAIK he's currently working on 64DD too.

it's not compatible right now, I think I'll wait for #762 to be finished & merged before I continue work on this PR,
LuigiBlood is aware of this PR but I'm not entirely sure if he wants to implement the functionality this PR wants to implement,
if he wants to, then he could take inspiration from this PR but that's upto him.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,802,2020-12-01T16:00:54Z,,2022-01-24T15:52:59Z,OPEN,False,88,41,6,https://github.com/Rosalie241,Allow 64DD disks to boot without N64 cart,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/802,https://github.com/Mastergatto,4,https://github.com/mupen64plus/mupen64plus-core/pull/802#issuecomment-737205587,"this PR is still WIP,
the main goal is to allow 64DD games to boot without requiring a N64 cart ROM.
I opened this PR early because I wanted some feedback on the changes I've made so far (mainly in open_rom & main_run)
the main things TODO are:

rework is_dd_rom
split load_dd_disk into separate functions,

note that this already functions as-is on ndd roms
cc @bsmiles32","As long as you both are aware of each other's PR, that's good. Thanks for your work on this, I think this is a nice feature to have on M64+.",True,{'THUMBS_UP': ['https://github.com/Rosalie241']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,802,2020-12-01T16:00:54Z,,2022-01-24T15:52:59Z,OPEN,False,88,41,6,https://github.com/Rosalie241,Allow 64DD disks to boot without N64 cart,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/802,https://github.com/LuigiBlood,5,https://github.com/mupen64plus/mupen64plus-core/pull/802#issuecomment-739253059,"this PR is still WIP,
the main goal is to allow 64DD games to boot without requiring a N64 cart ROM.
I opened this PR early because I wanted some feedback on the changes I've made so far (mainly in open_rom & main_run)
the main things TODO are:

rework is_dd_rom
split load_dd_disk into separate functions,

note that this already functions as-is on ndd roms
cc @bsmiles32",Feel free to work on this PR after the other will be merged probably soon as this functionality would be added later as @bsmiles32 would prefer splitting features in different PRs as he said in #762,True,{'HEART': ['https://github.com/Rosalie241']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,802,2020-12-01T16:00:54Z,,2022-01-24T15:52:59Z,OPEN,False,88,41,6,https://github.com/Rosalie241,Allow 64DD disks to boot without N64 cart,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/802,https://github.com/bsmiles32,6,https://github.com/mupen64plus/mupen64plus-core/pull/802#issuecomment-739884603,"this PR is still WIP,
the main goal is to allow 64DD games to boot without requiring a N64 cart ROM.
I opened this PR early because I wanted some feedback on the changes I've made so far (mainly in open_rom & main_run)
the main things TODO are:

rework is_dd_rom
split load_dd_disk into separate functions,

note that this already functions as-is on ndd roms
cc @bsmiles32","This subject is a little bit more tricky unfortunately because of how the core works.
I'll try to get back to you (either with a PR or with more precise comments) after the current DD rework.
edit: As a workaround current limitation, I select a Japanese cart ROM which has compatible ROM settings in the DB. For instance, to test Mario Studio with Transfer Pak I use the Perfect Dark (J) ROM with Mario Studio Disk.",True,{'THUMBS_UP': ['https://github.com/Rosalie241']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,802,2020-12-01T16:00:54Z,,2022-01-24T15:52:59Z,OPEN,False,88,41,6,https://github.com/Rosalie241,Allow 64DD disks to boot without N64 cart,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/802,https://github.com/Rosalie241,7,https://github.com/mupen64plus/mupen64plus-core/pull/802#issuecomment-1020246322,"this PR is still WIP,
the main goal is to allow 64DD games to boot without requiring a N64 cart ROM.
I opened this PR early because I wanted some feedback on the changes I've made so far (mainly in open_rom & main_run)
the main things TODO are:

rework is_dd_rom
split load_dd_disk into separate functions,

note that this already functions as-is on ndd roms
cc @bsmiles32","ping @bsmiles32, any ideas or progress? I could work on it myself if you give me some pointers on how to do it 'properly'",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,803,2020-12-06T11:22:47Z,2020-12-12T14:29:09Z,2021-02-01T11:13:17Z,MERGED,True,84,30,15,https://github.com/bsmiles32,storage backend save method nows know about modified byte range,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/803,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/803,"This features allows to notify storage backends about the range of modified bytes, and in turn allow them to not have to do a full data write every time save method is called, reducing the saving bandwidth requirement.
This was needed to handle 64DD saves which are several order of magnitude bigger than existing saves.
See https://github.com/bsmiles32/mupen64plus-core/tree/wip_64dd_save for possible usage of this feature.
I'd like to have this merge quickly (in the next few days), so please test and voice your concerns if any.
cc : @richard42, @loganmc10, @fzurita","This features allows to notify storage backends about the range of modified bytes, and in turn allow them to not have to do a full data write every time save method is called, reducing the saving bandwidth requirement.
This was needed to handle 64DD saves which are several order of magnitude bigger than existing saves.
See https://github.com/bsmiles32/mupen64plus-core/tree/wip_64dd_save for possible usage of this feature.
I'd like to have this merge quickly (in the next few days), so please test and voice your concerns if any.
cc : @richard42, @loganmc10, @fzurita",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,803,2020-12-06T11:22:47Z,2020-12-12T14:29:09Z,2021-02-01T11:13:17Z,MERGED,True,84,30,15,https://github.com/bsmiles32,storage backend save method nows know about modified byte range,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/803,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/803#issuecomment-739489002,"This features allows to notify storage backends about the range of modified bytes, and in turn allow them to not have to do a full data write every time save method is called, reducing the saving bandwidth requirement.
This was needed to handle 64DD saves which are several order of magnitude bigger than existing saves.
See https://github.com/bsmiles32/mupen64plus-core/tree/wip_64dd_save for possible usage of this feature.
I'd like to have this merge quickly (in the next few days), so please test and voice your concerns if any.
cc : @richard42, @loganmc10, @fzurita",also cc: @LuigiBlood,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,803,2020-12-06T11:22:47Z,2020-12-12T14:29:09Z,2021-02-01T11:13:17Z,MERGED,True,84,30,15,https://github.com/bsmiles32,storage backend save method nows know about modified byte range,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/803,https://github.com/fzurita,3,https://github.com/mupen64plus/mupen64plus-core/pull/803#issuecomment-739889549,"This features allows to notify storage backends about the range of modified bytes, and in turn allow them to not have to do a full data write every time save method is called, reducing the saving bandwidth requirement.
This was needed to handle 64DD saves which are several order of magnitude bigger than existing saves.
See https://github.com/bsmiles32/mupen64plus-core/tree/wip_64dd_save for possible usage of this feature.
I'd like to have this merge quickly (in the next few days), so please test and voice your concerns if any.
cc : @richard42, @loganmc10, @fzurita","I don't see an issue with this.
In Android, I already have to copy the while 64DD because of the Android SAF.
To be truthful, I think it would be better if the media loader API took a memory address rather than a file like the ROM loading API does. That would prevent issues with Android SAF.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,803,2020-12-06T11:22:47Z,2020-12-12T14:29:09Z,2021-02-01T11:13:17Z,MERGED,True,84,30,15,https://github.com/bsmiles32,storage backend save method nows know about modified byte range,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/803,https://github.com/bsmiles32,4,https://github.com/mupen64plus/mupen64plus-core/pull/803#issuecomment-739901602,"This features allows to notify storage backends about the range of modified bytes, and in turn allow them to not have to do a full data write every time save method is called, reducing the saving bandwidth requirement.
This was needed to handle 64DD saves which are several order of magnitude bigger than existing saves.
See https://github.com/bsmiles32/mupen64plus-core/tree/wip_64dd_save for possible usage of this feature.
I'd like to have this merge quickly (in the next few days), so please test and voice your concerns if any.
cc : @richard42, @loganmc10, @fzurita","I don't see an issue with this.

Good. Thanks!

To be truthful, I think it would be better if the media loader API took a memory address rather than a file like the ROM loading API does. That would prevent issues with Android SAF.

Could you be more specific with the Android SAF issues (sorry I'm not knowledgeable about Android dev) ?

If it is because you want memory mapped files, that may be done in the core (for the benefit of all users) via an extra ""storage backend"". Or at least that was my initial idea. Of course, it's a bit more complicated because some files have a format that is not the same as what is seen by the hardware (eg. byteswapped ROM) which greatly reduce the gains of avoiding the copy to a dedicated buffer.
If it is because of poor interface design choice (especially regarding string memory allocation/free), then yeah... I may not have made the best decision back then.
But we can still deprecate/change things if enough people want that.

It's kind of hard to draw the line of what should be done in the frontend, and what should be done in the core, and where do we move the complexity and dependencies. It's always a trade-off.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,803,2020-12-06T11:22:47Z,2020-12-12T14:29:09Z,2021-02-01T11:13:17Z,MERGED,True,84,30,15,https://github.com/bsmiles32,storage backend save method nows know about modified byte range,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/803,https://github.com/fzurita,5,https://github.com/mupen64plus/mupen64plus-core/pull/803#issuecomment-739907257,"This features allows to notify storage backends about the range of modified bytes, and in turn allow them to not have to do a full data write every time save method is called, reducing the saving bandwidth requirement.
This was needed to handle 64DD saves which are several order of magnitude bigger than existing saves.
See https://github.com/bsmiles32/mupen64plus-core/tree/wip_64dd_save for possible usage of this feature.
I'd like to have this merge quickly (in the next few days), so please test and voice your concerns if any.
cc : @richard42, @loganmc10, @fzurita","The thing with Android SAF is that it prevents applications from having direct access to user viewable storage using paths. Applications can only use paths to view internal private storage. This means that when a user provides a 64DD disk, I have to copy the file to internal storage first before I can provide a path to the core.
If the media loader API used a file handle or a memory address, I wouldn't have to copy the file to internal storage first.
The way Android SAF works is through URIs. I have to request permission to a user to view a folder or file. Once the permission is granted, I get a URI. I can use the URI to get a file handle or use a java input stream to read the whole file to memory.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,803,2020-12-06T11:22:47Z,2020-12-12T14:29:09Z,2021-02-01T11:13:17Z,MERGED,True,84,30,15,https://github.com/bsmiles32,storage backend save method nows know about modified byte range,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/803,https://github.com/bsmiles32,6,https://github.com/mupen64plus/mupen64plus-core/pull/803#issuecomment-739924794,"This features allows to notify storage backends about the range of modified bytes, and in turn allow them to not have to do a full data write every time save method is called, reducing the saving bandwidth requirement.
This was needed to handle 64DD saves which are several order of magnitude bigger than existing saves.
See https://github.com/bsmiles32/mupen64plus-core/tree/wip_64dd_save for possible usage of this feature.
I'd like to have this merge quickly (in the next few days), so please test and voice your concerns if any.
cc : @richard42, @loganmc10, @fzurita","Thanks for the explanation.
We could use a ""HACK"" to pass pointers between frontend/core by teaching the core to recognize path looking like ""buffer://<address_of_buffer_in_decimal>/<size_of_buffer_in_decimal>"". The core would then populate the storage members accordingly. The core should not take ownership of such buffer. We'd still have the problem of how to handle the ""save"" callback...
In a sense, it's an extension of current API were we currently omit the ""protocol"" (because only file:// was used). But we could extend the API to support more protocols (and default to file:// if omitted). That would bring some flexibility without breaking existing code.
Well that's just some thinking on top of my head, not necessarily something to rely on.
If you feel like discussing this further maybe you should open an issue in the issue tracker so we can gather more input from frontend writers.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,803,2020-12-06T11:22:47Z,2020-12-12T14:29:09Z,2021-02-01T11:13:17Z,MERGED,True,84,30,15,https://github.com/bsmiles32,storage backend save method nows know about modified byte range,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/803,https://github.com/Mastergatto,7,https://github.com/mupen64plus/mupen64plus-core/pull/803#issuecomment-739929170,"This features allows to notify storage backends about the range of modified bytes, and in turn allow them to not have to do a full data write every time save method is called, reducing the saving bandwidth requirement.
This was needed to handle 64DD saves which are several order of magnitude bigger than existing saves.
See https://github.com/bsmiles32/mupen64plus-core/tree/wip_64dd_save for possible usage of this feature.
I'd like to have this merge quickly (in the next few days), so please test and voice your concerns if any.
cc : @richard42, @loganmc10, @fzurita","* If it is because of poor interface design choice (especially regarding string memory allocation/free), then yeah... I may not have made the best decision back then.
  But we can still deprecate/change things if enough people want that.


Frontend 'maker' chiming in (#525 ), I was hesitant speaking about it, for the reason that the API has already settled in regarding the transfer pak and 64DD games, but I have never found a way to make the media loader work properly with my frontend; because that always result in a segmentation fault, double free or memory corruption, no matter what possible solution I have tried, that I have found by hopelessly browsing StackOverflow for days, if not weeks. Maybe I'm wrong and this theory is total BS, but I think the issue is that when I try to return the string (as an object) to the core through the media loader struct, Python will always free this returned object, and then when the core attempt to free, on its own, the same object that's already freed....
I haven't found a way to prevent Python from to do so, or to work around it. Or at least, if there is any, it probably involves changing the C code too (or even worse, the API), and unfortunately I'm not knowledgeable enough about the lower level parts of C (memory management and such) to attempt so.
Egoistically speaking, I'd like to get rid of the media loader, but unfortunately I'm not betting on it, it's just me that isn't good at programming...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,803,2020-12-06T11:22:47Z,2020-12-12T14:29:09Z,2021-02-01T11:13:17Z,MERGED,True,84,30,15,https://github.com/bsmiles32,storage backend save method nows know about modified byte range,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/803,https://github.com/bsmiles32,8,https://github.com/mupen64plus/mupen64plus-core/pull/803#issuecomment-739941296,"This features allows to notify storage backends about the range of modified bytes, and in turn allow them to not have to do a full data write every time save method is called, reducing the saving bandwidth requirement.
This was needed to handle 64DD saves which are several order of magnitude bigger than existing saves.
See https://github.com/bsmiles32/mupen64plus-core/tree/wip_64dd_save for possible usage of this feature.
I'd like to have this merge quickly (in the next few days), so please test and voice your concerns if any.
cc : @richard42, @loganmc10, @fzurita","@Mastergatto yep, I remember your issue with transerpak and strings. The issue is indeed the API where I ask the frontend to allocate a string (with malloc) but transfer the ownership (eg. the responsibility of calling free) to the core. This worked for the console-ui, because there is no cross-language magic happening, but for your Python front-end it would require your to call C malloc, copy your Python string content to the malloc'd buffer and pass it to the core. Not great. It may be indeed more sensible to do the copy inside the core and not transfering ownership between core and frontend like I did. Still we could change that.",True,{'THUMBS_UP': ['https://github.com/Mastergatto']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,803,2020-12-06T11:22:47Z,2020-12-12T14:29:09Z,2021-02-01T11:13:17Z,MERGED,True,84,30,15,https://github.com/bsmiles32,storage backend save method nows know about modified byte range,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/803,https://github.com/fzurita,9,https://github.com/mupen64plus/mupen64plus-core/pull/803#issuecomment-740012002,"This features allows to notify storage backends about the range of modified bytes, and in turn allow them to not have to do a full data write every time save method is called, reducing the saving bandwidth requirement.
This was needed to handle 64DD saves which are several order of magnitude bigger than existing saves.
See https://github.com/bsmiles32/mupen64plus-core/tree/wip_64dd_save for possible usage of this feature.
I'd like to have this merge quickly (in the next few days), so please test and voice your concerns if any.
cc : @richard42, @loganmc10, @fzurita","I crated this issue:
#804",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,808,2020-12-10T17:27:26Z,2020-12-14T10:27:30Z,2020-12-14T10:27:30Z,MERGED,True,3,2,1,https://github.com/SpiceyWolf,Fix to MacOSX building,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/808,https://github.com/SpiceyWolf,1,https://github.com/mupen64plus/mupen64plus-core/pull/808,"After some struggle and assistance in the 'issues', this was the necessary changes to make the mac stuff build","After some struggle and assistance in the 'issues', this was the necessary changes to make the mac stuff build",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,808,2020-12-10T17:27:26Z,2020-12-14T10:27:30Z,2020-12-14T10:27:30Z,MERGED,True,3,2,1,https://github.com/SpiceyWolf,Fix to MacOSX building,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/808,https://github.com/Jj0YzL5nvJ,2,https://github.com/mupen64plus/mupen64plus-core/pull/808#issuecomment-743108803,"After some struggle and assistance in the 'issues', this was the necessary changes to make the mac stuff build","BTW, you don't need those quotes in this case. They are ""good practice"" to avoid weird behaviours in some shells, keep special characters, keep spaces, keep quotation over quotation, etc.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,808,2020-12-10T17:27:26Z,2020-12-14T10:27:30Z,2020-12-14T10:27:30Z,MERGED,True,3,2,1,https://github.com/SpiceyWolf,Fix to MacOSX building,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/808,https://github.com/Narann,3,https://github.com/mupen64plus/mupen64plus-core/pull/808#issuecomment-744302047,"After some struggle and assistance in the 'issues', this was the necessary changes to make the mac stuff build","This mean we drop Mac OS X 10.6 Snow Leopard and minimal version is now Mac OS X 10.7 Lion.
Are we OK with that ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,808,2020-12-10T17:27:26Z,2020-12-14T10:27:30Z,2020-12-14T10:27:30Z,MERGED,True,3,2,1,https://github.com/SpiceyWolf,Fix to MacOSX building,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/808,https://github.com/SpiceyWolf,4,https://github.com/mupen64plus/mupen64plus-core/pull/808#issuecomment-744303115,"After some struggle and assistance in the 'issues', this was the necessary changes to make the mac stuff build","If you try to build with the libc++ it says minimum required is 10.7, not much of a way around that.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,809,2020-12-11T19:21:49Z,2020-12-12T14:28:38Z,2020-12-12T14:28:38Z,MERGED,True,3,3,1,https://github.com/timgates42,"docs: fix simple typo, unconditonal -> unconditional",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/809,https://github.com/timgates42,1,https://github.com/mupen64plus/mupen64plus-core/pull/809,"There is a small typo in src/device/r4300/new_dynarec/new_dynarec.c.
Should read unconditional rather than unconditonal.
Semi-automated pull request generated by
https://github.com/timgates42/meticulous/blob/master/docs/NOTE.md","There is a small typo in src/device/r4300/new_dynarec/new_dynarec.c.
Should read unconditional rather than unconditonal.
Semi-automated pull request generated by
https://github.com/timgates42/meticulous/blob/master/docs/NOTE.md",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,811,2020-12-14T21:10:59Z,2020-12-15T09:16:50Z,2020-12-15T17:10:07Z,MERGED,True,13,13,1,https://github.com/orbea,build: Allow out of tree builds.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/811,https://github.com/orbea,1,https://github.com/mupen64plus/mupen64plus-core/pull/811,"This allows building the project out of tree.
Example:
mkdir /tmp/build
cd /tmp/build
make install -f /path/to/mupen64plus-core/projects/unix/Makefile \
  SRCDIR=/path/to/mupen64plus-core/src \
  SUBDIR=/path/to/mupen64plus-core/subdir","This allows building the project out of tree.
Example:
mkdir /tmp/build
cd /tmp/build
make install -f /path/to/mupen64plus-core/projects/unix/Makefile \
  SRCDIR=/path/to/mupen64plus-core/src \
  SUBDIR=/path/to/mupen64plus-core/subdir",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,811,2020-12-14T21:10:59Z,2020-12-15T09:16:50Z,2020-12-15T17:10:07Z,MERGED,True,13,13,1,https://github.com/orbea,build: Allow out of tree builds.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/811,https://github.com/Rosalie241,2,https://github.com/mupen64plus/mupen64plus-core/pull/811#issuecomment-744714879,"This allows building the project out of tree.
Example:
mkdir /tmp/build
cd /tmp/build
make install -f /path/to/mupen64plus-core/projects/unix/Makefile \
  SRCDIR=/path/to/mupen64plus-core/src \
  SUBDIR=/path/to/mupen64plus-core/subdir",Wouldn't make [target] -C /path/to/mupen64plus-core/projects/unix work?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,811,2020-12-14T21:10:59Z,2020-12-15T09:16:50Z,2020-12-15T17:10:07Z,MERGED,True,13,13,1,https://github.com/orbea,build: Allow out of tree builds.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/811,https://github.com/orbea,3,https://github.com/mupen64plus/mupen64plus-core/pull/811#issuecomment-744716396,"This allows building the project out of tree.
Example:
mkdir /tmp/build
cd /tmp/build
make install -f /path/to/mupen64plus-core/projects/unix/Makefile \
  SRCDIR=/path/to/mupen64plus-core/src \
  SUBDIR=/path/to/mupen64plus-core/subdir","@Rosalie241 Using make -C /path changes to the directory and builds in the source tree. This allows building the project without changing directories or touching the source directory.
Build systems like autotools, sofort, cmake, meson and likely others all allow this.",True,{'THUMBS_UP': ['https://github.com/Rosalie241']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,811,2020-12-14T21:10:59Z,2020-12-15T09:16:50Z,2020-12-15T17:10:07Z,MERGED,True,13,13,1,https://github.com/orbea,build: Allow out of tree builds.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/811,https://github.com/Narann,4,https://github.com/mupen64plus/mupen64plus-core/pull/811#issuecomment-745161990,"This allows building the project out of tree.
Example:
mkdir /tmp/build
cd /tmp/build
make install -f /path/to/mupen64plus-core/projects/unix/Makefile \
  SRCDIR=/path/to/mupen64plus-core/src \
  SUBDIR=/path/to/mupen64plus-core/subdir","Thanks, looks like mupen64plus-video-glide64mk2 and mupen64plus-video-rice modifications are missing.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,811,2020-12-14T21:10:59Z,2020-12-15T09:16:50Z,2020-12-15T17:10:07Z,MERGED,True,13,13,1,https://github.com/orbea,build: Allow out of tree builds.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/811,https://github.com/orbea,5,https://github.com/mupen64plus/mupen64plus-core/pull/811#issuecomment-745275198,"This allows building the project out of tree.
Example:
mkdir /tmp/build
cd /tmp/build
make install -f /path/to/mupen64plus-core/projects/unix/Makefile \
  SRCDIR=/path/to/mupen64plus-core/src \
  SUBDIR=/path/to/mupen64plus-core/subdir","Thanks, looks like mupen64plus-video-glide64mk2 and mupen64plus-video-rice modifications are missing.

I'll make PRs later today. :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,811,2020-12-14T21:10:59Z,2020-12-15T09:16:50Z,2020-12-15T17:10:07Z,MERGED,True,13,13,1,https://github.com/orbea,build: Allow out of tree builds.,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/811,https://github.com/orbea,6,https://github.com/mupen64plus/mupen64plus-core/pull/811#issuecomment-745432707,"This allows building the project out of tree.
Example:
mkdir /tmp/build
cd /tmp/build
make install -f /path/to/mupen64plus-core/projects/unix/Makefile \
  SRCDIR=/path/to/mupen64plus-core/src \
  SUBDIR=/path/to/mupen64plus-core/subdir","@Narann The PRs for glide64mk2 and rice are up. I am not sure about the others, but I can do this for any other repo upon request. :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,814,2020-12-20T03:02:08Z,2020-12-21T10:48:10Z,2021-06-20T20:47:44Z,MERGED,True,6,1,1,https://github.com/loganmc10,Add SmashRemix0.9.5b to INI,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/814,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/814,A new version of Smash Remix is out. It has a new CRC and MD5,A new version of Smash Remix is out. It has a new CRC and MD5,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,814,2020-12-20T03:02:08Z,2020-12-21T10:48:10Z,2021-06-20T20:47:44Z,MERGED,True,6,1,1,https://github.com/loganmc10,Add SmashRemix0.9.5b to INI,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/814,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/814#issuecomment-748617203,A new version of Smash Remix is out. It has a new CRC and MD5,The settings are actually copy/pasted from the readme of the ROM hack. I just copied it this time to make sure it was correct and they had it in that order,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,815,2020-12-26T15:21:30Z,2020-12-29T12:48:16Z,2020-12-30T10:21:43Z,MERGED,True,55,41,3,https://github.com/Jj0YzL5nvJ,Simplify and make the asm script more robust to 3rd party scripts,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/815,https://github.com/Jj0YzL5nvJ,1,https://github.com/mupen64plus/mupen64plus-core/pull/815,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,815,2020-12-26T15:21:30Z,2020-12-29T12:48:16Z,2020-12-30T10:21:43Z,MERGED,True,55,41,3,https://github.com/Jj0YzL5nvJ,Simplify and make the asm script more robust to 3rd party scripts,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/815,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/815#issuecomment-751708393,,"Hi,
Code is cleaner, but the exact purpose is still difficult to get.
Can we take this PR as an opportunity to write few lines in the 8 does:
GAS_LOOP=$(LC_ALL=C grep -a @ASM_DEFINE ""$2"" | sed 's/@ASM_DEFINE offsetof_struct_//g' | sed 's/\n/ /g')
Like this: # for each .h file, we get every word starting by ""offsetof_struct_"" and remove the....
Because for not being used to compilation process, I (read: everyone) need to understand what those hacky code is exactly doing, not only the broad view.
Thanks in advance.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,815,2020-12-26T15:21:30Z,2020-12-29T12:48:16Z,2020-12-30T10:21:43Z,MERGED,True,55,41,3,https://github.com/Jj0YzL5nvJ,Simplify and make the asm script more robust to 3rd party scripts,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/815,https://github.com/Narann,3,https://github.com/mupen64plus/mupen64plus-core/pull/815#issuecomment-752063600,,"I think it's better now.
Damn, this script is definitely not easy.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,815,2020-12-26T15:21:30Z,2020-12-29T12:48:16Z,2020-12-30T10:21:43Z,MERGED,True,55,41,3,https://github.com/Jj0YzL5nvJ,Simplify and make the asm script more robust to 3rd party scripts,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/815,https://github.com/Jj0YzL5nvJ,4,https://github.com/mupen64plus/mupen64plus-core/pull/815#issuecomment-752405628,,"Damn, this script is definitely not easy.

#817",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,816,2020-12-26T17:18:49Z,2020-12-29T17:11:51Z,2020-12-29T17:11:51Z,MERGED,True,2,2,1,https://github.com/LuigiBlood,[Disk] Make sure the wrong System Data is checked upon read of the System Area,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/816,https://github.com/LuigiBlood,1,https://github.com/mupen64plus/mupen64plus-core/pull/816,"It only impacted SDK format but there were serious regressions where games just didn't work properly. It seems I didn't do proper testing. Now they do.
Basically when you run Mario Artist Paint Studio, and try to access 2D Paint mode (the first on the left) and it would return Error 23 (Unrecovered Read Error), which is definitely weird. Other games were also impacted in weird ways so that was pretty annoying.","It only impacted SDK format but there were serious regressions where games just didn't work properly. It seems I didn't do proper testing. Now they do.
Basically when you run Mario Artist Paint Studio, and try to access 2D Paint mode (the first on the left) and it would return Error 23 (Unrecovered Read Error), which is definitely weird. Other games were also impacted in weird ways so that was pretty annoying.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,816,2020-12-26T17:18:49Z,2020-12-29T17:11:51Z,2020-12-29T17:11:51Z,MERGED,True,2,2,1,https://github.com/LuigiBlood,[Disk] Make sure the wrong System Data is checked upon read of the System Area,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/816,https://github.com/LuigiBlood,2,https://github.com/mupen64plus/mupen64plus-core/pull/816#issuecomment-751380268,"It only impacted SDK format but there were serious regressions where games just didn't work properly. It seems I didn't do proper testing. Now they do.
Basically when you run Mario Artist Paint Studio, and try to access 2D Paint mode (the first on the left) and it would return Error 23 (Unrecovered Read Error), which is definitely weird. Other games were also impacted in weird ways so that was pretty annoying.",@bsmiles32,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,817,2020-12-30T10:20:39Z,2020-12-31T10:16:02Z,2021-01-03T17:04:03Z,MERGED,True,28,23,2,https://github.com/Jj0YzL5nvJ,Failing to explain the asm scripts in a better way...,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/817,https://github.com/Jj0YzL5nvJ,1,https://github.com/mupen64plus/mupen64plus-core/pull/817,"Damn, this script is definitely not easy.

That means I suck to explain the workflow...
asm_defines.o and asm_defines.obj looks something like this... and asm_defines_*.h like this...","Damn, this script is definitely not easy.

That means I suck to explain the workflow...
asm_defines.o and asm_defines.obj looks something like this... and asm_defines_*.h like this...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,819,2021-01-01T23:55:49Z,,2021-01-03T16:48:14Z,OPEN,False,55,8,4,https://github.com/joeldenning,Add support for netplay input delay.,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/819,https://github.com/joeldenning,1,https://github.com/mupen64plus/mupen64plus-core/pull/819,"This is an improved version of #799. The primary goal of the change is to improve performance of netplay when using fixed input delay. By informing mupen64plus-core of the input delay, the client is able to be the source of truth for local player inputs instead of having to wait on the server for local inputs.
One thing to note about the implementation here - mupen core is still sending the original count to the server instead of the adjusted-for-input-delay count. This is perhaps something that could be changed later on, but I didn't want to change it now since it would have been a breaking change.
This change also could help with a future p2p implementation, as two player p2p relies on the client using local inputs without waiting on the network to enjoy the perf benefits of p2p.
I made this change as part of some work on m64p - here's the corresponding change there: https://github.com/m64p/mupen64plus-gui/pull/70/files
cc @loganmc10","This is an improved version of #799. The primary goal of the change is to improve performance of netplay when using fixed input delay. By informing mupen64plus-core of the input delay, the client is able to be the source of truth for local player inputs instead of having to wait on the server for local inputs.
One thing to note about the implementation here - mupen core is still sending the original count to the server instead of the adjusted-for-input-delay count. This is perhaps something that could be changed later on, but I didn't want to change it now since it would have been a breaking change.
This change also could help with a future p2p implementation, as two player p2p relies on the client using local inputs without waiting on the network to enjoy the perf benefits of p2p.
I made this change as part of some work on m64p - here's the corresponding change there: https://github.com/m64p/mupen64plus-gui/pull/70/files
cc @loganmc10",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,819,2021-01-01T23:55:49Z,,2021-01-03T16:48:14Z,OPEN,False,55,8,4,https://github.com/joeldenning,Add support for netplay input delay.,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/819,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/819#issuecomment-753420483,"This is an improved version of #799. The primary goal of the change is to improve performance of netplay when using fixed input delay. By informing mupen64plus-core of the input delay, the client is able to be the source of truth for local player inputs instead of having to wait on the server for local inputs.
One thing to note about the implementation here - mupen core is still sending the original count to the server instead of the adjusted-for-input-delay count. This is perhaps something that could be changed later on, but I didn't want to change it now since it would have been a breaking change.
This change also could help with a future p2p implementation, as two player p2p relies on the client using local inputs without waiting on the network to enjoy the perf benefits of p2p.
I made this change as part of some work on m64p - here's the corresponding change there: https://github.com/m64p/mupen64plus-gui/pull/70/files
cc @loganmc10","I'm not sure what performance is to be gained here. In order for the game to advance a frame, it needs the inputs from all players. So having the local player's inputs registered early isn't going to allow the game to advance any quicker.
The other potential issue is desyncs (unless I missed something). The local player never re-sends inputs, so if it registers ""A"" for frame 123, but that never arrives at the server, the server needs to make an assumption about what the input should be. The m64p server just copies the previous frame's inputs, but if that differs from what the local player registered, it will desync.
p2p is essentially a game where 1 of the players is hosting the server locally. In that case, the round trip time for that player's inputs would be <1ms, so I don't think there would be anything to be gained there either.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,819,2021-01-01T23:55:49Z,,2021-01-03T16:48:14Z,OPEN,False,55,8,4,https://github.com/joeldenning,Add support for netplay input delay.,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/819,https://github.com/joeldenning,3,https://github.com/mupen64plus/mupen64plus-core/pull/819#issuecomment-753432242,"This is an improved version of #799. The primary goal of the change is to improve performance of netplay when using fixed input delay. By informing mupen64plus-core of the input delay, the client is able to be the source of truth for local player inputs instead of having to wait on the server for local inputs.
One thing to note about the implementation here - mupen core is still sending the original count to the server instead of the adjusted-for-input-delay count. This is perhaps something that could be changed later on, but I didn't want to change it now since it would have been a breaking change.
This change also could help with a future p2p implementation, as two player p2p relies on the client using local inputs without waiting on the network to enjoy the perf benefits of p2p.
I made this change as part of some work on m64p - here's the corresponding change there: https://github.com/m64p/mupen64plus-gui/pull/70/files
cc @loganmc10","Thanks for your comments - am happy to discuss this over Discord, too, if that would help clarify. I believe this change does have performance benefits, and also would be needed for a p2p (and maybe rollback) implementation.

So having the local player's inputs registered early isn't going to allow the game to advance any quicker.

Inputs for a frame don't arrive in the same packet / udp datagram for all players, so it's possible for you to have all inputs for your opponents, but be waiting on the network for your own inputs.

if it registers ""A"" for frame 123, but that never arrives at the server, the server needs to make an assumption about what the input should be. The m64p server just copies the previous frame's inputs, but if that differs from what the local player registered, it will desync.

This is not true of m64p-netplay-server with fixed input delay. It never copies inputs for fixed input delay games, but rather it always waits for the client to send them.

p2p is essentially a game where 1 of the players is hosting the server locally. In that case, the round trip time for that player's inputs would be <1ms, so I don't think there would be anything to be gained there either.

With two player p2p, you can halve the input delay by not waiting on the host server to send your own inputs back to you, since it is unnecessary for the input to make a roundtrip. Instead, the inputs are traveling one-way in each direction. Consider the following example, where two players have a ping of 45ms to a server and also a ping of 45ms to each other.
Server

For count 100, P1 and P2 send inputs to server. (45ms)
Server receives inputs for both players and sends them to P1 (45ms)
P1 netplay client updates PIF ram with inputs for P1 and P2, both of which came from the network.

Total Duration: 90ms
P2P

For count 100, P1 and P2 send inputs directly to each other. (45ms).
P1 netplay client receives P2 inputs. It does not receive inputs for itself (P1).
P1 netplay client updates PIF ram, using P2's network inputs but P1's locally cached inputs.

Total Duration: 45ms",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,819,2021-01-01T23:55:49Z,,2021-01-03T16:48:14Z,OPEN,False,55,8,4,https://github.com/joeldenning,Add support for netplay input delay.,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/819,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/819#issuecomment-753433008,"This is an improved version of #799. The primary goal of the change is to improve performance of netplay when using fixed input delay. By informing mupen64plus-core of the input delay, the client is able to be the source of truth for local player inputs instead of having to wait on the server for local inputs.
One thing to note about the implementation here - mupen core is still sending the original count to the server instead of the adjusted-for-input-delay count. This is perhaps something that could be changed later on, but I didn't want to change it now since it would have been a breaking change.
This change also could help with a future p2p implementation, as two player p2p relies on the client using local inputs without waiting on the network to enjoy the perf benefits of p2p.
I made this change as part of some work on m64p - here's the corresponding change there: https://github.com/m64p/mupen64plus-gui/pull/70/files
cc @loganmc10","Sorry yes I hadn't considered that neither player would need to receive their own packets in a p2p game. However it seems like that benefit would diminish with a 3rd and 4th player.

This is not true of m64p-netplay-server with fixed input delay. It never copies inputs for fixed input delay games, but rather it always waits for the client to send them

I don't think this is true currently, see:
https://github.com/m64p/m64p-netplay-server/blob/54f933dc599ede25b89997700e6daa419acaf3e5/udpServer.cpp#L230
The current core implementation has no method for retransmitting inputs. The server has no way to signal to the client ""I never received inputs for frame 123, please resend"". I think that would need to be implemented alongside this change (or before it).

Inputs for a frame don't arrive in the same packet / udp datagram for all players, so it's possible for you to have all inputs for your opponents, but be waiting on the network for your own inputs.

While this is true, the packets are being sent from the same source, and to the same destination, so any variance between arrival times for each player should be extremely minimal.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,819,2021-01-01T23:55:49Z,,2021-01-03T16:48:14Z,OPEN,False,55,8,4,https://github.com/joeldenning,Add support for netplay input delay.,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/819,https://github.com/joeldenning,5,https://github.com/mupen64plus/mupen64plus-core/pull/819#issuecomment-753434177,"This is an improved version of #799. The primary goal of the change is to improve performance of netplay when using fixed input delay. By informing mupen64plus-core of the input delay, the client is able to be the source of truth for local player inputs instead of having to wait on the server for local inputs.
One thing to note about the implementation here - mupen core is still sending the original count to the server instead of the adjusted-for-input-delay count. This is perhaps something that could be changed later on, but I didn't want to change it now since it would have been a breaking change.
This change also could help with a future p2p implementation, as two player p2p relies on the client using local inputs without waiting on the network to enjoy the perf benefits of p2p.
I made this change as part of some work on m64p - here's the corresponding change there: https://github.com/m64p/mupen64plus-gui/pull/70/files
cc @loganmc10","Sorry yes I hadn't considered that neither player would need to receive their own packets in a p2p game. However it seems like that benefit would diminish with a 3rd and 4th player.

Agreed, 3+ players wouldn't be able to do this.

I don't think this is true currently, see:
https://github.com/m64p/m64p-netplay-server/blob/54f933dc599ede25b89997700e6daa419acaf3e5/udpServer.cpp#L230


The current core implementation has no method for retransmitting inputs. The server has no way to signal to the client ""I never received inputs for frame 123, please resend"". I think that would need to be implemented alongside this change (or before it).

Ah I didn't realize that was happening! Thanks for the link to the code - I see what's happening there. I agree that the ""please retransmit"" feature is needed to avoid desyncs, and am happy to spend some time on it. To implement that, the netplay client would need to store the previous inputs for a while before discarding them, which I don't think it currently does. Perhaps it should store 10ish frames of previous inputs in a linked list, in case the server asks for them?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,819,2021-01-01T23:55:49Z,,2021-01-03T16:48:14Z,OPEN,False,55,8,4,https://github.com/joeldenning,Add support for netplay input delay.,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/819,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/819#issuecomment-753644561,"This is an improved version of #799. The primary goal of the change is to improve performance of netplay when using fixed input delay. By informing mupen64plus-core of the input delay, the client is able to be the source of truth for local player inputs instead of having to wait on the server for local inputs.
One thing to note about the implementation here - mupen core is still sending the original count to the server instead of the adjusted-for-input-delay count. This is perhaps something that could be changed later on, but I didn't want to change it now since it would have been a breaking change.
This change also could help with a future p2p implementation, as two player p2p relies on the client using local inputs without waiting on the network to enjoy the perf benefits of p2p.
I made this change as part of some work on m64p - here's the corresponding change there: https://github.com/m64p/mupen64plus-gui/pull/70/files
cc @loganmc10","Perhaps it should store 10ish frames of previous inputs in a linked list, in case the server asks for them?

Choosing arbitrary values can be a little risky and could lead to instability (you never know how long somebody might hang/lose internet for). It would probably be better to just hold on to the input locally until it hears about that input from the server (once the server sends that input to the client, the client knows it's been received/registered with the server, thus there is no longer a need to retain it locally)",True,{'THUMBS_UP': ['https://github.com/joeldenning']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,820,2021-01-02T05:11:27Z,2021-01-02T15:40:42Z,2021-01-02T15:40:42Z,MERGED,True,1,1,1,https://github.com/clobber,Add correct MD5 for SmashRemix0.9.5b to INI,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/820,https://github.com/clobber,1,https://github.com/mupen64plus/mupen64plus-core/pull/820,"Resolves:
(Warning): ROM Database: Invalid MD5 on line 13903
(Warning): ROM Database: Ignoring property on line 13904
(Warning): ROM Database: Ignoring property on line 13905
(Warning): ROM Database: Ignoring property on line 13906

cc: @loganmc10","Resolves:
(Warning): ROM Database: Invalid MD5 on line 13903
(Warning): ROM Database: Ignoring property on line 13904
(Warning): ROM Database: Ignoring property on line 13905
(Warning): ROM Database: Ignoring property on line 13906

cc: @loganmc10",True,{'THUMBS_UP': ['https://github.com/loganmc10']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,820,2021-01-02T05:11:27Z,2021-01-02T15:40:42Z,2021-01-02T15:40:42Z,MERGED,True,1,1,1,https://github.com/clobber,Add correct MD5 for SmashRemix0.9.5b to INI,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/820,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/820#issuecomment-753433256,"Resolves:
(Warning): ROM Database: Invalid MD5 on line 13903
(Warning): ROM Database: Ignoring property on line 13904
(Warning): ROM Database: Ignoring property on line 13905
(Warning): ROM Database: Ignoring property on line 13906

cc: @loganmc10","Whoops, thanks!",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,825,2021-01-17T11:08:11Z,2021-01-23T03:35:59Z,2021-02-01T11:10:57Z,MERGED,True,6,13,3,https://github.com/bsmiles32,Ai fixes,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/825,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/825,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,827,2021-01-23T11:26:04Z,2021-01-23T16:00:43Z,2021-01-23T16:00:43Z,MERGED,True,17,17,4,https://github.com/Rosalie241,Add prefix to m64p_rom_save_type members,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/827,https://github.com/Rosalie241,1,https://github.com/mupen64plus/mupen64plus-core/pull/827,Fixes #826,Fixes #826,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,828,2021-01-23T11:34:38Z,2021-01-23T16:02:05Z,2021-01-23T16:02:05Z,MERGED,True,40,0,1,https://github.com/Rosalie241,Mention save slot keybindings in docs,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/828,https://github.com/Rosalie241,1,https://github.com/mupen64plus/mupen64plus-core/pull/828,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,829,2021-01-23T17:08:03Z,2021-01-30T16:14:39Z,2021-01-30T16:14:39Z,CLOSED,False,151,15,6,https://github.com/LuigiBlood,Full 64DD Saving Support,14,[],https://github.com/mupen64plus/mupen64plus-core/pull/829,https://github.com/LuigiBlood,1,https://github.com/mupen64plus/mupen64plus-core/pull/829,"I wanted to attempt an experiment with File Storage saving, such as defining an area to save which would deal with RAM Area only saving, which might be a mess.
@bsmiles32 I don't think that's what you had in mind, I just wanted to attempt something of my own.","I wanted to attempt an experiment with File Storage saving, such as defining an area to save which would deal with RAM Area only saving, which might be a mess.
@bsmiles32 I don't think that's what you had in mind, I just wanted to attempt something of my own.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,829,2021-01-23T17:08:03Z,2021-01-30T16:14:39Z,2021-01-30T16:14:39Z,CLOSED,False,151,15,6,https://github.com/LuigiBlood,Full 64DD Saving Support,14,[],https://github.com/mupen64plus/mupen64plus-core/pull/829,https://github.com/LuigiBlood,2,https://github.com/mupen64plus/mupen64plus-core/pull/829#issuecomment-766143721,"I wanted to attempt an experiment with File Storage saving, such as defining an area to save which would deal with RAM Area only saving, which might be a mess.
@bsmiles32 I don't think that's what you had in mind, I just wanted to attempt something of my own.","Also maybe it's just the unoptimized debug but saving does really take a toll on the emulator. Thankfully the disk isn't constantly written, but it does quite the performance impact.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,829,2021-01-23T17:08:03Z,2021-01-30T16:14:39Z,2021-01-30T16:14:39Z,CLOSED,False,151,15,6,https://github.com/LuigiBlood,Full 64DD Saving Support,14,[],https://github.com/mupen64plus/mupen64plus-core/pull/829,https://github.com/bsmiles32,3,https://github.com/mupen64plus/mupen64plus-core/pull/829#issuecomment-766322149,"I wanted to attempt an experiment with File Storage saving, such as defining an area to save which would deal with RAM Area only saving, which might be a mess.
@bsmiles32 I don't think that's what you had in mind, I just wanted to attempt something of my own.","Yeah, I would prefer if we keep the disk format logic (Full vs RAM only) inside disk module because it is disk-specific.
The idea of interfaces/backends is that the emulation logic only cares about interface (e.g. emulation logic only notifies of chunks it has changed) and the core is free to choose appropriate backend to store said changes. For now, we only have a file_storage_backend so this distinction is not so visible (and some network code got inside, even if doing a separate backend would be more appropriate to avoid mixing file/network logic).
For 64DD disks, we put a ""format"" layer in between emulation and core, so that we can abstract both saving format and saving medium orthogonally.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,829,2021-01-23T17:08:03Z,2021-01-30T16:14:39Z,2021-01-30T16:14:39Z,CLOSED,False,151,15,6,https://github.com/LuigiBlood,Full 64DD Saving Support,14,[],https://github.com/mupen64plus/mupen64plus-core/pull/829,https://github.com/LuigiBlood,4,https://github.com/mupen64plus/mupen64plus-core/pull/829#issuecomment-766342240,"I wanted to attempt an experiment with File Storage saving, such as defining an area to save which would deal with RAM Area only saving, which might be a mess.
@bsmiles32 I don't think that's what you had in mind, I just wanted to attempt something of my own.","Would it be appropriate to do something like that? (Assume no changes has been done for file_storage.)
static void storage_disk_save(void* storage, size_t start, size_t size)
{
    struct dd_disk* disk = (struct dd_disk*)storage;
    struct file_storage* fstorage = disk->storage;
    struct file_storage tstorage;

    switch (disk->save_format)
    {
    case 0: /* Full disk save */
        disk->istorage->save(disk->storage, start, size);
        break;

    case 1: /* RAM only */
        tstorage.data = fstorage->data + disk->offset_ram;
        tstorage.size = fstorage->size - disk->offset_ram;
        tstorage.filename = fstorage->filename;
        tstorage.first_access = fstorage->first_access;
        disk->istorage->save(&tstorage, start - disk->offset_ram, size);
        fstorage->first_access = tstorage.first_access;
        break;
    default: /* ignoring */
        break;
    }
}
Because in theory this is really that simple and the reason why I had offset_ram in the first place.
We could seperate them between NDD, D64 and MAME (though MAME will not have any RAM only save support, it's too complicated and not worth the effort). RAM only saving would work exactly the same between NDD and D64 thanks to offset_ram.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,829,2021-01-23T17:08:03Z,2021-01-30T16:14:39Z,2021-01-30T16:14:39Z,CLOSED,False,151,15,6,https://github.com/LuigiBlood,Full 64DD Saving Support,14,[],https://github.com/mupen64plus/mupen64plus-core/pull/829,https://github.com/bsmiles32,5,https://github.com/mupen64plus/mupen64plus-core/pull/829#issuecomment-766684377,"I wanted to attempt an experiment with File Storage saving, such as defining an area to save which would deal with RAM Area only saving, which might be a mess.
@bsmiles32 I don't think that's what you had in mind, I just wanted to attempt something of my own.","I made an alternative proposition for saving LuigiBlood#7
The idea was to keep file_storage as is and move format specificity to disk module (and some part of it inside load_dd_disk). I had to add an extra save_storage member to disk struct linking to (part of) full disk storage so that I can have both full disk for reading and a save part. Might be a bit confusing, but it should work in practice.
Could you test to see if its good ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,829,2021-01-23T17:08:03Z,2021-01-30T16:14:39Z,2021-01-30T16:14:39Z,CLOSED,False,151,15,6,https://github.com/LuigiBlood,Full 64DD Saving Support,14,[],https://github.com/mupen64plus/mupen64plus-core/pull/829,https://github.com/LuigiBlood,6,https://github.com/mupen64plus/mupen64plus-core/pull/829#issuecomment-766784534,"I wanted to attempt an experiment with File Storage saving, such as defining an area to save which would deal with RAM Area only saving, which might be a mess.
@bsmiles32 I don't think that's what you had in mind, I just wanted to attempt something of my own.","Well it seems to work fine, it's a bit similar to what I did except it's kept in memory as part of dd_disk. If you're happy with that I'll merge it on my fork, I'll just do a couple changes like force full disk saves for MAME format, or maybe not even allow to save at all.
Also fix D64 full disk saving as there is a bug in the system data modification with RAM LBA End value.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,829,2021-01-23T17:08:03Z,2021-01-30T16:14:39Z,2021-01-30T16:14:39Z,CLOSED,False,151,15,6,https://github.com/LuigiBlood,Full 64DD Saving Support,14,[],https://github.com/mupen64plus/mupen64plus-core/pull/829,https://github.com/bsmiles32,7,https://github.com/mupen64plus/mupen64plus-core/pull/829#issuecomment-766795377,"I wanted to attempt an experiment with File Storage saving, such as defining an area to save which would deal with RAM Area only saving, which might be a mess.
@bsmiles32 I don't think that's what you had in mind, I just wanted to attempt something of my own.","I'll just do a couple changes like force full disk saves for MAME format

Yeah, you mentioned it but I forgot about it, so it's cool if you can do it. I think switching to a Full disk copy for MAME format is better than no saving at all, but either way is fine with me.
From my side it's all good, you can merge my changes to your PR and do the MAME saving handling then we can merge your work.
(If you want we can cherry-pick your bugfix commit right now independently of this PR if you want it in master faster)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,829,2021-01-23T17:08:03Z,2021-01-30T16:14:39Z,2021-01-30T16:14:39Z,CLOSED,False,151,15,6,https://github.com/LuigiBlood,Full 64DD Saving Support,14,[],https://github.com/mupen64plus/mupen64plus-core/pull/829,https://github.com/LuigiBlood,8,https://github.com/mupen64plus/mupen64plus-core/pull/829#issuecomment-766798153,"I wanted to attempt an experiment with File Storage saving, such as defining an area to save which would deal with RAM Area only saving, which might be a mess.
@bsmiles32 I don't think that's what you had in mind, I just wanted to attempt something of my own.","There's a huge bug with NDD format right now I get disk read errors when trying to go into 2D Paint mode in Paint Studio.
I went back to latest master to make sure and there's no issues.
I tried my own wip_64dd_save without your changes and it works, so it seems you broke something.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,829,2021-01-23T17:08:03Z,2021-01-30T16:14:39Z,2021-01-30T16:14:39Z,CLOSED,False,151,15,6,https://github.com/LuigiBlood,Full 64DD Saving Support,14,[],https://github.com/mupen64plus/mupen64plus-core/pull/829,https://github.com/bsmiles32,9,https://github.com/mupen64plus/mupen64plus-core/pull/829#issuecomment-766805073,"I wanted to attempt an experiment with File Storage saving, such as defining an area to save which would deal with RAM Area only saving, which might be a mess.
@bsmiles32 I don't think that's what you had in mind, I just wanted to attempt something of my own.","Oups, I'll check later what's wrong with my code.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,829,2021-01-23T17:08:03Z,2021-01-30T16:14:39Z,2021-01-30T16:14:39Z,CLOSED,False,151,15,6,https://github.com/LuigiBlood,Full 64DD Saving Support,14,[],https://github.com/mupen64plus/mupen64plus-core/pull/829,https://github.com/LuigiBlood,10,https://github.com/mupen64plus/mupen64plus-core/pull/829#issuecomment-766806489,"I wanted to attempt an experiment with File Storage saving, such as defining an area to save which would deal with RAM Area only saving, which might be a mess.
@bsmiles32 I don't think that's what you had in mind, I just wanted to attempt something of my own.","Gotta note that for some reason, it's doing it fine with D64 format, which is kinda odd.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,829,2021-01-23T17:08:03Z,2021-01-30T16:14:39Z,2021-01-30T16:14:39Z,CLOSED,False,151,15,6,https://github.com/LuigiBlood,Full 64DD Saving Support,14,[],https://github.com/mupen64plus/mupen64plus-core/pull/829,https://github.com/bsmiles32,11,https://github.com/mupen64plus/mupen64plus-core/pull/829#issuecomment-766861806,"I wanted to attempt an experiment with File Storage saving, such as defining an area to save which would deal with RAM Area only saving, which might be a mess.
@bsmiles32 I don't think that's what you had in mind, I just wanted to attempt something of my own.","I can't reproduce your error. I can run DMPJ just fine and save both as full disk copy or RAM only. There was a bug for RAM only save the first time, when the file didn't exist, it would fail to load and fallback to no save therefore preventing to save and create the RAM file.
But now it should be OK.
edit: I tested DMPJ .ndd (sealed) from ozidual.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,829,2021-01-23T17:08:03Z,2021-01-30T16:14:39Z,2021-01-30T16:14:39Z,CLOSED,False,151,15,6,https://github.com/LuigiBlood,Full 64DD Saving Support,14,[],https://github.com/mupen64plus/mupen64plus-core/pull/829,https://github.com/LuigiBlood,12,https://github.com/mupen64plus/mupen64plus-core/pull/829#issuecomment-766885719,"I wanted to attempt an experiment with File Storage saving, such as defining an area to save which would deal with RAM Area only saving, which might be a mess.
@bsmiles32 I don't think that's what you had in mind, I just wanted to attempt something of my own.",Well I'll merge for now but I need to test more on my end.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,829,2021-01-23T17:08:03Z,2021-01-30T16:14:39Z,2021-01-30T16:14:39Z,CLOSED,False,151,15,6,https://github.com/LuigiBlood,Full 64DD Saving Support,14,[],https://github.com/mupen64plus/mupen64plus-core/pull/829,https://github.com/LuigiBlood,13,https://github.com/mupen64plus/mupen64plus-core/pull/829#issuecomment-766888217,"I wanted to attempt an experiment with File Storage saving, such as defining an area to save which would deal with RAM Area only saving, which might be a mess.
@bsmiles32 I don't think that's what you had in mind, I just wanted to attempt something of my own.","...well I'm not sure what happened but it works now, maybe I just suck at using Git",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,829,2021-01-23T17:08:03Z,2021-01-30T16:14:39Z,2021-01-30T16:14:39Z,CLOSED,False,151,15,6,https://github.com/LuigiBlood,Full 64DD Saving Support,14,[],https://github.com/mupen64plus/mupen64plus-core/pull/829,https://github.com/LuigiBlood,14,https://github.com/mupen64plus/mupen64plus-core/pull/829#issuecomment-766900303,"I wanted to attempt an experiment with File Storage saving, such as defining an area to save which would deal with RAM Area only saving, which might be a mess.
@bsmiles32 I don't think that's what you had in mind, I just wanted to attempt something of my own.","Also the bugfix for D64 system data modification I might do something else than what I originally did, and for MAME format to force Full Disk saves it's gonna be more complex than I thought so I'd rather just disable saves, no one should really use that format anyway.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,829,2021-01-23T17:08:03Z,2021-01-30T16:14:39Z,2021-01-30T16:14:39Z,CLOSED,False,151,15,6,https://github.com/LuigiBlood,Full 64DD Saving Support,14,[],https://github.com/mupen64plus/mupen64plus-core/pull/829,https://github.com/bsmiles32,15,https://github.com/mupen64plus/mupen64plus-core/pull/829#issuecomment-766923631,"I wanted to attempt an experiment with File Storage saving, such as defining an area to save which would deal with RAM Area only saving, which might be a mess.
@bsmiles32 I don't think that's what you had in mind, I just wanted to attempt something of my own.","He he !
I proposed a similar fix to the MAME case, but upper in the logic to allow it to load the full save if present. Since 64DD disk format guessing is done based on file size, I added an utility function to get file size early (before save loading and also before scan_and_expand function).
The PR is LuigiBlood#8",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,829,2021-01-23T17:08:03Z,2021-01-30T16:14:39Z,2021-01-30T16:14:39Z,CLOSED,False,151,15,6,https://github.com/LuigiBlood,Full 64DD Saving Support,14,[],https://github.com/mupen64plus/mupen64plus-core/pull/829,https://github.com/LuigiBlood,16,https://github.com/mupen64plus/mupen64plus-core/pull/829#issuecomment-766930388,"I wanted to attempt an experiment with File Storage saving, such as defining an area to save which would deal with RAM Area only saving, which might be a mess.
@bsmiles32 I don't think that's what you had in mind, I just wanted to attempt something of my own.","Well that's even better, I didn't want to add functionality as I didn't really want to break anything since my way of things are quite not like the project lol",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,829,2021-01-23T17:08:03Z,2021-01-30T16:14:39Z,2021-01-30T16:14:39Z,CLOSED,False,151,15,6,https://github.com/LuigiBlood,Full 64DD Saving Support,14,[],https://github.com/mupen64plus/mupen64plus-core/pull/829,https://github.com/LuigiBlood,17,https://github.com/mupen64plus/mupen64plus-core/pull/829#issuecomment-767056533,"I wanted to attempt an experiment with File Storage saving, such as defining an area to save which would deal with RAM Area only saving, which might be a mess.
@bsmiles32 I don't think that's what you had in mind, I just wanted to attempt something of my own.",The only problem is that it creates *.ram files when it's supposed to be *.ndr. Otherwise this seems to be fine.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,829,2021-01-23T17:08:03Z,2021-01-30T16:14:39Z,2021-01-30T16:14:39Z,CLOSED,False,151,15,6,https://github.com/LuigiBlood,Full 64DD Saving Support,14,[],https://github.com/mupen64plus/mupen64plus-core/pull/829,https://github.com/LuigiBlood,18,https://github.com/mupen64plus/mupen64plus-core/pull/829#issuecomment-767139427,"I wanted to attempt an experiment with File Storage saving, such as defining an area to save which would deal with RAM Area only saving, which might be a mess.
@bsmiles32 I don't think that's what you had in mind, I just wanted to attempt something of my own.","I think this is ready to go? I don't think I see anything to add about saving.
I'll probably do the fix for D64 edits with another pull request or something.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,829,2021-01-23T17:08:03Z,2021-01-30T16:14:39Z,2021-01-30T16:14:39Z,CLOSED,False,151,15,6,https://github.com/LuigiBlood,Full 64DD Saving Support,14,[],https://github.com/mupen64plus/mupen64plus-core/pull/829,https://github.com/bsmiles32,19,https://github.com/mupen64plus/mupen64plus-core/pull/829#issuecomment-770235477,"I wanted to attempt an experiment with File Storage saving, such as defining an area to save which would deal with RAM Area only saving, which might be a mess.
@bsmiles32 I don't think that's what you had in mind, I just wanted to attempt something of my own.","Closing this PR and will merge #832 once CI is green.
The new PR is rebased against master and I squashed all the commits (except the one fixing some offset) to have a more readable commit history. I've also removed some duplicated logic for the non appropriate *.ram extension for MAME disks.",True,{'THUMBS_UP': ['https://github.com/Narann']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,830,2021-01-24T09:48:09Z,2021-02-01T08:50:51Z,2021-02-01T11:10:52Z,MERGED,True,3,3,2,https://github.com/bsmiles32,Fix some unsigned/signed comparison warnings,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/830,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/830,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/MaddTheSane,1,https://github.com/mupen64plus/mupen64plus-core/pull/831,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.","Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-768976531,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.","Thanks, I suspect we need to update the Makefile too. Anyone with Apple system to test?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/richard42,3,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-782561344,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.","I have Apple systems, but no M1 or anything with an ARM CPU.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/MaddTheSane,4,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-783184581,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.","Even with these patches, I can't get Mupen64 running on M1 under OpenEmu.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/ZachBacon,5,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-907624547,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.","So I was pointed to this PR by @Jj0YzL5nvJ and I can say that it helps proceed further along the compilation process, however it's far from a finished PR based what I've tried to do.
So on my m1 mac, I ran make -C ./projects/unix NEW_DYNAREC=1 ARCH_DETECTED=64BITS CPU=ARM OS=OSX PLUGINDIR= SHAREDIR= BINDIR= MANDIR= LIBDIR= APPSDIR= ICONSDIR=icons all
Now I know this is rather behind current git head, but the ouput I got was this https://gist.github.com/ZachBacon/5c4d4997eb665ec840e080da6d829ce9",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/Jj0YzL5nvJ,6,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-907632060,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.","Try with:
export CXXFLAGS='-stdlib=libc++'
export LDFLAGS='-mmacosx-version-min=10.7'
export OPTFLAGS='-O2'

And build with make -e.
And post your src/asm_defines/asm_defines_gas.h to discard gen_asm_script.sh malfunctions.
P.S: What assembler compiler are you using for ARM64?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/ZachBacon,7,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-907647121,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.","Try with:
export CXXFLAGS='-stdlib=libc++'
export LDFLAGS='-mmacosx-version-min=10.7'
export OPTFLAGS='-O2'

And build with make -e.
And post your src/asm_defines/asm_defines_gas.h to discard gen_asm_script.sh malfunctions.
P.S: What assembler compiler are you using for ARM64?

I'm using the default of whatever comes with the commandline tools within macOS for assembly
asm_defines_gas.h",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/Jj0YzL5nvJ,8,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-907663492,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.","OSX + ARM64 is out of the scope... the current Makefile is useless for OSX on ARM64.
Replace:
AS        = nasm for AS        = as
Erase:
ifeq ($(ARCH_DETECTED), 64BITS)
  ASFLAGS = -f macho64 -d LEADING_UNDERSCORE
else
  ASFLAGS = -f macho -d LEADING_UNDERSCORE
endif

And add:
ifeq ($(CPU), ARM)
  ifeq ($(ARCH_DETECTED), 64BITS)
    CFLAGS += -pipe -arch arm64 -mmacosx-version-min=10.7 -isysroot $(OSX_SDK_PATH)
  endif
endif",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/ZachBacon,9,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-907667608,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.","still no dice. Same error as I posted above for this branch and same error for git master that I posted in the issue's repo which was this.
error: unknown directive .hidden new_dyna_stop; .type new_dyna_stop, %function; new_dyna_stop:",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/MaddTheSane,10,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-907672092,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.",Are you running the assembly file through gas-preprocessor?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/ZachBacon,11,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-907672534,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.","Are you running the assembly file through gas-preprocessor?

by gas, you mean as? Then yes.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/MaddTheSane,12,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-907672733,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.","gas-preprocessor, as in https://github.com/libav/gas-preprocessor/blob/master/gas-preprocessor.pl",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/ZachBacon,13,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-907672980,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.",so basically you want me to adapt a step that's not in the makefile to bypass the issue... in order to get it linked with asm support.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/MaddTheSane,14,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-907673095,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.",Yep.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/Jj0YzL5nvJ,15,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-907673771,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.","https://wiki.libav.org/Tools/gas-preprocessor
# full use of the advanced options
gas-preprocessor.pl -arch aarch64 -as-type clang -- clang -arch arm64",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/ZachBacon,16,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-907674419,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.","so at this point /if/ it's known to work with this pr, shouldn't it be integrated specifically for the MacOS m1 silicon chips? To have the makefile do the work instead of manual intervention?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/Jj0YzL5nvJ,17,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-907686839,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.","It will first be necessary to know the changes that lead to a successful compilation that works without errors...
According to OpenH264, NASM works in brew for ARM64...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/ZachBacon,18,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-913108017,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.","took me a little bit to get back to this due to work, and perhaps I am not understanding what is expected of me, and I do apologize for that. But I'm still being brought back to square one with this.
So what I did first was this make OS=OSX ARCH=arm64 ARCH_DETECTED=64BITS AS=""./gas-preprocessor.pl -arch aarch64 -as-type clang -- clang -arch arm64"" all which got me back to hitting my original issue of
../../src/device/r4300/new_dynarec/arm64/linkage_arm64.S:224:1: error: unknown directive .hidden new_dyna_stop; .type new_dyna_stop, %function; new_dyna_stop:
but then I thought of trying to build the file outside of the makefile by using that perl script that I was linked to. And I still got nothing but errors.
https://gist.github.com/ZachBacon/a8db9d70f8fdb1263aea99ed92731346",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/Jj0YzL5nvJ,19,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-913231560,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.","Without a developer who implements the platform support, this will never be fixed.
Correct me if I'm wrong, but to me understand the Perl script is meant for asm_defines_gas.h.
Something like:
	perl $(SRCDIR)/../tools/gas-preprocessor.pl $(CC) $(OPTFLAGS) $(WARNFLAGS) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c -o $@ $<

Obviously you would have to add the script to tools folder for my example.
Try with:
export PIC=1
export OSX_SDK_PATH=""$(shell xcrun --sdk macosx --show-sdk-path)""
export CFLAGS=""-pipe -arch arm64 -DL_ENDIAN -fno-common -mmacosx-version-min=11.0 -isysroot $(OSX_SDK_PATH)""",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/ZachBacon,20,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-914217694,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.","well, it's we are trying to figure this out, so that it can be implemented on this m1 platform, I'll give it a go and hope for the best.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/keegandent,21,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-960360993,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.",I have opened #908 which as-is works but with NO_ASM turned on. I will see if I can get these assembly changes integrated on my testbed M1 and if it still works when NO_ASM is turned off.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/keegandent,22,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-961557725,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.","Tried getting these changes up to date with master and messing with gas-preprocessor and the Makefile, but I'm still getting a an unknown-directive error. If anybody wants to take a look at my changes, I have them in https://github.com/keegandent/mupen64plus-core/tree/apple-silicon-asm
I have access to an M1 via MacInCloud if anyone without access to a testbed would like to schedule some collaboration time.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/MaddTheSane,23,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-961580531,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.","I, too, got unknown-directive errors. I just ended up manually fixing the end-result. I think it's a limitation of gas-preprocessor.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/keegandent,24,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-961586308,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.","I, too, got unknown-directive errors. I just ended up manually fixing the end-result. I think it's a limitation of gas-preprocessor.

What do you mean by “manually fixing”? Is there a way we can ship this manual adjustment or produce it programmatically? We could add that to the relevant section of the makefile if so.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/MaddTheSane,25,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-961598489,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.","I can't remember what I did to make gas-preprocessor to output the preprocessed assembly, but the closest I've got to a proper command line is gas-preprocessor.pl -arch aarch64 -as-type apple-clang  -- clang -arch arm64 linkage_arm64.S -DLEADING_UNDERSCORE.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/MaddTheSane,26,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-961601573,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.","Ah, now I remember: the environment variable ""GASPP_DEBUG"", which writes the preprocessed source to STDOUT.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/keegandent,27,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-961627712,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.","I can't remember what I did to make gas-preprocessor to output the preprocessed assembly, but the closest I've got to a proper command line is gas-preprocessor.pl -arch aarch64 -as-type apple-clang -- clang -arch arm64 linkage_arm64.S -DLEADING_UNDERSCORE.

This is what I get out of that
user209549@TX233 unix % GASSP_DEBUG=1 ./gas-preprocessor.pl -verbose -arch aarch64 -as-type apple-clang -- clang -O2 -flto -Wall -fno-strict-aliasing -fvisibility=hidden -I../../src -I../../src/asm_defines -DM64P_PARALLEL -fPIC -pipe -arch arm64 -mmacosx-version-min=10.16 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.0.sdk -DLEADING_UNDERSCORE  -DNOCRYPT -DNOUNCRYPT -I../../subprojects/minizip  -I/Users/user209549/homebrew/Cellar/libpng/1.6.37/include/libpng16 -I/Users/user209549/homebrew/include/SDL2 -D_THREAD_SAFE -DM64P_OSD -I/Users/user209549/homebrew/opt/freetype/include/freetype2   -DNDEBUG -I../../subprojects/md5 -I../../subprojects/xxhash -DDYNAREC -DNEW_DYNAREC=4 -MD -MP ../../src/device/r4300/new_dynarec/arm64/linkage_arm64.S 
clang -O2 -flto -Wall -fno-strict-aliasing -fvisibility=hidden -I../../src -I../../src/asm_defines -DM64P_PARALLEL -fPIC -pipe -arch arm64 -mmacosx-version-min=10.16 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.0.sdk -DLEADING_UNDERSCORE -DNOCRYPT -DNOUNCRYPT -I../../subprojects/minizip -I/Users/user209549/homebrew/Cellar/libpng/1.6.37/include/libpng16 -I/Users/user209549/homebrew/include/SDL2 -D_THREAD_SAFE -DM64P_OSD -I/Users/user209549/homebrew/opt/freetype/include/freetype2 -DNDEBUG -I../../subprojects/md5 -I../../subprojects/xxhash -DDYNAREC -DNEW_DYNAREC=4 -MD -MP ../../src/device/r4300/new_dynarec/arm64/linkage_arm64.S -E
clang -O2 -flto -Wall -fno-strict-aliasing -fvisibility=hidden -I../../src -I../../src/asm_defines -DM64P_PARALLEL -fPIC -pipe -arch arm64 -mmacosx-version-min=10.16 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.0.sdk -DLEADING_UNDERSCORE -DNOCRYPT -DNOUNCRYPT -I../../subprojects/minizip -I/Users/user209549/homebrew/Cellar/libpng/1.6.37/include/libpng16 -I/Users/user209549/homebrew/include/SDL2 -D_THREAD_SAFE -DM64P_OSD -I/Users/user209549/homebrew/opt/freetype/include/freetype2 -DNDEBUG -I../../subprojects/md5 -I../../subprojects/xxhash -DDYNAREC -DNEW_DYNAREC=4 -MD -MP -x assembler -
<stdin>:308:5: error: unknown token in expression
 add, , @PAGEOFF
    ^
<stdin>:308:5: error: invalid operand
 add, , @PAGEOFF
    ^
<stdin>:313:5: error: unknown token in expression
 add, , @PAGEOFF
    ^
<stdin>:313:5: error: invalid operand
 add, , @PAGEOFF
    ^
user209549@TX233 unix % 

Let me know if there's anything else I should try. I'm beginning to wonder if we shouldn't benchmark performance with NO_ASM and see if these new M1 chips are good to go without further optimization. Or is it more than just acceleration and the emulator loses functionality without dynarec?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/Jj0YzL5nvJ,28,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-961667697,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.","Try with:
myzhang1029/gas-preprocessor
or
FFmpeg/gas-preprocessor
Libav variant is old...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/keegandent,29,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-962113920,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.","Try with: myzhang1029/gas-preprocessor or FFmpeg/gas-preprocessor
Libav variant is old...

Tried this, same issue. I'm editing my previous with a more verbose output.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/Jj0YzL5nvJ,30,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-962533485,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.","If we examine the libretro implementation, gas-preprocessor is only used in a single place...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,831,2021-01-28T05:34:43Z,,2021-11-09T05:30:49Z,OPEN,False,69,45,1,https://github.com/MaddTheSane,Update linkage_arm64.S,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/831,https://github.com/keegandent,31,https://github.com/mupen64plus/mupen64plus-core/pull/831#issuecomment-963831317,"Add support for underscores in symbol names.
This is based off of my work on OpenEmu/Mupen64Plus-Core@decfb5d and OpenEmu/Mupen64Plus-Core@7c5a3eb
This is needed for Darwin/macOS and, I believe, Windows. (To get it to compile on Mac, you will need to use gas-preprocessor, but the current version doesn't like the adrp/add used by this file.)
To enable, pass -DLEADING_UNDERSCORE to the compiler/preprocessor/assembler.","Tried with a ton of different compiler arguments from that libretro example, but no dice. Even for their iOS-64 implementation, it seems they go with NO_ASM. I think that's a pretty good indication this has a slim hope of working. I'll leave what I have in https://github.com/keegandent/mupen64plus-core/tree/apple-silicon-asm in case somebody else wants to take a crack at it.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,832,2021-01-30T16:08:44Z,2021-01-31T07:53:13Z,2021-01-31T07:53:19Z,MERGED,True,143,15,6,https://github.com/bsmiles32,64dd save rebased,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/832,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/832,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,832,2021-01-30T16:08:44Z,2021-01-31T07:53:13Z,2021-01-31T07:53:19Z,MERGED,True,143,15,6,https://github.com/bsmiles32,64dd save rebased,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/832,https://github.com/LuigiBlood,2,https://github.com/mupen64plus/mupen64plus-core/pull/832#issuecomment-770281240,,Seems to work fine to me.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,832,2021-01-30T16:08:44Z,2021-01-31T07:53:13Z,2021-01-31T07:53:19Z,MERGED,True,143,15,6,https://github.com/bsmiles32,64dd save rebased,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/832,https://github.com/LuigiBlood,3,https://github.com/mupen64plus/mupen64plus-core/pull/832#issuecomment-770281385,,"In retrospect though I should have done this:
sys_data_->ram_lba_end = big16(MAX_LBA - SYSTEM_LBAS);
It's the exact same result but it explains exactly what is intended.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,834,2021-01-31T11:03:06Z,2021-01-31T12:43:59Z,2021-01-31T12:44:11Z,MERGED,True,1,1,1,https://github.com/bsmiles32,refactor lba_end computation to better convey intent,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/834,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/834,"cc @LuigiBlood
Did what you mentionned in the previous PR. Should be equivalent to previous code.","cc @LuigiBlood
Did what you mentionned in the previous PR. Should be equivalent to previous code.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,834,2021-01-31T11:03:06Z,2021-01-31T12:43:59Z,2021-01-31T12:44:11Z,MERGED,True,1,1,1,https://github.com/bsmiles32,refactor lba_end computation to better convey intent,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/834,https://github.com/LuigiBlood,2,https://github.com/mupen64plus/mupen64plus-core/pull/834#issuecomment-770374607,"cc @LuigiBlood
Did what you mentionned in the previous PR. Should be equivalent to previous code.",this is good,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,835,2021-01-31T19:01:37Z,2021-02-01T08:46:53Z,2021-02-01T11:10:47Z,MERGED,True,25,7,1,https://github.com/bsmiles32,Change mempak formatting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/835,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/835,"This should better match what the underlying file system expects and is
in accordance with libdragon formatting procedure.
Previously we were writing 0x0003 (=Free page indicator) until the end
of mempak, but this should only be done in pages 5-128 slots.
The remaining content of the mempak is zeroed.
NOTE: this only change the default data for newly created MPK files.
cc: @bryc","This should better match what the underlying file system expects and is
in accordance with libdragon formatting procedure.
Previously we were writing 0x0003 (=Free page indicator) until the end
of mempak, but this should only be done in pages 5-128 slots.
The remaining content of the mempak is zeroed.
NOTE: this only change the default data for newly created MPK files.
cc: @bryc",True,{'THUMBS_UP': ['https://github.com/bryc']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,835,2021-01-31T19:01:37Z,2021-02-01T08:46:53Z,2021-02-01T11:10:47Z,MERGED,True,25,7,1,https://github.com/bsmiles32,Change mempak formatting,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/835,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/835#issuecomment-770683280,"This should better match what the underlying file system expects and is
in accordance with libdragon formatting procedure.
Previously we were writing 0x0003 (=Free page indicator) until the end
of mempak, but this should only be done in pages 5-128 slots.
The remaining content of the mempak is zeroed.
NOTE: this only change the default data for newly created MPK files.
cc: @bryc",Nice!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,836,2021-02-01T17:28:17Z,2021-02-02T18:22:31Z,2021-02-03T22:47:55Z,MERGED,True,2,2,2,https://github.com/bsmiles32,"Fix some warnings about wrong pointer format ""%p"" needs a void*",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/836,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/836,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,836,2021-02-01T17:28:17Z,2021-02-02T18:22:31Z,2021-02-03T22:47:55Z,MERGED,True,2,2,2,https://github.com/bsmiles32,"Fix some warnings about wrong pointer format ""%p"" needs a void*",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/836,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/836#issuecomment-771864526,,Thanks!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,840,2021-02-21T04:32:03Z,2021-02-21T05:22:33Z,2021-06-20T20:47:14Z,MERGED,True,7,0,1,https://github.com/loganmc10,Add Dinosaur Planet to ini,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/840,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/840,"Sent to me in: m64p/m64p#129
I tested the ROM and it works with these settings","Sent to me in: m64p/m64p#129
I tested the ROM and it works with these settings",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,840,2021-02-21T04:32:03Z,2021-02-21T05:22:33Z,2021-06-20T20:47:14Z,MERGED,True,7,0,1,https://github.com/loganmc10,Add Dinosaur Planet to ini,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/840,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/840#issuecomment-783319993,"Sent to me in: m64p/m64p#129
I tested the ROM and it works with these settings","Count per op of 1 makes enemies really hard to hit, almost impossible. Count per op of 2 makes them easier to hit, but the frame rate is lower.
You can see the difference in the first enemy.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,840,2021-02-21T04:32:03Z,2021-02-21T05:22:33Z,2021-06-20T20:47:14Z,MERGED,True,7,0,1,https://github.com/loganmc10,Add Dinosaur Planet to ini,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/840,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/840#issuecomment-783415191,"Sent to me in: m64p/m64p#129
I tested the ROM and it works with these settings","Interesting, I did notice it was almost impossible to hit the first bad guy, I didn't realize that was the cause.
I submitted #841 to remove that setting",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,841,2021-02-22T14:29:52Z,2021-02-22T17:50:31Z,2021-06-20T20:47:54Z,MERGED,True,0,1,1,https://github.com/loganmc10,Remove CountPerOp=1 for Dino Planet,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/841,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/841,Makes it hard to hit enemies,Makes it hard to hit enemies,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,843,2021-02-23T14:39:36Z,2021-02-23T14:40:38Z,2021-02-23T14:40:45Z,MERGED,True,2,0,1,https://github.com/m4xw,[new_dynarec] Trivial perf improvement on initial recompilation,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/843,https://github.com/m4xw,1,https://github.com/mupen64plus/mupen64plus-core/pull/843,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,843,2021-02-23T14:39:36Z,2021-02-23T14:40:38Z,2021-02-23T14:40:45Z,MERGED,True,2,0,1,https://github.com/m4xw,[new_dynarec] Trivial perf improvement on initial recompilation,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/843,https://github.com/m4xw,2,https://github.com/mupen64plus/mupen64plus-core/pull/843#issuecomment-784249186,,Combats the mess at https://github.com/mupen64plus/mupen64plus-core/blob/master/src/device/r4300/new_dynarec/new_dynarec.c#L7726-L7782,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,844,2021-02-28T12:40:23Z,,2021-06-13T12:48:16Z,OPEN,False,3241,266,1,https://github.com/Mastergatto,New Database fixes,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/844,https://github.com/Mastergatto,1,https://github.com/mupen64plus/mupen64plus-core/pull/844,"Since there are a lot of fixes, I thought it's best to make two separate commits for (a bit) easier review.
The first one commit is very large and the reason for this is that currently, according to the database, official and licensed games advertise their support for Pak accessories when they actually don't. For example, Super Mario 64 (U) [!] doesn't support any of available accessories for N64, but here on mupen64plus the game appears to advertise Rumble Pak support, which is false. So, to correct this lie, we must specify also what Paks it doesn't support, and the end result is that for all games we add some thousand of new lines to database.
The second commit just adds new prototypes and betas, and it also specify what Paks they support. There are also minor fixes, correcting good names to reflect more those in No-Intro. I have also moved Japanese OoT entries at the bottom of the list, for which it can make the PR appearing confusing to whose have to review it, and I apologize for that.
I have tested this new version of the database and it hasn't given any errors so far.","Since there are a lot of fixes, I thought it's best to make two separate commits for (a bit) easier review.
The first one commit is very large and the reason for this is that currently, according to the database, official and licensed games advertise their support for Pak accessories when they actually don't. For example, Super Mario 64 (U) [!] doesn't support any of available accessories for N64, but here on mupen64plus the game appears to advertise Rumble Pak support, which is false. So, to correct this lie, we must specify also what Paks it doesn't support, and the end result is that for all games we add some thousand of new lines to database.
The second commit just adds new prototypes and betas, and it also specify what Paks they support. There are also minor fixes, correcting good names to reflect more those in No-Intro. I have also moved Japanese OoT entries at the bottom of the list, for which it can make the PR appearing confusing to whose have to review it, and I apologize for that.
I have tested this new version of the database and it hasn't given any errors so far.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,844,2021-02-28T12:40:23Z,,2021-06-13T12:48:16Z,OPEN,False,3241,266,1,https://github.com/Mastergatto,New Database fixes,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/844,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/844#issuecomment-788813868,"Since there are a lot of fixes, I thought it's best to make two separate commits for (a bit) easier review.
The first one commit is very large and the reason for this is that currently, according to the database, official and licensed games advertise their support for Pak accessories when they actually don't. For example, Super Mario 64 (U) [!] doesn't support any of available accessories for N64, but here on mupen64plus the game appears to advertise Rumble Pak support, which is false. So, to correct this lie, we must specify also what Paks it doesn't support, and the end result is that for all games we add some thousand of new lines to database.
The second commit just adds new prototypes and betas, and it also specify what Paks they support. There are also minor fixes, correcting good names to reflect more those in No-Intro. I have also moved Japanese OoT entries at the bottom of the list, for which it can make the PR appearing confusing to whose have to review it, and I apologize for that.
I have tested this new version of the database and it hasn't given any errors so far.","according to the database, official and licensed games advertise their support for Pak accessories when they actually don't

I suspect this is the weird statement here. Where the database states a game support Pack accessories when it actually don't?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,844,2021-02-28T12:40:23Z,,2021-06-13T12:48:16Z,OPEN,False,3241,266,1,https://github.com/Mastergatto,New Database fixes,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/844,https://github.com/Jj0YzL5nvJ,3,https://github.com/mupen64plus/mupen64plus-core/pull/844#issuecomment-788837398,"Since there are a lot of fixes, I thought it's best to make two separate commits for (a bit) easier review.
The first one commit is very large and the reason for this is that currently, according to the database, official and licensed games advertise their support for Pak accessories when they actually don't. For example, Super Mario 64 (U) [!] doesn't support any of available accessories for N64, but here on mupen64plus the game appears to advertise Rumble Pak support, which is false. So, to correct this lie, we must specify also what Paks it doesn't support, and the end result is that for all games we add some thousand of new lines to database.
The second commit just adds new prototypes and betas, and it also specify what Paks they support. There are also minor fixes, correcting good names to reflect more those in No-Intro. I have also moved Japanese OoT entries at the bottom of the list, for which it can make the PR appearing confusing to whose have to review it, and I apologize for that.
I have tested this new version of the database and it hasn't given any errors so far.","Where the database states a game support Pak accessories when it actually don't?

As far as I know, the opposite case is more common. Many games can unlock additional functionality with certain Paks, even old ones by omission.
Example: If you have Perfect Dark and activate Hi-res with Expansion Pak and then you power off the console and switch to OoT, the PD's anti-aliasing is applied to OoT as well. But OoT hangs if you render certain parts of Hyrule Field. The Hi-res mode can be deactivated from any other game that supports Hi-res. But to apply it to OoT, it only recognizes PD's one.",True,{'EYES': ['https://github.com/Narann']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,844,2021-02-28T12:40:23Z,,2021-06-13T12:48:16Z,OPEN,False,3241,266,1,https://github.com/Mastergatto,New Database fixes,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/844,https://github.com/Mastergatto,4,https://github.com/mupen64plus/mupen64plus-core/pull/844#issuecomment-788886208,"Since there are a lot of fixes, I thought it's best to make two separate commits for (a bit) easier review.
The first one commit is very large and the reason for this is that currently, according to the database, official and licensed games advertise their support for Pak accessories when they actually don't. For example, Super Mario 64 (U) [!] doesn't support any of available accessories for N64, but here on mupen64plus the game appears to advertise Rumble Pak support, which is false. So, to correct this lie, we must specify also what Paks it doesn't support, and the end result is that for all games we add some thousand of new lines to database.
The second commit just adds new prototypes and betas, and it also specify what Paks they support. There are also minor fixes, correcting good names to reflect more those in No-Intro. I have also moved Japanese OoT entries at the bottom of the list, for which it can make the PR appearing confusing to whose have to review it, and I apologize for that.
I have tested this new version of the database and it hasn't given any errors so far.","according to the database, official and licensed games advertise their support for Pak accessories when they actually don't

I suspect this is the weird statement here. Where the database states a game support Pack accessories when it actually don't?

It's true that the database doesn't explicitly state that, but...bear with me.
For example, this is with current database:

With proposed fixes:

I suspect that somehow mupen64plus initializes by default the Rumble Pak and the Controller Pak, unless the relevant keys declare expressly the opposite. I guess this is an intended behavior to enable the two aforementioned accessories for homebrews, hacked roms or just unknown roms. @Jj0YzL5nvJ I think mupen64plus already uses what you propose, just that in this case Rumble Pak and Controller Pak are set on ""1"".",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,844,2021-02-28T12:40:23Z,,2021-06-13T12:48:16Z,OPEN,False,3241,266,1,https://github.com/Mastergatto,New Database fixes,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/844,https://github.com/Mastergatto,5,https://github.com/mupen64plus/mupen64plus-core/pull/844#issuecomment-860205722,"Since there are a lot of fixes, I thought it's best to make two separate commits for (a bit) easier review.
The first one commit is very large and the reason for this is that currently, according to the database, official and licensed games advertise their support for Pak accessories when they actually don't. For example, Super Mario 64 (U) [!] doesn't support any of available accessories for N64, but here on mupen64plus the game appears to advertise Rumble Pak support, which is false. So, to correct this lie, we must specify also what Paks it doesn't support, and the end result is that for all games we add some thousand of new lines to database.
The second commit just adds new prototypes and betas, and it also specify what Paks they support. There are also minor fixes, correcting good names to reflect more those in No-Intro. I have also moved Japanese OoT entries at the bottom of the list, for which it can make the PR appearing confusing to whose have to review it, and I apologize for that.
I have tested this new version of the database and it hasn't given any errors so far.","If there's no interest in merging this PR then we can close it, although I'd really like to see it being merged instead.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,847,2021-03-03T18:46:16Z,2021-04-12T03:25:32Z,2021-06-20T20:47:16Z,MERGED,True,19,28,2,https://github.com/loganmc10,Netplay fixes from Android port,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/847,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/847,"I wanted to make sure these don't get missed:
07a22ee
a00ba8d
@fzurita perhaps you could comment on the results of the speed limiter change? Do you think it could be merged into the upstream code?","I wanted to make sure these don't get missed:
07a22ee
a00ba8d
@fzurita perhaps you could comment on the results of the speed limiter change? Do you think it could be merged into the upstream code?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,847,2021-03-03T18:46:16Z,2021-04-12T03:25:32Z,2021-06-20T20:47:16Z,MERGED,True,19,28,2,https://github.com/loganmc10,Netplay fixes from Android port,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/847,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/847#issuecomment-789971164,"I wanted to make sure these don't get missed:
07a22ee
a00ba8d
@fzurita perhaps you could comment on the results of the speed limiter change? Do you think it could be merged into the upstream code?","Yeah, I think the speed limiter change can be merged. It mainly gets rid of the averaging and limits how long it can try to run faster to catch up to real time, if we fall behind momentarily.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,847,2021-03-03T18:46:16Z,2021-04-12T03:25:32Z,2021-06-20T20:47:16Z,MERGED,True,19,28,2,https://github.com/loganmc10,Netplay fixes from Android port,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/847,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/847#issuecomment-789972423,"I wanted to make sure these don't get missed:
07a22ee
a00ba8d
@fzurita perhaps you could comment on the results of the speed limiter change? Do you think it could be merged into the upstream code?","I know that @joeldenning experienced some issues with the speed limiter during netplay when he was doing performance/latency testing for Smash Bros.
I'm curious @joeldenning do you think you'd be able to test this change in a way that would tell you if it improved your netplay performance? I know you showed me some frame rate tracking that you were doing at the time.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,847,2021-03-03T18:46:16Z,2021-04-12T03:25:32Z,2021-06-20T20:47:16Z,MERGED,True,19,28,2,https://github.com/loganmc10,Netplay fixes from Android port,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/847,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/847#issuecomment-796847183,"I wanted to make sure these don't get missed:
07a22ee
a00ba8d
@fzurita perhaps you could comment on the results of the speed limiter change? Do you think it could be merged into the upstream code?","I suspect we may not hear back from Joel, @m4xw and @fzurita are you ok with these changes? I believe you've discussed it a bit on Discord?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,847,2021-03-03T18:46:16Z,2021-04-12T03:25:32Z,2021-06-20T20:47:16Z,MERGED,True,19,28,2,https://github.com/loganmc10,Netplay fixes from Android port,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/847,https://github.com/m4xw,5,https://github.com/mupen64plus/mupen64plus-core/pull/847#issuecomment-796850072,"I wanted to make sure these don't get missed:
07a22ee
a00ba8d
@fzurita perhaps you could comment on the results of the speed limiter change? Do you think it could be merged into the upstream code?",fwiw it can be cleaned up more,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,847,2021-03-03T18:46:16Z,2021-04-12T03:25:32Z,2021-06-20T20:47:16Z,MERGED,True,19,28,2,https://github.com/loganmc10,Netplay fixes from Android port,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/847,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/847#issuecomment-796861996,"I wanted to make sure these don't get missed:
07a22ee
a00ba8d
@fzurita perhaps you could comment on the results of the speed limiter change? Do you think it could be merged into the upstream code?",Do you have specific suggestions?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,847,2021-03-03T18:46:16Z,2021-04-12T03:25:32Z,2021-06-20T20:47:16Z,MERGED,True,19,28,2,https://github.com/loganmc10,Netplay fixes from Android port,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/847,https://github.com/m4xw,7,https://github.com/mupen64plus/mupen64plus-core/pull/847#issuecomment-796864182,"I wanted to make sure these don't get missed:
07a22ee
a00ba8d
@fzurita perhaps you could comment on the results of the speed limiter change? Do you think it could be merged into the upstream code?","For example the boolean equation if(sleepTime > 0 && sleepTime < maxSleepNeeded*SpeedFactorMultiple && l_MainSpeedLimit) can be optimize to check for l_MainSpeedLimit first, saves some unrequired calculations on the < case, iirc fzurita had smth in mind as well, can't remember what he meant tho",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,847,2021-03-03T18:46:16Z,2021-04-12T03:25:32Z,2021-06-20T20:47:16Z,MERGED,True,19,28,2,https://github.com/loganmc10,Netplay fixes from Android port,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/847,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/847#issuecomment-796887102,"I wanted to make sure these don't get missed:
07a22ee
a00ba8d
@fzurita perhaps you could comment on the results of the speed limiter change? Do you think it could be merged into the upstream code?",Ok I made the suggested optimization,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,847,2021-03-03T18:46:16Z,2021-04-12T03:25:32Z,2021-06-20T20:47:16Z,MERGED,True,19,28,2,https://github.com/loganmc10,Netplay fixes from Android port,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/847,https://github.com/fzurita,9,https://github.com/mupen64plus/mupen64plus-core/pull/847#issuecomment-796888741,"I wanted to make sure these don't get missed:
07a22ee
a00ba8d
@fzurita perhaps you could comment on the results of the speed limiter change? Do you think it could be merged into the upstream code?","#define SAMPLE_COUNT 3 can also be removed.
I can't remember what @m4xw was talking about though :/",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,847,2021-03-03T18:46:16Z,2021-04-12T03:25:32Z,2021-06-20T20:47:16Z,MERGED,True,19,28,2,https://github.com/loganmc10,Netplay fixes from Android port,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/847,https://github.com/m4xw,10,https://github.com/mupen64plus/mupen64plus-core/pull/847#issuecomment-796913805,"I wanted to make sure these don't get missed:
07a22ee
a00ba8d
@fzurita perhaps you could comment on the results of the speed limiter change? Do you think it could be merged into the upstream code?","Oh maybe I got your response wrong when i suggested removing sample count as well, thought you had yet something other than that.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,847,2021-03-03T18:46:16Z,2021-04-12T03:25:32Z,2021-06-20T20:47:16Z,MERGED,True,19,28,2,https://github.com/loganmc10,Netplay fixes from Android port,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/847,https://github.com/loganmc10,11,https://github.com/mupen64plus/mupen64plus-core/pull/847#issuecomment-798949852,"I wanted to make sure these don't get missed:
07a22ee
a00ba8d
@fzurita perhaps you could comment on the results of the speed limiter change? Do you think it could be merged into the upstream code?","Ok I've addressed the issues mentioned, any other feedback? I'm eager to merge a more netplay friendly limiter :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,847,2021-03-03T18:46:16Z,2021-04-12T03:25:32Z,2021-06-20T20:47:16Z,MERGED,True,19,28,2,https://github.com/loganmc10,Netplay fixes from Android port,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/847,https://github.com/loganmc10,12,https://github.com/mupen64plus/mupen64plus-core/pull/847#issuecomment-813564198,"I wanted to make sure these don't get missed:
07a22ee
a00ba8d
@fzurita perhaps you could comment on the results of the speed limiter change? Do you think it could be merged into the upstream code?",Still looking for someone to merge this plz,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,848,2021-03-04T15:14:17Z,2021-03-07T15:24:16Z,2021-03-10T09:05:29Z,MERGED,True,310,262,3,https://github.com/Gillou68310,Fix https://github.com/mupen64plus/mupen64plus-core/issues/842,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/848,https://github.com/Gillou68310,1,https://github.com/mupen64plus/mupen64plus-core/pull/848,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,848,2021-03-04T15:14:17Z,2021-03-07T15:24:16Z,2021-03-10T09:05:29Z,MERGED,True,310,262,3,https://github.com/Gillou68310,Fix https://github.com/mupen64plus/mupen64plus-core/issues/842,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/848,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/848#issuecomment-790735230,,"I think it deserves a better name, don't you? :D",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,848,2021-03-04T15:14:17Z,2021-03-07T15:24:16Z,2021-03-10T09:05:29Z,MERGED,True,310,262,3,https://github.com/Gillou68310,Fix https://github.com/mupen64plus/mupen64plus-core/issues/842,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/848,https://github.com/richard42,3,https://github.com/mupen64plus/mupen64plus-core/pull/848#issuecomment-792219983,,is it ready to go or still WIP?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,848,2021-03-04T15:14:17Z,2021-03-07T15:24:16Z,2021-03-10T09:05:29Z,MERGED,True,310,262,3,https://github.com/Gillou68310,Fix https://github.com/mupen64plus/mupen64plus-core/issues/842,3,[],https://github.com/mupen64plus/mupen64plus-core/pull/848,https://github.com/Gillou68310,4,https://github.com/mupen64plus/mupen64plus-core/pull/848#issuecomment-792240237,,Should be ready to go!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,853,2021-04-16T09:58:56Z,2021-04-16T10:46:28Z,2021-04-17T16:03:44Z,MERGED,True,2,0,1,https://github.com/Jj0YzL5nvJ,Prevents game freezing unrelated to dynarecs,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/853,https://github.com/Jj0YzL5nvJ,1,https://github.com/mupen64plus/mupen64plus-core/pull/853,gonetz/GLideN64#2473,gonetz/GLideN64#2473,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,853,2021-04-16T09:58:56Z,2021-04-16T10:46:28Z,2021-04-17T16:03:44Z,MERGED,True,2,0,1,https://github.com/Jj0YzL5nvJ,Prevents game freezing unrelated to dynarecs,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/853,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/853#issuecomment-821212388,gonetz/GLideN64#2473,"I believe this probably needs to be reverted.
@Jj0YzL5nvJ @Narann  you can test to confirm, but I don't think Indiana Jones boots with CountPerOp=1 if a save file doesn't exist.
Try deleting any save file you have (Indiana Jones and the Infernal Machine (U) [!].eep) and then boot the game with CountPerOp=1, from what I can see it always hangs/doesn't boot. For whatever reason, if the .eep file exists already, it seems to work",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,853,2021-04-16T09:58:56Z,2021-04-16T10:46:28Z,2021-04-17T16:03:44Z,MERGED,True,2,0,1,https://github.com/Jj0YzL5nvJ,Prevents game freezing unrelated to dynarecs,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/853,https://github.com/Narann,3,https://github.com/mupen64plus/mupen64plus-core/pull/853#issuecomment-821214649,gonetz/GLideN64#2473,"Damn, sorry guys, I didn't want to wait for such a simple task. I will revert and let you discuss.
Sorry again.
Edit: Before reverting, can anyone confirm Indiana Jones doesn't boot with CountPerOp=1?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,853,2021-04-16T09:58:56Z,2021-04-16T10:46:28Z,2021-04-17T16:03:44Z,MERGED,True,2,0,1,https://github.com/Jj0YzL5nvJ,Prevents game freezing unrelated to dynarecs,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/853,https://github.com/Jj0YzL5nvJ,4,https://github.com/mupen64plus/mupen64plus-core/pull/853#issuecomment-821321920,gonetz/GLideN64#2473,"Try deleting any save file you have (Indiana Jones and the Infernal Machine (U) [!].eep) and then boot the game with CountPerOp=1, from what I can see it always hangs/doesn't boot.

Yes, I can confirm.

For whatever reason, if the .eep file exists already, it seems to work

Boot up with a * .eep file produced with CountPerOp=0 but hangs with one produced with CountPerOp=1.
CountPerOp=0
$ xxd -l 512 ""0_Indiana Jones and the Infernal Machine (U) [!].eep""
00000000: 02d6 00f3 00f0 0002 0589 01c1 0000 0000  ................
00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000020: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000030: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000040: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000050: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000060: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000070: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000080: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000090: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000b0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000c0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000d0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000e0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000f0: 0000 0000 0000 0000 0000 0037 007f ff0b  ...........7....
00000100: 0589 01c1 0000 0000 0000 0000 0000 0000  ................
00000110: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000120: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000130: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000140: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000150: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000160: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000170: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000180: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000190: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000001a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000001b0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000001c0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000001d0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000001e0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000001f0: 0000 0037 007f ff0b 0000 0000 0000 0000  ...7............

CountPerOp=1
$ xxd -l 512 ""1_Indiana Jones and the Infernal Machine (U) [!].eep""
00000000: 0000 0000 0000 0000 ffff ffff ffff ffff  ................
00000010: ffff ffff ffff ffff ffff ffff ffff ffff  ................
00000020: ffff ffff ffff ffff ffff ffff ffff ffff  ................
00000030: ffff ffff ffff ffff ffff ffff ffff ffff  ................
00000040: ffff ffff ffff ffff ffff ffff ffff ffff  ................
00000050: ffff ffff ffff ffff ffff ffff ffff ffff  ................
00000060: ffff ffff ffff ffff ffff ffff ffff ffff  ................
00000070: ffff ffff ffff ffff ffff ffff ffff ffff  ................
00000080: ffff ffff ffff ffff ffff ffff ffff ffff  ................
00000090: ffff ffff ffff ffff ffff ffff ffff ffff  ................
000000a0: ffff ffff ffff ffff ffff ffff ffff ffff  ................
000000b0: ffff ffff ffff ffff ffff ffff ffff ffff  ................
000000c0: ffff ffff ffff ffff ffff ffff ffff ffff  ................
000000d0: ffff ffff ffff ffff ffff ffff ffff ffff  ................
000000e0: ffff ffff ffff ffff ffff ffff ffff ffff  ................
000000f0: ffff ffff ffff ffff ffff ffff ffff ffff  ................
00000100: ffff ffff ffff ffff ffff ffff ffff ffff  ................
00000110: ffff ffff ffff ffff ffff ffff ffff ffff  ................
00000120: ffff ffff ffff ffff ffff ffff ffff ffff  ................
00000130: ffff ffff ffff ffff ffff ffff ffff ffff  ................
00000140: ffff ffff ffff ffff ffff ffff ffff ffff  ................
00000150: ffff ffff ffff ffff ffff ffff ffff ffff  ................
00000160: ffff ffff ffff ffff ffff ffff ffff ffff  ................
00000170: ffff ffff ffff ffff ffff ffff ffff ffff  ................
00000180: ffff ffff ffff ffff ffff ffff ffff ffff  ................
00000190: ffff ffff ffff ffff ffff ffff ffff ffff  ................
000001a0: ffff ffff ffff ffff ffff ffff ffff ffff  ................
000001b0: ffff ffff ffff ffff ffff ffff ffff ffff  ................
000001c0: ffff ffff ffff ffff ffff ffff ffff ffff  ................
000001d0: ffff ffff ffff ffff ffff ffff ffff ffff  ................
000001e0: ffff ffff ffff ffff ffff ffff ffff ffff  ................
000001f0: ffff ffff ffff ffff ffff ffff ffff ffff  ................",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,853,2021-04-16T09:58:56Z,2021-04-16T10:46:28Z,2021-04-17T16:03:44Z,MERGED,True,2,0,1,https://github.com/Jj0YzL5nvJ,Prevents game freezing unrelated to dynarecs,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/853,https://github.com/Narann,5,https://github.com/mupen64plus/mupen64plus-core/pull/853#issuecomment-821487143,gonetz/GLideN64#2473,I reverted the commit.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,853,2021-04-16T09:58:56Z,2021-04-16T10:46:28Z,2021-04-17T16:03:44Z,MERGED,True,2,0,1,https://github.com/Jj0YzL5nvJ,Prevents game freezing unrelated to dynarecs,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/853,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/853#issuecomment-821498207,gonetz/GLideN64#2473,"Yeah it's definitely a weird/interesting issue. I remember looking into it when I was working on improving the compatibility of Indiana Jones. The overall game might actually work better with CountPerOp=1, but for some reason that prevents the initial boot, quite frustrating. I never did figure out a good solution",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,853,2021-04-16T09:58:56Z,2021-04-16T10:46:28Z,2021-04-17T16:03:44Z,MERGED,True,2,0,1,https://github.com/Jj0YzL5nvJ,Prevents game freezing unrelated to dynarecs,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/853,https://github.com/Jj0YzL5nvJ,7,https://github.com/mupen64plus/mupen64plus-core/pull/853#issuecomment-821529558,gonetz/GLideN64#2473,It looks like an overflow bug in EEPROM initialization.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,854,2021-04-16T18:44:11Z,2021-04-16T19:00:00Z,2021-04-16T19:00:10Z,MERGED,True,0,2,1,https://github.com/Narann,"Revert ""Prevents game freezing unrelated to dynarecs""",1,[],https://github.com/mupen64plus/mupen64plus-core/pull/854,https://github.com/Narann,1,https://github.com/mupen64plus/mupen64plus-core/pull/854,Reverts #853. Indiana Jones doesn't boots with CountPerOp=1 if a save file doesn't exist.,Reverts #853. Indiana Jones doesn't boots with CountPerOp=1 if a save file doesn't exist.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,858,2021-05-11T14:10:24Z,2021-05-11T19:07:09Z,2021-06-20T20:47:55Z,MERGED,True,5,0,1,https://github.com/loganmc10,Add SmashRemix0.9.7,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/858,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/858,The MD5 and CRC for the ROM were taken from the README.txt (https://github.com/JSsixtyfour/smashremix/releases/tag/0.9.7),The MD5 and CRC for the ROM were taken from the README.txt (https://github.com/JSsixtyfour/smashremix/releases/tag/0.9.7),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,858,2021-05-11T14:10:24Z,2021-05-11T19:07:09Z,2021-06-20T20:47:55Z,MERGED,True,5,0,1,https://github.com/loganmc10,Add SmashRemix0.9.7,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/858,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/858#issuecomment-839017057,The MD5 and CRC for the ROM were taken from the README.txt (https://github.com/JSsixtyfour/smashremix/releases/tag/0.9.7),Thanks!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,860,2021-06-01T01:30:51Z,2021-06-17T00:37:46Z,2021-06-20T20:47:22Z,MERGED,True,111,70,14,https://github.com/loganmc10,Support Unicode on Windows,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/860,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/860,"In order for Windows to support Unicode characters, it needs to use the _w versions of the functions (_wfopen and gzopen_w for example).
Right now mupen64plus doesn't support referencing files on Windows that are in a path containing non-Latin characters, this PR fixes that problem.","In order for Windows to support Unicode characters, it needs to use the _w versions of the functions (_wfopen and gzopen_w for example).
Right now mupen64plus doesn't support referencing files on Windows that are in a path containing non-Latin characters, this PR fixes that problem.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,860,2021-06-01T01:30:51Z,2021-06-17T00:37:46Z,2021-06-20T20:47:22Z,MERGED,True,111,70,14,https://github.com/loganmc10,Support Unicode on Windows,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/860,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/860#issuecomment-852191395,"In order for Windows to support Unicode characters, it needs to use the _w versions of the functions (_wfopen and gzopen_w for example).
Right now mupen64plus doesn't support referencing files on Windows that are in a path containing non-Latin characters, this PR fixes that problem.","I believe this is ready to merge. I had a German-language user who has a Unicode character in their username test it: m64p/m64p#157 (comment)
@bsmiles32 @richard42 @Gillou68310 @Narann",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,860,2021-06-01T01:30:51Z,2021-06-17T00:37:46Z,2021-06-20T20:47:22Z,MERGED,True,111,70,14,https://github.com/loganmc10,Support Unicode on Windows,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/860,https://github.com/Narann,3,https://github.com/mupen64plus/mupen64plus-core/pull/860#issuecomment-852242418,"In order for Windows to support Unicode characters, it needs to use the _w versions of the functions (_wfopen and gzopen_w for example).
Right now mupen64plus doesn't support referencing files on Windows that are in a path containing non-Latin characters, this PR fixes that problem.","Thanks for the good work!
Looks nice to me, except the few questions to @richard42 (I'm not a Windows dev).",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,860,2021-06-01T01:30:51Z,2021-06-17T00:37:46Z,2021-06-20T20:47:22Z,MERGED,True,111,70,14,https://github.com/loganmc10,Support Unicode on Windows,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/860,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/860#issuecomment-853243055,"In order for Windows to support Unicode characters, it needs to use the _w versions of the functions (_wfopen and gzopen_w for example).
Right now mupen64plus doesn't support referencing files on Windows that are in a path containing non-Latin characters, this PR fixes that problem.","Yeah I didn't make an osal_gzopen since it only occurred in 1 file, it didn't seem like there was much to be gained by abstracting it.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,860,2021-06-01T01:30:51Z,2021-06-17T00:37:46Z,2021-06-20T20:47:22Z,MERGED,True,111,70,14,https://github.com/loganmc10,Support Unicode on Windows,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/860,https://github.com/Narann,5,https://github.com/mupen64plus/mupen64plus-core/pull/860#issuecomment-853299049,"In order for Windows to support Unicode characters, it needs to use the _w versions of the functions (_wfopen and gzopen_w for example).
Right now mupen64plus doesn't support referencing files on Windows that are in a path containing non-Latin characters, this PR fixes that problem.","This would centralize ifdef WIN32 which is cleaner, IMHO.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,860,2021-06-01T01:30:51Z,2021-06-17T00:37:46Z,2021-06-20T20:47:22Z,MERGED,True,111,70,14,https://github.com/loganmc10,Support Unicode on Windows,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/860,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/860#issuecomment-856304068,"In order for Windows to support Unicode characters, it needs to use the _w versions of the functions (_wfopen and gzopen_w for example).
Right now mupen64plus doesn't support referencing files on Windows that are in a path containing non-Latin characters, this PR fixes that problem.",Ok I've created the osal_gzopen function,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,860,2021-06-01T01:30:51Z,2021-06-17T00:37:46Z,2021-06-20T20:47:22Z,MERGED,True,111,70,14,https://github.com/loganmc10,Support Unicode on Windows,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/860,https://github.com/Narann,7,https://github.com/mupen64plus/mupen64plus-core/pull/860#issuecomment-856871242,"In order for Windows to support Unicode characters, it needs to use the _w versions of the functions (_wfopen and gzopen_w for example).
Right now mupen64plus doesn't support referencing files on Windows that are in a path containing non-Latin characters, this PR fixes that problem.","Thanks! Looks better to me, I will let @richard42 merge this.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,863,2021-06-07T14:19:08Z,2021-06-17T01:17:34Z,2021-06-20T20:47:18Z,MERGED,True,1,1,1,https://github.com/loganmc10,Get Xena (E) to boot,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/863,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/863,"Xena (E) doesn't boot currently, needs CountPerOp=4. Obviously it's not the best solution, but the game seems to run OK and the in-game count down timer seems to be fairly accurate","Xena (E) doesn't boot currently, needs CountPerOp=4. Obviously it's not the best solution, but the game seems to run OK and the in-game count down timer seems to be fairly accurate",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,865,2021-06-10T03:01:30Z,2021-07-05T14:47:54Z,2021-07-05T14:48:00Z,MERGED,True,1,0,1,https://github.com/loganmc10,Fix Pokemon Puzzle League saving,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/865,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/865,"Saving in Pokemon Puzzle League is currently broken. No .fla file is created at all.
It was broken by: 6049618
This commit restores this line (using the new logic):
6049618#diff-af6d71b286c633a07adc8703bbbb9f229f697dcd1c913aafad1a592d61492205L90
This makes Pokemon Puzzle League saving work again.
I checked a few other Flash RAM games (Command & Conquer, Pokemon Stadium, JFG, Paper Mario) and they are all still working normally. @bsmiles32 I'd really like to hear your feedback on this if possible","Saving in Pokemon Puzzle League is currently broken. No .fla file is created at all.
It was broken by: 6049618
This commit restores this line (using the new logic):
6049618#diff-af6d71b286c633a07adc8703bbbb9f229f697dcd1c913aafad1a592d61492205L90
This makes Pokemon Puzzle League saving work again.
I checked a few other Flash RAM games (Command & Conquer, Pokemon Stadium, JFG, Paper Mario) and they are all still working normally. @bsmiles32 I'd really like to hear your feedback on this if possible",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,865,2021-06-10T03:01:30Z,2021-07-05T14:47:54Z,2021-07-05T14:48:00Z,MERGED,True,1,0,1,https://github.com/loganmc10,Fix Pokemon Puzzle League saving,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/865,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/865#issuecomment-864312626,"Saving in Pokemon Puzzle League is currently broken. No .fla file is created at all.
It was broken by: 6049618
This commit restores this line (using the new logic):
6049618#diff-af6d71b286c633a07adc8703bbbb9f229f697dcd1c913aafad1a592d61492205L90
This makes Pokemon Puzzle League saving work again.
I checked a few other Flash RAM games (Command & Conquer, Pokemon Stadium, JFG, Paper Mario) and they are all still working normally. @bsmiles32 I'd really like to hear your feedback on this if possible","I'm not sure why the program busy flag should be set when entering silicon_id mode. Maybe some kind of timing issue + incorrect usage of flashram ? But anyway, if it fixes the game I'm OK for merging this if you add a comment like ""// Needed for Pokemon Puzzle league"" so we know what game to check if we change that logic in the future.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,865,2021-06-10T03:01:30Z,2021-07-05T14:47:54Z,2021-07-05T14:48:00Z,MERGED,True,1,0,1,https://github.com/loganmc10,Fix Pokemon Puzzle League saving,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/865,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/865#issuecomment-864590699,"Saving in Pokemon Puzzle League is currently broken. No .fla file is created at all.
It was broken by: 6049618
This commit restores this line (using the new logic):
6049618#diff-af6d71b286c633a07adc8703bbbb9f229f697dcd1c913aafad1a592d61492205L90
This makes Pokemon Puzzle League saving work again.
I checked a few other Flash RAM games (Command & Conquer, Pokemon Stadium, JFG, Paper Mario) and they are all still working normally. @bsmiles32 I'd really like to hear your feedback on this if possible","Sure, I've made that change",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,865,2021-06-10T03:01:30Z,2021-07-05T14:47:54Z,2021-07-05T14:48:00Z,MERGED,True,1,0,1,https://github.com/loganmc10,Fix Pokemon Puzzle League saving,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/865,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/865#issuecomment-874082623,"Saving in Pokemon Puzzle League is currently broken. No .fla file is created at all.
It was broken by: 6049618
This commit restores this line (using the new logic):
6049618#diff-af6d71b286c633a07adc8703bbbb9f229f697dcd1c913aafad1a592d61492205L90
This makes Pokemon Puzzle League saving work again.
I checked a few other Flash RAM games (Command & Conquer, Pokemon Stadium, JFG, Paper Mario) and they are all still working normally. @bsmiles32 I'd really like to hear your feedback on this if possible",I think this should be ok to merge now,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,865,2021-06-10T03:01:30Z,2021-07-05T14:47:54Z,2021-07-05T14:48:00Z,MERGED,True,1,0,1,https://github.com/loganmc10,Fix Pokemon Puzzle League saving,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/865,https://github.com/Narann,5,https://github.com/mupen64plus/mupen64plus-core/pull/865#issuecomment-874168179,"Saving in Pokemon Puzzle League is currently broken. No .fla file is created at all.
It was broken by: 6049618
This commit restores this line (using the new logic):
6049618#diff-af6d71b286c633a07adc8703bbbb9f229f697dcd1c913aafad1a592d61492205L90
This makes Pokemon Puzzle League saving work again.
I checked a few other Flash RAM games (Command & Conquer, Pokemon Stadium, JFG, Paper Mario) and they are all still working normally. @bsmiles32 I'd really like to hear your feedback on this if possible",Thanks ! :),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,866,2021-06-11T04:32:03Z,2021-06-17T02:03:49Z,2021-06-20T20:47:19Z,MERGED,True,2,0,1,https://github.com/loganmc10,invalidate alternate address on write,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/866,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/866,"Fixes #738
@Gillou68310 @bsmiles32 @richard42
I'd appreciate some feedback to ensure I've done the right thing here (I think I have).
libdragon seems to have a habit of accessing memory using the 0x8.... address and the 0xa.... address interchangeably.
In the other calls to invalidate_r4300_cached_code, both addresses are invalidated, but not in r4300_write_aligned_(d)word.
This allows libdragon software like Flappy Bird to function. I didn't see any negative side affects with other games.","Fixes #738
@Gillou68310 @bsmiles32 @richard42
I'd appreciate some feedback to ensure I've done the right thing here (I think I have).
libdragon seems to have a habit of accessing memory using the 0x8.... address and the 0xa.... address interchangeably.
In the other calls to invalidate_r4300_cached_code, both addresses are invalidated, but not in r4300_write_aligned_(d)word.
This allows libdragon software like Flappy Bird to function. I didn't see any negative side affects with other games.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,866,2021-06-11T04:32:03Z,2021-06-17T02:03:49Z,2021-06-20T20:47:19Z,MERGED,True,2,0,1,https://github.com/loganmc10,invalidate alternate address on write,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/866,https://github.com/Gillou68310,2,https://github.com/mupen64plus/mupen64plus-core/pull/866#issuecomment-859496417,"Fixes #738
@Gillou68310 @bsmiles32 @richard42
I'd appreciate some feedback to ensure I've done the right thing here (I think I have).
libdragon seems to have a habit of accessing memory using the 0x8.... address and the 0xa.... address interchangeably.
In the other calls to invalidate_r4300_cached_code, both addresses are invalidated, but not in r4300_write_aligned_(d)word.
This allows libdragon software like Flappy Bird to function. I didn't see any negative side affects with other games.",This only fixes cached interpreter right?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,866,2021-06-11T04:32:03Z,2021-06-17T02:03:49Z,2021-06-20T20:47:19Z,MERGED,True,2,0,1,https://github.com/loganmc10,invalidate alternate address on write,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/866,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/866#issuecomment-859580757,"Fixes #738
@Gillou68310 @bsmiles32 @richard42
I'd appreciate some feedback to ensure I've done the right thing here (I think I have).
libdragon seems to have a habit of accessing memory using the 0x8.... address and the 0xa.... address interchangeably.
In the other calls to invalidate_r4300_cached_code, both addresses are invalidated, but not in r4300_write_aligned_(d)word.
This allows libdragon software like Flappy Bird to function. I didn't see any negative side affects with other games.","This only fixes cached interpreter right?

I just tested, it now works on the new dynarec (tested x64), but not the old dynarec. I'm guessing there is something else unrelated to this issue that would need to be fixed on the old dynarec.
This particular code isn't specific to a single interpreter/dynarec.
Edit: also just keep in mind that due to the unique nature of these games, they don't work with every GFX plugin, I'd test using angrylion, although I think they should also work with recent versions of GlideN64.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,867,2021-06-11T15:07:08Z,2021-06-17T02:04:55Z,2021-06-17T02:04:55Z,MERGED,True,2,2,1,https://github.com/thekovic,Rearranged order of Core settings in the config file,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/867,https://github.com/thekovic,1,https://github.com/mupen64plus/mupen64plus-core/pull/867,"CountPerOp is (along with DisableExtraMem) one of the settings that have to be often changed between games (and sometimes even while playing the same game to resolve bugs). However, it is inexplicably located near the bottom. I placed it higher up, next to DisableExtraMem.
EnableDebugger was located between the two save slot options, I placed it lower.
I believe these changes not only make more sense when working with the config by itself, more importantly they also help with user experience in those downstream GUI projects that render their settings menu by reading the config from top to bottom.","CountPerOp is (along with DisableExtraMem) one of the settings that have to be often changed between games (and sometimes even while playing the same game to resolve bugs). However, it is inexplicably located near the bottom. I placed it higher up, next to DisableExtraMem.
EnableDebugger was located between the two save slot options, I placed it lower.
I believe these changes not only make more sense when working with the config by itself, more importantly they also help with user experience in those downstream GUI projects that render their settings menu by reading the config from top to bottom.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,868,2021-06-11T17:25:29Z,2021-06-14T18:59:23Z,2021-06-20T20:48:09Z,MERGED,True,32,6,2,https://github.com/loganmc10,Update PI DMA alignment as per CEN64,1,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/868,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/868,"Taken from: https://github.com/n64dev/cen64/blob/master/pi/controller.c
Tested using: https://github.com/PeterLemon/N64/tree/master/CPUTest/DMAAlignment-PI-cart
Before:

After:

There are still 2 tests that fail here that pass on CEN64: n64dev/cen64#200. However, I couldn't get those tests to pass without breaking the graphics in AI Shougi 3, so I left it at the point where AI Shougi 3 would work. AI Shougi 3 graphics are messed up in CEN64, so I assume there is still more work to be done on their implementation.","Taken from: https://github.com/n64dev/cen64/blob/master/pi/controller.c
Tested using: https://github.com/PeterLemon/N64/tree/master/CPUTest/DMAAlignment-PI-cart
Before:

After:

There are still 2 tests that fail here that pass on CEN64: n64dev/cen64#200. However, I couldn't get those tests to pass without breaking the graphics in AI Shougi 3, so I left it at the point where AI Shougi 3 would work. AI Shougi 3 graphics are messed up in CEN64, so I assume there is still more work to be done on their implementation.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,868,2021-06-11T17:25:29Z,2021-06-14T18:59:23Z,2021-06-20T20:48:09Z,MERGED,True,32,6,2,https://github.com/loganmc10,Update PI DMA alignment as per CEN64,1,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/868,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/868#issuecomment-860030426,"Taken from: https://github.com/n64dev/cen64/blob/master/pi/controller.c
Tested using: https://github.com/PeterLemon/N64/tree/master/CPUTest/DMAAlignment-PI-cart
Before:

After:

There are still 2 tests that fail here that pass on CEN64: n64dev/cen64#200. However, I couldn't get those tests to pass without breaking the graphics in AI Shougi 3, so I left it at the point where AI Shougi 3 would work. AI Shougi 3 graphics are messed up in CEN64, so I assume there is still more work to be done on their implementation.","Thanks for the hard work. The code is clean, thanks for this!
I can merge this because I suspect no-one will have the required knowledge to validate this and the scope of this flag seems to be limited.
EDIT: I saw some force pushes, tell me when you think the PR is ready for merge. :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,868,2021-06-11T17:25:29Z,2021-06-14T18:59:23Z,2021-06-20T20:48:09Z,MERGED,True,32,6,2,https://github.com/loganmc10,Update PI DMA alignment as per CEN64,1,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/868,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/868#issuecomment-860052319,"Taken from: https://github.com/n64dev/cen64/blob/master/pi/controller.c
Tested using: https://github.com/PeterLemon/N64/tree/master/CPUTest/DMAAlignment-PI-cart
Before:

After:

There are still 2 tests that fail here that pass on CEN64: n64dev/cen64#200. However, I couldn't get those tests to pass without breaking the graphics in AI Shougi 3, so I left it at the point where AI Shougi 3 would work. AI Shougi 3 graphics are messed up in CEN64, so I assume there is still more work to be done on their implementation.","Yeah it's ready now, I don't plan on making any further changes",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,868,2021-06-11T17:25:29Z,2021-06-14T18:59:23Z,2021-06-20T20:48:09Z,MERGED,True,32,6,2,https://github.com/loganmc10,Update PI DMA alignment as per CEN64,1,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/868,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/868#issuecomment-860052984,"Taken from: https://github.com/n64dev/cen64/blob/master/pi/controller.c
Tested using: https://github.com/PeterLemon/N64/tree/master/CPUTest/DMAAlignment-PI-cart
Before:

After:

There are still 2 tests that fail here that pass on CEN64: n64dev/cen64#200. However, I couldn't get those tests to pass without breaking the graphics in AI Shougi 3, so I left it at the point where AI Shougi 3 would work. AI Shougi 3 graphics are messed up in CEN64, so I assume there is still more work to be done on their implementation.",Actually hold on for a little bit. @rasky did some hardware tests to figure out how to get the test ROM and AI Shougi 3 working,True,{'HEART': ['https://github.com/Narann']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,868,2021-06-11T17:25:29Z,2021-06-14T18:59:23Z,2021-06-20T20:48:09Z,MERGED,True,32,6,2,https://github.com/loganmc10,Update PI DMA alignment as per CEN64,1,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/868,https://github.com/Narann,5,https://github.com/mupen64plus/mupen64plus-core/pull/868#issuecomment-860058245,"Taken from: https://github.com/n64dev/cen64/blob/master/pi/controller.c
Tested using: https://github.com/PeterLemon/N64/tree/master/CPUTest/DMAAlignment-PI-cart
Before:

After:

There are still 2 tests that fail here that pass on CEN64: n64dev/cen64#200. However, I couldn't get those tests to pass without breaking the graphics in AI Shougi 3, so I left it at the point where AI Shougi 3 would work. AI Shougi 3 graphics are messed up in CEN64, so I assume there is still more work to be done on their implementation.",Haha! :) No worry!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,868,2021-06-11T17:25:29Z,2021-06-14T18:59:23Z,2021-06-20T20:48:09Z,MERGED,True,32,6,2,https://github.com/loganmc10,Update PI DMA alignment as per CEN64,1,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/868,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/868#issuecomment-860224908,"Taken from: https://github.com/n64dev/cen64/blob/master/pi/controller.c
Tested using: https://github.com/PeterLemon/N64/tree/master/CPUTest/DMAAlignment-PI-cart
Before:

After:

There are still 2 tests that fail here that pass on CEN64: n64dev/cen64#200. However, I couldn't get those tests to pass without breaking the graphics in AI Shougi 3, so I left it at the point where AI Shougi 3 would work. AI Shougi 3 graphics are messed up in CEN64, so I assume there is still more work to be done on their implementation.","Ok I'm happy with this now. The test ROM passes at the same level as CEN64, AI Shougi works. I also tested other games I know that have specific PI alignment requirements (like command & conquer and taz express). Everything seems to be working normally.
This work was based on hardware tests done by @rasky:

As well as tests previously documented here: https://n64brew.dev/wiki/Peripheral_Interface#Unaligned_DMA_transfer",True,{'HEART': ['https://github.com/Narann']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,868,2021-06-11T17:25:29Z,2021-06-14T18:59:23Z,2021-06-20T20:48:09Z,MERGED,True,32,6,2,https://github.com/loganmc10,Update PI DMA alignment as per CEN64,1,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/868,https://github.com/Narann,7,https://github.com/mupen64plus/mupen64plus-core/pull/868#issuecomment-860639493,"Taken from: https://github.com/n64dev/cen64/blob/master/pi/controller.c
Tested using: https://github.com/PeterLemon/N64/tree/master/CPUTest/DMAAlignment-PI-cart
Before:

After:

There are still 2 tests that fail here that pass on CEN64: n64dev/cen64#200. However, I couldn't get those tests to pass without breaking the graphics in AI Shougi 3, so I left it at the point where AI Shougi 3 would work. AI Shougi 3 graphics are messed up in CEN64, so I assume there is still more work to be done on their implementation.","Thanks for the hard work!
I don't know how the compatibility situation is but can you just convert the // by /* */ ?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,868,2021-06-11T17:25:29Z,2021-06-14T18:59:23Z,2021-06-20T20:48:09Z,MERGED,True,32,6,2,https://github.com/loganmc10,Update PI DMA alignment as per CEN64,1,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/868,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/868#issuecomment-860775154,"Taken from: https://github.com/n64dev/cen64/blob/master/pi/controller.c
Tested using: https://github.com/PeterLemon/N64/tree/master/CPUTest/DMAAlignment-PI-cart
Before:

After:

There are still 2 tests that fail here that pass on CEN64: n64dev/cen64#200. However, I couldn't get those tests to pass without breaking the graphics in AI Shougi 3, so I left it at the point where AI Shougi 3 would work. AI Shougi 3 graphics are messed up in CEN64, so I assume there is still more work to be done on their implementation.",ok done,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,868,2021-06-11T17:25:29Z,2021-06-14T18:59:23Z,2021-06-20T20:48:09Z,MERGED,True,32,6,2,https://github.com/loganmc10,Update PI DMA alignment as per CEN64,1,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/868,https://github.com/Narann,9,https://github.com/mupen64plus/mupen64plus-core/pull/868#issuecomment-860919380,"Taken from: https://github.com/n64dev/cen64/blob/master/pi/controller.c
Tested using: https://github.com/PeterLemon/N64/tree/master/CPUTest/DMAAlignment-PI-cart
Before:

After:

There are still 2 tests that fail here that pass on CEN64: n64dev/cen64#200. However, I couldn't get those tests to pass without breaking the graphics in AI Shougi 3, so I left it at the point where AI Shougi 3 would work. AI Shougi 3 graphics are messed up in CEN64, so I assume there is still more work to be done on their implementation.",Thanks! :),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,868,2021-06-11T17:25:29Z,2021-06-14T18:59:23Z,2021-06-20T20:48:09Z,MERGED,True,32,6,2,https://github.com/loganmc10,Update PI DMA alignment as per CEN64,1,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/868,https://github.com/m4xw,10,https://github.com/mupen64plus/mupen64plus-core/pull/868#issuecomment-861760293,"Taken from: https://github.com/n64dev/cen64/blob/master/pi/controller.c
Tested using: https://github.com/PeterLemon/N64/tree/master/CPUTest/DMAAlignment-PI-cart
Before:

After:

There are still 2 tests that fail here that pass on CEN64: n64dev/cen64#200. However, I couldn't get those tests to pass without breaking the graphics in AI Shougi 3, so I left it at the point where AI Shougi 3 would work. AI Shougi 3 graphics are messed up in CEN64, so I assume there is still more work to be done on their implementation.","This caused a regression for 64DD for me.
Reverting pi_controller solves this. No game would boot (stuck on black screen) or it would just enter the IPL.
Didnt check yet which change in particular caused this, just a headsup.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,868,2021-06-11T17:25:29Z,2021-06-14T18:59:23Z,2021-06-20T20:48:09Z,MERGED,True,32,6,2,https://github.com/loganmc10,Update PI DMA alignment as per CEN64,1,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/868,https://github.com/loganmc10,11,https://github.com/mupen64plus/mupen64plus-core/pull/868#issuecomment-861927378,"Taken from: https://github.com/n64dev/cen64/blob/master/pi/controller.c
Tested using: https://github.com/PeterLemon/N64/tree/master/CPUTest/DMAAlignment-PI-cart
Before:

After:

There are still 2 tests that fail here that pass on CEN64: n64dev/cen64#200. However, I couldn't get those tests to pass without breaking the graphics in AI Shougi 3, so I left it at the point where AI Shougi 3 would work. AI Shougi 3 graphics are messed up in CEN64, so I assume there is still more work to be done on their implementation.","No problem, I'll fix this and submit a new pr",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,868,2021-06-11T17:25:29Z,2021-06-14T18:59:23Z,2021-06-20T20:48:09Z,MERGED,True,32,6,2,https://github.com/loganmc10,Update PI DMA alignment as per CEN64,1,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/868,https://github.com/m4xw,12,https://github.com/mupen64plus/mupen64plus-core/pull/868#issuecomment-861928198,"Taken from: https://github.com/n64dev/cen64/blob/master/pi/controller.c
Tested using: https://github.com/PeterLemon/N64/tree/master/CPUTest/DMAAlignment-PI-cart
Before:

After:

There are still 2 tests that fail here that pass on CEN64: n64dev/cen64#200. However, I couldn't get those tests to pass without breaking the graphics in AI Shougi 3, so I left it at the point where AI Shougi 3 would work. AI Shougi 3 graphics are messed up in CEN64, so I assume there is still more work to be done on their implementation.","Thanks, if you read discord, my suspicion rn is the pi->regs[PI_CART_ADDR_REG] touching it in some way that doesnt trigger the
      if ((pi->regs[PI_CART_ADDR_REG] == MM_DD_C2S_BUFFER) ||
           (pi->regs[PI_CART_ADDR_REG] == MM_DD_DS_BUFFER)) {

condition for the if(dd) stuff at end of pi event.
Didnt spend time today investigating further tho.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,868,2021-06-11T17:25:29Z,2021-06-14T18:59:23Z,2021-06-20T20:48:09Z,MERGED,True,32,6,2,https://github.com/loganmc10,Update PI DMA alignment as per CEN64,1,['enhancement'],https://github.com/mupen64plus/mupen64plus-core/pull/868,https://github.com/m4xw,13,https://github.com/mupen64plus/mupen64plus-core/pull/868#issuecomment-861946093,"Taken from: https://github.com/n64dev/cen64/blob/master/pi/controller.c
Tested using: https://github.com/PeterLemon/N64/tree/master/CPUTest/DMAAlignment-PI-cart
Before:

After:

There are still 2 tests that fail here that pass on CEN64: n64dev/cen64#200. However, I couldn't get those tests to pass without breaking the graphics in AI Shougi 3, so I left it at the point where AI Shougi 3 would work. AI Shougi 3 graphics are messed up in CEN64, so I assume there is still more work to be done on their implementation.","Forgot to add, as far i can tell from the talks with luigi, we can consider the end of pi dma event stuff for DD a hack. So feel free to rework as you see fit.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,869,2021-06-11T20:18:04Z,2021-06-14T18:59:53Z,2021-06-20T20:48:05Z,MERGED,True,2,2,1,https://github.com/loganmc10,Update RSP alignment code as per CEN64,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/869,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/869,"Taken from: https://github.com/n64dev/cen64/blob/master/rsp/interface.c
Tested using: https://github.com/PeterLemon/N64/tree/master/RSPTest/DMAAlignment-SP
Before:

After:

With these changes, we achieve the same compatibility as CEN64","Taken from: https://github.com/n64dev/cen64/blob/master/rsp/interface.c
Tested using: https://github.com/PeterLemon/N64/tree/master/RSPTest/DMAAlignment-SP
Before:

After:

With these changes, we achieve the same compatibility as CEN64",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,869,2021-06-11T20:18:04Z,2021-06-14T18:59:53Z,2021-06-20T20:48:05Z,MERGED,True,2,2,1,https://github.com/loganmc10,Update RSP alignment code as per CEN64,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/869,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/869#issuecomment-860065453,"Taken from: https://github.com/n64dev/cen64/blob/master/rsp/interface.c
Tested using: https://github.com/PeterLemon/N64/tree/master/RSPTest/DMAAlignment-SP
Before:

After:

With these changes, we achieve the same compatibility as CEN64","By the way, this does line up with the documentation:",True,{'THUMBS_UP': ['https://github.com/Narann']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,869,2021-06-11T20:18:04Z,2021-06-14T18:59:53Z,2021-06-20T20:48:05Z,MERGED,True,2,2,1,https://github.com/loganmc10,Update RSP alignment code as per CEN64,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/869,https://github.com/Narann,3,https://github.com/mupen64plus/mupen64plus-core/pull/869#issuecomment-860919616,"Taken from: https://github.com/n64dev/cen64/blob/master/rsp/interface.c
Tested using: https://github.com/PeterLemon/N64/tree/master/RSPTest/DMAAlignment-SP
Before:

After:

With these changes, we achieve the same compatibility as CEN64",Thanks!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,871,2021-06-15T13:26:59Z,2021-07-08T14:49:31Z,2021-07-10T13:04:50Z,MERGED,True,7200,9070,23,https://github.com/Gillou68310,Misc fixes,21,[],https://github.com/mupen64plus/mupen64plus-core/pull/871,https://github.com/Gillou68310,1,https://github.com/mupen64plus/mupen64plus-core/pull/871,"I don't even know what to say here...
Maybe, lot of fixes for the new dynarec ;-)","I don't even know what to say here...
Maybe, lot of fixes for the new dynarec ;-)",True,"{'ROCKET': ['https://github.com/m4xw'], 'HEART': ['https://github.com/dankcushions']}"
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,871,2021-06-15T13:26:59Z,2021-07-08T14:49:31Z,2021-07-10T13:04:50Z,MERGED,True,7200,9070,23,https://github.com/Gillou68310,Misc fixes,21,[],https://github.com/mupen64plus/mupen64plus-core/pull/871,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/871#issuecomment-862697412,"I don't even know what to say here...
Maybe, lot of fixes for the new dynarec ;-)","Hi Guillou! That's huge!
As you are the only one with authority on the new dynarec, I will let @loganmc10 test a little and confirm so I can merge this. :)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,871,2021-06-15T13:26:59Z,2021-07-08T14:49:31Z,2021-07-10T13:04:50Z,MERGED,True,7200,9070,23,https://github.com/Gillou68310,Misc fixes,21,[],https://github.com/mupen64plus/mupen64plus-core/pull/871,https://github.com/m4xw,3,https://github.com/mupen64plus/mupen64plus-core/pull/871#issuecomment-862700489,"I don't even know what to say here...
Maybe, lot of fixes for the new dynarec ;-)","Hi Guillou! That's huge!
As you are the only one with authority on the new dynarec, I will let @loganmc10 test a little and confirm so I can merge this. :)

Its still a bit of a WIP, theres still a few opcodes to match with the interpreter ;)
This fixes the oot freeze as well and many other issues. What i am specifically excited about is interpreting single instruction for debugging, heh.
He did a good job, currently running regression testing with him on my fork and standalone to catch anything obvious, so please no hasty merges.
The issues have been over a decade old, at this point a few more days dont matter^^",True,{'LAUGH': ['https://github.com/Narann']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,871,2021-06-15T13:26:59Z,2021-07-08T14:49:31Z,2021-07-10T13:04:50Z,MERGED,True,7200,9070,23,https://github.com/Gillou68310,Misc fixes,21,[],https://github.com/mupen64plus/mupen64plus-core/pull/871,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/871#issuecomment-862702650,"I don't even know what to say here...
Maybe, lot of fixes for the new dynarec ;-)","Yeah I don't really use or understand the new dynarec at all. The changes look more or less localized to the new dynarec, so I'd trust @Gillou68310 on this one",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,871,2021-06-15T13:26:59Z,2021-07-08T14:49:31Z,2021-07-10T13:04:50Z,MERGED,True,7200,9070,23,https://github.com/Gillou68310,Misc fixes,21,[],https://github.com/mupen64plus/mupen64plus-core/pull/871,https://github.com/m4xw,5,https://github.com/mupen64plus/mupen64plus-core/pull/871#issuecomment-862710248,"I don't even know what to say here...
Maybe, lot of fixes for the new dynarec ;-)","Its what a year of hunting the same bug does for new dynarec 🙈
This PR is a witch hunt of anything that did hide the oot issue
The debug tooling was significantly improved (core compare) to handle this",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,871,2021-06-15T13:26:59Z,2021-07-08T14:49:31Z,2021-07-10T13:04:50Z,MERGED,True,7200,9070,23,https://github.com/Gillou68310,Misc fixes,21,[],https://github.com/mupen64plus/mupen64plus-core/pull/871,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/871#issuecomment-865496587,"I don't even know what to say here...
Maybe, lot of fixes for the new dynarec ;-)",I was just doing some testing and the English translation of Densha de Go (https://www.romhacking.net/translations/2947/) does not boot using the new dynarec (x64). The original Japanese version works. Both versions work with the Cached Interpreter.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,871,2021-06-15T13:26:59Z,2021-07-08T14:49:31Z,2021-07-10T13:04:50Z,MERGED,True,7200,9070,23,https://github.com/Gillou68310,Misc fixes,21,[],https://github.com/mupen64plus/mupen64plus-core/pull/871,https://github.com/Gillou68310,7,https://github.com/mupen64plus/mupen64plus-core/pull/871#issuecomment-865986151,"I don't even know what to say here...
Maybe, lot of fixes for the new dynarec ;-)","Please don't merge anything right now, last commit is under investigation...",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,871,2021-06-15T13:26:59Z,2021-07-08T14:49:31Z,2021-07-10T13:04:50Z,MERGED,True,7200,9070,23,https://github.com/Gillou68310,Misc fixes,21,[],https://github.com/mupen64plus/mupen64plus-core/pull/871,https://github.com/Jj0YzL5nvJ,8,https://github.com/mupen64plus/mupen64plus-core/pull/871#issuecomment-875909193,"I don't even know what to say here...
Maybe, lot of fixes for the new dynarec ;-)",The current state of this PR is way better than the one in the current master branch...,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,871,2021-06-15T13:26:59Z,2021-07-08T14:49:31Z,2021-07-10T13:04:50Z,MERGED,True,7200,9070,23,https://github.com/Gillou68310,Misc fixes,21,[],https://github.com/mupen64plus/mupen64plus-core/pull/871,https://github.com/Narann,9,https://github.com/mupen64plus/mupen64plus-core/pull/871#issuecomment-875929444,"I don't even know what to say here...
Maybe, lot of fixes for the new dynarec ;-)","@Jj0YzL5nvJ yes, but @Gillou68310 ask to not merge this PR yet.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,871,2021-06-15T13:26:59Z,2021-07-08T14:49:31Z,2021-07-10T13:04:50Z,MERGED,True,7200,9070,23,https://github.com/Gillou68310,Misc fixes,21,[],https://github.com/mupen64plus/mupen64plus-core/pull/871,https://github.com/Jj0YzL5nvJ,10,https://github.com/mupen64plus/mupen64plus-core/pull/871#issuecomment-875934643,"I don't even know what to say here...
Maybe, lot of fixes for the new dynarec ;-)","I actually forgot to mention a tiny issue...
$ git apply ../mupen64plus-core_new-dynarec-fix.patch
../mupen64plus-core_new-dynarec-fix.patch:1154: trailing whitespace.
  
../mupen64plus-core_new-dynarec-fix.patch:1156: trailing whitespace.
  
../mupen64plus-core_new-dynarec-fix.patch:3019: trailing whitespace.
        
../mupen64plus-core_new-dynarec-fix.patch:3612: trailing whitespace.
    
../mupen64plus-core_new-dynarec-fix.patch:4041: trailing whitespace.
  
warning: squelched 18 whitespace errors
warning: 23 lines add whitespace errors.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,871,2021-06-15T13:26:59Z,2021-07-08T14:49:31Z,2021-07-10T13:04:50Z,MERGED,True,7200,9070,23,https://github.com/Gillou68310,Misc fixes,21,[],https://github.com/mupen64plus/mupen64plus-core/pull/871,https://github.com/Gillou68310,11,https://github.com/mupen64plus/mupen64plus-core/pull/871#issuecomment-876440214,"I don't even know what to say here...
Maybe, lot of fixes for the new dynarec ;-)",Should be ok to merge!,True,"{'ROCKET': ['https://github.com/m4xw', 'https://github.com/Clownacy', 'https://github.com/Narann', 'https://github.com/Rosalie241', 'https://github.com/fzurita']}"
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,871,2021-06-15T13:26:59Z,2021-07-08T14:49:31Z,2021-07-10T13:04:50Z,MERGED,True,7200,9070,23,https://github.com/Gillou68310,Misc fixes,21,[],https://github.com/mupen64plus/mupen64plus-core/pull/871,https://github.com/Narann,12,https://github.com/mupen64plus/mupen64plus-core/pull/871#issuecomment-876504239,"I don't even know what to say here...
Maybe, lot of fixes for the new dynarec ;-)",BOOM!,True,{'ROCKET': ['https://github.com/Gillou68310']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,872,2021-06-16T03:22:32Z,2021-06-16T20:26:55Z,2021-06-20T20:48:17Z,MERGED,True,2,2,1,https://github.com/loganmc10,Fix address check for DD DMA Interrupt,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/872,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/872,"Fixes the issue identified in #868 (comment)
@m4xw","Fixes the issue identified in #868 (comment)
@m4xw",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,873,2021-06-17T17:44:46Z,,2022-05-31T21:49:38Z,OPEN,False,429,20,24,https://github.com/loganmc10,VRU support and Hey You Pikachu audio fix,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/873,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/873,"https://youtu.be/6_iPf8ZC_3M

Windows build of m64p with VRU support: https://drive.google.com/file/d/1ZarcKEHs0ZpNhtan0QatjdIOPhxCP3S1/view?usp=sharing
Linux: https://drive.google.com/file/d/191vE6ZoghRPGHdyUUnClEYaeA0onBz-1/view?usp=sharing

You can see the other changes that were made (to the input plugin) by looking at this branch: https://github.com/loganmc10/m64p/tree/vru


VRU Support

Only 2 games support the VRU: Hey You Pikachu, and Densha de Go! (English translation: https://www.romhacking.net/translations/2947/ also supports the VRU)
Might not be perfect. I don't own a physical VRU, so all this work was done based on what zoinkity wrote and what I could get from the programming manual, and from trying to match the behaviour I saw on YouTube playthroughs).
This is an HLE implementation. I did not emulate the manner in which the VRU does voice recognition. Voice recognition is handled by the input plugin. I used Vosk (https://github.com/alphacep/vosk-api), so the voice recognition I'm sure will be better than an actual VRU.
Added some more functions to the input plugin spec, but they are all optional.
To specify that a VRU is plugged into a controller slot, I added a new Pak type, PLUGIN_VRU. I understand that the VRU is not a Pak, but this was the simplest and least intrusive way I could see to set this information.
Save states probably won't work. As you'll see in the YouTube video, the game uploads a list of words to the VRU. This would be part of the ""state"". So if a save state was created after that word list is uploaded to the input plugin, it won't be there when the state is loaded.



Hey you Pikachu audio fixes

The audio in this game has always been choppy. It appears to be a timing issue, the AI DMAs take too long, so there are large pauses between the audio data. Shortening the AI DMA time fixes the issue. I added a new INI parameter: AiDmaModifier. This is a percentage of the DMA time, so a setting of 88 means ""AI DMA time should be 88% of the regular time (shortened by 12%)"". Until we have accurate timing emulation, this may be a helpful lever in games with audio problems.



References:
https://pastebin.com/6UiErk5h (zoinkity reverse engineering)
https://ultra64.ca/files/documentation/online-manuals/man/pro-man/pro26/index26.8.html","https://youtu.be/6_iPf8ZC_3M

Windows build of m64p with VRU support: https://drive.google.com/file/d/1ZarcKEHs0ZpNhtan0QatjdIOPhxCP3S1/view?usp=sharing
Linux: https://drive.google.com/file/d/191vE6ZoghRPGHdyUUnClEYaeA0onBz-1/view?usp=sharing

You can see the other changes that were made (to the input plugin) by looking at this branch: https://github.com/loganmc10/m64p/tree/vru


VRU Support

Only 2 games support the VRU: Hey You Pikachu, and Densha de Go! (English translation: https://www.romhacking.net/translations/2947/ also supports the VRU)
Might not be perfect. I don't own a physical VRU, so all this work was done based on what zoinkity wrote and what I could get from the programming manual, and from trying to match the behaviour I saw on YouTube playthroughs).
This is an HLE implementation. I did not emulate the manner in which the VRU does voice recognition. Voice recognition is handled by the input plugin. I used Vosk (https://github.com/alphacep/vosk-api), so the voice recognition I'm sure will be better than an actual VRU.
Added some more functions to the input plugin spec, but they are all optional.
To specify that a VRU is plugged into a controller slot, I added a new Pak type, PLUGIN_VRU. I understand that the VRU is not a Pak, but this was the simplest and least intrusive way I could see to set this information.
Save states probably won't work. As you'll see in the YouTube video, the game uploads a list of words to the VRU. This would be part of the ""state"". So if a save state was created after that word list is uploaded to the input plugin, it won't be there when the state is loaded.



Hey you Pikachu audio fixes

The audio in this game has always been choppy. It appears to be a timing issue, the AI DMAs take too long, so there are large pauses between the audio data. Shortening the AI DMA time fixes the issue. I added a new INI parameter: AiDmaModifier. This is a percentage of the DMA time, so a setting of 88 means ""AI DMA time should be 88% of the regular time (shortened by 12%)"". Until we have accurate timing emulation, this may be a helpful lever in games with audio problems.



References:
https://pastebin.com/6UiErk5h (zoinkity reverse engineering)
https://ultra64.ca/files/documentation/online-manuals/man/pro-man/pro26/index26.8.html",True,"{'THUMBS_UP': ['https://github.com/Jj0YzL5nvJ', 'https://github.com/cyreb7'], 'ROCKET': ['https://github.com/Ecksters'], 'HOORAY': ['https://github.com/vilhelmgray', 'https://github.com/Zowayix', 'https://github.com/cyreb7']}"
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,873,2021-06-17T17:44:46Z,,2022-05-31T21:49:38Z,OPEN,False,429,20,24,https://github.com/loganmc10,VRU support and Hey You Pikachu audio fix,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/873,https://github.com/Jj0YzL5nvJ,2,https://github.com/mupen64plus/mupen64plus-core/pull/873#issuecomment-863467977,"https://youtu.be/6_iPf8ZC_3M

Windows build of m64p with VRU support: https://drive.google.com/file/d/1ZarcKEHs0ZpNhtan0QatjdIOPhxCP3S1/view?usp=sharing
Linux: https://drive.google.com/file/d/191vE6ZoghRPGHdyUUnClEYaeA0onBz-1/view?usp=sharing

You can see the other changes that were made (to the input plugin) by looking at this branch: https://github.com/loganmc10/m64p/tree/vru


VRU Support

Only 2 games support the VRU: Hey You Pikachu, and Densha de Go! (English translation: https://www.romhacking.net/translations/2947/ also supports the VRU)
Might not be perfect. I don't own a physical VRU, so all this work was done based on what zoinkity wrote and what I could get from the programming manual, and from trying to match the behaviour I saw on YouTube playthroughs).
This is an HLE implementation. I did not emulate the manner in which the VRU does voice recognition. Voice recognition is handled by the input plugin. I used Vosk (https://github.com/alphacep/vosk-api), so the voice recognition I'm sure will be better than an actual VRU.
Added some more functions to the input plugin spec, but they are all optional.
To specify that a VRU is plugged into a controller slot, I added a new Pak type, PLUGIN_VRU. I understand that the VRU is not a Pak, but this was the simplest and least intrusive way I could see to set this information.
Save states probably won't work. As you'll see in the YouTube video, the game uploads a list of words to the VRU. This would be part of the ""state"". So if a save state was created after that word list is uploaded to the input plugin, it won't be there when the state is loaded.



Hey you Pikachu audio fixes

The audio in this game has always been choppy. It appears to be a timing issue, the AI DMAs take too long, so there are large pauses between the audio data. Shortening the AI DMA time fixes the issue. I added a new INI parameter: AiDmaModifier. This is a percentage of the DMA time, so a setting of 88 means ""AI DMA time should be 88% of the regular time (shortened by 12%)"". Until we have accurate timing emulation, this may be a helpful lever in games with audio problems.



References:
https://pastebin.com/6UiErk5h (zoinkity reverse engineering)
https://ultra64.ca/files/documentation/online-manuals/man/pro-man/pro26/index26.8.html","Majora's Mask too... with cheats.
https://youtu.be/lFa6GwuG-8I
https://youtu.be/VxK8XqYecSg",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,873,2021-06-17T17:44:46Z,,2022-05-31T21:49:38Z,OPEN,False,429,20,24,https://github.com/loganmc10,VRU support and Hey You Pikachu audio fix,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/873,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/873#issuecomment-863479092,"https://youtu.be/6_iPf8ZC_3M

Windows build of m64p with VRU support: https://drive.google.com/file/d/1ZarcKEHs0ZpNhtan0QatjdIOPhxCP3S1/view?usp=sharing
Linux: https://drive.google.com/file/d/191vE6ZoghRPGHdyUUnClEYaeA0onBz-1/view?usp=sharing

You can see the other changes that were made (to the input plugin) by looking at this branch: https://github.com/loganmc10/m64p/tree/vru


VRU Support

Only 2 games support the VRU: Hey You Pikachu, and Densha de Go! (English translation: https://www.romhacking.net/translations/2947/ also supports the VRU)
Might not be perfect. I don't own a physical VRU, so all this work was done based on what zoinkity wrote and what I could get from the programming manual, and from trying to match the behaviour I saw on YouTube playthroughs).
This is an HLE implementation. I did not emulate the manner in which the VRU does voice recognition. Voice recognition is handled by the input plugin. I used Vosk (https://github.com/alphacep/vosk-api), so the voice recognition I'm sure will be better than an actual VRU.
Added some more functions to the input plugin spec, but they are all optional.
To specify that a VRU is plugged into a controller slot, I added a new Pak type, PLUGIN_VRU. I understand that the VRU is not a Pak, but this was the simplest and least intrusive way I could see to set this information.
Save states probably won't work. As you'll see in the YouTube video, the game uploads a list of words to the VRU. This would be part of the ""state"". So if a save state was created after that word list is uploaded to the input plugin, it won't be there when the state is loaded.



Hey you Pikachu audio fixes

The audio in this game has always been choppy. It appears to be a timing issue, the AI DMAs take too long, so there are large pauses between the audio data. Shortening the AI DMA time fixes the issue. I added a new INI parameter: AiDmaModifier. This is a percentage of the DMA time, so a setting of 88 means ""AI DMA time should be 88% of the regular time (shortened by 12%)"". Until we have accurate timing emulation, this may be a helpful lever in games with audio problems.



References:
https://pastebin.com/6UiErk5h (zoinkity reverse engineering)
https://ultra64.ca/files/documentation/online-manuals/man/pro-man/pro26/index26.8.html","Even though Majora's Mask does work with the NTSC ROM, it looks like it's still using the Japanese VRU, which probably won't work with this PR. The library I'm using for voice recognition (Vosk) doesn't support Japanese, and I don't speak or read Japanese, so I didn't feel I'd be able to test/troubleshoot it in a meaningful way.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,873,2021-06-17T17:44:46Z,,2022-05-31T21:49:38Z,OPEN,False,429,20,24,https://github.com/loganmc10,VRU support and Hey You Pikachu audio fix,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/873,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/873#issuecomment-863705600,"https://youtu.be/6_iPf8ZC_3M

Windows build of m64p with VRU support: https://drive.google.com/file/d/1ZarcKEHs0ZpNhtan0QatjdIOPhxCP3S1/view?usp=sharing
Linux: https://drive.google.com/file/d/191vE6ZoghRPGHdyUUnClEYaeA0onBz-1/view?usp=sharing

You can see the other changes that were made (to the input plugin) by looking at this branch: https://github.com/loganmc10/m64p/tree/vru


VRU Support

Only 2 games support the VRU: Hey You Pikachu, and Densha de Go! (English translation: https://www.romhacking.net/translations/2947/ also supports the VRU)
Might not be perfect. I don't own a physical VRU, so all this work was done based on what zoinkity wrote and what I could get from the programming manual, and from trying to match the behaviour I saw on YouTube playthroughs).
This is an HLE implementation. I did not emulate the manner in which the VRU does voice recognition. Voice recognition is handled by the input plugin. I used Vosk (https://github.com/alphacep/vosk-api), so the voice recognition I'm sure will be better than an actual VRU.
Added some more functions to the input plugin spec, but they are all optional.
To specify that a VRU is plugged into a controller slot, I added a new Pak type, PLUGIN_VRU. I understand that the VRU is not a Pak, but this was the simplest and least intrusive way I could see to set this information.
Save states probably won't work. As you'll see in the YouTube video, the game uploads a list of words to the VRU. This would be part of the ""state"". So if a save state was created after that word list is uploaded to the input plugin, it won't be there when the state is loaded.



Hey you Pikachu audio fixes

The audio in this game has always been choppy. It appears to be a timing issue, the AI DMAs take too long, so there are large pauses between the audio data. Shortening the AI DMA time fixes the issue. I added a new INI parameter: AiDmaModifier. This is a percentage of the DMA time, so a setting of 88 means ""AI DMA time should be 88% of the regular time (shortened by 12%)"". Until we have accurate timing emulation, this may be a helpful lever in games with audio problems.



References:
https://pastebin.com/6UiErk5h (zoinkity reverse engineering)
https://ultra64.ca/files/documentation/online-manuals/man/pro-man/pro26/index26.8.html","I spent some time testing/debugging Densha de Go. I got the VRU initialization much closer to the communication dump that zoinkity provided. I also got audio recognition working (if you say ""depart"" when you're leaving for instance you get ""1 bonus voice point""). I've updated the Google Drive links in the first post.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,873,2021-06-17T17:44:46Z,,2022-05-31T21:49:38Z,OPEN,False,429,20,24,https://github.com/loganmc10,VRU support and Hey You Pikachu audio fix,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/873,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/873#issuecomment-864229037,"https://youtu.be/6_iPf8ZC_3M

Windows build of m64p with VRU support: https://drive.google.com/file/d/1ZarcKEHs0ZpNhtan0QatjdIOPhxCP3S1/view?usp=sharing
Linux: https://drive.google.com/file/d/191vE6ZoghRPGHdyUUnClEYaeA0onBz-1/view?usp=sharing

You can see the other changes that were made (to the input plugin) by looking at this branch: https://github.com/loganmc10/m64p/tree/vru


VRU Support

Only 2 games support the VRU: Hey You Pikachu, and Densha de Go! (English translation: https://www.romhacking.net/translations/2947/ also supports the VRU)
Might not be perfect. I don't own a physical VRU, so all this work was done based on what zoinkity wrote and what I could get from the programming manual, and from trying to match the behaviour I saw on YouTube playthroughs).
This is an HLE implementation. I did not emulate the manner in which the VRU does voice recognition. Voice recognition is handled by the input plugin. I used Vosk (https://github.com/alphacep/vosk-api), so the voice recognition I'm sure will be better than an actual VRU.
Added some more functions to the input plugin spec, but they are all optional.
To specify that a VRU is plugged into a controller slot, I added a new Pak type, PLUGIN_VRU. I understand that the VRU is not a Pak, but this was the simplest and least intrusive way I could see to set this information.
Save states probably won't work. As you'll see in the YouTube video, the game uploads a list of words to the VRU. This would be part of the ""state"". So if a save state was created after that word list is uploaded to the input plugin, it won't be there when the state is loaded.



Hey you Pikachu audio fixes

The audio in this game has always been choppy. It appears to be a timing issue, the AI DMAs take too long, so there are large pauses between the audio data. Shortening the AI DMA time fixes the issue. I added a new INI parameter: AiDmaModifier. This is a percentage of the DMA time, so a setting of 88 means ""AI DMA time should be 88% of the regular time (shortened by 12%)"". Until we have accurate timing emulation, this may be a helpful lever in games with audio problems.



References:
https://pastebin.com/6UiErk5h (zoinkity reverse engineering)
https://ultra64.ca/files/documentation/online-manuals/man/pro-man/pro26/index26.8.html","I decided I might as well go all the way with this. I got Japanese support working. I tested Hey You Pikachu, Densha de Go, and the VRU test ROM included in the SDK, they all work. As mentioned, the library I'm using in the input plugin doesn't have Japanese support, so you can't speak Japanese to it, but I did test that language recognition works. So it would work in Japanese if someone wanted to write an input plugin that supported it.
I've updated the .zips in the main post. I'd consider this complete at this point",True,{'THUMBS_UP': ['https://github.com/vilhelmgray']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,873,2021-06-17T17:44:46Z,,2022-05-31T21:49:38Z,OPEN,False,429,20,24,https://github.com/loganmc10,VRU support and Hey You Pikachu audio fix,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/873,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/873#issuecomment-864594183,"https://youtu.be/6_iPf8ZC_3M

Windows build of m64p with VRU support: https://drive.google.com/file/d/1ZarcKEHs0ZpNhtan0QatjdIOPhxCP3S1/view?usp=sharing
Linux: https://drive.google.com/file/d/191vE6ZoghRPGHdyUUnClEYaeA0onBz-1/view?usp=sharing

You can see the other changes that were made (to the input plugin) by looking at this branch: https://github.com/loganmc10/m64p/tree/vru


VRU Support

Only 2 games support the VRU: Hey You Pikachu, and Densha de Go! (English translation: https://www.romhacking.net/translations/2947/ also supports the VRU)
Might not be perfect. I don't own a physical VRU, so all this work was done based on what zoinkity wrote and what I could get from the programming manual, and from trying to match the behaviour I saw on YouTube playthroughs).
This is an HLE implementation. I did not emulate the manner in which the VRU does voice recognition. Voice recognition is handled by the input plugin. I used Vosk (https://github.com/alphacep/vosk-api), so the voice recognition I'm sure will be better than an actual VRU.
Added some more functions to the input plugin spec, but they are all optional.
To specify that a VRU is plugged into a controller slot, I added a new Pak type, PLUGIN_VRU. I understand that the VRU is not a Pak, but this was the simplest and least intrusive way I could see to set this information.
Save states probably won't work. As you'll see in the YouTube video, the game uploads a list of words to the VRU. This would be part of the ""state"". So if a save state was created after that word list is uploaded to the input plugin, it won't be there when the state is loaded.



Hey you Pikachu audio fixes

The audio in this game has always been choppy. It appears to be a timing issue, the AI DMAs take too long, so there are large pauses between the audio data. Shortening the AI DMA time fixes the issue. I added a new INI parameter: AiDmaModifier. This is a percentage of the DMA time, so a setting of 88 means ""AI DMA time should be 88% of the regular time (shortened by 12%)"". Until we have accurate timing emulation, this may be a helpful lever in games with audio problems.



References:
https://pastebin.com/6UiErk5h (zoinkity reverse engineering)
https://ultra64.ca/files/documentation/online-manuals/man/pro-man/pro26/index26.8.html","Thanks for the feedback:

For the AI DMA timing, I tried your branch, but unfortunately I didn't notice any improvement in the audio. It's still very choppy (you can hear it in the opening song that plays)
There are 2 issues I can think of having the HLE VRU logic in the core:

Vosk is not an easy dependency to install. I had to extract the .so and .dll files from the Python package and then manually include them in my input plugin. I've looked around at a few alternatives, but it's actually a little hard to find speech recognition libraries that are maintained and have C interfaces as part of their releases. Many are focused on Python.
Related to the above, it may actually be easier on other platforms to use a different speech recognition library. For instance, Android has an android.speech.SpeechRecognizer library. It may be easier for the AE project to use that than figure out how to integrate Vosk on Android.
The HLE implementation relies on zoinkitys deciphering of the words (https://pastebin.com/JWwSVUS7). My input plugin contains these mappings in a header file. Depending on who you ask, these may be considered ROM assets and shouldn't be included in the core project.



For points 3 and 4 I agree, I can clean that up. I was under the impression that anything that plugged into a controller port was a ""game controller"" and the flavors were used to specify the different types, but I can put it in it's own file.
In order for the input plugin to specify that a VRU is connected, can I extend the CONTROL struct (
  
    
      mupen64plus-core/src/api/m64p_plugin.h
    
    
        Lines 139 to 143
      in
      db56853
    
  
  
    

        
          
           typedef struct { 
        

        
          
               int Present; 
        

        
          
               int RawData; 
        

        
          
               int Plugin; 
        

        
          
           } CONTROL; 
        
    
  

) to include another int for ""Type"", where 0 would be a regular controller, and 1 could be mouse, 2 could be VRU, etc? This should be backwards compatible if I add it to the end of the struct I believe?
The other option might be to repurpose the RawData int, rename it to Type, and say that 0=Regular Controller, 1=RawData, 2=VRU, 3=Mouse, etc... which should still be backwards compatible.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,873,2021-06-17T17:44:46Z,,2022-05-31T21:49:38Z,OPEN,False,429,20,24,https://github.com/loganmc10,VRU support and Hey You Pikachu audio fix,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/873,https://github.com/vilhelmgray,7,https://github.com/mupen64plus/mupen64plus-core/pull/873#issuecomment-882310161,"https://youtu.be/6_iPf8ZC_3M

Windows build of m64p with VRU support: https://drive.google.com/file/d/1ZarcKEHs0ZpNhtan0QatjdIOPhxCP3S1/view?usp=sharing
Linux: https://drive.google.com/file/d/191vE6ZoghRPGHdyUUnClEYaeA0onBz-1/view?usp=sharing

You can see the other changes that were made (to the input plugin) by looking at this branch: https://github.com/loganmc10/m64p/tree/vru


VRU Support

Only 2 games support the VRU: Hey You Pikachu, and Densha de Go! (English translation: https://www.romhacking.net/translations/2947/ also supports the VRU)
Might not be perfect. I don't own a physical VRU, so all this work was done based on what zoinkity wrote and what I could get from the programming manual, and from trying to match the behaviour I saw on YouTube playthroughs).
This is an HLE implementation. I did not emulate the manner in which the VRU does voice recognition. Voice recognition is handled by the input plugin. I used Vosk (https://github.com/alphacep/vosk-api), so the voice recognition I'm sure will be better than an actual VRU.
Added some more functions to the input plugin spec, but they are all optional.
To specify that a VRU is plugged into a controller slot, I added a new Pak type, PLUGIN_VRU. I understand that the VRU is not a Pak, but this was the simplest and least intrusive way I could see to set this information.
Save states probably won't work. As you'll see in the YouTube video, the game uploads a list of words to the VRU. This would be part of the ""state"". So if a save state was created after that word list is uploaded to the input plugin, it won't be there when the state is loaded.



Hey you Pikachu audio fixes

The audio in this game has always been choppy. It appears to be a timing issue, the AI DMAs take too long, so there are large pauses between the audio data. Shortening the AI DMA time fixes the issue. I added a new INI parameter: AiDmaModifier. This is a percentage of the DMA time, so a setting of 88 means ""AI DMA time should be 88% of the regular time (shortened by 12%)"". Until we have accurate timing emulation, this may be a helpful lever in games with audio problems.



References:
https://pastebin.com/6UiErk5h (zoinkity reverse engineering)
https://ultra64.ca/files/documentation/online-manuals/man/pro-man/pro26/index26.8.html","* There are 2 issues I can think of having the HLE VRU logic in the core:
  
  * Vosk is not an easy dependency to install. I had to extract the .so and .dll files from the Python package and then manually include them in my input plugin. I've looked around at a few alternatives, but it's actually a little hard to find speech recognition libraries that are maintained and have C interfaces as part of their releases. Many are focused on Python.
  * Related to the above, it may actually be easier on other platforms to use a different speech recognition library. For instance, Android has an android.speech.SpeechRecognizer library. It may be easier for the AE project to use that than figure out how to integrate Vosk on Android.


I don't know whether it would make sense to integrate the HLE VRU logic into the core, but regarding the difficulty and limitations of Vosk, would Julius be a viable alternative? It's a BSD-licensed speech recognition C library maintained by the prestigious Kyoto University and it recognizes both Japanese and English (thanks to help from the Mozilla foundation) -- actually it can recognize more languages, but I think those are the only two relevant to the Nintendo 64 VRU. Furthermore, Julius is cross-platform and runs on Linux, Windows, Android, Mac, etc, so it shouldn't be a problem to build for those.
It looks like you can just pass audio to the library and it'll return an array of recognized sentences, which you can then grep for the words the game expects. Here's the documentation to the JuliusLib API along with a simple example program showing how to use it.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,873,2021-06-17T17:44:46Z,,2022-05-31T21:49:38Z,OPEN,False,429,20,24,https://github.com/loganmc10,VRU support and Hey You Pikachu audio fix,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/873,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/873#issuecomment-882568717,"https://youtu.be/6_iPf8ZC_3M

Windows build of m64p with VRU support: https://drive.google.com/file/d/1ZarcKEHs0ZpNhtan0QatjdIOPhxCP3S1/view?usp=sharing
Linux: https://drive.google.com/file/d/191vE6ZoghRPGHdyUUnClEYaeA0onBz-1/view?usp=sharing

You can see the other changes that were made (to the input plugin) by looking at this branch: https://github.com/loganmc10/m64p/tree/vru


VRU Support

Only 2 games support the VRU: Hey You Pikachu, and Densha de Go! (English translation: https://www.romhacking.net/translations/2947/ also supports the VRU)
Might not be perfect. I don't own a physical VRU, so all this work was done based on what zoinkity wrote and what I could get from the programming manual, and from trying to match the behaviour I saw on YouTube playthroughs).
This is an HLE implementation. I did not emulate the manner in which the VRU does voice recognition. Voice recognition is handled by the input plugin. I used Vosk (https://github.com/alphacep/vosk-api), so the voice recognition I'm sure will be better than an actual VRU.
Added some more functions to the input plugin spec, but they are all optional.
To specify that a VRU is plugged into a controller slot, I added a new Pak type, PLUGIN_VRU. I understand that the VRU is not a Pak, but this was the simplest and least intrusive way I could see to set this information.
Save states probably won't work. As you'll see in the YouTube video, the game uploads a list of words to the VRU. This would be part of the ""state"". So if a save state was created after that word list is uploaded to the input plugin, it won't be there when the state is loaded.



Hey you Pikachu audio fixes

The audio in this game has always been choppy. It appears to be a timing issue, the AI DMAs take too long, so there are large pauses between the audio data. Shortening the AI DMA time fixes the issue. I added a new INI parameter: AiDmaModifier. This is a percentage of the DMA time, so a setting of 88 means ""AI DMA time should be 88% of the regular time (shortened by 12%)"". Until we have accurate timing emulation, this may be a helpful lever in games with audio problems.



References:
https://pastebin.com/6UiErk5h (zoinkity reverse engineering)
https://ultra64.ca/files/documentation/online-manuals/man/pro-man/pro26/index26.8.html","There are probably pros and cons to various speech recognition libraries. For instance, the Julius English voice model is 479MB, vs 40MB for Vosk. However, it does look there are Ubuntu packages available for Julius.
Overall this is why I think it would be best to leave the voice recognition up to the input plugin. As I mentioned before, there are platforms like Android that have native speech recognition libraries that could possibly be used.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,873,2021-06-17T17:44:46Z,,2022-05-31T21:49:38Z,OPEN,False,429,20,24,https://github.com/loganmc10,VRU support and Hey You Pikachu audio fix,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/873,https://github.com/vilhelmgray,9,https://github.com/mupen64plus/mupen64plus-core/pull/873#issuecomment-882936616,"https://youtu.be/6_iPf8ZC_3M

Windows build of m64p with VRU support: https://drive.google.com/file/d/1ZarcKEHs0ZpNhtan0QatjdIOPhxCP3S1/view?usp=sharing
Linux: https://drive.google.com/file/d/191vE6ZoghRPGHdyUUnClEYaeA0onBz-1/view?usp=sharing

You can see the other changes that were made (to the input plugin) by looking at this branch: https://github.com/loganmc10/m64p/tree/vru


VRU Support

Only 2 games support the VRU: Hey You Pikachu, and Densha de Go! (English translation: https://www.romhacking.net/translations/2947/ also supports the VRU)
Might not be perfect. I don't own a physical VRU, so all this work was done based on what zoinkity wrote and what I could get from the programming manual, and from trying to match the behaviour I saw on YouTube playthroughs).
This is an HLE implementation. I did not emulate the manner in which the VRU does voice recognition. Voice recognition is handled by the input plugin. I used Vosk (https://github.com/alphacep/vosk-api), so the voice recognition I'm sure will be better than an actual VRU.
Added some more functions to the input plugin spec, but they are all optional.
To specify that a VRU is plugged into a controller slot, I added a new Pak type, PLUGIN_VRU. I understand that the VRU is not a Pak, but this was the simplest and least intrusive way I could see to set this information.
Save states probably won't work. As you'll see in the YouTube video, the game uploads a list of words to the VRU. This would be part of the ""state"". So if a save state was created after that word list is uploaded to the input plugin, it won't be there when the state is loaded.



Hey you Pikachu audio fixes

The audio in this game has always been choppy. It appears to be a timing issue, the AI DMAs take too long, so there are large pauses between the audio data. Shortening the AI DMA time fixes the issue. I added a new INI parameter: AiDmaModifier. This is a percentage of the DMA time, so a setting of 88 means ""AI DMA time should be 88% of the regular time (shortened by 12%)"". Until we have accurate timing emulation, this may be a helpful lever in games with audio problems.



References:
https://pastebin.com/6UiErk5h (zoinkity reverse engineering)
https://ultra64.ca/files/documentation/online-manuals/man/pro-man/pro26/index26.8.html","That's a fair point, although Julius might be a more advanced engine, the downside of a large voice model would make it impractical for platforms where disk space is at a premium. Perhaps a plugin setup would be better after all: platforms that can benefit from more advanced engines can use them as they like, whereas platforms that require something simpler can select such plugins as necessary.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,873,2021-06-17T17:44:46Z,,2022-05-31T21:49:38Z,OPEN,False,429,20,24,https://github.com/loganmc10,VRU support and Hey You Pikachu audio fix,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/873,https://github.com/bsmiles32,10,https://github.com/mupen64plus/mupen64plus-core/pull/873#issuecomment-883294171,"https://youtu.be/6_iPf8ZC_3M

Windows build of m64p with VRU support: https://drive.google.com/file/d/1ZarcKEHs0ZpNhtan0QatjdIOPhxCP3S1/view?usp=sharing
Linux: https://drive.google.com/file/d/191vE6ZoghRPGHdyUUnClEYaeA0onBz-1/view?usp=sharing

You can see the other changes that were made (to the input plugin) by looking at this branch: https://github.com/loganmc10/m64p/tree/vru


VRU Support

Only 2 games support the VRU: Hey You Pikachu, and Densha de Go! (English translation: https://www.romhacking.net/translations/2947/ also supports the VRU)
Might not be perfect. I don't own a physical VRU, so all this work was done based on what zoinkity wrote and what I could get from the programming manual, and from trying to match the behaviour I saw on YouTube playthroughs).
This is an HLE implementation. I did not emulate the manner in which the VRU does voice recognition. Voice recognition is handled by the input plugin. I used Vosk (https://github.com/alphacep/vosk-api), so the voice recognition I'm sure will be better than an actual VRU.
Added some more functions to the input plugin spec, but they are all optional.
To specify that a VRU is plugged into a controller slot, I added a new Pak type, PLUGIN_VRU. I understand that the VRU is not a Pak, but this was the simplest and least intrusive way I could see to set this information.
Save states probably won't work. As you'll see in the YouTube video, the game uploads a list of words to the VRU. This would be part of the ""state"". So if a save state was created after that word list is uploaded to the input plugin, it won't be there when the state is loaded.



Hey you Pikachu audio fixes

The audio in this game has always been choppy. It appears to be a timing issue, the AI DMAs take too long, so there are large pauses between the audio data. Shortening the AI DMA time fixes the issue. I added a new INI parameter: AiDmaModifier. This is a percentage of the DMA time, so a setting of 88 means ""AI DMA time should be 88% of the regular time (shortened by 12%)"". Until we have accurate timing emulation, this may be a helpful lever in games with audio problems.



References:
https://pastebin.com/6UiErk5h (zoinkity reverse engineering)
https://ultra64.ca/files/documentation/online-manuals/man/pro-man/pro26/index26.8.html",In the core you have backends that would allow to choose at compile time ans runtime what voice recognition engine to use. You juste have to create a dedicated backend interface and implement a vosk and/or Julius implementation. Just make sure that no emulation state is kept inside the backend as it can't be savestated,True,{'THUMBS_UP': ['https://github.com/vilhelmgray']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,873,2021-06-17T17:44:46Z,,2022-05-31T21:49:38Z,OPEN,False,429,20,24,https://github.com/loganmc10,VRU support and Hey You Pikachu audio fix,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/873,https://github.com/amatho,11,https://github.com/mupen64plus/mupen64plus-core/pull/873#issuecomment-894295997,"https://youtu.be/6_iPf8ZC_3M

Windows build of m64p with VRU support: https://drive.google.com/file/d/1ZarcKEHs0ZpNhtan0QatjdIOPhxCP3S1/view?usp=sharing
Linux: https://drive.google.com/file/d/191vE6ZoghRPGHdyUUnClEYaeA0onBz-1/view?usp=sharing

You can see the other changes that were made (to the input plugin) by looking at this branch: https://github.com/loganmc10/m64p/tree/vru


VRU Support

Only 2 games support the VRU: Hey You Pikachu, and Densha de Go! (English translation: https://www.romhacking.net/translations/2947/ also supports the VRU)
Might not be perfect. I don't own a physical VRU, so all this work was done based on what zoinkity wrote and what I could get from the programming manual, and from trying to match the behaviour I saw on YouTube playthroughs).
This is an HLE implementation. I did not emulate the manner in which the VRU does voice recognition. Voice recognition is handled by the input plugin. I used Vosk (https://github.com/alphacep/vosk-api), so the voice recognition I'm sure will be better than an actual VRU.
Added some more functions to the input plugin spec, but they are all optional.
To specify that a VRU is plugged into a controller slot, I added a new Pak type, PLUGIN_VRU. I understand that the VRU is not a Pak, but this was the simplest and least intrusive way I could see to set this information.
Save states probably won't work. As you'll see in the YouTube video, the game uploads a list of words to the VRU. This would be part of the ""state"". So if a save state was created after that word list is uploaded to the input plugin, it won't be there when the state is loaded.



Hey you Pikachu audio fixes

The audio in this game has always been choppy. It appears to be a timing issue, the AI DMAs take too long, so there are large pauses between the audio data. Shortening the AI DMA time fixes the issue. I added a new INI parameter: AiDmaModifier. This is a percentage of the DMA time, so a setting of 88 means ""AI DMA time should be 88% of the regular time (shortened by 12%)"". Until we have accurate timing emulation, this may be a helpful lever in games with audio problems.



References:
https://pastebin.com/6UiErk5h (zoinkity reverse engineering)
https://ultra64.ca/files/documentation/online-manuals/man/pro-man/pro26/index26.8.html","In order for the input plugin to specify that a VRU is connected, can I extend the CONTROL struct (

  
    
      mupen64plus-core/src/api/m64p_plugin.h
    
    
        Lines 139 to 143
      in
      db56853
    
  
  
    

        
          
           typedef struct { 
        

        
          
               int Present; 
        

        
          
               int RawData; 
        

        
          
               int Plugin; 
        

        
          
           } CONTROL; 
        
    
  


) to include another int for ""Type"", where 0 would be a regular controller, and 1 could be mouse, 2 could be VRU, etc? This should be backwards compatible if I add it to the end of the struct I believe?

This is unfortunately not backwards compatible, as the CONTROL struct is part of an array in CONTROL_INFO here:

  
    
      mupen64plus-core/src/api/m64p_plugin.h
    
    
        Lines 171 to 174
      in
      db56853
    
  
  
    

        
          
           typedef struct { 
        

        
          
               CONTROL *Controls;      /* A pointer to an array of 4 controllers .. eg: 
        

        
          
                                          CONTROL Controls[4]; */ 
        

        
          
           } CONTROL_INFO; 
        
    
  


This would increase the size of the array (to 4 * 16 bytes), while older plugins would assume it's shorter (4 * 12 bytes). This is what I tried to convey in my bad explanation in m64p/m64p#206 😉.

The other option might be to repurpose the RawData int, rename it to Type, and say that 0=Regular Controller, 1=RawData, 2=VRU, 3=Mouse, etc... which should still be backwards compatible.

However, this should be backwards compatible.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,873,2021-06-17T17:44:46Z,,2022-05-31T21:49:38Z,OPEN,False,429,20,24,https://github.com/loganmc10,VRU support and Hey You Pikachu audio fix,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/873,https://github.com/vilhelmgray,12,https://github.com/mupen64plus/mupen64plus-core/pull/873#issuecomment-931890083,"https://youtu.be/6_iPf8ZC_3M

Windows build of m64p with VRU support: https://drive.google.com/file/d/1ZarcKEHs0ZpNhtan0QatjdIOPhxCP3S1/view?usp=sharing
Linux: https://drive.google.com/file/d/191vE6ZoghRPGHdyUUnClEYaeA0onBz-1/view?usp=sharing

You can see the other changes that were made (to the input plugin) by looking at this branch: https://github.com/loganmc10/m64p/tree/vru


VRU Support

Only 2 games support the VRU: Hey You Pikachu, and Densha de Go! (English translation: https://www.romhacking.net/translations/2947/ also supports the VRU)
Might not be perfect. I don't own a physical VRU, so all this work was done based on what zoinkity wrote and what I could get from the programming manual, and from trying to match the behaviour I saw on YouTube playthroughs).
This is an HLE implementation. I did not emulate the manner in which the VRU does voice recognition. Voice recognition is handled by the input plugin. I used Vosk (https://github.com/alphacep/vosk-api), so the voice recognition I'm sure will be better than an actual VRU.
Added some more functions to the input plugin spec, but they are all optional.
To specify that a VRU is plugged into a controller slot, I added a new Pak type, PLUGIN_VRU. I understand that the VRU is not a Pak, but this was the simplest and least intrusive way I could see to set this information.
Save states probably won't work. As you'll see in the YouTube video, the game uploads a list of words to the VRU. This would be part of the ""state"". So if a save state was created after that word list is uploaded to the input plugin, it won't be there when the state is loaded.



Hey you Pikachu audio fixes

The audio in this game has always been choppy. It appears to be a timing issue, the AI DMAs take too long, so there are large pauses between the audio data. Shortening the AI DMA time fixes the issue. I added a new INI parameter: AiDmaModifier. This is a percentage of the DMA time, so a setting of 88 means ""AI DMA time should be 88% of the regular time (shortened by 12%)"". Until we have accurate timing emulation, this may be a helpful lever in games with audio problems.



References:
https://pastebin.com/6UiErk5h (zoinkity reverse engineering)
https://ultra64.ca/files/documentation/online-manuals/man/pro-man/pro26/index26.8.html","Because the VRU vocabulary list is small, a future optimization is to train custom voice models tuned specifically to the vocabulary list for the N64 games that use the VRU. I expect this would significantly reduce the size of the language models that are included with mupen64plus by not having to recognize such a large subset of a language's vocabulary, instead only concerning itself with the small number of words the VRU is interested in.
See the ""Training your own model"" section on the VOSK website, and the ""About Models"" section of the Julius website.",True,{'THUMBS_UP': ['https://github.com/i30817']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,873,2021-06-17T17:44:46Z,,2022-05-31T21:49:38Z,OPEN,False,429,20,24,https://github.com/loganmc10,VRU support and Hey You Pikachu audio fix,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/873,https://github.com/fzurita,13,https://github.com/mupen64plus/mupen64plus-core/pull/873#issuecomment-945101744,"https://youtu.be/6_iPf8ZC_3M

Windows build of m64p with VRU support: https://drive.google.com/file/d/1ZarcKEHs0ZpNhtan0QatjdIOPhxCP3S1/view?usp=sharing
Linux: https://drive.google.com/file/d/191vE6ZoghRPGHdyUUnClEYaeA0onBz-1/view?usp=sharing

You can see the other changes that were made (to the input plugin) by looking at this branch: https://github.com/loganmc10/m64p/tree/vru


VRU Support

Only 2 games support the VRU: Hey You Pikachu, and Densha de Go! (English translation: https://www.romhacking.net/translations/2947/ also supports the VRU)
Might not be perfect. I don't own a physical VRU, so all this work was done based on what zoinkity wrote and what I could get from the programming manual, and from trying to match the behaviour I saw on YouTube playthroughs).
This is an HLE implementation. I did not emulate the manner in which the VRU does voice recognition. Voice recognition is handled by the input plugin. I used Vosk (https://github.com/alphacep/vosk-api), so the voice recognition I'm sure will be better than an actual VRU.
Added some more functions to the input plugin spec, but they are all optional.
To specify that a VRU is plugged into a controller slot, I added a new Pak type, PLUGIN_VRU. I understand that the VRU is not a Pak, but this was the simplest and least intrusive way I could see to set this information.
Save states probably won't work. As you'll see in the YouTube video, the game uploads a list of words to the VRU. This would be part of the ""state"". So if a save state was created after that word list is uploaded to the input plugin, it won't be there when the state is loaded.



Hey you Pikachu audio fixes

The audio in this game has always been choppy. It appears to be a timing issue, the AI DMAs take too long, so there are large pauses between the audio data. Shortening the AI DMA time fixes the issue. I added a new INI parameter: AiDmaModifier. This is a percentage of the DMA time, so a setting of 88 means ""AI DMA time should be 88% of the regular time (shortened by 12%)"". Until we have accurate timing emulation, this may be a helpful lever in games with audio problems.



References:
https://pastebin.com/6UiErk5h (zoinkity reverse engineering)
https://ultra64.ca/files/documentation/online-manuals/man/pro-man/pro26/index26.8.html",What's preventing this from being merged? Is it just the lack of backend?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,873,2021-06-17T17:44:46Z,,2022-05-31T21:49:38Z,OPEN,False,429,20,24,https://github.com/loganmc10,VRU support and Hey You Pikachu audio fix,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/873,https://github.com/jet082,14,https://github.com/mupen64plus/mupen64plus-core/pull/873#issuecomment-1029783727,"https://youtu.be/6_iPf8ZC_3M

Windows build of m64p with VRU support: https://drive.google.com/file/d/1ZarcKEHs0ZpNhtan0QatjdIOPhxCP3S1/view?usp=sharing
Linux: https://drive.google.com/file/d/191vE6ZoghRPGHdyUUnClEYaeA0onBz-1/view?usp=sharing

You can see the other changes that were made (to the input plugin) by looking at this branch: https://github.com/loganmc10/m64p/tree/vru


VRU Support

Only 2 games support the VRU: Hey You Pikachu, and Densha de Go! (English translation: https://www.romhacking.net/translations/2947/ also supports the VRU)
Might not be perfect. I don't own a physical VRU, so all this work was done based on what zoinkity wrote and what I could get from the programming manual, and from trying to match the behaviour I saw on YouTube playthroughs).
This is an HLE implementation. I did not emulate the manner in which the VRU does voice recognition. Voice recognition is handled by the input plugin. I used Vosk (https://github.com/alphacep/vosk-api), so the voice recognition I'm sure will be better than an actual VRU.
Added some more functions to the input plugin spec, but they are all optional.
To specify that a VRU is plugged into a controller slot, I added a new Pak type, PLUGIN_VRU. I understand that the VRU is not a Pak, but this was the simplest and least intrusive way I could see to set this information.
Save states probably won't work. As you'll see in the YouTube video, the game uploads a list of words to the VRU. This would be part of the ""state"". So if a save state was created after that word list is uploaded to the input plugin, it won't be there when the state is loaded.



Hey you Pikachu audio fixes

The audio in this game has always been choppy. It appears to be a timing issue, the AI DMAs take too long, so there are large pauses between the audio data. Shortening the AI DMA time fixes the issue. I added a new INI parameter: AiDmaModifier. This is a percentage of the DMA time, so a setting of 88 means ""AI DMA time should be 88% of the regular time (shortened by 12%)"". Until we have accurate timing emulation, this may be a helpful lever in games with audio problems.



References:
https://pastebin.com/6UiErk5h (zoinkity reverse engineering)
https://ultra64.ca/files/documentation/online-manuals/man/pro-man/pro26/index26.8.html","If you need someone who can test Japanese, I am fairly fluent.",True,{'HEART': ['https://github.com/Narann']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,873,2021-06-17T17:44:46Z,,2022-05-31T21:49:38Z,OPEN,False,429,20,24,https://github.com/loganmc10,VRU support and Hey You Pikachu audio fix,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/873,https://github.com/jet082,15,https://github.com/mupen64plus/mupen64plus-core/pull/873#issuecomment-1029785338,"https://youtu.be/6_iPf8ZC_3M

Windows build of m64p with VRU support: https://drive.google.com/file/d/1ZarcKEHs0ZpNhtan0QatjdIOPhxCP3S1/view?usp=sharing
Linux: https://drive.google.com/file/d/191vE6ZoghRPGHdyUUnClEYaeA0onBz-1/view?usp=sharing

You can see the other changes that were made (to the input plugin) by looking at this branch: https://github.com/loganmc10/m64p/tree/vru


VRU Support

Only 2 games support the VRU: Hey You Pikachu, and Densha de Go! (English translation: https://www.romhacking.net/translations/2947/ also supports the VRU)
Might not be perfect. I don't own a physical VRU, so all this work was done based on what zoinkity wrote and what I could get from the programming manual, and from trying to match the behaviour I saw on YouTube playthroughs).
This is an HLE implementation. I did not emulate the manner in which the VRU does voice recognition. Voice recognition is handled by the input plugin. I used Vosk (https://github.com/alphacep/vosk-api), so the voice recognition I'm sure will be better than an actual VRU.
Added some more functions to the input plugin spec, but they are all optional.
To specify that a VRU is plugged into a controller slot, I added a new Pak type, PLUGIN_VRU. I understand that the VRU is not a Pak, but this was the simplest and least intrusive way I could see to set this information.
Save states probably won't work. As you'll see in the YouTube video, the game uploads a list of words to the VRU. This would be part of the ""state"". So if a save state was created after that word list is uploaded to the input plugin, it won't be there when the state is loaded.



Hey you Pikachu audio fixes

The audio in this game has always been choppy. It appears to be a timing issue, the AI DMAs take too long, so there are large pauses between the audio data. Shortening the AI DMA time fixes the issue. I added a new INI parameter: AiDmaModifier. This is a percentage of the DMA time, so a setting of 88 means ""AI DMA time should be 88% of the regular time (shortened by 12%)"". Until we have accurate timing emulation, this may be a helpful lever in games with audio problems.



References:
https://pastebin.com/6UiErk5h (zoinkity reverse engineering)
https://ultra64.ca/files/documentation/online-manuals/man/pro-man/pro26/index26.8.html",The builds on the google drive are also no longer operational.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,873,2021-06-17T17:44:46Z,,2022-05-31T21:49:38Z,OPEN,False,429,20,24,https://github.com/loganmc10,VRU support and Hey You Pikachu audio fix,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/873,https://github.com/richard42,16,https://github.com/mupen64plus/mupen64plus-core/pull/873#issuecomment-1126588793,"https://youtu.be/6_iPf8ZC_3M

Windows build of m64p with VRU support: https://drive.google.com/file/d/1ZarcKEHs0ZpNhtan0QatjdIOPhxCP3S1/view?usp=sharing
Linux: https://drive.google.com/file/d/191vE6ZoghRPGHdyUUnClEYaeA0onBz-1/view?usp=sharing

You can see the other changes that were made (to the input plugin) by looking at this branch: https://github.com/loganmc10/m64p/tree/vru


VRU Support

Only 2 games support the VRU: Hey You Pikachu, and Densha de Go! (English translation: https://www.romhacking.net/translations/2947/ also supports the VRU)
Might not be perfect. I don't own a physical VRU, so all this work was done based on what zoinkity wrote and what I could get from the programming manual, and from trying to match the behaviour I saw on YouTube playthroughs).
This is an HLE implementation. I did not emulate the manner in which the VRU does voice recognition. Voice recognition is handled by the input plugin. I used Vosk (https://github.com/alphacep/vosk-api), so the voice recognition I'm sure will be better than an actual VRU.
Added some more functions to the input plugin spec, but they are all optional.
To specify that a VRU is plugged into a controller slot, I added a new Pak type, PLUGIN_VRU. I understand that the VRU is not a Pak, but this was the simplest and least intrusive way I could see to set this information.
Save states probably won't work. As you'll see in the YouTube video, the game uploads a list of words to the VRU. This would be part of the ""state"". So if a save state was created after that word list is uploaded to the input plugin, it won't be there when the state is loaded.



Hey you Pikachu audio fixes

The audio in this game has always been choppy. It appears to be a timing issue, the AI DMAs take too long, so there are large pauses between the audio data. Shortening the AI DMA time fixes the issue. I added a new INI parameter: AiDmaModifier. This is a percentage of the DMA time, so a setting of 88 means ""AI DMA time should be 88% of the regular time (shortened by 12%)"". Until we have accurate timing emulation, this may be a helpful lever in games with audio problems.



References:
https://pastebin.com/6UiErk5h (zoinkity reverse engineering)
https://ultra64.ca/files/documentation/online-manuals/man/pro-man/pro26/index26.8.html","@loganmc10 are you finished with your work on this, or is this still WIP?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,873,2021-06-17T17:44:46Z,,2022-05-31T21:49:38Z,OPEN,False,429,20,24,https://github.com/loganmc10,VRU support and Hey You Pikachu audio fix,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/873,https://github.com/loganmc10,17,https://github.com/mupen64plus/mupen64plus-core/pull/873#issuecomment-1126607347,"https://youtu.be/6_iPf8ZC_3M

Windows build of m64p with VRU support: https://drive.google.com/file/d/1ZarcKEHs0ZpNhtan0QatjdIOPhxCP3S1/view?usp=sharing
Linux: https://drive.google.com/file/d/191vE6ZoghRPGHdyUUnClEYaeA0onBz-1/view?usp=sharing

You can see the other changes that were made (to the input plugin) by looking at this branch: https://github.com/loganmc10/m64p/tree/vru


VRU Support

Only 2 games support the VRU: Hey You Pikachu, and Densha de Go! (English translation: https://www.romhacking.net/translations/2947/ also supports the VRU)
Might not be perfect. I don't own a physical VRU, so all this work was done based on what zoinkity wrote and what I could get from the programming manual, and from trying to match the behaviour I saw on YouTube playthroughs).
This is an HLE implementation. I did not emulate the manner in which the VRU does voice recognition. Voice recognition is handled by the input plugin. I used Vosk (https://github.com/alphacep/vosk-api), so the voice recognition I'm sure will be better than an actual VRU.
Added some more functions to the input plugin spec, but they are all optional.
To specify that a VRU is plugged into a controller slot, I added a new Pak type, PLUGIN_VRU. I understand that the VRU is not a Pak, but this was the simplest and least intrusive way I could see to set this information.
Save states probably won't work. As you'll see in the YouTube video, the game uploads a list of words to the VRU. This would be part of the ""state"". So if a save state was created after that word list is uploaded to the input plugin, it won't be there when the state is loaded.



Hey you Pikachu audio fixes

The audio in this game has always been choppy. It appears to be a timing issue, the AI DMAs take too long, so there are large pauses between the audio data. Shortening the AI DMA time fixes the issue. I added a new INI parameter: AiDmaModifier. This is a percentage of the DMA time, so a setting of 88 means ""AI DMA time should be 88% of the regular time (shortened by 12%)"". Until we have accurate timing emulation, this may be a helpful lever in games with audio problems.



References:
https://pastebin.com/6UiErk5h (zoinkity reverse engineering)
https://ultra64.ca/files/documentation/online-manuals/man/pro-man/pro26/index26.8.html","I'm finished with it, I've just been rebasing it against master. But I know @bsmiles32 had some disagreement about the implementation. I've been including it with my package for quite some time.
There is some disagreement about whether the voice recognition library should like inside the core or the input plugin basically, and that decision would affect the API design, so it's not just a matter of code organization.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,873,2021-06-17T17:44:46Z,,2022-05-31T21:49:38Z,OPEN,False,429,20,24,https://github.com/loganmc10,VRU support and Hey You Pikachu audio fix,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/873,https://github.com/bsmiles32,18,https://github.com/mupen64plus/mupen64plus-core/pull/873#issuecomment-1126716879,"https://youtu.be/6_iPf8ZC_3M

Windows build of m64p with VRU support: https://drive.google.com/file/d/1ZarcKEHs0ZpNhtan0QatjdIOPhxCP3S1/view?usp=sharing
Linux: https://drive.google.com/file/d/191vE6ZoghRPGHdyUUnClEYaeA0onBz-1/view?usp=sharing

You can see the other changes that were made (to the input plugin) by looking at this branch: https://github.com/loganmc10/m64p/tree/vru


VRU Support

Only 2 games support the VRU: Hey You Pikachu, and Densha de Go! (English translation: https://www.romhacking.net/translations/2947/ also supports the VRU)
Might not be perfect. I don't own a physical VRU, so all this work was done based on what zoinkity wrote and what I could get from the programming manual, and from trying to match the behaviour I saw on YouTube playthroughs).
This is an HLE implementation. I did not emulate the manner in which the VRU does voice recognition. Voice recognition is handled by the input plugin. I used Vosk (https://github.com/alphacep/vosk-api), so the voice recognition I'm sure will be better than an actual VRU.
Added some more functions to the input plugin spec, but they are all optional.
To specify that a VRU is plugged into a controller slot, I added a new Pak type, PLUGIN_VRU. I understand that the VRU is not a Pak, but this was the simplest and least intrusive way I could see to set this information.
Save states probably won't work. As you'll see in the YouTube video, the game uploads a list of words to the VRU. This would be part of the ""state"". So if a save state was created after that word list is uploaded to the input plugin, it won't be there when the state is loaded.



Hey you Pikachu audio fixes

The audio in this game has always been choppy. It appears to be a timing issue, the AI DMAs take too long, so there are large pauses between the audio data. Shortening the AI DMA time fixes the issue. I added a new INI parameter: AiDmaModifier. This is a percentage of the DMA time, so a setting of 88 means ""AI DMA time should be 88% of the regular time (shortened by 12%)"". Until we have accurate timing emulation, this may be a helpful lever in games with audio problems.



References:
https://pastebin.com/6UiErk5h (zoinkity reverse engineering)
https://ultra64.ca/files/documentation/online-manuals/man/pro-man/pro26/index26.8.html","I'm sorry but I won't have time to work on this project anymore (at least for the coming months/years). So you can disregard my opinion on this and other PR. If you feel like merging it no problem. It would be unfair of me to block other contribution given that I won't be around to help.
Sorry it took me so long to realize that I won't have time for this project anymore.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,873,2021-06-17T17:44:46Z,,2022-05-31T21:49:38Z,OPEN,False,429,20,24,https://github.com/loganmc10,VRU support and Hey You Pikachu audio fix,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/873,https://github.com/vilhelmgray,19,https://github.com/mupen64plus/mupen64plus-core/pull/873#issuecomment-1126731435,"https://youtu.be/6_iPf8ZC_3M

Windows build of m64p with VRU support: https://drive.google.com/file/d/1ZarcKEHs0ZpNhtan0QatjdIOPhxCP3S1/view?usp=sharing
Linux: https://drive.google.com/file/d/191vE6ZoghRPGHdyUUnClEYaeA0onBz-1/view?usp=sharing

You can see the other changes that were made (to the input plugin) by looking at this branch: https://github.com/loganmc10/m64p/tree/vru


VRU Support

Only 2 games support the VRU: Hey You Pikachu, and Densha de Go! (English translation: https://www.romhacking.net/translations/2947/ also supports the VRU)
Might not be perfect. I don't own a physical VRU, so all this work was done based on what zoinkity wrote and what I could get from the programming manual, and from trying to match the behaviour I saw on YouTube playthroughs).
This is an HLE implementation. I did not emulate the manner in which the VRU does voice recognition. Voice recognition is handled by the input plugin. I used Vosk (https://github.com/alphacep/vosk-api), so the voice recognition I'm sure will be better than an actual VRU.
Added some more functions to the input plugin spec, but they are all optional.
To specify that a VRU is plugged into a controller slot, I added a new Pak type, PLUGIN_VRU. I understand that the VRU is not a Pak, but this was the simplest and least intrusive way I could see to set this information.
Save states probably won't work. As you'll see in the YouTube video, the game uploads a list of words to the VRU. This would be part of the ""state"". So if a save state was created after that word list is uploaded to the input plugin, it won't be there when the state is loaded.



Hey you Pikachu audio fixes

The audio in this game has always been choppy. It appears to be a timing issue, the AI DMAs take too long, so there are large pauses between the audio data. Shortening the AI DMA time fixes the issue. I added a new INI parameter: AiDmaModifier. This is a percentage of the DMA time, so a setting of 88 means ""AI DMA time should be 88% of the regular time (shortened by 12%)"". Until we have accurate timing emulation, this may be a helpful lever in games with audio problems.



References:
https://pastebin.com/6UiErk5h (zoinkity reverse engineering)
https://ultra64.ca/files/documentation/online-manuals/man/pro-man/pro26/index26.8.html",It might not be so bad to tentatively merge this PR so that mupen64plus has at least some sort of VRU support. I think in the longterm it would be good to transition this plugin VRU functionality into the mupen64plus core as a proper backend -- thus allowing better support for savestates and such as mentioned earlier in this thread -- but that can happen in the future when someone with the motivation and familiarity with the code is available to spearhead such an effort.,True,{'THUMBS_UP': ['https://github.com/bsmiles32']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,876,2021-06-23T04:08:49Z,2021-07-08T09:18:03Z,2021-07-08T09:18:37Z,MERGED,True,130,0,7,https://github.com/loganmc10,IS Viewer support,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/876,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/876,"IS-Viewer 64 was a physical debugging tool (https://n64squid.com/homebrew/n64-sdk/development-hardware/). CEN64 has had support for a while (https://github.com/n64dev/cen64/blob/master/pi/is_viewer.c). I referenced/copied their implementation for mupen64plus.
When a ROM has IS64 support, the output is printed as a DebugMessage:

This is used today by homebrew ROM developers to debug their games.
I don't think this should interfere with any existing games. The address space is inside dom1 addr2 (cart ROM), but I map the IS Viewer before the cart ROM. As I understand it, if the current ROM includes that address space, it'll overwrite the IS Viewer mapping. @bsmiles32","IS-Viewer 64 was a physical debugging tool (https://n64squid.com/homebrew/n64-sdk/development-hardware/). CEN64 has had support for a while (https://github.com/n64dev/cen64/blob/master/pi/is_viewer.c). I referenced/copied their implementation for mupen64plus.
When a ROM has IS64 support, the output is printed as a DebugMessage:

This is used today by homebrew ROM developers to debug their games.
I don't think this should interfere with any existing games. The address space is inside dom1 addr2 (cart ROM), but I map the IS Viewer before the cart ROM. As I understand it, if the current ROM includes that address space, it'll overwrite the IS Viewer mapping. @bsmiles32",True,"{'HEART': ['https://github.com/jkbenaim', 'https://github.com/CrashOveride95', 'https://github.com/meeq']}"
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,876,2021-06-23T04:08:49Z,2021-07-08T09:18:03Z,2021-07-08T09:18:37Z,MERGED,True,130,0,7,https://github.com/loganmc10,IS Viewer support,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/876,https://github.com/mikeryan,2,https://github.com/mupen64plus/mupen64plus-core/pull/876#issuecomment-867043092,"IS-Viewer 64 was a physical debugging tool (https://n64squid.com/homebrew/n64-sdk/development-hardware/). CEN64 has had support for a while (https://github.com/n64dev/cen64/blob/master/pi/is_viewer.c). I referenced/copied their implementation for mupen64plus.
When a ROM has IS64 support, the output is printed as a DebugMessage:

This is used today by homebrew ROM developers to debug their games.
I don't think this should interfere with any existing games. The address space is inside dom1 addr2 (cart ROM), but I map the IS Viewer before the cart ROM. As I understand it, if the current ROM includes that address space, it'll overwrite the IS Viewer mapping. @bsmiles32","Hi, I'm the original author of the code you borrowed from CEN64. I notice that you didn't include any of the iconv code. In order to interface with retail games, you'll need to convert the text from whatever locale it was originally in (typically EUC-JP) into UTF-8 for it to display correctly in your GUI. I'm not sure if iconv is the best option for mupen, but you'll definitely need something. Best of luck and thanks for porting this over.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,876,2021-06-23T04:08:49Z,2021-07-08T09:18:03Z,2021-07-08T09:18:37Z,MERGED,True,130,0,7,https://github.com/loganmc10,IS Viewer support,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/876,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/876#issuecomment-867061116,"IS-Viewer 64 was a physical debugging tool (https://n64squid.com/homebrew/n64-sdk/development-hardware/). CEN64 has had support for a while (https://github.com/n64dev/cen64/blob/master/pi/is_viewer.c). I referenced/copied their implementation for mupen64plus.
When a ROM has IS64 support, the output is printed as a DebugMessage:

This is used today by homebrew ROM developers to debug their games.
I don't think this should interfere with any existing games. The address space is inside dom1 addr2 (cart ROM), but I map the IS Viewer before the cart ROM. As I understand it, if the current ROM includes that address space, it'll overwrite the IS Viewer mapping. @bsmiles32","I mostly had homebrews in mind. I assume the only games that use EUC-JP are the OG Zelda debug ROMs.
These messages are actually passed to a front-end, so technically the front-end could probably detect EUC-JP encoding and display it accordingly, without modifying this code.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,876,2021-06-23T04:08:49Z,2021-07-08T09:18:03Z,2021-07-08T09:18:37Z,MERGED,True,130,0,7,https://github.com/loganmc10,IS Viewer support,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/876,https://github.com/jkbenaim,4,https://github.com/mupen64plus/mupen64plus-core/pull/876#issuecomment-867078315,"IS-Viewer 64 was a physical debugging tool (https://n64squid.com/homebrew/n64-sdk/development-hardware/). CEN64 has had support for a while (https://github.com/n64dev/cen64/blob/master/pi/is_viewer.c). I referenced/copied their implementation for mupen64plus.
When a ROM has IS64 support, the output is printed as a DebugMessage:

This is used today by homebrew ROM developers to debug their games.
I don't think this should interfere with any existing games. The address space is inside dom1 addr2 (cart ROM), but I map the IS Viewer before the cart ROM. As I understand it, if the current ROM includes that address space, it'll overwrite the IS Viewer mapping. @bsmiles32",This PR looks good. It makes sense for the core to pass the data to the frontend without conversion. Any changes to the frontend would be done in a separate PR.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,876,2021-06-23T04:08:49Z,2021-07-08T09:18:03Z,2021-07-08T09:18:37Z,MERGED,True,130,0,7,https://github.com/loganmc10,IS Viewer support,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/876,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/876#issuecomment-875934527,"IS-Viewer 64 was a physical debugging tool (https://n64squid.com/homebrew/n64-sdk/development-hardware/). CEN64 has had support for a while (https://github.com/n64dev/cen64/blob/master/pi/is_viewer.c). I referenced/copied their implementation for mupen64plus.
When a ROM has IS64 support, the output is printed as a DebugMessage:

This is used today by homebrew ROM developers to debug their games.
I don't think this should interfere with any existing games. The address space is inside dom1 addr2 (cart ROM), but I map the IS Viewer before the cart ROM. As I understand it, if the current ROM includes that address space, it'll overwrite the IS Viewer mapping. @bsmiles32","Unless @bsmiles32 or @richard42 have any objections I think this should be pretty safe to merge. The code is basically self contained, so I don't think there is much of a chance for regressions.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,876,2021-06-23T04:08:49Z,2021-07-08T09:18:03Z,2021-07-08T09:18:37Z,MERGED,True,130,0,7,https://github.com/loganmc10,IS Viewer support,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/876,https://github.com/richard42,6,https://github.com/mupen64plus/mupen64plus-core/pull/876#issuecomment-876122980,"IS-Viewer 64 was a physical debugging tool (https://n64squid.com/homebrew/n64-sdk/development-hardware/). CEN64 has had support for a while (https://github.com/n64dev/cen64/blob/master/pi/is_viewer.c). I referenced/copied their implementation for mupen64plus.
When a ROM has IS64 support, the output is printed as a DebugMessage:

This is used today by homebrew ROM developers to debug their games.
I don't think this should interfere with any existing games. The address space is inside dom1 addr2 (cart ROM), but I map the IS Viewer before the cart ROM. As I understand it, if the current ROM includes that address space, it'll overwrite the IS Viewer mapping. @bsmiles32",I'm fine with this.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,876,2021-06-23T04:08:49Z,2021-07-08T09:18:03Z,2021-07-08T09:18:37Z,MERGED,True,130,0,7,https://github.com/loganmc10,IS Viewer support,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/876,https://github.com/Narann,7,https://github.com/mupen64plus/mupen64plus-core/pull/876#issuecomment-876277460,"IS-Viewer 64 was a physical debugging tool (https://n64squid.com/homebrew/n64-sdk/development-hardware/). CEN64 has had support for a while (https://github.com/n64dev/cen64/blob/master/pi/is_viewer.c). I referenced/copied their implementation for mupen64plus.
When a ROM has IS64 support, the output is printed as a DebugMessage:

This is used today by homebrew ROM developers to debug their games.
I don't think this should interfere with any existing games. The address space is inside dom1 addr2 (cart ROM), but I map the IS Viewer before the cart ROM. As I understand it, if the current ROM includes that address space, it'll overwrite the IS Viewer mapping. @bsmiles32","Thanks @richard42 !
EDIT: And thanks all, of course! 👍",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,878,2021-06-23T22:04:26Z,2021-07-07T20:56:46Z,2021-07-07T20:56:52Z,MERGED,True,36,20,5,https://github.com/meeq,Make 4K EEPROM default save type; support carts with no EEPROM,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/878,https://github.com/meeq,1,https://github.com/mupen64plus/mupen64plus-core/pull/878,"Proper fix for workaround in DragonMinded/libdragon#125 (review)
@rasky  @sp1187 @loganmc10
The Joybus response values have been confirmed on real hardware using the following test ROM which dumps the EEPROM status input and output data:  eepromtest.zip
I was not able to run this test ROM on Mupen64Plus; all of my libdragon example ROMs get stuck at ""Mupen64Plus Started..."":

I'd appreciate some assistance on getting this to run. I was able to test this ROM successfully with cen64.","Proper fix for workaround in DragonMinded/libdragon#125 (review)
@rasky  @sp1187 @loganmc10
The Joybus response values have been confirmed on real hardware using the following test ROM which dumps the EEPROM status input and output data:  eepromtest.zip
I was not able to run this test ROM on Mupen64Plus; all of my libdragon example ROMs get stuck at ""Mupen64Plus Started..."":

I'd appreciate some assistance on getting this to run. I was able to test this ROM successfully with cen64.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,878,2021-06-23T22:04:26Z,2021-07-07T20:56:46Z,2021-07-07T20:56:52Z,MERGED,True,36,20,5,https://github.com/meeq,Make 4K EEPROM default save type; support carts with no EEPROM,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/878,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/878#issuecomment-867238962,"Proper fix for workaround in DragonMinded/libdragon#125 (review)
@rasky  @sp1187 @loganmc10
The Joybus response values have been confirmed on real hardware using the following test ROM which dumps the EEPROM status input and output data:  eepromtest.zip
I was not able to run this test ROM on Mupen64Plus; all of my libdragon example ROMs get stuck at ""Mupen64Plus Started..."":

I'd appreciate some assistance on getting this to run. I was able to test this ROM successfully with cen64.","I'll test this in a bit, I think it would be cleaner to just leave the type as a uint16_t and do
rx_buf[0] = (uint8_t)(cart->eeprom.type >> 0);
rx_buf[1] = (uint8_t)(cart->eeprom.type >> 8);
rx_buf[2] = (uint8_t)(cart->eeprom.type >> 0);

(Just repeat the first byte, which is 0 when present and 0xff when absent)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,878,2021-06-23T22:04:26Z,2021-07-07T20:56:46Z,2021-07-07T20:56:52Z,MERGED,True,36,20,5,https://github.com/meeq,Make 4K EEPROM default save type; support carts with no EEPROM,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/878,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/878#issuecomment-867244307,"Proper fix for workaround in DragonMinded/libdragon#125 (review)
@rasky  @sp1187 @loganmc10
The Joybus response values have been confirmed on real hardware using the following test ROM which dumps the EEPROM status input and output data:  eepromtest.zip
I was not able to run this test ROM on Mupen64Plus; all of my libdragon example ROMs get stuck at ""Mupen64Plus Started..."":

I'd appreciate some assistance on getting this to run. I was able to test this ROM successfully with cen64.","The other thing I'll say: the way this is written, it defaults to ""no eeprom"". This means that any ROM not in the INI won't support eeprom saves. This might be a problem for ROM hacks/new ROMs (like a new version of Smash Remix or something).
I think it would be better to retain the default of 4k eeprom. I don't think we've run across a game that failed because it said it had eeprom when it shouldn't.
EDIT: Or maybe we just set it to ""no eeprom"" if the INI says it uses another save type like flash or sram",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,878,2021-06-23T22:04:26Z,2021-07-07T20:56:46Z,2021-07-07T20:56:52Z,MERGED,True,36,20,5,https://github.com/meeq,Make 4K EEPROM default save type; support carts with no EEPROM,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/878,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/878#issuecomment-867254310,"Proper fix for workaround in DragonMinded/libdragon#125 (review)
@rasky  @sp1187 @loganmc10
The Joybus response values have been confirmed on real hardware using the following test ROM which dumps the EEPROM status input and output data:  eepromtest.zip
I was not able to run this test ROM on Mupen64Plus; all of my libdragon example ROMs get stuck at ""Mupen64Plus Started..."":

I'd appreciate some assistance on getting this to run. I was able to test this ROM successfully with cen64.","Here is the result of the test ROM (after I applied this PR):

I think that looks right, but as I said, I think we should still default to 4k eeprom. It's a fairly safe assumption that if a commercial game is probing that address, it expects the eeprom to be there.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,878,2021-06-23T22:04:26Z,2021-07-07T20:56:46Z,2021-07-07T20:56:52Z,MERGED,True,36,20,5,https://github.com/meeq,Make 4K EEPROM default save type; support carts with no EEPROM,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/878,https://github.com/meeq,5,https://github.com/mupen64plus/mupen64plus-core/pull/878#issuecomment-867281000,"Proper fix for workaround in DragonMinded/libdragon#125 (review)
@rasky  @sp1187 @loganmc10
The Joybus response values have been confirmed on real hardware using the following test ROM which dumps the EEPROM status input and output data:  eepromtest.zip
I was not able to run this test ROM on Mupen64Plus; all of my libdragon example ROMs get stuck at ""Mupen64Plus Started..."":

I'd appreciate some assistance on getting this to run. I was able to test this ROM successfully with cen64.","I have an updated EEPROM test ROM that exercises a variety of EEPROM probe command formats: eepromtest.zip
This branch has been updated to reflect a more-accurate understanding of how the real hardware handles EEPROM checking: If there is no EEPROM, the recv buffer will not be modified.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,878,2021-06-23T22:04:26Z,2021-07-07T20:56:46Z,2021-07-07T20:56:52Z,MERGED,True,36,20,5,https://github.com/meeq,Make 4K EEPROM default save type; support carts with no EEPROM,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/878,https://github.com/meeq,6,https://github.com/mupen64plus/mupen64plus-core/pull/878#issuecomment-867285027,"Proper fix for workaround in DragonMinded/libdragon#125 (review)
@rasky  @sp1187 @loganmc10
The Joybus response values have been confirmed on real hardware using the following test ROM which dumps the EEPROM status input and output data:  eepromtest.zip
I was not able to run this test ROM on Mupen64Plus; all of my libdragon example ROMs get stuck at ""Mupen64Plus Started..."":

I'd appreciate some assistance on getting this to run. I was able to test this ROM successfully with cen64.","As for the ""user-experience question"" of whether it's actually a good idea to make this change: it's subjective.
According to this list of save types, 4K EEPROM is the second-most popular save format for N64 titles. There is a lot of sense in the argument that a user-friendly emulator should assume 4K EEPROM if no other save type is specified, since it (almost always) won't hurt and has a decent chance of helping.
My only argument against is that homebrew/mods that want other save types (such as Smash Remix which uses SRAM) will still be a broken experience that requires the user to select the right save type. So it will ""just work"" some of the time, but silently fail other times.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,878,2021-06-23T22:04:26Z,2021-07-07T20:56:46Z,2021-07-07T20:56:52Z,MERGED,True,36,20,5,https://github.com/meeq,Make 4K EEPROM default save type; support carts with no EEPROM,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/878,https://github.com/loganmc10,7,https://github.com/mupen64plus/mupen64plus-core/pull/878#issuecomment-867291103,"Proper fix for workaround in DragonMinded/libdragon#125 (review)
@rasky  @sp1187 @loganmc10
The Joybus response values have been confirmed on real hardware using the following test ROM which dumps the EEPROM status input and output data:  eepromtest.zip
I was not able to run this test ROM on Mupen64Plus; all of my libdragon example ROMs get stuck at ""Mupen64Plus Started..."":

I'd appreciate some assistance on getting this to run. I was able to test this ROM successfully with cen64.","-    JDT_EEPROM_4K        = 0x8000,  /* 4k EEPROM */
-    JDT_EEPROM_16K       = 0xc000,  /* 16k EEPROM */
+    JDT_EEPROM_4K        = 0x0080,  /* 4k EEPROM */
+   JDT_EEPROM_16K       = 0x00c0,  /* 16k EEPROM */

Did you mean to flip the order of these bytes? I don't think that's right.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,878,2021-06-23T22:04:26Z,2021-07-07T20:56:46Z,2021-07-07T20:56:52Z,MERGED,True,36,20,5,https://github.com/meeq,Make 4K EEPROM default save type; support carts with no EEPROM,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/878,https://github.com/meeq,8,https://github.com/mupen64plus/mupen64plus-core/pull/878#issuecomment-867609194,"Proper fix for workaround in DragonMinded/libdragon#125 (review)
@rasky  @sp1187 @loganmc10
The Joybus response values have been confirmed on real hardware using the following test ROM which dumps the EEPROM status input and output data:  eepromtest.zip
I was not able to run this test ROM on Mupen64Plus; all of my libdragon example ROMs get stuck at ""Mupen64Plus Started..."":

I'd appreciate some assistance on getting this to run. I was able to test this ROM successfully with cen64.","Sorry, I definitely messed up by flipping the bytes of the EEPROM identifiers. Let me try to figure out how to get my libdragon ROMs running on this branch so I can run the test ROM and verify these changes myself.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,878,2021-06-23T22:04:26Z,2021-07-07T20:56:46Z,2021-07-07T20:56:52Z,MERGED,True,36,20,5,https://github.com/meeq,Make 4K EEPROM default save type; support carts with no EEPROM,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/878,https://github.com/meeq,9,https://github.com/mupen64plus/mupen64plus-core/pull/878#issuecomment-867653998,"Proper fix for workaround in DragonMinded/libdragon#125 (review)
@rasky  @sp1187 @loganmc10
The Joybus response values have been confirmed on real hardware using the following test ROM which dumps the EEPROM status input and output data:  eepromtest.zip
I was not able to run this test ROM on Mupen64Plus; all of my libdragon example ROMs get stuck at ""Mupen64Plus Started..."":

I'd appreciate some assistance on getting this to run. I was able to test this ROM successfully with cen64.","I have attached the libdragon test suite, which includes EEPROM Joybus command tests: testrom_emu.zip
Line numbers for test_eeprom failures are mapped to this file: libdragon/tests/test_eeprom.c
There are several other failures unrelated to EEPROM that are out of scope for this PR.
Without the changes in this PR, it is not possible to exercise the ""EEPROM not detected"" code-path since Mupen64Plus will always have a 4K EEPROM (unless 16K EEPROM is specified)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,878,2021-06-23T22:04:26Z,2021-07-07T20:56:46Z,2021-07-07T20:56:52Z,MERGED,True,36,20,5,https://github.com/meeq,Make 4K EEPROM default save type; support carts with no EEPROM,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/878,https://github.com/loganmc10,10,https://github.com/mupen64plus/mupen64plus-core/pull/878#issuecomment-867669215,"Proper fix for workaround in DragonMinded/libdragon#125 (review)
@rasky  @sp1187 @loganmc10
The Joybus response values have been confirmed on real hardware using the following test ROM which dumps the EEPROM status input and output data:  eepromtest.zip
I was not able to run this test ROM on Mupen64Plus; all of my libdragon example ROMs get stuck at ""Mupen64Plus Started..."":

I'd appreciate some assistance on getting this to run. I was able to test this ROM successfully with cen64.","Here are the results with the PR applied (default settings):
Core: IS64: **** Starting test: test_exception
Core: IS64: ASSERTION FAILED (test_exception.c:258):
Core: IS64: breakpoint_occured != 1 (0 != 1)
Core: IS64: Breakpoint exception was not triggered
Core: IS64: **** Starting test: test_timer_ticks
Core: IS64: ASSERTION FAILED (test_timer.c:195):
Core: IS64: t5-t0 < 1000
Core: IS64: invalid timer_ticks [start=ffffffe9]: 160000000b - 17000002fd
Core: IS64: **** Starting test: test_timer_oneshot
Core: IS64: **** Starting test: test_timer_slow_callback
Core: IS64: **** Starting test: test_timer_continuous
Core: IS64: **** Starting test: test_timer_mixed
Core: IS64: **** Starting test: test_timer_disabled_start
Core: IS64: **** Starting test: test_timer_disabled_restart
Core: IS64: **** Starting test: test_irq_reentrancy
Core: IS64: **** Starting test: test_eeprom
Core: IS64: 4K EEPROM detected.
Core: IS64: 4K EEPROM detected.
Core: IS64: 4K EEPROM detected.
Core: IS64: 4K EEPROM detected.
Core: IS64: **** Starting test: test_dfs_read
Core: IS64: **** Starting test: test_dfs_rom_addr
Core: IS64: **** Starting test: test_eepromfs
Core: IS64: **** Starting test: test_cache_invalidate
Core: IS64: ASSERTION FAILED (test_cache.c:34):
Core: IS64: [----deadbe] != [----aaaaaa]
Core: IS64:      ^^              ^^  idx: 0
Core: IS64: unexpected data in not-invalidated cached cacheline 0 (0/0)
Core: IS64: **** Starting test: test_debug_sdfs
Core: IS64: TEST SKIPPED:
Core: IS64: no SD support
Core: IS64: SKIP
Core: IS64: 
Core: IS64: Testsuite finished in 00:02
Core: IS64: Passed: 11 out of 16 (1 skipped)

When I add an entry for the ROM to the INI and set the SaveType to None:
Core: IS64: **** Starting test: test_exception
Core: IS64: ASSERTION FAILED (test_exception.c:258):
Core: IS64: breakpoint_occured != 1 (0 != 1)
Core: IS64: Breakpoint exception was not triggered
Core: IS64: **** Starting test: test_timer_ticks
Core: IS64: ASSERTION FAILED (test_timer.c:195):
Core: IS64: t5-t0 < 1000
Core: IS64: invalid timer_ticks [start=ffffffe9]: 160000000b - 17000002fd
Core: IS64: **** Starting test: test_timer_oneshot
Core: IS64: **** Starting test: test_timer_slow_callback
Core: IS64: **** Starting test: test_timer_continuous
Core: IS64: **** Starting test: test_timer_mixed
Core: IS64: **** Starting test: test_timer_disabled_start
Core: IS64: **** Starting test: test_timer_disabled_restart
Core: IS64: **** Starting test: test_irq_reentrancy
Core: IS64: **** Starting test: test_eeprom
Core: IS64: EEPROM not detected.
Core: IS64: EEPROM not detected.
Core: IS64: EEPROM not detected.
Core: IS64: EEPROM not detected.
Core: IS64: **** Starting test: test_dfs_read
Core: IS64: **** Starting test: test_dfs_rom_addr
Core: IS64: **** Starting test: test_eepromfs
Core: IS64: TEST SKIPPED:
Core: IS64: EEPROM not found; skipping eepfs tests
Core: IS64: SKIP
Core: IS64: **** Starting test: test_cache_invalidate
Core: IS64: ASSERTION FAILED (test_cache.c:34):
Core: IS64: [----deadbe] != [----aaaaaa]
Core: IS64:      ^^              ^^  idx: 0
Core: IS64: unexpected data in not-invalidated cached cacheline 0 (0/0)
Core: IS64: **** Starting test: test_debug_sdfs
Core: IS64: TEST SKIPPED:
Core: IS64: no SD support
Core: IS64: SKIP
Core: IS64: 
Core: IS64: Testsuite finished in 00:02
Core: IS64: Passed: 10 out of 16 (2 skipped)

The results (for eeprom) look good to me, PR looks good to me in the state it's in currently.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,878,2021-06-23T22:04:26Z,2021-07-07T20:56:46Z,2021-07-07T20:56:52Z,MERGED,True,36,20,5,https://github.com/meeq,Make 4K EEPROM default save type; support carts with no EEPROM,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/878,https://github.com/loganmc10,11,https://github.com/mupen64plus/mupen64plus-core/pull/878#issuecomment-875887559,"Proper fix for workaround in DragonMinded/libdragon#125 (review)
@rasky  @sp1187 @loganmc10
The Joybus response values have been confirmed on real hardware using the following test ROM which dumps the EEPROM status input and output data:  eepromtest.zip
I was not able to run this test ROM on Mupen64Plus; all of my libdragon example ROMs get stuck at ""Mupen64Plus Started..."":

I'd appreciate some assistance on getting this to run. I was able to test this ROM successfully with cen64.","This LGTM, we've got a lot of pending PRs, if we don't start merging things we'll end up with conflicts soon enough",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,878,2021-06-23T22:04:26Z,2021-07-07T20:56:46Z,2021-07-07T20:56:52Z,MERGED,True,36,20,5,https://github.com/meeq,Make 4K EEPROM default save type; support carts with no EEPROM,8,[],https://github.com/mupen64plus/mupen64plus-core/pull/878,https://github.com/Narann,12,https://github.com/mupen64plus/mupen64plus-core/pull/878#issuecomment-875927355,"Proper fix for workaround in DragonMinded/libdragon#125 (review)
@rasky  @sp1187 @loganmc10
The Joybus response values have been confirmed on real hardware using the following test ROM which dumps the EEPROM status input and output data:  eepromtest.zip
I was not able to run this test ROM on Mupen64Plus; all of my libdragon example ROMs get stuck at ""Mupen64Plus Started..."":

I'd appreciate some assistance on getting this to run. I was able to test this ROM successfully with cen64.",Here we go.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,880,2021-07-07T19:23:30Z,2021-07-07T20:57:36Z,2021-07-07T20:57:36Z,MERGED,True,2,2,1,https://github.com/LuigiBlood,Fix 64DD Write Address Check Regression,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/880,https://github.com/LuigiBlood,1,https://github.com/mupen64plus/mupen64plus-core/pull/880,"The DMA Address check fix only worked for reads but writes did not trigger dd_update_bm, and therefore no interrupts were issued
I made it check the entire buffer space so there's no room for errors: It works.","The DMA Address check fix only worked for reads but writes did not trigger dd_update_bm, and therefore no interrupts were issued
I made it check the entire buffer space so there's no room for errors: It works.",True,{'THUMBS_UP': ['https://github.com/loganmc10']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,881,2021-07-08T15:58:21Z,2021-07-09T12:18:26Z,2021-07-09T12:18:26Z,MERGED,True,1,1,1,https://github.com/loganmc10,Fix for compiler warning,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/881,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/881,See c55e48e,See c55e48e,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,884,2021-07-10T13:06:19Z,2021-07-11T03:02:48Z,2021-07-19T09:54:10Z,MERGED,True,10,7,2,https://github.com/Gillou68310,Fix https://github.com/mupen64plus/mupen64plus-core/issues/883,1,['new dynarec'],https://github.com/mupen64plus/mupen64plus-core/pull/884,https://github.com/Gillou68310,1,https://github.com/mupen64plus/mupen64plus-core/pull/884,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,884,2021-07-10T13:06:19Z,2021-07-11T03:02:48Z,2021-07-19T09:54:10Z,MERGED,True,10,7,2,https://github.com/Gillou68310,Fix https://github.com/mupen64plus/mupen64plus-core/issues/883,1,['new dynarec'],https://github.com/mupen64plus/mupen64plus-core/pull/884,https://github.com/Gillou68310,2,https://github.com/mupen64plus/mupen64plus-core/pull/884#issuecomment-877635471,,@dmrlawson could you confirm that this fixes #883,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,884,2021-07-10T13:06:19Z,2021-07-11T03:02:48Z,2021-07-19T09:54:10Z,MERGED,True,10,7,2,https://github.com/Gillou68310,Fix https://github.com/mupen64plus/mupen64plus-core/issues/883,1,['new dynarec'],https://github.com/mupen64plus/mupen64plus-core/pull/884,https://github.com/dmrlawson,3,https://github.com/mupen64plus/mupen64plus-core/pull/884#issuecomment-877643951,,"Yep, game starts now. Thanks!",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,884,2021-07-10T13:06:19Z,2021-07-11T03:02:48Z,2021-07-19T09:54:10Z,MERGED,True,10,7,2,https://github.com/Gillou68310,Fix https://github.com/mupen64plus/mupen64plus-core/issues/883,1,['new dynarec'],https://github.com/mupen64plus/mupen64plus-core/pull/884,https://github.com/Gillou68310,4,https://github.com/mupen64plus/mupen64plus-core/pull/884#issuecomment-877661004,,Cool thanks for testing!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,884,2021-07-10T13:06:19Z,2021-07-11T03:02:48Z,2021-07-19T09:54:10Z,MERGED,True,10,7,2,https://github.com/Gillou68310,Fix https://github.com/mupen64plus/mupen64plus-core/issues/883,1,['new dynarec'],https://github.com/mupen64plus/mupen64plus-core/pull/884,https://github.com/loganmc10,5,https://github.com/mupen64plus/mupen64plus-core/pull/884#issuecomment-881510972,,"I received a report that Indiana Jones is freezing using the new dynarec (and wasn't before): m64p/m64p#202 Sorry I haven't had a chance to test yet, but this is the only change to the new dynarec that could have caused it",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,884,2021-07-10T13:06:19Z,2021-07-11T03:02:48Z,2021-07-19T09:54:10Z,MERGED,True,10,7,2,https://github.com/Gillou68310,Fix https://github.com/mupen64plus/mupen64plus-core/issues/883,1,['new dynarec'],https://github.com/mupen64plus/mupen64plus-core/pull/884,https://github.com/Jj0YzL5nvJ,6,https://github.com/mupen64plus/mupen64plus-core/pull/884#issuecomment-881753253,,I tested and can ratify Logan's suspicions.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,887,2021-07-19T10:14:05Z,2021-07-19T12:36:42Z,2021-07-27T08:46:34Z,MERGED,True,1,1,1,https://github.com/Gillou68310,Fix https://github.com/mupen64plus/mupen64plus-core/issues/886,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/887,https://github.com/Gillou68310,1,https://github.com/mupen64plus/mupen64plus-core/pull/887,,,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,887,2021-07-19T10:14:05Z,2021-07-19T12:36:42Z,2021-07-27T08:46:34Z,MERGED,True,1,1,1,https://github.com/Gillou68310,Fix https://github.com/mupen64plus/mupen64plus-core/issues/886,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/887,https://github.com/fzurita,2,https://github.com/mupen64plus/mupen64plus-core/pull/887#issuecomment-882470554,,"I tested Road Rush 64 and it works. I tested Indiana jones and didn't see any issues either, but I didn't have the original indiana jones issue described in #886 .",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,887,2021-07-19T10:14:05Z,2021-07-19T12:36:42Z,2021-07-27T08:46:34Z,MERGED,True,1,1,1,https://github.com/Gillou68310,Fix https://github.com/mupen64plus/mupen64plus-core/issues/886,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/887,https://github.com/fzurita,3,https://github.com/mupen64plus/mupen64plus-core/pull/887#issuecomment-882472270,,"Actually, I tested Indiana Jones before this fix and it's not working, so this fix does take care of that.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,887,2021-07-19T10:14:05Z,2021-07-19T12:36:42Z,2021-07-27T08:46:34Z,MERGED,True,1,1,1,https://github.com/Gillou68310,Fix https://github.com/mupen64plus/mupen64plus-core/issues/886,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/887,https://github.com/Narann,4,https://github.com/mupen64plus/mupen64plus-core/pull/887#issuecomment-882512547,,Thanks all!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,887,2021-07-19T10:14:05Z,2021-07-19T12:36:42Z,2021-07-27T08:46:34Z,MERGED,True,1,1,1,https://github.com/Gillou68310,Fix https://github.com/mupen64plus/mupen64plus-core/issues/886,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/887,https://github.com/thekovic,5,https://github.com/mupen64plus/mupen64plus-core/pull/887#issuecomment-882560447,,I tested Indiana Jones and I can confirm the issue is fixed,True,{'THUMBS_UP': ['https://github.com/Narann']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,890,2021-07-27T13:40:29Z,2021-07-27T16:03:22Z,2021-07-27T16:03:23Z,MERGED,True,36,14,2,https://github.com/Gillou68310,Fix https://github.com/mupen64plus/mupen64plus-core/issues/889,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/890,https://github.com/Gillou68310,1,https://github.com/mupen64plus/mupen64plus-core/pull/890,"@loganmc10 This is basically a no brain fix. The whole function is unreadable and need a major refactoring. I'm not even sure all cases are correctly handled right now...
Anyway this should do it for the time being.
The issue was a missing pop register, leading to stack growing indefinitely.","@loganmc10 This is basically a no brain fix. The whole function is unreadable and need a major refactoring. I'm not even sure all cases are correctly handled right now...
Anyway this should do it for the time being.
The issue was a missing pop register, leading to stack growing indefinitely.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,890,2021-07-27T13:40:29Z,2021-07-27T16:03:22Z,2021-07-27T16:03:23Z,MERGED,True,36,14,2,https://github.com/Gillou68310,Fix https://github.com/mupen64plus/mupen64plus-core/issues/889,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/890,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/890#issuecomment-887616339,"@loganmc10 This is basically a no brain fix. The whole function is unreadable and need a major refactoring. I'm not even sure all cases are correctly handled right now...
Anyway this should do it for the time being.
The issue was a missing pop register, leading to stack growing indefinitely.","The whole function is unreadable and need a major refactoring

This describes the entire new dynarec to me :)
LGTM",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,893,2021-08-27T11:18:57Z,2021-09-07T04:49:22Z,2021-09-07T04:49:22Z,MERGED,True,17,3,2,https://github.com/Rosalie241,Add KEYBINDINGS=0 option to Makefile,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/893,https://github.com/Rosalie241,1,https://github.com/mupen64plus/mupen64plus-core/pull/893,This adds an option to allow a front-end to ship a mupen64plus build without any keybindings.,This adds an option to allow a front-end to ship a mupen64plus build without any keybindings.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,893,2021-08-27T11:18:57Z,2021-09-07T04:49:22Z,2021-09-07T04:49:22Z,MERGED,True,17,3,2,https://github.com/Rosalie241,Add KEYBINDINGS=0 option to Makefile,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/893,https://github.com/Jj0YzL5nvJ,2,https://github.com/mupen64plus/mupen64plus-core/pull/893#issuecomment-907636600,This adds an option to allow a front-end to ship a mupen64plus build without any keybindings.,"Mupen64Plus definitely needs an option to be used in ""slave mode"" or ""custom script injector mode"".",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,898,2021-09-11T09:22:10Z,2021-09-14T22:02:55Z,2021-09-14T22:02:55Z,MERGED,True,7,0,1,https://github.com/archanox,Add RISC-V Support,1,['compilation'],https://github.com/mupen64plus/mupen64plus-core/pull/898,https://github.com/archanox,1,https://github.com/mupen64plus/mupen64plus-core/pull/898,Resolves #897 for mupen64plus-core,Resolves #897 for mupen64plus-core,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,898,2021-09-11T09:22:10Z,2021-09-14T22:02:55Z,2021-09-14T22:02:55Z,MERGED,True,7,0,1,https://github.com/archanox,Add RISC-V Support,1,['compilation'],https://github.com/mupen64plus/mupen64plus-core/pull/898,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/898#issuecomment-917411584,Resolves #897 for mupen64plus-core,"Looks good to me, but I would love to know how does it run?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,898,2021-09-11T09:22:10Z,2021-09-14T22:02:55Z,2021-09-14T22:02:55Z,MERGED,True,7,0,1,https://github.com/archanox,Add RISC-V Support,1,['compilation'],https://github.com/mupen64plus/mupen64plus-core/pull/898,https://github.com/archanox,3,https://github.com/mupen64plus/mupen64plus-core/pull/898#issuecomment-917536986,Resolves #897 for mupen64plus-core,"Without a dynarec, not well. But I'll put a video capture up hopefully today.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,898,2021-09-11T09:22:10Z,2021-09-14T22:02:55Z,2021-09-14T22:02:55Z,MERGED,True,7,0,1,https://github.com/archanox,Add RISC-V Support,1,['compilation'],https://github.com/mupen64plus/mupen64plus-core/pull/898,https://github.com/archanox,4,https://github.com/mupen64plus/mupen64plus-core/pull/898#issuecomment-919027612,Resolves #897 for mupen64plus-core,"Looks good to me, but I would love to know how does it run?

https://youtu.be/5vn0IyB2xqM
Judge for yourself, but I wouldn't deem this very playable with the cached interpreter. But the good news is that the port from MIPS to RISC-V dynarec should be relatively straight forward.",True,{'HEART': ['https://github.com/Narann']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,898,2021-09-11T09:22:10Z,2021-09-14T22:02:55Z,2021-09-14T22:02:55Z,MERGED,True,7,0,1,https://github.com/archanox,Add RISC-V Support,1,['compilation'],https://github.com/mupen64plus/mupen64plus-core/pull/898,https://github.com/Narann,5,https://github.com/mupen64plus/mupen64plus-core/pull/898#issuecomment-919544283,Resolves #897 for mupen64plus-core,Thanks for the video! :),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,899,2021-09-18T11:52:52Z,2021-09-18T18:57:55Z,2021-09-18T18:57:55Z,MERGED,True,12,0,1,https://github.com/Rosalie241,Add NO_KEYBINDINGS for joy mappings,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/899,https://github.com/Rosalie241,1,https://github.com/mupen64plus/mupen64plus-core/pull/899,I forgot to do this in my previous PR.,I forgot to do this in my previous PR.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,901,2021-09-19T21:23:25Z,2021-09-23T02:40:49Z,2021-09-23T02:40:49Z,MERGED,True,10,0,1,https://github.com/loganmc10,Add SmashRemix1.0.0/1.0.1,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/901,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/901,"Add INI entry for Smash Remix 1.0.0 (https://github.com/JSsixtyfour/smashremix/releases/tag/1.0.0)
CRC and MD5 were taken from the README in the release","Add INI entry for Smash Remix 1.0.0 (https://github.com/JSsixtyfour/smashremix/releases/tag/1.0.0)
CRC and MD5 were taken from the README in the release",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,906,2021-10-23T11:59:16Z,2021-10-23T16:27:08Z,2021-10-23T16:27:21Z,CLOSED,False,896,1,3,https://github.com/Rosalie241,Add InternalName to ROM database,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/906,https://github.com/Rosalie241,1,https://github.com/mupen64plus/mupen64plus-core/pull/906,"When you have a patched ROM, generally mupen64plus won't know which ROM it is so the good name and rom settings won't be applied, to solve this problem this PR adds the InternalName entry to the rom database which allows unknown roms to be detected using the internal ROM name as a last resort.","When you have a patched ROM, generally mupen64plus won't know which ROM it is so the good name and rom settings won't be applied, to solve this problem this PR adds the InternalName entry to the rom database which allows unknown roms to be detected using the internal ROM name as a last resort.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,906,2021-10-23T11:59:16Z,2021-10-23T16:27:08Z,2021-10-23T16:27:21Z,CLOSED,False,896,1,3,https://github.com/Rosalie241,Add InternalName to ROM database,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/906,https://github.com/Rosalie241,2,https://github.com/mupen64plus/mupen64plus-core/pull/906#issuecomment-950176868,"When you have a patched ROM, generally mupen64plus won't know which ROM it is so the good name and rom settings won't be applied, to solve this problem this PR adds the InternalName entry to the rom database which allows unknown roms to be detected using the internal ROM name as a last resort.","After thinking about it more, I don't think this'd work very well because the goodname will be wrong, closing.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,908,2021-11-04T01:18:20Z,2021-11-22T22:27:54Z,2021-11-22T22:27:55Z,CLOSED,False,0,0,0,https://github.com/keegandent,Native Apple Silicon (darwin-arm64) Support,0,[],https://github.com/mupen64plus/mupen64plus-core/pull/908,https://github.com/keegandent,1,https://github.com/mupen64plus/mupen64plus-core/pull/908,"I made some basic switches in the Makefile so now it's possible to build and run on macOS without Rosetta 2.
Without knowing maintainer plans, I have it display a warning that arm64 (not aarch64) is not officially supported. If project leadership wishes to officially support this configuration, recommended as this is Apple's architecture going forward, we can remove the warning.
Currently the linkage_arm64.S file cannot be compiled because real GCC is not yet officially supported on darwin-arm64. The gcc used to build on darwin-arm64 uses the LLVM behind the scenes. I can't be more descriptive than that without more guidance, as I am no compiler expert.
First PR for a community project, constructive feedback is much appreciated.","I made some basic switches in the Makefile so now it's possible to build and run on macOS without Rosetta 2.
Without knowing maintainer plans, I have it display a warning that arm64 (not aarch64) is not officially supported. If project leadership wishes to officially support this configuration, recommended as this is Apple's architecture going forward, we can remove the warning.
Currently the linkage_arm64.S file cannot be compiled because real GCC is not yet officially supported on darwin-arm64. The gcc used to build on darwin-arm64 uses the LLVM behind the scenes. I can't be more descriptive than that without more guidance, as I am no compiler expert.
First PR for a community project, constructive feedback is much appreciated.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,908,2021-11-04T01:18:20Z,2021-11-22T22:27:54Z,2021-11-22T22:27:55Z,CLOSED,False,0,0,0,https://github.com/keegandent,Native Apple Silicon (darwin-arm64) Support,0,[],https://github.com/mupen64plus/mupen64plus-core/pull/908,https://github.com/keegandent,2,https://github.com/mupen64plus/mupen64plus-core/pull/908#issuecomment-960357436,"I made some basic switches in the Makefile so now it's possible to build and run on macOS without Rosetta 2.
Without knowing maintainer plans, I have it display a warning that arm64 (not aarch64) is not officially supported. If project leadership wishes to officially support this configuration, recommended as this is Apple's architecture going forward, we can remove the warning.
Currently the linkage_arm64.S file cannot be compiled because real GCC is not yet officially supported on darwin-arm64. The gcc used to build on darwin-arm64 uses the LLVM behind the scenes. I can't be more descriptive than that without more guidance, as I am no compiler expert.
First PR for a community project, constructive feedback is much appreciated.","Oh, I didn't implement any packaging code for binary releases. I did build the entire mupen64plus from source, but I would need some help figuring out how to add this configuration to the deliverables.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,908,2021-11-04T01:18:20Z,2021-11-22T22:27:54Z,2021-11-22T22:27:55Z,CLOSED,False,0,0,0,https://github.com/keegandent,Native Apple Silicon (darwin-arm64) Support,0,[],https://github.com/mupen64plus/mupen64plus-core/pull/908,https://github.com/keegandent,3,https://github.com/mupen64plus/mupen64plus-core/pull/908#issuecomment-969308508,"I made some basic switches in the Makefile so now it's possible to build and run on macOS without Rosetta 2.
Without knowing maintainer plans, I have it display a warning that arm64 (not aarch64) is not officially supported. If project leadership wishes to officially support this configuration, recommended as this is Apple's architecture going forward, we can remove the warning.
Currently the linkage_arm64.S file cannot be compiled because real GCC is not yet officially supported on darwin-arm64. The gcc used to build on darwin-arm64 uses the LLVM behind the scenes. I can't be more descriptive than that without more guidance, as I am no compiler expert.
First PR for a community project, constructive feedback is much appreciated.",Anything else I need to do to get this merged?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,908,2021-11-04T01:18:20Z,2021-11-22T22:27:54Z,2021-11-22T22:27:55Z,CLOSED,False,0,0,0,https://github.com/keegandent,Native Apple Silicon (darwin-arm64) Support,0,[],https://github.com/mupen64plus/mupen64plus-core/pull/908,https://github.com/Jj0YzL5nvJ,4,https://github.com/mupen64plus/mupen64plus-core/pull/908#issuecomment-969389723,"I made some basic switches in the Makefile so now it's possible to build and run on macOS without Rosetta 2.
Without knowing maintainer plans, I have it display a warning that arm64 (not aarch64) is not officially supported. If project leadership wishes to officially support this configuration, recommended as this is Apple's architecture going forward, we can remove the warning.
Currently the linkage_arm64.S file cannot be compiled because real GCC is not yet officially supported on darwin-arm64. The gcc used to build on darwin-arm64 uses the LLVM behind the scenes. I can't be more descriptive than that without more guidance, as I am no compiler expert.
First PR for a community project, constructive feedback is much appreciated.","Squash to a single commit
Be patient",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,909,2021-11-11T22:04:26Z,2021-11-17T04:24:35Z,2021-11-17T04:24:35Z,MERGED,True,16,4,2,https://github.com/Rosalie241,Fix IS Viewer crash,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/909,https://github.com/Rosalie241,1,https://github.com/mupen64plus/mupen64plus-core/pull/909,Fixes a segfault in The Missing Link when entering a door.,Fixes a segfault in The Missing Link when entering a door.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,909,2021-11-11T22:04:26Z,2021-11-17T04:24:35Z,2021-11-17T04:24:35Z,MERGED,True,16,4,2,https://github.com/Rosalie241,Fix IS Viewer crash,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/909,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/909#issuecomment-966675902,Fixes a segfault in The Missing Link when entering a door.,I think it would be better to fix the logic behind buffer_pos if that is wrong,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,909,2021-11-11T22:04:26Z,2021-11-17T04:24:35Z,2021-11-17T04:24:35Z,MERGED,True,16,4,2,https://github.com/Rosalie241,Fix IS Viewer crash,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/909,https://github.com/Rosalie241,3,https://github.com/mupen64plus/mupen64plus-core/pull/909#issuecomment-966682371,Fixes a segfault in The Missing Link when entering a door.,"I think it would be better to fix the logic behind buffer_pos if that is wrong

Will you do that then? I'm unfamiliar with this code and this seemed like the easiest fix.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,909,2021-11-11T22:04:26Z,2021-11-17T04:24:35Z,2021-11-17T04:24:35Z,MERGED,True,16,4,2,https://github.com/Rosalie241,Fix IS Viewer crash,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/909,https://github.com/loganmc10,4,https://github.com/mupen64plus/mupen64plus-core/pull/909#issuecomment-967172799,Fixes a segfault in The Missing Link when entering a door.,"I'm guessing the size of is_viewer->output_buffer just needs to be increased. The current size (0x200) was taken from CEN64:
https://github.com/n64dev/cen64/blob/d6b5b043956af205d5f6d28eb321ca796adfa021/pi/is_viewer.c#L7-L8
and their code says that size was arbitrarily chosen, I would just see what the value of is_viewer->buffer_pos is when the crash occurs, and increase the size of is_viewer->output_buffer accordingly",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,909,2021-11-11T22:04:26Z,2021-11-17T04:24:35Z,2021-11-17T04:24:35Z,MERGED,True,16,4,2,https://github.com/Rosalie241,Fix IS Viewer crash,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/909,https://github.com/Rosalie241,5,https://github.com/mupen64plus/mupen64plus-core/pull/909#issuecomment-967223806,Fixes a segfault in The Missing Link when entering a door.,"I'm guessing the size of is_viewer->output_buffer just needs to be increased. The current size (0x200) was taken from CEN64:
https://github.com/n64dev/cen64/blob/d6b5b043956af205d5f6d28eb321ca796adfa021/pi/is_viewer.c#L7-L8
and their code says that size was arbitrarily chosen, I would just see what the value of is_viewer->buffer_pos is when the crash occurs, and increase the size of is_viewer->output_buffer accordingly

I added some debug logging and well:
buffer_pos = 7166750

This happens because if you look at the previous lines
memcpy(&is_viewer->output_buffer[is_viewer->buffer_pos], &is_viewer->data[0x20], word);

this overflows and changes the buffer_pos variable (because it's an array in a struct, buffer_pos is at most 636 in this memcpy), on CEN64 it also overflows because of the static buffer size (buffer_pos is 636 on CEN64), but on CEN64 it's allocated with calloc, so it doesn't push into the buffer_pos variable and doesn't crash there (though it also overflows there).
I'll modify this PR to change the code to make use of malloc/realloc and never have this happen again.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,909,2021-11-11T22:04:26Z,2021-11-17T04:24:35Z,2021-11-17T04:24:35Z,MERGED,True,16,4,2,https://github.com/Rosalie241,Fix IS Viewer crash,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/909,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/909#issuecomment-967226880,Fixes a segfault in The Missing Link when entering a door.,"Thats fine, you could probably also just change the if statement:
if (word > 0)
        {

to something like
if (word > 0 && is_viewer->buffer_pos < 0x200 - word)
        {

and maybe add an else that would emit a DebugMessage telling you you would overflow the buffer. Then it's never going to try to memcpy into a bad address space",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,909,2021-11-11T22:04:26Z,2021-11-17T04:24:35Z,2021-11-17T04:24:35Z,MERGED,True,16,4,2,https://github.com/Rosalie241,Fix IS Viewer crash,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/909,https://github.com/Rosalie241,7,https://github.com/mupen64plus/mupen64plus-core/pull/909#issuecomment-967275061,Fixes a segfault in The Missing Link when entering a door.,"Thats fine, you could probably also just change the if statement:
if (word > 0)
        {

to something like
if (word > 0 && is_viewer->buffer_pos < 0x200 - word)
        {

and maybe add an else that would emit a DebugMessage telling you you would overflow the buffer. Then it's never going to try to memcpy into a bad address space

I've updated the PR to dynamically realloc if needed instead, which is a much cleaner solution I think.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,909,2021-11-11T22:04:26Z,2021-11-17T04:24:35Z,2021-11-17T04:24:35Z,MERGED,True,16,4,2,https://github.com/Rosalie241,Fix IS Viewer crash,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/909,https://github.com/loganmc10,8,https://github.com/mupen64plus/mupen64plus-core/pull/909#issuecomment-967278785,Fixes a segfault in The Missing Link when entering a door.,"if (is_viewer->buffer_pos + word >= is_viewer->buffer_len)
            {
                is_viewer->buffer_len += IS_CHUNK_SZ;
                is_viewer->output_buffer = realloc(is_viewer->output_buffer, is_viewer->buffer_len);

How is this guaranteed to solve the problem though? What if buffer_len is still too small? IS_CHUNK_SZ is hardcoded to 0x200
This is such a rarely used feature, I would just figure out how big the buffer needs to be for A Missing Link and increase it from 0x200 to whatever it needs to be.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,909,2021-11-11T22:04:26Z,2021-11-17T04:24:35Z,2021-11-17T04:24:35Z,MERGED,True,16,4,2,https://github.com/Rosalie241,Fix IS Viewer crash,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/909,https://github.com/Rosalie241,9,https://github.com/mupen64plus/mupen64plus-core/pull/909#issuecomment-967285075,Fixes a segfault in The Missing Link when entering a door.,"if (is_viewer->buffer_pos + word >= is_viewer->buffer_len)
            {
                is_viewer->buffer_len += IS_CHUNK_SZ;
                is_viewer->output_buffer = realloc(is_viewer->output_buffer, is_viewer->buffer_len);

How is this guaranteed to solve the problem though? What if buffer_len is still too small? IS_CHUNK_SZ is hardcoded to 0x200

fixed it in the latest push.

This is such a rarely used feature, I would just figure out how big the buffer needs to be for A Missing Link and increase it from 0x200 to whatever it needs to be.

but then in the future we might have the same problem again, I dislike a band-aid solution so I'd rather have a permanent solution that'll keep on working.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,909,2021-11-11T22:04:26Z,2021-11-17T04:24:35Z,2021-11-17T04:24:35Z,MERGED,True,16,4,2,https://github.com/Rosalie241,Fix IS Viewer crash,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/909,https://github.com/loganmc10,10,https://github.com/mupen64plus/mupen64plus-core/pull/909#issuecomment-967402104,Fixes a segfault in The Missing Link when entering a door.,"Given that the IS viewer address space size is 0xfff:

  
    
      mupen64plus-core/src/device/device.c
    
    
         Line 154
      in
      db0f736
    
  
  
    

        
          
           { A(MM_IS_VIEWER, 0xfff), M64P_MEM_NOTHING, { &dev->is, RW(is_viewer) } }, 
        
    
  

 it probably shouldn't be able to write outside that.
I never tried A Missing Link, so I don't know how much data it tries to write, but I'd be surprised if it was more than 0x1000. I assume it should be safe to just set the output buffer size to 0x1000. If it actually needed more than that, then we've got the address space mapping wrong for the IS Viewer and that should be fixed as well.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,909,2021-11-11T22:04:26Z,2021-11-17T04:24:35Z,2021-11-17T04:24:35Z,MERGED,True,16,4,2,https://github.com/Rosalie241,Fix IS Viewer crash,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/909,https://github.com/Rosalie241,11,https://github.com/mupen64plus/mupen64plus-core/pull/909#issuecomment-967544189,Fixes a segfault in The Missing Link when entering a door.,"Good point, I'll do that tomorrow-ish then, thank you",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,909,2021-11-11T22:04:26Z,2021-11-17T04:24:35Z,2021-11-17T04:24:35Z,MERGED,True,16,4,2,https://github.com/Rosalie241,Fix IS Viewer crash,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/909,https://github.com/Rosalie241,12,https://github.com/mupen64plus/mupen64plus-core/pull/909#issuecomment-968053868,Fixes a segfault in The Missing Link when entering a door.,"Okay, pushed, the patch is a lot more simple right now, though I added an overflow check, and when it'll overflow, it'll reset the buffer & buffer_pos and show a warning.",True,"{'THUMBS_UP': ['https://github.com/loganmc10', 'https://github.com/i30817']}"
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,910,2021-11-22T22:49:32Z,2022-04-12T03:06:28Z,2022-04-12T03:06:28Z,MERGED,True,25,15,1,https://github.com/keegandent,Native Apple Silicon (darwin-arm64) Support,1,['compilation'],https://github.com/mupen64plus/mupen64plus-core/pull/910,https://github.com/keegandent,1,https://github.com/mupen64plus/mupen64plus-core/pull/910,"Re-do of #908 with squashed commits.
I made some basic switches in the Makefile so now it's possible to build and run on macOS without Rosetta 2.
Without knowing maintainer plans, I have it display a warning that arm64 (not aarch64) is not officially supported. If project leadership wishes to officially support this configuration, recommended as this is Apple's architecture going forward, we can remove the warning.
I made an effort to support assembly functionality for the new dynarec as part of #831, but it is either beyond my abilities or not feasible at this time. Regardless, the emulator passes the tests without this element, so I am presuming there is no drawback to releasing with NO_ASM for darwin-arm64.","Re-do of #908 with squashed commits.
I made some basic switches in the Makefile so now it's possible to build and run on macOS without Rosetta 2.
Without knowing maintainer plans, I have it display a warning that arm64 (not aarch64) is not officially supported. If project leadership wishes to officially support this configuration, recommended as this is Apple's architecture going forward, we can remove the warning.
I made an effort to support assembly functionality for the new dynarec as part of #831, but it is either beyond my abilities or not feasible at this time. Regardless, the emulator passes the tests without this element, so I am presuming there is no drawback to releasing with NO_ASM for darwin-arm64.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,910,2021-11-22T22:49:32Z,2022-04-12T03:06:28Z,2022-04-12T03:06:28Z,MERGED,True,25,15,1,https://github.com/keegandent,Native Apple Silicon (darwin-arm64) Support,1,['compilation'],https://github.com/mupen64plus/mupen64plus-core/pull/910,https://github.com/keegandent,2,https://github.com/mupen64plus/mupen64plus-core/pull/910#issuecomment-993924815,"Re-do of #908 with squashed commits.
I made some basic switches in the Makefile so now it's possible to build and run on macOS without Rosetta 2.
Without knowing maintainer plans, I have it display a warning that arm64 (not aarch64) is not officially supported. If project leadership wishes to officially support this configuration, recommended as this is Apple's architecture going forward, we can remove the warning.
I made an effort to support assembly functionality for the new dynarec as part of #831, but it is either beyond my abilities or not feasible at this time. Regardless, the emulator passes the tests without this element, so I am presuming there is no drawback to releasing with NO_ASM for darwin-arm64.","I know the commit message on this one is pretty bad, does the maintainer doing the merge have the option of changing it upon approval?
Should I be including any artifacts to show these changes perform as advertised?",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,910,2021-11-22T22:49:32Z,2022-04-12T03:06:28Z,2022-04-12T03:06:28Z,MERGED,True,25,15,1,https://github.com/keegandent,Native Apple Silicon (darwin-arm64) Support,1,['compilation'],https://github.com/mupen64plus/mupen64plus-core/pull/910,https://github.com/Jj0YzL5nvJ,3,https://github.com/mupen64plus/mupen64plus-core/pull/910#issuecomment-994281366,"Re-do of #908 with squashed commits.
I made some basic switches in the Makefile so now it's possible to build and run on macOS without Rosetta 2.
Without knowing maintainer plans, I have it display a warning that arm64 (not aarch64) is not officially supported. If project leadership wishes to officially support this configuration, recommended as this is Apple's architecture going forward, we can remove the warning.
I made an effort to support assembly functionality for the new dynarec as part of #831, but it is either beyond my abilities or not feasible at this time. Regardless, the emulator passes the tests without this element, so I am presuming there is no drawback to releasing with NO_ASM for darwin-arm64.","git clone https://github.com/keegandent/mupen64plus-core.git
wget -O apple-silicon.patch https://github.com/keegandent/mupen64plus-core/commit/d57d9029100b7a4b44c4d850e3902dae04def00a.patch
cd mupen64plus-core/
git remote add upstream https://github.com/mupen64plus/mupen64plus-core.git
git fetch upstream
git fetch --tags upstream
git checkout apple-silicon
git reset --hard 57828d930280554c7400bb2bcf1e46c7f2ee8373
git merge upstream/master
git apply ../apple-silicon.patch
git add projects/unix/Makefile
git commit -m ""Adding Apple Silicon support...""
git push --force origin apple-silicon

This code will 'rebase' your 'pull' to mupen64plus-core:master and re-add your changes as Adding Apple Silicon support..., you can change the message as you see fit.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,910,2021-11-22T22:49:32Z,2022-04-12T03:06:28Z,2022-04-12T03:06:28Z,MERGED,True,25,15,1,https://github.com/keegandent,Native Apple Silicon (darwin-arm64) Support,1,['compilation'],https://github.com/mupen64plus/mupen64plus-core/pull/910,https://github.com/keegandent,4,https://github.com/mupen64plus/mupen64plus-core/pull/910#issuecomment-1007760084,"Re-do of #908 with squashed commits.
I made some basic switches in the Makefile so now it's possible to build and run on macOS without Rosetta 2.
Without knowing maintainer plans, I have it display a warning that arm64 (not aarch64) is not officially supported. If project leadership wishes to officially support this configuration, recommended as this is Apple's architecture going forward, we can remove the warning.
I made an effort to support assembly functionality for the new dynarec as part of #831, but it is either beyond my abilities or not feasible at this time. Regardless, the emulator passes the tests without this element, so I am presuming there is no drawback to releasing with NO_ASM for darwin-arm64.",Thank you; the commit message is less terrible now. Please let me know if there are any artifacts that should be provided as evidence. I would be happy to create and attach them.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,910,2021-11-22T22:49:32Z,2022-04-12T03:06:28Z,2022-04-12T03:06:28Z,MERGED,True,25,15,1,https://github.com/keegandent,Native Apple Silicon (darwin-arm64) Support,1,['compilation'],https://github.com/mupen64plus/mupen64plus-core/pull/910,https://github.com/keegandent,5,https://github.com/mupen64plus/mupen64plus-core/pull/910#issuecomment-1086899635,"Re-do of #908 with squashed commits.
I made some basic switches in the Makefile so now it's possible to build and run on macOS without Rosetta 2.
Without knowing maintainer plans, I have it display a warning that arm64 (not aarch64) is not officially supported. If project leadership wishes to officially support this configuration, recommended as this is Apple's architecture going forward, we can remove the warning.
I made an effort to support assembly functionality for the new dynarec as part of #831, but it is either beyond my abilities or not feasible at this time. Regardless, the emulator passes the tests without this element, so I am presuming there is no drawback to releasing with NO_ASM for darwin-arm64.",Is there something else I need to provide before this can be merged?,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,910,2021-11-22T22:49:32Z,2022-04-12T03:06:28Z,2022-04-12T03:06:28Z,MERGED,True,25,15,1,https://github.com/keegandent,Native Apple Silicon (darwin-arm64) Support,1,['compilation'],https://github.com/mupen64plus/mupen64plus-core/pull/910,https://github.com/richard42,6,https://github.com/mupen64plus/mupen64plus-core/pull/910#issuecomment-1086904668,"Re-do of #908 with squashed commits.
I made some basic switches in the Makefile so now it's possible to build and run on macOS without Rosetta 2.
Without knowing maintainer plans, I have it display a warning that arm64 (not aarch64) is not officially supported. If project leadership wishes to officially support this configuration, recommended as this is Apple's architecture going forward, we can remove the warning.
I made an effort to support assembly functionality for the new dynarec as part of #831, but it is either beyond my abilities or not feasible at this time. Regardless, the emulator passes the tests without this element, so I am presuming there is no drawback to releasing with NO_ASM for darwin-arm64.",sorry it's been so long. I have a huge list of stuff to review for m64+ and this is actually at the top. I'll take a look after I get back from vacation in a week.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,911,2021-11-27T13:19:53Z,2021-11-30T16:04:34Z,2021-11-30T16:04:35Z,MERGED,True,5,0,1,https://github.com/Isotarge,Add Donkey Kong 64 - Tag Anywhere V5 (U),1,[],https://github.com/mupen64plus/mupen64plus-core/pull/911,https://github.com/Isotarge,1,https://github.com/mupen64plus/mupen64plus-core/pull/911,"Needs EEPROM 16K save type, see Isotarge/dk64-tag-anywhere#2","Needs EEPROM 16K save type, see Isotarge/dk64-tag-anywhere#2",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,912,2021-11-30T16:27:37Z,2022-04-12T04:01:48Z,2022-04-19T02:58:24Z,MERGED,True,303,3,2,https://github.com/Jj0YzL5nvJ,CI/CD: Implement GitHub Actions and public nightly builds,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/912,https://github.com/Jj0YzL5nvJ,1,https://github.com/mupen64plus/mupen64plus-core/pull/912,"You can see the changes taking effect from my repository in the ci-tests branch:
https://github.com/Jj0YzL5nvJ/mupen64plus-core/actions
https://github.com/Jj0YzL5nvJ/mupen64plus-core/releases","You can see the changes taking effect from my repository in the ci-tests branch:
https://github.com/Jj0YzL5nvJ/mupen64plus-core/actions
https://github.com/Jj0YzL5nvJ/mupen64plus-core/releases",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,912,2021-11-30T16:27:37Z,2022-04-12T04:01:48Z,2022-04-19T02:58:24Z,MERGED,True,303,3,2,https://github.com/Jj0YzL5nvJ,CI/CD: Implement GitHub Actions and public nightly builds,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/912,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/912#issuecomment-983534821,"You can see the changes taking effect from my repository in the ci-tests branch:
https://github.com/Jj0YzL5nvJ/mupen64plus-core/actions
https://github.com/Jj0YzL5nvJ/mupen64plus-core/releases","Thanks a lot for the hard work!
(I comment here for all other PRs)
Code looks OK to me. Here are my concerns, it's open to discussion and those would not prevent any merge :) :
I thinks we should follow original release name conventions.
mupen64plus-bundle-linux32-2.5.9.tar.gz 1.67 MB
mupen64plus-bundle-linux64-2.5.9.tar.gz 1.65 MB
mupen64plus-bundle-osx-2.5.9.zip 2.56 MB
mupen64plus-bundle-src-2.5.9.tar.gz 2.74 MB
mupen64plus-bundle-win32-2.5.9.zip 2.36 MB
mupen64plus-core-src-2.5.9.tar.gz 1.54 MB
mupen64plus-core-src-2.5.9.tar.gz.asc 

In your case this would mean:
mupen64plus-core-msvc-x64-g0c39f7f.zip
mupen64plus-core-msvc-x86-g0c39f7f.zip
mupen64plus-core-msys2-x64-g0c39f7f.zip
mupen64plus-core-msys2-x86-g0c39f7f.zip

I would also add few archive for potential distribution package managers because we could start to use your config for linux nightly built binaries:
mupen64plus-core-src-g0c39f7f.zip
mupen64plus-core-src-g0c39f7f.zip.asc

What do you think? Any advise @richard42 ?
Thanks a lot for the hard work, Windows binaries are often asked for and we never took the time to do a proper release.
Keep the good work!",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,912,2021-11-30T16:27:37Z,2022-04-12T04:01:48Z,2022-04-19T02:58:24Z,MERGED,True,303,3,2,https://github.com/Jj0YzL5nvJ,CI/CD: Implement GitHub Actions and public nightly builds,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/912,https://github.com/Jj0YzL5nvJ,3,https://github.com/mupen64plus/mupen64plus-core/pull/912#issuecomment-984321594,"You can see the changes taking effect from my repository in the ci-tests branch:
https://github.com/Jj0YzL5nvJ/mupen64plus-core/actions
https://github.com/Jj0YzL5nvJ/mupen64plus-core/releases","I'm fine with the naming convention part.
Regarding the distribution of useful binaries for Linux, a complete redesign will be necessary. Maybe generate an AppImage? In any case, that is out of my range of ability at the moment.
The distribution of signed source code from a tagged git commit is redundant in my opinion and I find its usefulness questionable. I have no idea how to use *.asc key files as checksum (only connections with secret/public keys). I think sha256 and sha512 would be useful for Windows binaries, better than nothing to say the least.
I will wait a while to see if more observations accumulate before introducing the corrections, in the meantime I will research how to incorporate the aforementioned checksums.",True,{'HEART': ['https://github.com/Narann']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,912,2021-11-30T16:27:37Z,2022-04-12T04:01:48Z,2022-04-19T02:58:24Z,MERGED,True,303,3,2,https://github.com/Jj0YzL5nvJ,CI/CD: Implement GitHub Actions and public nightly builds,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/912,https://github.com/Jj0YzL5nvJ,4,https://github.com/mupen64plus/mupen64plus-core/pull/912#issuecomment-985471295,"You can see the changes taking effect from my repository in the ci-tests branch:
https://github.com/Jj0YzL5nvJ/mupen64plus-core/actions
https://github.com/Jj0YzL5nvJ/mupen64plus-core/releases",Prototype... I have no idea why yt-dlp uses overcomplicated hashing code.,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,912,2021-11-30T16:27:37Z,2022-04-12T04:01:48Z,2022-04-19T02:58:24Z,MERGED,True,303,3,2,https://github.com/Jj0YzL5nvJ,CI/CD: Implement GitHub Actions and public nightly builds,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/912,https://github.com/Narann,5,https://github.com/mupen64plus/mupen64plus-core/pull/912#issuecomment-985583753,"You can see the changes taking effect from my repository in the ci-tests branch:
https://github.com/Jj0YzL5nvJ/mupen64plus-core/actions
https://github.com/Jj0YzL5nvJ/mupen64plus-core/releases","Thanks!
The hash should be to the end: mupen64plus-rsp-z64-ge4a135f-msys2-x86.zip -> mupen64plus-rsp-z64-msys2-x86-ge4a135f.zip",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,912,2021-11-30T16:27:37Z,2022-04-12T04:01:48Z,2022-04-19T02:58:24Z,MERGED,True,303,3,2,https://github.com/Jj0YzL5nvJ,CI/CD: Implement GitHub Actions and public nightly builds,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/912,https://github.com/Jj0YzL5nvJ,6,https://github.com/mupen64plus/mupen64plus-core/pull/912#issuecomment-985778606,"You can see the changes taking effect from my repository in the ci-tests branch:
https://github.com/Jj0YzL5nvJ/mupen64plus-core/actions
https://github.com/Jj0YzL5nvJ/mupen64plus-core/releases","Whoops, that went completely unnoticed =P
Check again.",True,{'HEART': ['https://github.com/Narann']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,919,2022-01-19T21:53:02Z,2022-04-12T06:04:32Z,2022-04-12T06:04:32Z,MERGED,True,351,44,5,https://github.com/bsmiles32,Generate unique mempaks ID when formatting them,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/919,https://github.com/bsmiles32,1,https://github.com/mupen64plus/mupen64plus-core/pull/919,"also better conform to expected factory formatted state
according to @bryc research
unique mempak ID is based on xoshiro256++ PRNG seeded with current
time. This should prove good enough for our purpose, while still being
simple to implement.
added endian aware serialization primitives (loosely modeled after http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2827.htm)
added xoshiro256++ PRNG functions","also better conform to expected factory formatted state
according to @bryc research
unique mempak ID is based on xoshiro256++ PRNG seeded with current
time. This should prove good enough for our purpose, while still being
simple to implement.
added endian aware serialization primitives (loosely modeled after http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2827.htm)
added xoshiro256++ PRNG functions",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,919,2022-01-19T21:53:02Z,2022-04-12T06:04:32Z,2022-04-12T06:04:32Z,MERGED,True,351,44,5,https://github.com/bsmiles32,Generate unique mempaks ID when formatting them,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/919,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/919#issuecomment-1017625560,"also better conform to expected factory formatted state
according to @bryc research
unique mempak ID is based on xoshiro256++ PRNG seeded with current
time. This should prove good enough for our purpose, while still being
simple to implement.
added endian aware serialization primitives (loosely modeled after http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2827.htm)
added xoshiro256++ PRNG functions","Code looks good to me. :)
What mempak ID are actually used for? Why should we emulate it?
Thanks in advance!",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,919,2022-01-19T21:53:02Z,2022-04-12T06:04:32Z,2022-04-12T06:04:32Z,MERGED,True,351,44,5,https://github.com/bsmiles32,Generate unique mempaks ID when formatting them,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/919,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/919#issuecomment-1017731577,"also better conform to expected factory formatted state
according to @bryc research
unique mempak ID is based on xoshiro256++ PRNG seeded with current
time. This should prove good enough for our purpose, while still being
simple to implement.
added endian aware serialization primitives (loosely modeled after http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2827.htm)
added xoshiro256++ PRNG functions","What is the reason for using xoshiro256++ instead of rand() for a random number? We already use rand() elsewhere in the code for random numbers (
  
    
      mupen64plus-core/src/device/r4300/interrupt.c
    
    
        Lines 119 to 123
      in
      6860d13
    
  
  
    

        
          
           #ifdef __MINGW32__ 
        

        
          
                   rand_s(&value); 
        

        
          
           #else 
        

        
          
                   value = rand(); 
        

        
          
           #endif 
        
    
  

). The seeding is done during r4300 init (
  
    
      mupen64plus-core/src/device/r4300/r4300_core.c
    
    
         Line 66
      in
      6860d13
    
  
  
    

        
          
           srand((unsigned int) time(NULL)); 
        
    
  

)",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,919,2022-01-19T21:53:02Z,2022-04-12T06:04:32Z,2022-04-12T06:04:32Z,MERGED,True,351,44,5,https://github.com/bsmiles32,Generate unique mempaks ID when formatting them,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/919,https://github.com/bsmiles32,4,https://github.com/mupen64plus/mupen64plus-core/pull/919#issuecomment-1018024808,"also better conform to expected factory formatted state
according to @bryc research
unique mempak ID is based on xoshiro256++ PRNG seeded with current
time. This should prove good enough for our purpose, while still being
simple to implement.
added endian aware serialization primitives (loosely modeled after http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2827.htm)
added xoshiro256++ PRNG functions","What mempak ID are actually used for? Why should we emulate it?

All mempaks when factory formatted are assigned a unique ID which is written (and backed up in many places) in mempak memory. This ID is useful for software to determine when switching between different paks if the newly plugged mempak is still the same as the last known memory pak.
It shouldn't really change anything in practice though, because current m64p logic doesn't allow to change between different mempaks while in game. (You can switch between mempak, rumblepak, transferpak, none, and back to original mempak).

What is the reason for using xoshiro256++ instead of rand() for a random number? We already use rand() elsewhere in the code for random numbers

I chose xoshiro256++ because it was fast, recent and easy to implement. It also has other advantages regarding reproducibility:

the algorithm is public / documented. vs implementation defined for rand / srand (can be different between MSVC and GLIBC for instance)
the algorithm doesn't rely on some global state (vs rand), so we can have different independent instances of xoshiro256++ in the same program. That could come handy if we need to add other sources of randomness without modifying the existing behavior (eg. for TAS).",True,{'HEART': ['https://github.com/Narann']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,919,2022-01-19T21:53:02Z,2022-04-12T06:04:32Z,2022-04-12T06:04:32Z,MERGED,True,351,44,5,https://github.com/bsmiles32,Generate unique mempaks ID when formatting them,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/919,https://github.com/bryc,5,https://github.com/mupen64plus/mupen64plus-core/pull/919#issuecomment-1018033850,"also better conform to expected factory formatted state
according to @bryc research
unique mempak ID is based on xoshiro256++ PRNG seeded with current
time. This should prove good enough for our purpose, while still being
simple to implement.
added endian aware serialization primitives (loosely modeled after http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2827.htm)
added xoshiro256++ PRNG functions","Just giving my two cents 😄

What mempak ID are actually used for?

When a user switches between controller paks on real hardware (physically remove and insert a different one), the checksum of the ID is checked to determine if a new pak was inserted. Some input plugins may allow pak swapping during emulation that can trigger this result.

Also, the ID would've been used to support bank sizes beyond 32 KiB, but it was never fully realized.

Why should we emulate it?

Less hacky. It better models real world conditions. Future-proofing. Creating the .MPK as if it were brand new and unused. Real paks have unique serial numbers preinstalled to them when they flash the chip data, including even third-party ones (InterAct specifically). See: Mempak Serial block list to see real dumps of the preinstalled serial data (ID refers to the whole 32-byte block. The first 24 bytes is the 'serial number' part of the ID struct).
When games do a 'repair' to a controller pak, a new serial is intentionally generated using a ""random"" value (technically the CP0 timer register value).


What is the reason for using xoshiro256++ instead of rand() for a random number? We already use rand() elsewhere in the code for random numbers

rand() is probably fine. xoshiro is high quality, but any PRNG should get the job done. The actual bottleneck is the final 16-bit checksum (both sum and isum are effectively just one 16-bit sum); and it should be sufficiently different each time. Generating a unique serial is intended to cause the checksum to be sufficiently different.
As mentioned before, actual games don't use random numbers. Even the preinstalled serials in official paks don't seem fully random (InterAct did use random numbers however). The library simply writes the current value of the CP0 timer (32-bit program counter), which isn't great, but is usually enough to make the checksum different. One homebrew utility does pak formatting this way:
  uint64_t sn =  C0_COUNT(); // some form of entropy, time(0) would've worked too
  for (i = 0; i < 24; i++) {
    // simple 64-bit generator with decent statistics
    sn ^= sn >> 27; sn *= 0x9E3779B97F4A7C55; sn ^= sn >> 33;  
    init_id_block[i] = sn; // set one byte AAT to the random output
  }",True,{'HEART': ['https://github.com/Narann']}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,919,2022-01-19T21:53:02Z,2022-04-12T06:04:32Z,2022-04-12T06:04:32Z,MERGED,True,351,44,5,https://github.com/bsmiles32,Generate unique mempaks ID when formatting them,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/919,https://github.com/loganmc10,6,https://github.com/mupen64plus/mupen64plus-core/pull/919#issuecomment-1018089229,"also better conform to expected factory formatted state
according to @bryc research
unique mempak ID is based on xoshiro256++ PRNG seeded with current
time. This should prove good enough for our purpose, while still being
simple to implement.
added endian aware serialization primitives (loosely modeled after http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2827.htm)
added xoshiro256++ PRNG functions","Personally, I'm more in favour of just using rand(), it would keep the code more simple, and seems like it would accomplish the same goal, but I'm fine with whatever, mupen64plus doesn't see a lot of development so I don't think we should be too picky about contributions if the author is happy with it.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,920,2022-01-24T14:41:18Z,2022-05-14T00:03:29Z,2022-05-14T00:03:29Z,MERGED,True,53,8,4,https://github.com/Rosalie241,Allow frontends to know what DD ROM region they should use,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/920,https://github.com/Rosalie241,1,https://github.com/mupen64plus/mupen64plus-core/pull/920,"This adds a function called set_dd_rom_region to the media loader, allowing frontends to easily switch 64DD ROM based on DD disk region.","This adds a function called set_dd_rom_region to the media loader, allowing frontends to easily switch 64DD ROM based on DD disk region.",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,922,2022-02-06T16:55:48Z,2022-02-07T08:38:13Z,2022-02-07T08:38:20Z,MERGED,True,1522,708,1,https://github.com/loganmc10,Update xxhash to 0.8.1,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/922,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/922,https://github.com/Cyan4973/xxHash/releases/tag/v0.8.1,https://github.com/Cyan4973/xxHash/releases/tag/v0.8.1,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,922,2022-02-06T16:55:48Z,2022-02-07T08:38:13Z,2022-02-07T08:38:20Z,MERGED,True,1522,708,1,https://github.com/loganmc10,Update xxhash to 0.8.1,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/922,https://github.com/Narann,2,https://github.com/mupen64plus/mupen64plus-core/pull/922#issuecomment-1031203963,https://github.com/Cyan4973/xxHash/releases/tag/v0.8.1,Thanks!,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,925,2022-02-11T00:17:47Z,2022-02-18T15:08:20Z,2022-02-18T15:08:20Z,MERGED,True,10,0,1,https://github.com/loganmc10,Entry for SmashRemix1.1.0,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/925,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/925,"https://github.com/JSsixtyfour/smashremix/releases/tag/1.1.0
CRC and MD5 taken from the README","https://github.com/JSsixtyfour/smashremix/releases/tag/1.1.0
CRC and MD5 taken from the README",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,925,2022-02-11T00:17:47Z,2022-02-18T15:08:20Z,2022-02-18T15:08:20Z,MERGED,True,10,0,1,https://github.com/loganmc10,Entry for SmashRemix1.1.0,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/925,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/925#issuecomment-1042558421,"https://github.com/JSsixtyfour/smashremix/releases/tag/1.1.0
CRC and MD5 taken from the README",@Narann,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,925,2022-02-11T00:17:47Z,2022-02-18T15:08:20Z,2022-02-18T15:08:20Z,MERGED,True,10,0,1,https://github.com/loganmc10,Entry for SmashRemix1.1.0,2,[],https://github.com/mupen64plus/mupen64plus-core/pull/925,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/925#issuecomment-1043522742,"https://github.com/JSsixtyfour/smashremix/releases/tag/1.1.0
CRC and MD5 taken from the README",Added an entry for 1.1.1 as well (https://github.com/JSsixtyfour/smashremix/releases/tag/1.1.1),True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,926,2022-02-13T16:01:38Z,2022-02-18T17:20:07Z,2022-02-18T17:20:07Z,MERGED,True,10,0,1,https://github.com/loganmc10,Add ROM entries for SM64 splitscreen hack,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/926,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/926,"I'm aware of 2 different ROMs for this hack, a beta that is still floating around, and the official release","I'm aware of 2 different ROMs for this hack, a beta that is still floating around, and the official release",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,926,2022-02-13T16:01:38Z,2022-02-18T17:20:07Z,2022-02-18T17:20:07Z,MERGED,True,10,0,1,https://github.com/loganmc10,Add ROM entries for SM64 splitscreen hack,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/926,https://github.com/loganmc10,2,https://github.com/mupen64plus/mupen64plus-core/pull/926#issuecomment-1038233948,"I'm aware of 2 different ROMs for this hack, a beta that is still floating around, and the official release","The reason for this is that these are popular ROMs on m64p netplay, the goodname is required for them to be announced properly:",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,926,2022-02-13T16:01:38Z,2022-02-18T17:20:07Z,2022-02-18T17:20:07Z,MERGED,True,10,0,1,https://github.com/loganmc10,Add ROM entries for SM64 splitscreen hack,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/926,https://github.com/loganmc10,3,https://github.com/mupen64plus/mupen64plus-core/pull/926#issuecomment-1044683679,"I'm aware of 2 different ROMs for this hack, a beta that is still floating around, and the official release",@Narann this should be safe to merge. I have copies of both these ROMs so I verified the MD5/CRC,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,929,2022-02-13T17:08:42Z,2022-02-14T08:20:12Z,2022-02-14T08:20:27Z,MERGED,True,1,0,1,https://github.com/loganmc10,CountPerOp=1 for Bottom of the 9th,1,['game specific'],https://github.com/mupen64plus/mupen64plus-core/pull/929,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/929,Fixes #927,Fixes #927,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,946,2022-04-12T13:53:42Z,2022-04-20T09:49:38Z,2022-04-20T09:49:39Z,MERGED,True,2,1,1,https://github.com/loganmc10,Use a predictable seed when using netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/946,https://github.com/loganmc10,1,https://github.com/mupen64plus/mupen64plus-core/pull/946,"I hadn't thought of this for the mempak PR, but I think there is a small possibility of netplay desyncs because of the randomized mempak IDs.
If the mempak save file already exists, it won't be a problem, because netplay will sync P1's mempak with the other players, but if no mempak save file exists, netplay will just let each player create their own file.
Because of this randomization, each mempak will be slightly different. I don't know if this would cause desyncs, because I can't say for sure if a game reads a mempak to create some RNG or something.
This PR uses a constant seed for generating the mempak ID when netplay is active.
@bsmiles32","I hadn't thought of this for the mempak PR, but I think there is a small possibility of netplay desyncs because of the randomized mempak IDs.
If the mempak save file already exists, it won't be a problem, because netplay will sync P1's mempak with the other players, but if no mempak save file exists, netplay will just let each player create their own file.
Because of this randomization, each mempak will be slightly different. I don't know if this would cause desyncs, because I can't say for sure if a game reads a mempak to create some RNG or something.
This PR uses a constant seed for generating the mempak ID when netplay is active.
@bsmiles32",True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,946,2022-04-12T13:53:42Z,2022-04-20T09:49:38Z,2022-04-20T09:49:39Z,MERGED,True,2,1,1,https://github.com/loganmc10,Use a predictable seed when using netplay,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/946,https://github.com/bsmiles32,2,https://github.com/mupen64plus/mupen64plus-core/pull/946#issuecomment-1102931356,"I hadn't thought of this for the mempak PR, but I think there is a small possibility of netplay desyncs because of the randomized mempak IDs.
If the mempak save file already exists, it won't be a problem, because netplay will sync P1's mempak with the other players, but if no mempak save file exists, netplay will just let each player create their own file.
Because of this randomization, each mempak will be slightly different. I don't know if this would cause desyncs, because I can't say for sure if a game reads a mempak to create some RNG or something.
This PR uses a constant seed for generating the mempak ID when netplay is active.
@bsmiles32",Forcing a known seed when in netplay (or TAS) is indeed valuable. LGTM,True,{}
mupen64plus/mupen64plus-core,https://github.com/mupen64plus/mupen64plus-core,954,2022-05-05T03:09:50Z,2022-05-14T01:27:47Z,2022-05-14T01:27:47Z,MERGED,True,7,3,1,https://github.com/ZachBacon,Add support for clang/mingw targets,1,[],https://github.com/mupen64plus/mupen64plus-core/pull/954,https://github.com/ZachBacon,1,https://github.com/mupen64plus/mupen64plus-core/pull/954,"clang built mingw doesn't support -Bsymbolic
or version scripts unfortunetly
Signed-off-by: Zach Bacon zachbacon@vba-m.com","clang built mingw doesn't support -Bsymbolic
or version scripts unfortunetly
Signed-off-by: Zach Bacon zachbacon@vba-m.com",True,{}
