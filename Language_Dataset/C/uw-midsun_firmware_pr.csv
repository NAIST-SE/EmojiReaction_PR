uw-midsun/firmware,https://github.com/uw-midsun/firmware,1,2016-10-02T21:28:47Z,2016-10-09T17:21:46Z,2016-10-10T17:47:24Z,CLOSED,False,172,103,14,https://github.com/ckitagawa,Cleanup to Makefile and revised library handling,7,['enhancement'],https://github.com/uw-midsun/firmware/pull/1,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/1,"Cleaned up Makefile components, created standardized rules.mk template for projects and edited the Makefile to accommodate. Removed a .vscode folder and added .vscode to the .gitignore. Still needs functionality to add a project with a template main.c and rules.mk file on demand.","Cleaned up Makefile components, created standardized rules.mk template for projects and edited the Makefile to accommodate. Removed a .vscode folder and added .vscode to the .gitignore. Still needs functionality to add a project with a template main.c and rules.mk file on demand.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,1,2016-10-02T21:28:47Z,2016-10-09T17:21:46Z,2016-10-10T17:47:24Z,CLOSED,False,172,103,14,https://github.com/ckitagawa,Cleanup to Makefile and revised library handling,7,['enhancement'],https://github.com/uw-midsun/firmware/pull/1,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/1#issuecomment-251008726,"Cleaned up Makefile components, created standardized rules.mk template for projects and edited the Makefile to accommodate. Removed a .vscode folder and added .vscode to the .gitignore. Still needs functionality to add a project with a template main.c and rules.mk file on demand.",Revised the file structure such that each library needs a rules.mk file to build the library. Each device also needs a device_congfig.mk to set up the build rules for the project. Each project needs a rules.mk file that specifies its dependencies. This could be extended to handle headers as well.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,1,2016-10-02T21:28:47Z,2016-10-09T17:21:46Z,2016-10-10T17:47:24Z,CLOSED,False,172,103,14,https://github.com/ckitagawa,Cleanup to Makefile and revised library handling,7,['enhancement'],https://github.com/uw-midsun/firmware/pull/1,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/1#issuecomment-252492621,"Cleaned up Makefile components, created standardized rules.mk template for projects and edited the Makefile to accommodate. Removed a .vscode folder and added .vscode to the .gitignore. Still needs functionality to add a project with a template main.c and rules.mk file on demand.",@ckitagawa - Is it okay if I close this PR and open my own?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,2,2016-10-09T17:42:34Z,2016-10-10T17:45:55Z,2016-10-10T17:46:50Z,MERGED,True,195,115,16,https://github.com/tituschow,Build system cleanup,10,['enhancement'],https://github.com/uw-midsun/firmware/pull/2,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/2,"Adds support for library dependencies, multiple source directories.
Hopefully cleaned up the magic a bit.
Note that this is still lacking some features - see the build system epic on JIRA.","Adds support for library dependencies, multiple source directories.
Hopefully cleaned up the magic a bit.
Note that this is still lacking some features - see the build system epic on JIRA.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,3,2016-10-15T23:45:01Z,2016-10-16T15:52:57Z,2016-10-17T00:52:55Z,MERGED,True,82679,15958,759,https://github.com/tituschow,Improved device support and includes,18,[],https://github.com/uw-midsun/firmware/pull/3,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/3,"Renamed device to platform and got the STM platform working.
Cleaned up CFLAGS, includes, and library dependencies.
Added gdb and program targets.","Renamed device to platform and got the STM platform working.
Cleaned up CFLAGS, includes, and library dependencies.
Added gdb and program targets.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,4,2016-10-16T20:13:49Z,2016-10-16T20:15:56Z,2016-10-16T20:15:58Z,MERGED,True,27,18,3,https://github.com/tituschow,"ELEC-30: Replace ms-common dev branch with master, updated startup file",1,[],https://github.com/uw-midsun/firmware/pull/4,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/4,,,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,5,2016-10-22T19:08:04Z,2016-10-22T19:09:42Z,2017-05-01T17:00:27Z,MERGED,True,59260,55199,68,https://github.com/tituschow,ELEC-34: Replaced STM libraries with v1.4.0,1,[],https://github.com/uw-midsun/firmware/pull/5,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/5,,,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,6,2016-10-24T20:13:20Z,2016-10-29T18:18:20Z,2017-05-01T17:00:29Z,MERGED,True,5136,10,25,https://github.com/tituschow,ELEC-31 ELEC-33: Added unit test support,7,[],https://github.com/uw-midsun/firmware/pull/6,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/6,"WIP - added basic unit test support using Unity, enabled LTO for code savings


This change is","WIP - added basic unit test support using Unity, enabled LTO for code savings


This change is",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,6,2016-10-24T20:13:20Z,2016-10-29T18:18:20Z,2017-05-01T17:00:29Z,MERGED,True,5136,10,25,https://github.com/tituschow,ELEC-31 ELEC-33: Added unit test support,7,[],https://github.com/uw-midsun/firmware/pull/6,https://github.com/karlding,2,https://github.com/uw-midsun/firmware/pull/6#issuecomment-256231160,"WIP - added basic unit test support using Unity, enabled LTO for code savings


This change is","Reviewed 21 of 25 files at r1.
Review status: 21 of 25 files reviewed at latest revision, 1 unresolved discussion, some commit checks failed.

Makefile, line 15 at r1 (raw file):

# CONFIG

# Default directories

Your folder names and variable names singular/plurals are reversed.

Comments from Reviewable",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,6,2016-10-24T20:13:20Z,2016-10-29T18:18:20Z,2017-05-01T17:00:29Z,MERGED,True,5136,10,25,https://github.com/tituschow,ELEC-31 ELEC-33: Added unit test support,7,[],https://github.com/uw-midsun/firmware/pull/6,https://github.com/ckitagawa,3,https://github.com/uw-midsun/firmware/pull/6#issuecomment-256809645,"WIP - added basic unit test support using Unity, enabled LTO for code savings


This change is","Assuming this is finished enough to commit. LGTM.

Reviewed 25 of 25 files at r1.
Review status: all files reviewed at latest revision, 1 unresolved discussion, some commit checks failed.

Comments from Reviewable",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,6,2016-10-24T20:13:20Z,2016-10-29T18:18:20Z,2017-05-01T17:00:29Z,MERGED,True,5136,10,25,https://github.com/tituschow,ELEC-31 ELEC-33: Added unit test support,7,[],https://github.com/uw-midsun/firmware/pull/6,https://github.com/ckitagawa,4,https://github.com/uw-midsun/firmware/pull/6#issuecomment-256810385,"WIP - added basic unit test support using Unity, enabled LTO for code savings


This change is","Review status: all files reviewed at latest revision, 1 unresolved discussion, some commit checks failed.

Comments from Reviewable

... This is so messy",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,7,2016-11-06T02:35:06Z,2016-11-06T02:57:59Z,2016-11-07T01:39:21Z,MERGED,True,24,31,2,https://github.com/ckitagawa,"ELEC-20 updated gitignore, changed test_project to use HAL",1,[],https://github.com/uw-midsun/firmware/pull/7,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/7,"Minor changes to .gitignore to support some python and vim things.
Switched test_project to use ms-common HAL.
TESTED=true


This change is","Minor changes to .gitignore to support some python and vim things.
Switched test_project to use ms-common HAL.
TESTED=true


This change is",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,8,2016-11-07T01:37:38Z,2016-11-07T01:40:53Z,2016-11-07T01:40:58Z,MERGED,True,6,6,1,https://github.com/ckitagawa,ELEC-40 linter support for TODO(TYPE-#): style comments for JIRA tickets.,1,[],https://github.com/uw-midsun/firmware/pull/8,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/8,This change is,This change is,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,9,2016-11-07T06:33:29Z,2016-11-08T01:47:46Z,2017-05-01T17:00:32Z,MERGED,True,208,183,14,https://github.com/tituschow,ELEC-23: Project support,4,[],https://github.com/uw-midsun/firmware/pull/9,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/9,"Enables the use of multiple source projects in a file and adds a build_all target.


This change is","Enables the use of multiple source projects in a file and adds a build_all target.


This change is",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,9,2016-11-07T06:33:29Z,2016-11-08T01:47:46Z,2017-05-01T17:00:32Z,MERGED,True,208,183,14,https://github.com/tituschow,ELEC-23: Project support,4,[],https://github.com/uw-midsun/firmware/pull/9,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/9#issuecomment-259021048,"Enables the use of multiple source projects in a file and adds a build_all target.


This change is","Yeah, I might do a writeup of the basic idea behind our build system once we've got it pretty much finalized. The problem is that no one else really understands how make works.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,10,2016-11-08T03:41:41Z,2016-11-09T08:37:43Z,2017-05-01T17:00:35Z,MERGED,True,1,1,1,https://github.com/tituschow,ELEC-46: Updated ms-common submodule,1,[],https://github.com/uw-midsun/firmware/pull/10,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/10,"Added event queue, unit tests, and supports the new build system


This change is","Added event queue, unit tests, and supports the new build system


This change is",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,11,2016-11-13T02:39:15Z,2016-11-13T22:03:12Z,2017-05-01T17:00:36Z,MERGED,True,57,5,9,https://github.com/tituschow,ELEC-36: Retarget STDOUT on STMF0xx,6,[],https://github.com/uw-midsun/firmware/pull/11,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/11,"Currently redirects stdout to semihosting - once we receive UART to USB adapters, I'll switch it to UART.
I found that if you include stdio.h, putchar is defined as both a function and a macro, and that macro overrides the function declaration with an inlined function that doesn't work. For unity, I undefined the macro. For everything else, just don't use putchar. :)


This change is ","Currently redirects stdout to semihosting - once we receive UART to USB adapters, I'll switch it to UART.
I found that if you include stdio.h, putchar is defined as both a function and a macro, and that macro overrides the function declaration with an inlined function that doesn't work. For unity, I undefined the macro. For everything else, just don't use putchar. :)


This change is ",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,12,2016-11-13T21:05:39Z,2016-11-13T22:48:46Z,2016-11-19T22:48:30Z,MERGED,True,37,0,1,https://github.com/karlding,ELEC-54: Add .travis.yml file,2,[],https://github.com/uw-midsun/firmware/pull/12,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/12,"Add .travis.yml file for continuous integration.


This change is ","Add .travis.yml file for continuous integration.


This change is ",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,12,2016-11-13T21:05:39Z,2016-11-13T22:48:46Z,2016-11-19T22:48:30Z,MERGED,True,37,0,1,https://github.com/karlding,ELEC-54: Add .travis.yml file,2,[],https://github.com/uw-midsun/firmware/pull/12,https://github.com/karlding,2,https://github.com/uw-midsun/firmware/pull/12#issuecomment-260213139,"Add .travis.yml file for continuous integration.


This change is ","Note that builds are failing right now because Travis is complaining that we aren't using the -std=c99 flags. Once the changes @tituschow made to the platform.mk files in #11 are merged, we should see these builds start to pass.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,12,2016-11-13T21:05:39Z,2016-11-13T22:48:46Z,2016-11-19T22:48:30Z,MERGED,True,37,0,1,https://github.com/karlding,ELEC-54: Add .travis.yml file,2,[],https://github.com/uw-midsun/firmware/pull/12,https://github.com/karlding,3,https://github.com/uw-midsun/firmware/pull/12#issuecomment-260216287,"Add .travis.yml file for continuous integration.


This change is ","I haven't looked too much into our Makefile, but I think if we want to run the linter and build_all, we can just run
make lint build_all PLATFORM=$PLATFORM",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,12,2016-11-13T21:05:39Z,2016-11-13T22:48:46Z,2016-11-19T22:48:30Z,MERGED,True,37,0,1,https://github.com/karlding,ELEC-54: Add .travis.yml file,2,[],https://github.com/uw-midsun/firmware/pull/12,https://github.com/tituschow,4,https://github.com/uw-midsun/firmware/pull/12#issuecomment-260216402,"Add .travis.yml file for continuous integration.


This change is ","#11 has been merged.
make lint lints all files, so you can just add that as another check.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,12,2016-11-13T21:05:39Z,2016-11-13T22:48:46Z,2016-11-19T22:48:30Z,MERGED,True,37,0,1,https://github.com/karlding,ELEC-54: Add .travis.yml file,2,[],https://github.com/uw-midsun/firmware/pull/12,https://github.com/karlding,5,https://github.com/uw-midsun/firmware/pull/12#issuecomment-260217997,"Add .travis.yml file for continuous integration.


This change is ","I've restructured the .travis.yml file so that linting is included in the CI process.
For C projects, env and compiler can be given as arrays to construct a build matrix. As a result, I've set $TARGET to the various build options, so that make lint is pipelined as well (and so we don't spend time linting the same files during each item in the build matrix).",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,13,2016-11-14T05:45:49Z,2016-11-14T05:49:19Z,2016-11-20T21:45:01Z,MERGED,True,77,1,2,https://github.com/karlding,ELEC-56: Update README and add MIT LICENSE,2,[],https://github.com/uw-midsun/firmware/pull/13,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/13,"Update README.md with Travis CI badge, and some more details about
how to get started. There's a bit about how our build system works. Added
MIT software LICENSE.","Update README.md with Travis CI badge, and some more details about
how to get started. There's a bit about how our build system works. Added
MIT software LICENSE.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,14,2016-11-19T20:42:32Z,2016-11-19T20:49:06Z,2016-11-19T20:49:08Z,MERGED,True,3,5,2,https://github.com/ckitagawa,ELEC-40 Updated comment rules in linter and submodules,1,[],https://github.com/uw-midsun/firmware/pull/14,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/14,"Update so comments such as
bool ok = true: // Sets ok to true.
Are valid with a single space rather than needing two spaces.
Updated submodules.","Update so comments such as
bool ok = true: // Sets ok to true.
Are valid with a single space rather than needing two spaces.
Updated submodules.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,15,2016-11-19T23:15:47Z,2016-11-20T18:15:26Z,2017-02-06T01:30:16Z,MERGED,True,7,0,1,https://github.com/karlding,ELEC-60: Configure Travis to build PRs and master,1,[],https://github.com/uw-midsun/firmware/pull/15,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/15,"Currently Travis CI is configured to build on every push, and every pull request (running tests as if the PR is merged). This isn't great, since disabling Travis for push requests via the settings means that tests against the master branch are not run whenever PRs are merged.
This change configures Travis so that it builds against every merge into master (a push request, since we never push directly to master) and on every PR (a pull request).","Currently Travis CI is configured to build on every push, and every pull request (running tests as if the PR is merged). This isn't great, since disabling Travis for push requests via the settings means that tests against the master branch are not run whenever PRs are merged.
This change configures Travis so that it builds against every merge into master (a push request, since we never push directly to master) and on every PR (a pull request).",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,16,2016-12-10T03:28:23Z,2016-12-14T00:28:54Z,2016-12-14T00:29:00Z,MERGED,True,10,57,4,https://github.com/ckitagawa,ELEC-21 ELEC-38 ELEC-39 ELEC-42 Fixed a bunch of small things,2,[],https://github.com/uw-midsun/firmware/pull/16,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/16,"Improved linter to support the format of our test files. It was expecting filename_test.c we are using test_filename.c. This allows ""proper"" header formatting of this file's header, std library headers, other headers for tests. I have not added enforcement of this yet but am working towards an auto format for this.
Added support for device headers. This allows for things like providing the number of GPIO pins and ports on a per platform basis without using #ifdef.
Changed x86 platform.mk to gnu99 std to support signals.h for interrupts (wouldn't build under normal c99 see this for a discussion of why this is necessary).
Removed hooks as this is not in active use anymore due to .travis.yml.","Improved linter to support the format of our test files. It was expecting filename_test.c we are using test_filename.c. This allows ""proper"" header formatting of this file's header, std library headers, other headers for tests. I have not added enforcement of this yet but am working towards an auto format for this.
Added support for device headers. This allows for things like providing the number of GPIO pins and ports on a per platform basis without using #ifdef.
Changed x86 platform.mk to gnu99 std to support signals.h for interrupts (wouldn't build under normal c99 see this for a discussion of why this is necessary).
Removed hooks as this is not in active use anymore due to .travis.yml.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,16,2016-12-10T03:28:23Z,2016-12-14T00:28:54Z,2016-12-14T00:29:00Z,MERGED,True,10,57,4,https://github.com/ckitagawa,ELEC-21 ELEC-38 ELEC-39 ELEC-42 Fixed a bunch of small things,2,[],https://github.com/uw-midsun/firmware/pull/16,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/16#issuecomment-266182647,"Improved linter to support the format of our test files. It was expecting filename_test.c we are using test_filename.c. This allows ""proper"" header formatting of this file's header, std library headers, other headers for tests. I have not added enforcement of this yet but am working towards an auto format for this.
Added support for device headers. This allows for things like providing the number of GPIO pins and ports on a per platform basis without using #ifdef.
Changed x86 platform.mk to gnu99 std to support signals.h for interrupts (wouldn't build under normal c99 see this for a discussion of why this is necessary).
Removed hooks as this is not in active use anymore due to .travis.yml.","Note that device-specific testing isn't really something that should be necessary for device-specific headers, as that means we weren't able to fully abstract that device.
If it's a test against something that uses device-specific headers that is written properly, that single test should be able to work across all platforms, as it'll pick up the specific header when we compile for that platform.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,16,2016-12-10T03:28:23Z,2016-12-14T00:28:54Z,2016-12-14T00:29:00Z,MERGED,True,10,57,4,https://github.com/ckitagawa,ELEC-21 ELEC-38 ELEC-39 ELEC-42 Fixed a bunch of small things,2,[],https://github.com/uw-midsun/firmware/pull/16,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/16#issuecomment-266182844,"Improved linter to support the format of our test files. It was expecting filename_test.c we are using test_filename.c. This allows ""proper"" header formatting of this file's header, std library headers, other headers for tests. I have not added enforcement of this yet but am working towards an auto format for this.
Added support for device headers. This allows for things like providing the number of GPIO pins and ports on a per platform basis without using #ifdef.
Changed x86 platform.mk to gnu99 std to support signals.h for interrupts (wouldn't build under normal c99 see this for a discussion of why this is necessary).
Removed hooks as this is not in active use anymore due to .travis.yml.","If you want to support platform-specific headers, you just need to add the platform directory's contents to $(T)_INC the same way you added platform tests. I don't see that here. How are you planning on supporting them?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,16,2016-12-10T03:28:23Z,2016-12-14T00:28:54Z,2016-12-14T00:29:00Z,MERGED,True,10,57,4,https://github.com/ckitagawa,ELEC-21 ELEC-38 ELEC-39 ELEC-42 Fixed a bunch of small things,2,[],https://github.com/uw-midsun/firmware/pull/16,https://github.com/ckitagawa,4,https://github.com/uw-midsun/firmware/pull/16#issuecomment-266216274,"Improved linter to support the format of our test files. It was expecting filename_test.c we are using test_filename.c. This allows ""proper"" header formatting of this file's header, std library headers, other headers for tests. I have not added enforcement of this yet but am working towards an auto format for this.
Added support for device headers. This allows for things like providing the number of GPIO pins and ports on a per platform basis without using #ifdef.
Changed x86 platform.mk to gnu99 std to support signals.h for interrupts (wouldn't build under normal c99 see this for a discussion of why this is necessary).
Removed hooks as this is not in active use anymore due to .travis.yml.","I'm going to clean the bay now so I won't fix the test make stuff until later but I want to address these comments.
I want device specific headers to be tested because IMO testing the implementation details of device specific headers (such as guard clauses and status responses) is valuable. I understand this is a bit like testing a private function in a class as these headers should only ever be included in the implementation of a specific library header and not directly in any project.  However, I don't think it signifies a failure to abstract away the device as I am mainly using these headers to make reusing functionality like NVIC and EXTI more pleasant as multiple libraries will use them in general interrupt modules ie GPIO and Timer interrupts and frankly I am not a fan of the HAL variant supplied by STM.
I personally, strongly prefer if device specific headers are supported via #include ""platform/header.h"" I understand this is against the convention we have been using but I think the readability and clarity improvement of this far outweigh the small cost of the style guide infraction as it makes it clear that a device specific header has been included, what device it is for and that the code in this file is no longer portable. This will also help reduce the likelihood people use these headers by mistake. It is easy for someone new to the system to accidentally include gpio_cpu.h or gpio_mcu.h by mistake and I would rather make it hard to do that by prefacing with a dir.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,16,2016-12-10T03:28:23Z,2016-12-14T00:28:54Z,2016-12-14T00:29:00Z,MERGED,True,10,57,4,https://github.com/ckitagawa,ELEC-21 ELEC-38 ELEC-39 ELEC-42 Fixed a bunch of small things,2,[],https://github.com/uw-midsun/firmware/pull/16,https://github.com/tituschow,5,https://github.com/uw-midsun/firmware/pull/16#issuecomment-266235062,"Improved linter to support the format of our test files. It was expecting filename_test.c we are using test_filename.c. This allows ""proper"" header formatting of this file's header, std library headers, other headers for tests. I have not added enforcement of this yet but am working towards an auto format for this.
Added support for device headers. This allows for things like providing the number of GPIO pins and ports on a per platform basis without using #ifdef.
Changed x86 platform.mk to gnu99 std to support signals.h for interrupts (wouldn't build under normal c99 see this for a discussion of why this is necessary).
Removed hooks as this is not in active use anymore due to .travis.yml.","My point is that testing device-specific headers shouldn't require specifically writing tests for them. Most headers will primarily be a set of defines or enums, and your tests should just enumerate that. For device-specific modules, I can understand that, although I think developing a more generic module is more valuable.
If you force the inclusion of device-specific headers through the platform folder, how are you planning on exposing device-specific defines such as number of pins or ports? How will GPIO tests work? The point of a device-specific header to have the ability to redefine a common set of data structures or macros to suit the platform without any knowledge of that change on the application side.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,16,2016-12-10T03:28:23Z,2016-12-14T00:28:54Z,2016-12-14T00:29:00Z,MERGED,True,10,57,4,https://github.com/ckitagawa,ELEC-21 ELEC-38 ELEC-39 ELEC-42 Fixed a bunch of small things,2,[],https://github.com/uw-midsun/firmware/pull/16,https://github.com/ckitagawa,6,https://github.com/uw-midsun/firmware/pull/16#issuecomment-266610264,"Improved linter to support the format of our test files. It was expecting filename_test.c we are using test_filename.c. This allows ""proper"" header formatting of this file's header, std library headers, other headers for tests. I have not added enforcement of this yet but am working towards an auto format for this.
Added support for device headers. This allows for things like providing the number of GPIO pins and ports on a per platform basis without using #ifdef.
Changed x86 platform.mk to gnu99 std to support signals.h for interrupts (wouldn't build under normal c99 see this for a discussion of why this is necessary).
Removed hooks as this is not in active use anymore due to .travis.yml.",Abandoned the concept of platform specific tests. Added actual support for device specific headers.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,17,2016-12-14T03:13:38Z,2016-12-14T04:16:36Z,2017-05-01T17:00:50Z,MERGED,True,1340,5,25,https://github.com/tituschow,ELEC-86: Integrate ms-common into main repo,3,[],https://github.com/uw-midsun/firmware/pull/17,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/17,"Integrating the ms-common submodule into the main repo.
After this is merged, ms-common will be considered deprecated and should be reference-only.","Integrating the ms-common submodule into the main repo.
After this is merged, ms-common will be considered deprecated and should be reference-only.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,18,2016-12-14T06:32:50Z,2016-12-16T03:03:17Z,2017-05-01T17:00:47Z,MERGED,True,49,20,5,https://github.com/tituschow,ELEC-89: Platform target cleanup,4,[],https://github.com/uw-midsun/firmware/pull/18,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/18,Moves platform-specific targets into their platform makefiles and enables semihosting by default with the assumption that most of our development will be plugged in for the time being.,Moves platform-specific targets into their platform makefiles and enables semihosting by default with the assumption that most of our development will be plugged in for the time being.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,19,2016-12-14T06:56:56Z,2016-12-16T02:50:40Z,2017-05-01T17:00:48Z,MERGED,True,76,0,1,https://github.com/tituschow,ELEC-45: Added FSM unit test,2,[],https://github.com/uw-midsun/firmware/pull/19,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/19,"Added basic FSM unit test. Checks the ability to self-cycle, transition between states, output, and fail to transition.","Added basic FSM unit test. Checks the ability to self-cycle, transition between states, output, and fail to transition.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,20,2016-12-17T21:34:47Z,2016-12-27T22:56:23Z,2017-05-19T06:34:19Z,CLOSED,False,578,37,11,https://github.com/ckitagawa,"ELEC-21 ELEC-38 ELEC-43 Interrupts, Critical Sections, Fix a bug in Semihosting.",10,[],https://github.com/uw-midsun/firmware/pull/20,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/20,"This PR provides an API for GPIO interrupts, and internal support to expand this to any other modules on both stm32f0xx using the hardware interrupts and in x86 using <signals.h>. Also provides a minor bug fix to semihosting. Critical sections are also supported.","This PR provides an API for GPIO interrupts, and internal support to expand this to any other modules on both stm32f0xx using the hardware interrupts and in x86 using <signals.h>. Also provides a minor bug fix to semihosting. Critical sections are also supported.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,20,2016-12-17T21:34:47Z,2016-12-27T22:56:23Z,2017-05-19T06:34:19Z,CLOSED,False,578,37,11,https://github.com/ckitagawa,"ELEC-21 ELEC-38 ELEC-43 Interrupts, Critical Sections, Fix a bug in Semihosting.",10,[],https://github.com/uw-midsun/firmware/pull/20,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/20#issuecomment-267828897,"This PR provides an API for GPIO interrupts, and internal support to expand this to any other modules on both stm32f0xx using the hardware interrupts and in x86 using <signals.h>. Also provides a minor bug fix to semihosting. Critical sections are also supported.",Will work on resolving code related comments tomorrow. Responded to comments that I felt required discussion prior to any changes happening.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,20,2016-12-17T21:34:47Z,2016-12-27T22:56:23Z,2017-05-19T06:34:19Z,CLOSED,False,578,37,11,https://github.com/ckitagawa,"ELEC-21 ELEC-38 ELEC-43 Interrupts, Critical Sections, Fix a bug in Semihosting.",10,[],https://github.com/uw-midsun/firmware/pull/20,https://github.com/ckitagawa,3,https://github.com/uw-midsun/firmware/pull/20#issuecomment-269394649,"This PR provides an API for GPIO interrupts, and internal support to expand this to any other modules on both stm32f0xx using the hardware interrupts and in x86 using <signals.h>. Also provides a minor bug fix to semihosting. Critical sections are also supported.",Closing this as a major refactoring is required and I want to split this into multiple PRs. DO NOT DELETE THIS BRANCH. I will delete it when I am done with it as I may need to pull it again for reference.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,21,2016-12-18T00:11:05Z,2016-12-18T23:04:02Z,2017-05-01T17:00:58Z,MERGED,True,57,22,5,https://github.com/tituschow,ELEC-79: Added test specifier for unit tests,2,[],https://github.com/uw-midsun/firmware/pull/21,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/21,"Added ability to specify a unit test to run with TEST=. Requires LIBRARY or PROJECT to be defined.
Also fixed make test running all tests.","Added ability to specify a unit test to run with TEST=. Requires LIBRARY or PROJECT to be defined.
Also fixed make test running all tests.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,21,2016-12-18T00:11:05Z,2016-12-18T23:04:02Z,2017-05-01T17:00:58Z,MERGED,True,57,22,5,https://github.com/tituschow,ELEC-79: Added test specifier for unit tests,2,[],https://github.com/uw-midsun/firmware/pull/21,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/21#issuecomment-267853782,"Added ability to specify a unit test to run with TEST=. Requires LIBRARY or PROJECT to be defined.
Also fixed make test running all tests.",I made it so build_all doesn't run the tests and explicitly used the test_all target for x86.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,22,2016-12-19T00:29:56Z,2016-12-19T20:16:38Z,2017-05-01T17:00:57Z,MERGED,True,1,1,1,https://github.com/tituschow,ELEC-79: Fix test_all target,1,[],https://github.com/uw-midsun/firmware/pull/22,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/22,Fix test_all target so it actually runs all the tests. :P,Fix test_all target so it actually runs all the tests. :P,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,23,2016-12-25T01:15:33Z,2016-12-28T03:45:47Z,2017-05-01T17:00:54Z,MERGED,True,213,82,16,https://github.com/tituschow,ELEC-92: Backed PQueue,7,[],https://github.com/uw-midsun/firmware/pull/23,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/23,Added a backed PQueue implementation and moved objpool's node tracking responsibility.,Added a backed PQueue implementation and moved objpool's node tracking responsibility.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,23,2016-12-25T01:15:33Z,2016-12-28T03:45:47Z,2017-05-01T17:00:54Z,MERGED,True,213,82,16,https://github.com/tituschow,ELEC-92: Backed PQueue,7,[],https://github.com/uw-midsun/firmware/pull/23,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/23#issuecomment-269399369,Added a backed PQueue implementation and moved objpool's node tracking responsibility.,"@ckitagawa - #24 was for the wrong slash direction, so I flipped it.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,23,2016-12-25T01:15:33Z,2016-12-28T03:45:47Z,2017-05-01T17:00:54Z,MERGED,True,213,82,16,https://github.com/tituschow,ELEC-92: Backed PQueue,7,[],https://github.com/uw-midsun/firmware/pull/23,https://github.com/karlding,3,https://github.com/uw-midsun/firmware/pull/23#issuecomment-269399937,Added a backed PQueue implementation and moved objpool's node tracking responsibility.,"Is it worth creating a more generic heap implementation, and simply passing a function pointer for a comparator function, as opposed to a minheap like we currently are using?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,23,2016-12-25T01:15:33Z,2016-12-28T03:45:47Z,2017-05-01T17:00:54Z,MERGED,True,213,82,16,https://github.com/tituschow,ELEC-92: Backed PQueue,7,[],https://github.com/uw-midsun/firmware/pull/23,https://github.com/tituschow,4,https://github.com/uw-midsun/firmware/pull/23#issuecomment-269400843,Added a backed PQueue implementation and moved objpool's node tracking responsibility.,"I'm not sure if we really have any use for anything other than a minheap. Right now, it's only used for priority queues, and that could be replaced with another data structure if necessary.
It's a pretty easy change if we want to support it later, but I figured we'd avoid the overhead for now since the functions will be called pretty often within ISRs. I want to keep the priority separate from the data to ensure that its priority doesn't change, so there wouldn't be a lot of variety in comparison functions. :)",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,24,2016-12-27T22:25:44Z,2016-12-27T22:35:34Z,2016-12-27T22:35:38Z,MERGED,True,1,1,1,https://github.com/ckitagawa,ELEC-40 Added support for macro line continuation spacing variance.,1,[],https://github.com/uw-midsun/firmware/pull/24,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/24,"Allows for ""weird"" (1 or 3) space indentation when continuing a macro.
Example this is now ok:
#define MY_MACRO() \
___foo()
NOTE: _ is a space it won't render on here correctly.
MERGE BEFORE #23","Allows for ""weird"" (1 or 3) space indentation when continuing a macro.
Example this is now ok:
#define MY_MACRO() \
___foo()
NOTE: _ is a space it won't render on here correctly.
MERGE BEFORE #23",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,24,2016-12-27T22:25:44Z,2016-12-27T22:35:34Z,2016-12-27T22:35:38Z,MERGED,True,1,1,1,https://github.com/ckitagawa,ELEC-40 Added support for macro line continuation spacing variance.,1,[],https://github.com/uw-midsun/firmware/pull/24,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/24#issuecomment-269391901,"Allows for ""weird"" (1 or 3) space indentation when continuing a macro.
Example this is now ok:
#define MY_MACRO() \
___foo()
NOTE: _ is a space it won't render on here correctly.
MERGE BEFORE #23","Fun fact: You can use four backticks to start and end a code block
#define MY_MACRO() \
  foo()",True,{'THUMBS_UP': ['https://github.com/ckitagawa']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,25,2016-12-27T22:58:17Z,2016-12-28T21:29:42Z,2016-12-28T21:29:45Z,MERGED,True,1,1,1,https://github.com/ckitagawa,ELEC-36 Fixed a bug/typo that caused Semihosting to not enable.,1,[],https://github.com/uw-midsun/firmware/pull/25,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/25,Fixed a typo where SEMIHOSTING in platform.mk for stm32f0xx should have read SEMIHOSTING_ENABLED. This now allows semihosting to work.,Fixed a typo where SEMIHOSTING in platform.mk for stm32f0xx should have read SEMIHOSTING_ENABLED. This now allows semihosting to work.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,26,2016-12-28T22:45:48Z,2017-01-07T17:27:04Z,2017-01-07T17:54:29Z,MERGED,True,140,0,5,https://github.com/ckitagawa,ELEC-43 Support for Critical Sections,7,[],https://github.com/uw-midsun/firmware/pull/26,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/26,"This PR also defines generic enums/structs for interrupts. And fixes another bug with semihosting (=1).
The core interrupt API (not to be used outside of other library modules) will be in a follow-up PR using the device header interrupt_mcu.h alternatively it can be placed into stm32f0xx and x86 libraries as the interface for each will be significantly different. The first interrupt module will also follow using the module name gpio_it.
Usage
bool disabled = critical_section_start();
// Do critical stuff here. Nesting these is also ok.
critical_section_end(disabled);
...","This PR also defines generic enums/structs for interrupts. And fixes another bug with semihosting (=1).
The core interrupt API (not to be used outside of other library modules) will be in a follow-up PR using the device header interrupt_mcu.h alternatively it can be placed into stm32f0xx and x86 libraries as the interface for each will be significantly different. The first interrupt module will also follow using the module name gpio_it.
Usage
bool disabled = critical_section_start();
// Do critical stuff here. Nesting these is also ok.
critical_section_end(disabled);
...",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,26,2016-12-28T22:45:48Z,2017-01-07T17:27:04Z,2017-01-07T17:54:29Z,MERGED,True,140,0,5,https://github.com/ckitagawa,ELEC-43 Support for Critical Sections,7,[],https://github.com/uw-midsun/firmware/pull/26,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/26#issuecomment-269556918,"This PR also defines generic enums/structs for interrupts. And fixes another bug with semihosting (=1).
The core interrupt API (not to be used outside of other library modules) will be in a follow-up PR using the device header interrupt_mcu.h alternatively it can be placed into stm32f0xx and x86 libraries as the interface for each will be significantly different. The first interrupt module will also follow using the module name gpio_it.
Usage
bool disabled = critical_section_start();
// Do critical stuff here. Nesting these is also ok.
critical_section_end(disabled);
...","You seem to have missed your change for semihosting, but it's actually #if on purpose. This allows someone to define SEMIHOSTING_ENABLED=0.",True,{'THUMBS_UP': ['https://github.com/ckitagawa']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,26,2016-12-28T22:45:48Z,2017-01-07T17:27:04Z,2017-01-07T17:54:29Z,MERGED,True,140,0,5,https://github.com/ckitagawa,ELEC-43 Support for Critical Sections,7,[],https://github.com/uw-midsun/firmware/pull/26,https://github.com/ckitagawa,3,https://github.com/uw-midsun/firmware/pull/26#issuecomment-269820904,"This PR also defines generic enums/structs for interrupts. And fixes another bug with semihosting (=1).
The core interrupt API (not to be used outside of other library modules) will be in a follow-up PR using the device header interrupt_mcu.h alternatively it can be placed into stm32f0xx and x86 libraries as the interface for each will be significantly different. The first interrupt module will also follow using the module name gpio_it.
Usage
bool disabled = critical_section_start();
// Do critical stuff here. Nesting these is also ok.
critical_section_end(disabled);
...","Resolved tituschow's comments.
In response to the discussion about the interrupt_callback typedef. It occurs to me that the solution of passing the name of the ISR handling the callback while helpful presents an issue of portability. On x86 there will only be one ISR and the names of ISRs will vary across platforms so unless this information is mainly used for debugging it is unlikely to be a good idea to rely on it to trigger any kind of behaviour. That is to say, if the name or information about the ISR is used in a switch case or if statement to alter the behaviour of the callback then this code will not be portable unless we define our own ""ID"" system for providing information about the triggering ISR.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,26,2016-12-28T22:45:48Z,2017-01-07T17:27:04Z,2017-01-07T17:54:29Z,MERGED,True,140,0,5,https://github.com/ckitagawa,ELEC-43 Support for Critical Sections,7,[],https://github.com/uw-midsun/firmware/pull/26,https://github.com/tituschow,4,https://github.com/uw-midsun/firmware/pull/26#issuecomment-269823524,"This PR also defines generic enums/structs for interrupts. And fixes another bug with semihosting (=1).
The core interrupt API (not to be used outside of other library modules) will be in a follow-up PR using the device header interrupt_mcu.h alternatively it can be placed into stm32f0xx and x86 libraries as the interface for each will be significantly different. The first interrupt module will also follow using the module name gpio_it.
Usage
bool disabled = critical_section_start();
// Do critical stuff here. Nesting these is also ok.
critical_section_end(disabled);
...","Yep, I don't think function names are the best solution for determining the source of a callback. I think it makes more sense to define callbacks on a per-module basis instead.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,26,2016-12-28T22:45:48Z,2017-01-07T17:27:04Z,2017-01-07T17:54:29Z,MERGED,True,140,0,5,https://github.com/ckitagawa,ELEC-43 Support for Critical Sections,7,[],https://github.com/uw-midsun/firmware/pull/26,https://github.com/ckitagawa,5,https://github.com/uw-midsun/firmware/pull/26#issuecomment-269824887,"This PR also defines generic enums/structs for interrupts. And fixes another bug with semihosting (=1).
The core interrupt API (not to be used outside of other library modules) will be in a follow-up PR using the device header interrupt_mcu.h alternatively it can be placed into stm32f0xx and x86 libraries as the interface for each will be significantly different. The first interrupt module will also follow using the module name gpio_it.
Usage
bool disabled = critical_section_start();
// Do critical stuff here. Nesting these is also ok.
critical_section_end(disabled);
...",Removed interrupt_callback so that each module can have its own callback type. This is going to complicate or possibly even break the x86 interrupt emulation method but I'll try to figure something out.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,26,2016-12-28T22:45:48Z,2017-01-07T17:27:04Z,2017-01-07T17:54:29Z,MERGED,True,140,0,5,https://github.com/ckitagawa,ELEC-43 Support for Critical Sections,7,[],https://github.com/uw-midsun/firmware/pull/26,https://github.com/tituschow,6,https://github.com/uw-midsun/firmware/pull/26#issuecomment-271063069,"This PR also defines generic enums/structs for interrupts. And fixes another bug with semihosting (=1).
The core interrupt API (not to be used outside of other library modules) will be in a follow-up PR using the device header interrupt_mcu.h alternatively it can be placed into stm32f0xx and x86 libraries as the interface for each will be significantly different. The first interrupt module will also follow using the module name gpio_it.
Usage
bool disabled = critical_section_start();
// Do critical stuff here. Nesting these is also ok.
critical_section_end(disabled);
...",@ckitagawa Do you mind making a page explaining how the x86 signal thing works? I'm mostly curious as to why a mutex wouldn't have worked for x86. You'll probably need one if you're planning on running things in a background thread anyways.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,26,2016-12-28T22:45:48Z,2017-01-07T17:27:04Z,2017-01-07T17:54:29Z,MERGED,True,140,0,5,https://github.com/ckitagawa,ELEC-43 Support for Critical Sections,7,[],https://github.com/uw-midsun/firmware/pull/26,https://github.com/ckitagawa,7,https://github.com/uw-midsun/firmware/pull/26#issuecomment-271098910,"This PR also defines generic enums/structs for interrupts. And fixes another bug with semihosting (=1).
The core interrupt API (not to be used outside of other library modules) will be in a follow-up PR using the device header interrupt_mcu.h alternatively it can be placed into stm32f0xx and x86 libraries as the interface for each will be significantly different. The first interrupt module will also follow using the module name gpio_it.
Usage
bool disabled = critical_section_start();
// Do critical stuff here. Nesting these is also ok.
critical_section_end(disabled);
...","Yeah, I'll get on that. I'll think about the mutex. Although, the signals are sent to a specific thread/process ID so the interrupt handler would be owned by the main thread and if any process sends an interrupt to it it gets pushed into a pqueue (managed by the OS). The critical section thing could be an issue if a different thread calls the critical section code but I can't think of a case where that would ever happen. If it becomes an issue, interrupt_mcu could record the process ID on interrupt_init() for the main thread owning the interrupt handler and disable it using that stored value. I'm just thinking that a mutex limits us from taking advantage of the ability to enqueue signals and leverage the OS to handle prioritisation and timing for us. By just disabling the signals it just blocks until the critical section is ended so if any threads that enqueue a signal in that time the order they were sent is maintained.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,27,2017-01-06T20:56:17Z,2017-01-07T20:40:49Z,2017-01-07T20:41:04Z,MERGED,True,47,36,5,https://github.com/ckitagawa,ELEC-39 Added GPIO Device Headers,8,[],https://github.com/uw-midsun/firmware/pull/27,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/27,Simple change adding GPIO device headers. Prerequisite to GPIO interrupts PR I will put up once this and critical sections #26 are merged.,Simple change adding GPIO device headers. Prerequisite to GPIO interrupts PR I will put up once this and critical sections #26 are merged.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,28,2017-01-06T21:02:28Z,2017-01-07T17:54:46Z,2017-01-07T20:41:19Z,MERGED,True,5,5,5,https://github.com/ckitagawa,ELEC-95 Specify void as arg for some functions.,1,[],https://github.com/uw-midsun/firmware/pull/28,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/28,Trivial change that specifies void arguments for a few functions I wrote in C++ style not knowing any better.,Trivial change that specifies void arguments for a few functions I wrote in C++ style not knowing any better.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,29,2017-01-06T21:20:30Z,2017-02-04T15:53:03Z,2017-02-04T15:53:03Z,CLOSED,False,263,1,5,https://github.com/ckitagawa,ELEC-37 Added support for software timers.,14,[],https://github.com/uw-midsun/firmware/pull/29,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/29,Added polling software timer support for stm32f0xx and x86.,Added polling software timer support for stm32f0xx and x86.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,29,2017-01-06T21:20:30Z,2017-02-04T15:53:03Z,2017-02-04T15:53:03Z,CLOSED,False,263,1,5,https://github.com/ckitagawa,ELEC-37 Added support for software timers.,14,[],https://github.com/uw-midsun/firmware/pull/29,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/29#issuecomment-271014564,Added polling software timer support for stm32f0xx and x86.,This is failing due to the call clock_gettime which is standard on Linux. If someone is aware of an alternative or know how to fix the Travis CI let me know and I can fix the build.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,29,2017-01-06T21:20:30Z,2017-02-04T15:53:03Z,2017-02-04T15:53:03Z,CLOSED,False,263,1,5,https://github.com/ckitagawa,ELEC-37 Added support for software timers.,14,[],https://github.com/uw-midsun/firmware/pull/29,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/29#issuecomment-271064869,Added polling software timer support for stm32f0xx and x86.,"For the CI failure, this might be useful
http://stackoverflow.com/questions/2418157/ubuntu-linux-c-error-undefined-reference-to-clock-gettime-and-clock-settim",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,29,2017-01-06T21:20:30Z,2017-02-04T15:53:03Z,2017-02-04T15:53:03Z,CLOSED,False,263,1,5,https://github.com/ckitagawa,ELEC-37 Added support for software timers.,14,[],https://github.com/uw-midsun/firmware/pull/29,https://github.com/karlding,4,https://github.com/uw-midsun/firmware/pull/29#issuecomment-271065058,Added polling software timer support for stm32f0xx and x86.,"I suspect that there's a difference between our virtual environments, which run Ubuntu 16.04 and the Travis CI environment, which runs Ubuntu 12.04 by default.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,29,2017-01-06T21:20:30Z,2017-02-04T15:53:03Z,2017-02-04T15:53:03Z,CLOSED,False,263,1,5,https://github.com/ckitagawa,ELEC-37 Added support for software timers.,14,[],https://github.com/uw-midsun/firmware/pull/29,https://github.com/ckitagawa,5,https://github.com/uw-midsun/firmware/pull/29#issuecomment-271180225,Added polling software timer support for stm32f0xx and x86.,"Latest commit doesn't need review, was just to save changes and handle the minor comments. I still need to sort out the Travis CI stuff and I'll be moving to an event driven design once my interrupt code is added to the repo.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,29,2017-01-06T21:20:30Z,2017-02-04T15:53:03Z,2017-02-04T15:53:03Z,CLOSED,False,263,1,5,https://github.com/ckitagawa,ELEC-37 Added support for software timers.,14,[],https://github.com/uw-midsun/firmware/pull/29,https://github.com/karlding,6,https://github.com/uw-midsun/firmware/pull/29#issuecomment-273399689,Added polling software timer support for stm32f0xx and x86.,"Did you try putting the -lrt flag last in the list of arguments?
Also, if we want to upgrade Travis CI to use Ubuntu 14.04 LTS (Trusty), we just need to add this to the top of our .travis.yml file:
dist: trusty
sudo: required
Or for sudoless
dist: trusty
sudo: false
More details about the Trusty environment can be found on that page (but I don't think the changes really apply to us).",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,29,2017-01-06T21:20:30Z,2017-02-04T15:53:03Z,2017-02-04T15:53:03Z,CLOSED,False,263,1,5,https://github.com/ckitagawa,ELEC-37 Added support for software timers.,14,[],https://github.com/uw-midsun/firmware/pull/29,https://github.com/tituschow,7,https://github.com/uw-midsun/firmware/pull/29#issuecomment-273399924,Added polling software timer support for stm32f0xx and x86.,Would upgrading Travis mean we don't need to build make from source? @karlding,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,29,2017-01-06T21:20:30Z,2017-02-04T15:53:03Z,2017-02-04T15:53:03Z,CLOSED,False,263,1,5,https://github.com/ckitagawa,ELEC-37 Added support for software timers.,14,[],https://github.com/uw-midsun/firmware/pull/29,https://github.com/karlding,8,https://github.com/uw-midsun/firmware/pull/29#issuecomment-273497827,Added polling software timer support for stm32f0xx and x86.,"It doesn't look like it. If I recall correctly, our Makefile requires 4.x, while the version in the Trusty repos is 3.81-8.2ubuntu3. Unfortunately, Travis doesn't seem to support Xenial, which has 4.1-6.
For our use case, it shouldn't really matter, since newer versions of gcc need the linker flag at the end, and it's only old versions that don't care about the position (plus we're installing gcc-arm-embedded from a PPA anyways).",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,29,2017-01-06T21:20:30Z,2017-02-04T15:53:03Z,2017-02-04T15:53:03Z,CLOSED,False,263,1,5,https://github.com/ckitagawa,ELEC-37 Added support for software timers.,14,[],https://github.com/uw-midsun/firmware/pull/29,https://github.com/tituschow,9,https://github.com/uw-midsun/firmware/pull/29#issuecomment-274300576,Added polling software timer support for stm32f0xx and x86.,ping @ckitagawa,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,29,2017-01-06T21:20:30Z,2017-02-04T15:53:03Z,2017-02-04T15:53:03Z,CLOSED,False,263,1,5,https://github.com/ckitagawa,ELEC-37 Added support for software timers.,14,[],https://github.com/uw-midsun/firmware/pull/29,https://github.com/ckitagawa,10,https://github.com/uw-midsun/firmware/pull/29#issuecomment-274301093,Added polling software timer support for stm32f0xx and x86.,? I'm waiting on interrupt MCU code to be approved to be able to refactor this. No point in working on it until interrupts are done/approved of if we are switching to event driven. And no point in using my interrupt API until it is approved because otherwise I'm just wasting time.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,29,2017-01-06T21:20:30Z,2017-02-04T15:53:03Z,2017-02-04T15:53:03Z,CLOSED,False,263,1,5,https://github.com/ckitagawa,ELEC-37 Added support for software timers.,14,[],https://github.com/uw-midsun/firmware/pull/29,https://github.com/ckitagawa,11,https://github.com/uw-midsun/firmware/pull/29#issuecomment-277454578,Added polling software timer support for stm32f0xx and x86.,Closing this as a significant refactor is needed to switch to an event driven system and the PR history is getting really messy. Should have a new PR up in a few days.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,30,2017-01-08T21:26:13Z,2017-02-01T01:04:38Z,2017-02-01T01:09:37Z,MERGED,True,294,1,9,https://github.com/ckitagawa,ELEC-38 Core Interrupt API,4,[],https://github.com/uw-midsun/firmware/pull/30,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/30,"This is the core internals of the interrupt API. In order to test it I also developed a GPIO interrupt module but it depends on this module so I won't create a PR for it just yet.
For x86 documentation can be found on Confluence under HAL/FSM Library.","This is the core internals of the interrupt API. In order to test it I also developed a GPIO interrupt module but it depends on this module so I won't create a PR for it just yet.
For x86 documentation can be found on Confluence under HAL/FSM Library.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,30,2017-01-08T21:26:13Z,2017-02-01T01:04:38Z,2017-02-01T01:09:37Z,MERGED,True,294,1,9,https://github.com/ckitagawa,ELEC-38 Core Interrupt API,4,[],https://github.com/uw-midsun/firmware/pull/30,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/30#issuecomment-274300734,"This is the core internals of the interrupt API. In order to test it I also developed a GPIO interrupt module but it depends on this module so I won't create a PR for it just yet.
For x86 documentation can be found on Confluence under HAL/FSM Library.",Is there a general interrupt API? I only see MCU-specific functions.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,30,2017-01-08T21:26:13Z,2017-02-01T01:04:38Z,2017-02-01T01:09:37Z,MERGED,True,294,1,9,https://github.com/ckitagawa,ELEC-38 Core Interrupt API,4,[],https://github.com/uw-midsun/firmware/pull/30,https://github.com/ckitagawa,3,https://github.com/uw-midsun/firmware/pull/30#issuecomment-274301042,"This is the core internals of the interrupt API. In order to test it I also developed a GPIO interrupt module but it depends on this module so I won't create a PR for it just yet.
For x86 documentation can be found on Confluence under HAL/FSM Library.","No there can't really be there is no unified way/interface to support the core of the interrupt code on both devices the implementation is too different. The modules will each have their own code that uses the mcu specific code to achieve a unified API for the HAL (ie GPIO interrupts, timer interrupts etc.) this code should never be called outside the library. By API I meant MCU specific stuff. Maybe core interrupt code is a better descriptor. But I digress.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,30,2017-01-08T21:26:13Z,2017-02-01T01:04:38Z,2017-02-01T01:09:37Z,MERGED,True,294,1,9,https://github.com/ckitagawa,ELEC-38 Core Interrupt API,4,[],https://github.com/uw-midsun/firmware/pull/30,https://github.com/tituschow,4,https://github.com/uw-midsun/firmware/pull/30#issuecomment-275590599,"This is the core internals of the interrupt API. In order to test it I also developed a GPIO interrupt module but it depends on this module so I won't create a PR for it just yet.
For x86 documentation can be found on Confluence under HAL/FSM Library.","Just a general comment - I'm never a huge fan of static variables, and modules that have completely different APIs seems a little out of place. Maybe they belong in their platform-specific library?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,30,2017-01-08T21:26:13Z,2017-02-01T01:04:38Z,2017-02-01T01:09:37Z,MERGED,True,294,1,9,https://github.com/ckitagawa,ELEC-38 Core Interrupt API,4,[],https://github.com/uw-midsun/firmware/pull/30,https://github.com/ckitagawa,5,https://github.com/uw-midsun/firmware/pull/30#issuecomment-275949126,"This is the core internals of the interrupt API. In order to test it I also developed a GPIO interrupt module but it depends on this module so I won't create a PR for it just yet.
For x86 documentation can be found on Confluence under HAL/FSM Library.","I have resolved the implementation issues Karl mentioned. I also moved everything to platform specific libraries and altered the build system to match. I have verified all these changes work using the gpio_interrupt module/unit tests I will submit in a separate PR. I tried to reduce the number of static variables slightly; however, in favour of progress I recommend we account them to technical debt and deal with it if it becomes an issue once everything else is functional.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,31,2017-02-01T01:19:52Z,2017-02-04T15:41:09Z,2017-02-04T15:41:14Z,MERGED,True,266,0,4,https://github.com/ckitagawa,ELEC-94 GPIO Interrupt API,3,[],https://github.com/uw-midsun/firmware/pull/31,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/31,"This is the GPIO interrupt API, it is a good example and test of the core interrupt platform libraries. Only one interrupt is available per pin on stm32f0xx.","This is the GPIO interrupt API, it is a good example and test of the core interrupt platform libraries. Only one interrupt is available per pin on stm32f0xx.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,32,2017-02-10T01:03:48Z,2017-05-19T19:58:30Z,2017-05-25T04:49:11Z,CLOSED,False,218,0,2,https://github.com/eric98zhang,ELEC-61 Interface for SPI,9,[],https://github.com/uw-midsun/firmware/pull/32,https://github.com/eric98zhang,1,https://github.com/uw-midsun/firmware/pull/32,,,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,32,2017-02-10T01:03:48Z,2017-05-19T19:58:30Z,2017-05-25T04:49:11Z,CLOSED,False,218,0,2,https://github.com/eric98zhang,ELEC-61 Interface for SPI,9,[],https://github.com/uw-midsun/firmware/pull/32,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/32#issuecomment-278859403,,"Just a general comment - I noticed that you have a lot of different peripheral settings, but one of the nice things about designing a portable interface is that we can tailor our options to the specific settings that we want to support. For example, we'll probably never want to use SPI in slave mode or change the data size.
In addition, we don't want to expose hardware-specific things in the general interface, such as how many SPI peripherals there are. We could use a chip that has 1 or 4, and this should be able to support that chip without any changes to the main interface.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,32,2017-02-10T01:03:48Z,2017-05-19T19:58:30Z,2017-05-25T04:49:11Z,CLOSED,False,218,0,2,https://github.com/eric98zhang,ELEC-61 Interface for SPI,9,[],https://github.com/uw-midsun/firmware/pull/32,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/32#issuecomment-286319640,,"I think writing a test program to verify your driver is super important. Have you been able to read data from the gyroscope?
Other than that, tests, and some comments to address, I think we should switch back to a blocking driver for now. I'm not sure that we'll see much of a gain with an interrupt-driven SPI driver, and it's looking to be more complex than we thought to make it work nicely. I think our priority right now should be to merge this in and address the interrupt-driven portion in a new PR.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,33,2017-02-11T21:31:03Z,2017-06-03T20:44:17Z,2017-06-09T16:35:18Z,CLOSED,False,559,369,4,https://github.com/michelledang,ELEC-107 UART Interface,9,[],https://github.com/uw-midsun/firmware/pull/33,https://github.com/michelledang,1,https://github.com/uw-midsun/firmware/pull/33,,,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,33,2017-02-11T21:31:03Z,2017-06-03T20:44:17Z,2017-06-09T16:35:18Z,CLOSED,False,559,369,4,https://github.com/michelledang,ELEC-107 UART Interface,9,[],https://github.com/uw-midsun/firmware/pull/33,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/33#issuecomment-279300423,,"Note that UART and USART are different things, where a USART peripheral can support UART, but is capable of many other protocols. In this case, we only want to support UART for now.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,33,2017-02-11T21:31:03Z,2017-06-03T20:44:17Z,2017-06-09T16:35:18Z,CLOSED,False,559,369,4,https://github.com/michelledang,ELEC-107 UART Interface,9,[],https://github.com/uw-midsun/firmware/pull/33,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/33#issuecomment-279301274,,"So mirroring the comments I made here, we only need to expose the specific settings that we'll be using. Since the goal is to make it easy to use, having too many options just adds a lot of boilerplate code that's required to use the API.
Also, I suggest writing a test program or some unit tests to understand how it'll be used. It's very difficult to develop a good API without having used the module and understood what its requirements really are. We only want to expose things we'll use often, and the end goal is to minimize the amount of effort it takes to use this interface.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,34,2017-02-12T20:23:43Z,2017-02-25T03:54:54Z,2017-02-25T03:54:58Z,MERGED,True,692,21,16,https://github.com/ckitagawa,ELEC-37 Event-driven software timers,54,[],https://github.com/uw-midsun/firmware/pull/34,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/34,"Event-driven software timer support on x86 Linux (using signals) and stm32f0xx (using TIM2).
#include <stdbool.h>
#include <stdint.h>

#include ""interrupt.h""
#include ""soft_timer.h""
#include ""status.h""

// Usage:

// Initialization.
interrupt_init();
soft_timer_init();

// The callback will run once the duration_us has expired. 
// The callback is passed the `id_returned` and `context` as arguments. 
// The `id_returned` is set by this function.
StatusCode status = 
  soft_timer_start(uint32_t duration_us, soft_timer_callback callback,
          void* context, uint8_t* id_returned);

// Checks if timers are active.
bool working = soft_timer_inuse();
Possible addition:
soft_timer_stop(uint8_t timer_id) which would cancel/stop/disarm a timer by it's ID. I'm not sure how useful this is given the callbacks will have access to the timer_id but if it is requested it isn't too hard to add.","Event-driven software timer support on x86 Linux (using signals) and stm32f0xx (using TIM2).
#include <stdbool.h>
#include <stdint.h>

#include ""interrupt.h""
#include ""soft_timer.h""
#include ""status.h""

// Usage:

// Initialization.
interrupt_init();
soft_timer_init();

// The callback will run once the duration_us has expired. 
// The callback is passed the `id_returned` and `context` as arguments. 
// The `id_returned` is set by this function.
StatusCode status = 
  soft_timer_start(uint32_t duration_us, soft_timer_callback callback,
          void* context, uint8_t* id_returned);

// Checks if timers are active.
bool working = soft_timer_inuse();
Possible addition:
soft_timer_stop(uint8_t timer_id) which would cancel/stop/disarm a timer by it's ID. I'm not sure how useful this is given the callbacks will have access to the timer_id but if it is requested it isn't too hard to add.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,34,2017-02-12T20:23:43Z,2017-02-25T03:54:54Z,2017-02-25T03:54:58Z,MERGED,True,692,21,16,https://github.com/ckitagawa,ELEC-37 Event-driven software timers,54,[],https://github.com/uw-midsun/firmware/pull/34,https://github.com/karlding,2,https://github.com/uw-midsun/firmware/pull/34#issuecomment-279252449,"Event-driven software timer support on x86 Linux (using signals) and stm32f0xx (using TIM2).
#include <stdbool.h>
#include <stdint.h>

#include ""interrupt.h""
#include ""soft_timer.h""
#include ""status.h""

// Usage:

// Initialization.
interrupt_init();
soft_timer_init();

// The callback will run once the duration_us has expired. 
// The callback is passed the `id_returned` and `context` as arguments. 
// The `id_returned` is set by this function.
StatusCode status = 
  soft_timer_start(uint32_t duration_us, soft_timer_callback callback,
          void* context, uint8_t* id_returned);

// Checks if timers are active.
bool working = soft_timer_inuse();
Possible addition:
soft_timer_stop(uint8_t timer_id) which would cancel/stop/disarm a timer by it's ID. I'm not sure how useful this is given the callbacks will have access to the timer_id but if it is requested it isn't too hard to add.","Hmm, if we're requiring explicit acknowledgements (in our CAN protocol), then it might be useful to have a way of canceling timers. I don't remember if we actually sat down and specced things out that far.
Example: Heartbeat/data is sent, and a software timer starts counting down. If no response is received before the timer runs out, then the other device is presumed to be stuck and we trigger a fault. Otherwise, we cancel the timer when an acknowledgement is received.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,34,2017-02-12T20:23:43Z,2017-02-25T03:54:54Z,2017-02-25T03:54:58Z,MERGED,True,692,21,16,https://github.com/ckitagawa,ELEC-37 Event-driven software timers,54,[],https://github.com/uw-midsun/firmware/pull/34,https://github.com/ckitagawa,3,https://github.com/uw-midsun/firmware/pull/34#issuecomment-279254772,"Event-driven software timer support on x86 Linux (using signals) and stm32f0xx (using TIM2).
#include <stdbool.h>
#include <stdint.h>

#include ""interrupt.h""
#include ""soft_timer.h""
#include ""status.h""

// Usage:

// Initialization.
interrupt_init();
soft_timer_init();

// The callback will run once the duration_us has expired. 
// The callback is passed the `id_returned` and `context` as arguments. 
// The `id_returned` is set by this function.
StatusCode status = 
  soft_timer_start(uint32_t duration_us, soft_timer_callback callback,
          void* context, uint8_t* id_returned);

// Checks if timers are active.
bool working = soft_timer_inuse();
Possible addition:
soft_timer_stop(uint8_t timer_id) which would cancel/stop/disarm a timer by it's ID. I'm not sure how useful this is given the callbacks will have access to the timer_id but if it is requested it isn't too hard to add.","Okay, I'm willing to do it. I thought of that too but my counter example, was to check if bool heartbeat is true every cycle and when the timer goes off just set that to false and when the timer expires have it automatically re-register itself. The CAN interrupt would just set heartbeat to true. They are basically equivalent.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,34,2017-02-12T20:23:43Z,2017-02-25T03:54:54Z,2017-02-25T03:54:58Z,MERGED,True,692,21,16,https://github.com/ckitagawa,ELEC-37 Event-driven software timers,54,[],https://github.com/uw-midsun/firmware/pull/34,https://github.com/tituschow,4,https://github.com/uw-midsun/firmware/pull/34#issuecomment-279298106,"Event-driven software timer support on x86 Linux (using signals) and stm32f0xx (using TIM2).
#include <stdbool.h>
#include <stdint.h>

#include ""interrupt.h""
#include ""soft_timer.h""
#include ""status.h""

// Usage:

// Initialization.
interrupt_init();
soft_timer_init();

// The callback will run once the duration_us has expired. 
// The callback is passed the `id_returned` and `context` as arguments. 
// The `id_returned` is set by this function.
StatusCode status = 
  soft_timer_start(uint32_t duration_us, soft_timer_callback callback,
          void* context, uint8_t* id_returned);

// Checks if timers are active.
bool working = soft_timer_inuse();
Possible addition:
soft_timer_stop(uint8_t timer_id) which would cancel/stop/disarm a timer by it's ID. I'm not sure how useful this is given the callbacks will have access to the timer_id but if it is requested it isn't too hard to add.","The way I've defined CAN acknowledgements is generic and independent of periodic messages like a heartbeat. When a critical message is sent, we add a ACK request to a list of waiting ACKs on the host. This also creates an associated timer. When an ACK is received on the host matching the requested ACK ID, the ACK callback is fired. Once we've received the expected number of ACKs, the ACK request and its associated timer is invalidated. Otherwise, if the timer fires before all ACKs are received, the ACK request is canceled and the callback is fired with a timeout error.
Since this timer is created for every critical message, we'd probably run out of timers pretty quickly if we weren't able to invalidate them.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,34,2017-02-12T20:23:43Z,2017-02-25T03:54:54Z,2017-02-25T03:54:58Z,MERGED,True,692,21,16,https://github.com/ckitagawa,ELEC-37 Event-driven software timers,54,[],https://github.com/uw-midsun/firmware/pull/34,https://github.com/ckitagawa,5,https://github.com/uw-midsun/firmware/pull/34#issuecomment-279902700,"Event-driven software timer support on x86 Linux (using signals) and stm32f0xx (using TIM2).
#include <stdbool.h>
#include <stdint.h>

#include ""interrupt.h""
#include ""soft_timer.h""
#include ""status.h""

// Usage:

// Initialization.
interrupt_init();
soft_timer_init();

// The callback will run once the duration_us has expired. 
// The callback is passed the `id_returned` and `context` as arguments. 
// The `id_returned` is set by this function.
StatusCode status = 
  soft_timer_start(uint32_t duration_us, soft_timer_callback callback,
          void* context, uint8_t* id_returned);

// Checks if timers are active.
bool working = soft_timer_inuse();
Possible addition:
soft_timer_stop(uint8_t timer_id) which would cancel/stop/disarm a timer by it's ID. I'm not sure how useful this is given the callbacks will have access to the timer_id but if it is requested it isn't too hard to add.","Resolved all of @karlding  and @tituschow comments in last two commits.

Added cancel functionality.
Use CC1 on stm32f0xx.
SYSCLK -> PCLK
Validated rollovers.
Validated double fires.
Volatile markers.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,34,2017-02-12T20:23:43Z,2017-02-25T03:54:54Z,2017-02-25T03:54:58Z,MERGED,True,692,21,16,https://github.com/ckitagawa,ELEC-37 Event-driven software timers,54,[],https://github.com/uw-midsun/firmware/pull/34,https://github.com/karlding,6,https://github.com/uw-midsun/firmware/pull/34#issuecomment-280523513,"Event-driven software timer support on x86 Linux (using signals) and stm32f0xx (using TIM2).
#include <stdbool.h>
#include <stdint.h>

#include ""interrupt.h""
#include ""soft_timer.h""
#include ""status.h""

// Usage:

// Initialization.
interrupt_init();
soft_timer_init();

// The callback will run once the duration_us has expired. 
// The callback is passed the `id_returned` and `context` as arguments. 
// The `id_returned` is set by this function.
StatusCode status = 
  soft_timer_start(uint32_t duration_us, soft_timer_callback callback,
          void* context, uint8_t* id_returned);

// Checks if timers are active.
bool working = soft_timer_inuse();
Possible addition:
soft_timer_stop(uint8_t timer_id) which would cancel/stop/disarm a timer by it's ID. I'm not sure how useful this is given the callbacks will have access to the timer_id but if it is requested it isn't too hard to add.","You probably need to rebase your branch, since you've moved the extra_unity.h file, and merged in the GPIO interrupt stuff earlier.",True,{'THUMBS_UP': ['https://github.com/ckitagawa']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,34,2017-02-12T20:23:43Z,2017-02-25T03:54:54Z,2017-02-25T03:54:58Z,MERGED,True,692,21,16,https://github.com/ckitagawa,ELEC-37 Event-driven software timers,54,[],https://github.com/uw-midsun/firmware/pull/34,https://github.com/ckitagawa,7,https://github.com/uw-midsun/firmware/pull/34#issuecomment-281859223,"Event-driven software timer support on x86 Linux (using signals) and stm32f0xx (using TIM2).
#include <stdbool.h>
#include <stdint.h>

#include ""interrupt.h""
#include ""soft_timer.h""
#include ""status.h""

// Usage:

// Initialization.
interrupt_init();
soft_timer_init();

// The callback will run once the duration_us has expired. 
// The callback is passed the `id_returned` and `context` as arguments. 
// The `id_returned` is set by this function.
StatusCode status = 
  soft_timer_start(uint32_t duration_us, soft_timer_callback callback,
          void* context, uint8_t* id_returned);

// Checks if timers are active.
bool working = soft_timer_inuse();
Possible addition:
soft_timer_stop(uint8_t timer_id) which would cancel/stop/disarm a timer by it's ID. I'm not sure how useful this is given the callbacks will have access to the timer_id but if it is requested it isn't too hard to add.","Refactored stm32f0xx to be backed by a doubly linked list. This speeds up all interrupts as they can be scheduled during an interrupt much faster. However, this is slightly more costly in terms of insertion and cancellation delays. My tests show the worst case resolution of starting and differentiating interrupts is between 50 and 75 us on the stm32f0xx running at 8 MHz. This is awesome as we can probably expect 4-6 times increase in resolution running at higher speeds. Obviously x86 can handle nanoseconds but we can't really hope to match that on stm32f0xx.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,34,2017-02-12T20:23:43Z,2017-02-25T03:54:54Z,2017-02-25T03:54:58Z,MERGED,True,692,21,16,https://github.com/ckitagawa,ELEC-37 Event-driven software timers,54,[],https://github.com/uw-midsun/firmware/pull/34,https://github.com/ckitagawa,8,https://github.com/uw-midsun/firmware/pull/34#issuecomment-281865609,"Event-driven software timer support on x86 Linux (using signals) and stm32f0xx (using TIM2).
#include <stdbool.h>
#include <stdint.h>

#include ""interrupt.h""
#include ""soft_timer.h""
#include ""status.h""

// Usage:

// Initialization.
interrupt_init();
soft_timer_init();

// The callback will run once the duration_us has expired. 
// The callback is passed the `id_returned` and `context` as arguments. 
// The `id_returned` is set by this function.
StatusCode status = 
  soft_timer_start(uint32_t duration_us, soft_timer_callback callback,
          void* context, uint8_t* id_returned);

// Checks if timers are active.
bool working = soft_timer_inuse();
Possible addition:
soft_timer_stop(uint8_t timer_id) which would cancel/stop/disarm a timer by it's ID. I'm not sure how useful this is given the callbacks will have access to the timer_id but if it is requested it isn't too hard to add.","@karlding Any ideas why the Travis CI is segfaulting on gpio_it_runner? It works fine locally, I've committed everything and built again from scratch.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,34,2017-02-12T20:23:43Z,2017-02-25T03:54:54Z,2017-02-25T03:54:58Z,MERGED,True,692,21,16,https://github.com/ckitagawa,ELEC-37 Event-driven software timers,54,[],https://github.com/uw-midsun/firmware/pull/34,https://github.com/karlding,9,https://github.com/uw-midsun/firmware/pull/34#issuecomment-281867092,"Event-driven software timer support on x86 Linux (using signals) and stm32f0xx (using TIM2).
#include <stdbool.h>
#include <stdint.h>

#include ""interrupt.h""
#include ""soft_timer.h""
#include ""status.h""

// Usage:

// Initialization.
interrupt_init();
soft_timer_init();

// The callback will run once the duration_us has expired. 
// The callback is passed the `id_returned` and `context` as arguments. 
// The `id_returned` is set by this function.
StatusCode status = 
  soft_timer_start(uint32_t duration_us, soft_timer_callback callback,
          void* context, uint8_t* id_returned);

// Checks if timers are active.
bool working = soft_timer_inuse();
Possible addition:
soft_timer_stop(uint8_t timer_id) which would cancel/stop/disarm a timer by it's ID. I'm not sure how useful this is given the callbacks will have access to the timer_id but if it is requested it isn't too hard to add.",I'll look into the Travis failure.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,34,2017-02-12T20:23:43Z,2017-02-25T03:54:54Z,2017-02-25T03:54:58Z,MERGED,True,692,21,16,https://github.com/ckitagawa,ELEC-37 Event-driven software timers,54,[],https://github.com/uw-midsun/firmware/pull/34,https://github.com/ckitagawa,10,https://github.com/uw-midsun/firmware/pull/34#issuecomment-282457711,"Event-driven software timer support on x86 Linux (using signals) and stm32f0xx (using TIM2).
#include <stdbool.h>
#include <stdint.h>

#include ""interrupt.h""
#include ""soft_timer.h""
#include ""status.h""

// Usage:

// Initialization.
interrupt_init();
soft_timer_init();

// The callback will run once the duration_us has expired. 
// The callback is passed the `id_returned` and `context` as arguments. 
// The `id_returned` is set by this function.
StatusCode status = 
  soft_timer_start(uint32_t duration_us, soft_timer_callback callback,
          void* context, uint8_t* id_returned);

// Checks if timers are active.
bool working = soft_timer_inuse();
Possible addition:
soft_timer_stop(uint8_t timer_id) which would cancel/stop/disarm a timer by it's ID. I'm not sure how useful this is given the callbacks will have access to the timer_id but if it is requested it isn't too hard to add.","Added documentation to the file but yes the DLL is ordered.
The x86 implementation uses a set timers each of which triggers an interrupt when finished. Since there are 10 interrupt sources and only one interrupt handler registered this signal is demultiplexed to a single handler which fires callbacks for all finished timers (in the event multiple interrupts are received at once). Instead of tracking the next timer it just tracks how many timers are active. I could have registered 10 interrupt callbacks but this didn't scale well.
I added a time remaining function, the issue is you need to know whether your timer expired or not. This is because currently, I am reusing the timer ids after they expire. So for instance, if you call it after the timer expires there is no guarantee the time remaining will be for your instance of that timer. I'm not sure if we will ever actually run into this issue but if we do I can add some kind of modulus based ID or a mapping to timer ID values.
I fixed the CI issue by tracking down a buffer overflow with asan in clang. I'm going to add some options to the x86 makefiles to support building with clang/llvm using asan and possibly tsan to aid in debugging.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,35,2017-02-21T04:59:34Z,2017-02-23T02:00:36Z,2017-05-19T06:30:41Z,CLOSED,False,127,0,2,https://github.com/boowangoo,ELEC-107: Add uart.c & uart.h,1,[],https://github.com/uw-midsun/firmware/pull/35,https://github.com/boowangoo,1,https://github.com/uw-midsun/firmware/pull/35,"Incomplete,
TODO: usage of GPIO","Incomplete,
TODO: usage of GPIO",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,35,2017-02-21T04:59:34Z,2017-02-23T02:00:36Z,2017-05-19T06:30:41Z,CLOSED,False,127,0,2,https://github.com/boowangoo,ELEC-107: Add uart.c & uart.h,1,[],https://github.com/uw-midsun/firmware/pull/35,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/35#issuecomment-281867594,"Incomplete,
TODO: usage of GPIO",Closing incomplete PR - It was just used to gauge progress.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,36,2017-02-25T16:48:47Z,2017-02-26T01:52:29Z,2017-02-26T01:52:34Z,MERGED,True,74,4,4,https://github.com/ckitagawa,ELEC-111 Clang Tools Support,1,[],https://github.com/uw-midsun/firmware/pull/36,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/36,"Added support and documentation for optionally using clang instead of gcc on x86. This adds support for memory sanitization, leak checking and stack traces via ASAN and race condition checks via TSAN. Also added documentation on using Build EAR and clang-tidy for static analysis.
For users uninterested in these features they are entirely opt-in, there is no change to the existing build workflow and no additional downloads are needed to keep working as you have been. They simply make my life easier when writing x86 code.
Added variables to the x86 paltform.mk for COMPILER= [gcc | clang] COPTIONS = [asan | tsan]. gcc without options remains the default.
@karlding I'll leave it up to you whether or not to change/add a Travis CI check for x86 tests that builds with ASAN enabled. This would provide stack traces on segfaults which would be nice but it would also entail adding clang/llvm to the CI. The bash for this would be
$ make test PLATFORM=x86 COMPILER=clang COPTIONS=asan","Added support and documentation for optionally using clang instead of gcc on x86. This adds support for memory sanitization, leak checking and stack traces via ASAN and race condition checks via TSAN. Also added documentation on using Build EAR and clang-tidy for static analysis.
For users uninterested in these features they are entirely opt-in, there is no change to the existing build workflow and no additional downloads are needed to keep working as you have been. They simply make my life easier when writing x86 code.
Added variables to the x86 paltform.mk for COMPILER= [gcc | clang] COPTIONS = [asan | tsan]. gcc without options remains the default.
@karlding I'll leave it up to you whether or not to change/add a Travis CI check for x86 tests that builds with ASAN enabled. This would provide stack traces on segfaults which would be nice but it would also entail adding clang/llvm to the CI. The bash for this would be
$ make test PLATFORM=x86 COMPILER=clang COPTIONS=asan",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,36,2017-02-25T16:48:47Z,2017-02-26T01:52:29Z,2017-02-26T01:52:34Z,MERGED,True,74,4,4,https://github.com/ckitagawa,ELEC-111 Clang Tools Support,1,[],https://github.com/uw-midsun/firmware/pull/36,https://github.com/karlding,2,https://github.com/uw-midsun/firmware/pull/36#issuecomment-282496866,"Added support and documentation for optionally using clang instead of gcc on x86. This adds support for memory sanitization, leak checking and stack traces via ASAN and race condition checks via TSAN. Also added documentation on using Build EAR and clang-tidy for static analysis.
For users uninterested in these features they are entirely opt-in, there is no change to the existing build workflow and no additional downloads are needed to keep working as you have been. They simply make my life easier when writing x86 code.
Added variables to the x86 paltform.mk for COMPILER= [gcc | clang] COPTIONS = [asan | tsan]. gcc without options remains the default.
@karlding I'll leave it up to you whether or not to change/add a Travis CI check for x86 tests that builds with ASAN enabled. This would provide stack traces on segfaults which would be nice but it would also entail adding clang/llvm to the CI. The bash for this would be
$ make test PLATFORM=x86 COMPILER=clang COPTIONS=asan","Hmm, last week, I was actually looking into static code analysis options we could use (managed to get facebook/infer building and everything, but it didn't seem to support embedded very well).
I'll probably have to push out a new Vagrant box image once this get merged in, but that should be fine. I can bundle the other changes that need to be made together with that.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,36,2017-02-25T16:48:47Z,2017-02-26T01:52:29Z,2017-02-26T01:52:34Z,MERGED,True,74,4,4,https://github.com/ckitagawa,ELEC-111 Clang Tools Support,1,[],https://github.com/uw-midsun/firmware/pull/36,https://github.com/ckitagawa,3,https://github.com/uw-midsun/firmware/pull/36#issuecomment-282526338,"Added support and documentation for optionally using clang instead of gcc on x86. This adds support for memory sanitization, leak checking and stack traces via ASAN and race condition checks via TSAN. Also added documentation on using Build EAR and clang-tidy for static analysis.
For users uninterested in these features they are entirely opt-in, there is no change to the existing build workflow and no additional downloads are needed to keep working as you have been. They simply make my life easier when writing x86 code.
Added variables to the x86 paltform.mk for COMPILER= [gcc | clang] COPTIONS = [asan | tsan]. gcc without options remains the default.
@karlding I'll leave it up to you whether or not to change/add a Travis CI check for x86 tests that builds with ASAN enabled. This would provide stack traces on segfaults which would be nice but it would also entail adding clang/llvm to the CI. The bash for this would be
$ make test PLATFORM=x86 COMPILER=clang COPTIONS=asan",@tituschow most of this is only supported on x86 Linux os it will work for generic libraries and project code but not with the stm32f0xx side of ms-common. Only clang-tidy for static analysis using Build EAR works on both embedded and emulated code.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,37,2017-03-11T18:23:55Z,2017-03-11T18:46:15Z,2017-03-11T18:46:20Z,MERGED,True,8,2,2,https://github.com/ckitagawa,ELEC-116 x86_interrupt bug fix.,1,[],https://github.com/uw-midsun/firmware/pull/37,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/37,"Calling getpid() from a thread other than the main thread would result in an incorrect software interrupt trigger. To resolve this issue a static pid should be recorded from the initializing thread.
Update gpio.h docs.","Calling getpid() from a thread other than the main thread would result in an incorrect software interrupt trigger. To resolve this issue a static pid should be recorded from the initializing thread.
Update gpio.h docs.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,38,2017-03-18T22:04:16Z,2017-03-18T22:06:09Z,2017-03-18T22:06:14Z,CLOSED,False,219,1,3,https://github.com/eric98zhang,ELEC-20: ALTFN pinsource bugfix,10,[],https://github.com/uw-midsun/firmware/pull/38,https://github.com/eric98zhang,1,https://github.com/uw-midsun/firmware/pull/38,,,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,39,2017-03-18T22:24:01Z,2017-03-18T23:20:45Z,2017-05-19T06:30:45Z,MERGED,True,1,1,1,https://github.com/eric98zhang,ELEC-20: Fixed ALTFN pinsource,1,[],https://github.com/uw-midsun/firmware/pull/39,https://github.com/eric98zhang,1,https://github.com/uw-midsun/firmware/pull/39,,,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,40,2017-05-09T16:37:51Z,2017-05-15T13:48:18Z,2017-05-19T06:32:23Z,MERGED,True,133,137,8,https://github.com/tituschow,"ELEC-88 ELEC-140: Retarget STDOUT to UART, run at 48Mhz",5,[],https://github.com/uw-midsun/firmware/pull/40,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/40,"Retargets STDOUT to UART so printf outputs to USART1 (PB6: TX, PB7: RX). I needed to remove gpio_init's deinit of the GPIO clocks so my IO changes would stick. Alternatively, we could just move retargeting into ms-common.
Also fixes config so we actually run at 48Mhz using the HSI.","Retargets STDOUT to UART so printf outputs to USART1 (PB6: TX, PB7: RX). I needed to remove gpio_init's deinit of the GPIO clocks so my IO changes would stick. Alternatively, we could just move retargeting into ms-common.
Also fixes config so we actually run at 48Mhz using the HSI.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,41,2017-05-15T17:20:53Z,2017-05-19T19:57:14Z,2017-05-20T19:53:58Z,MERGED,True,259,73,17,https://github.com/tituschow,ELEC-61: Added STM32 SPI support,7,[],https://github.com/uw-midsun/firmware/pull/41,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/41,"Added a basic blocking driver for SPI. The test project has been modified to demonstrate SPI on the discovery board. I didn't add a test because the only thing we could really test is whether it works, and that requires hardware support. Additionally, there's no reason to emulate SPI so our test would need to run only for STM32.
Also renamed _cfg to _mcu and added GPIO_PORT enums.","Added a basic blocking driver for SPI. The test project has been modified to demonstrate SPI on the discovery board. I didn't add a test because the only thing we could really test is whether it works, and that requires hardware support. Additionally, there's no reason to emulate SPI so our test would need to run only for STM32.
Also renamed _cfg to _mcu and added GPIO_PORT enums.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,42,2017-05-15T19:35:44Z,2017-05-20T20:01:44Z,2017-05-20T20:01:48Z,MERGED,True,28,0,2,https://github.com/tituschow,ELEC-93: Added log macro,6,[],https://github.com/uw-midsun/firmware/pull/42,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/42,"Added LOG macro - 0: Debug, 1: Warn, 2: Fault
Usage: LOG(level, fmt, ...) or LOG_level(fmt, ...)
Example output:
[0] project/test_project/src/main.c:29:51730
[2] project/test_project/src/main.c:30:???
[0] project/test_project/src/main.c:29:51740
[2] project/test_project/src/main.c:30:???

I'm thinking we can use hash string literals (ELEC-59) to reduce code size if they take too much space. Alternatively, the source file isn't strictly necessary.","Added LOG macro - 0: Debug, 1: Warn, 2: Fault
Usage: LOG(level, fmt, ...) or LOG_level(fmt, ...)
Example output:
[0] project/test_project/src/main.c:29:51730
[2] project/test_project/src/main.c:30:???
[0] project/test_project/src/main.c:29:51740
[2] project/test_project/src/main.c:30:???

I'm thinking we can use hash string literals (ELEC-59) to reduce code size if they take too much space. Alternatively, the source file isn't strictly necessary.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,43,2017-05-16T07:26:28Z,2017-05-19T06:28:54Z,2017-05-20T19:54:00Z,MERGED,True,42,40,7,https://github.com/tituschow,ELEC-143: CMSIS-DAP support,7,[],https://github.com/uw-midsun/firmware/pull/43,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/43,"Adds support for our ST-Link clones running the dap42 firmware and cleans up test handling a lot. Uses the CMSIS-DAP probe by default - to use with an stlink, add PROBE=stlink-v2.
Serial support is still a TODO - I wasn't able to pass the serial port through to my VM properly. @ckitagawa, can you let me know what setup you ended up using to receive serial data?","Adds support for our ST-Link clones running the dap42 firmware and cleans up test handling a lot. Uses the CMSIS-DAP probe by default - to use with an stlink, add PROBE=stlink-v2.
Serial support is still a TODO - I wasn't able to pass the serial port through to my VM properly. @ckitagawa, can you let me know what setup you ended up using to receive serial data?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,43,2017-05-16T07:26:28Z,2017-05-19T06:28:54Z,2017-05-20T19:54:00Z,MERGED,True,42,40,7,https://github.com/tituschow,ELEC-143: CMSIS-DAP support,7,[],https://github.com/uw-midsun/firmware/pull/43,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/43#issuecomment-302381069,"Adds support for our ST-Link clones running the dap42 firmware and cleans up test handling a lot. Uses the CMSIS-DAP probe by default - to use with an stlink, add PROBE=stlink-v2.
Serial support is still a TODO - I wasn't able to pass the serial port through to my VM properly. @ckitagawa, can you let me know what setup you ended up using to receive serial data?","Maybe hold off on submitting. I'm wondering if for  the platform.mk script to be dumb and just used as gdb (for individual tests) and openocd without the serial reader program automatically opening? Personally I would prefer to just open a persistent serial reader session and use it without trying to integrate it into a tmux session. This way, the messages persist and you can start it before any commands fixing the timing issue. I know it is slightly more inconvenient to run two commands but I see a lot of value in having the serial window persist across sessions (you can see past tests and progress on fixes as you go, no timing problems, people can use any program they want and do so in the windows environment using Putty avoiding any virtual box issues). Thoughts?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,43,2017-05-16T07:26:28Z,2017-05-19T06:28:54Z,2017-05-20T19:54:00Z,MERGED,True,42,40,7,https://github.com/tituschow,ELEC-143: CMSIS-DAP support,7,[],https://github.com/uw-midsun/firmware/pull/43,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/43#issuecomment-302618861,"Adds support for our ST-Link clones running the dap42 firmware and cleans up test handling a lot. Uses the CMSIS-DAP probe by default - to use with an stlink, add PROBE=stlink-v2.
Serial support is still a TODO - I wasn't able to pass the serial port through to my VM properly. @ckitagawa, can you let me know what setup you ended up using to receive serial data?",Removed serial output and cleaned up GDB support to allow debugging tests.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,44,2017-05-16T07:27:52Z,2017-05-18T03:34:42Z,2017-05-19T06:30:15Z,MERGED,True,30,4,2,https://github.com/tituschow,ELEC-44: Added critical sections to objpool and pqueue,2,[],https://github.com/uw-midsun/firmware/pull/44,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/44,"Simple change to protect sections and make our data structures atomic. I didn't really think very hard about this one, so let me know if I messed something up. We may want to add some tests to verify that we handle ISRs properly.","Simple change to protect sections and make our data structures atomic. I didn't really think very hard about this one, so let me know if I messed something up. We may want to add some tests to verify that we handle ISRs properly.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,45,2017-05-17T06:27:31Z,2017-05-17T12:42:47Z,2017-06-02T05:32:14Z,MERGED,True,1,1,1,https://github.com/karlding,ELEC-153: Remove qq flag from GCC ARM install step,1,[],https://github.com/uw-midsun/firmware/pull/45,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/45,"Replace -qq flag with -y.
-qq No output except for errors

Travis is killing the job due to installs taking more than 10 minutes. Since qq suppresses all output, no output is produced, and Travis will kill any job with no log output produced.","Replace -qq flag with -y.
-qq No output except for errors

Travis is killing the job due to installs taking more than 10 minutes. Since qq suppresses all output, no output is produced, and Travis will kill any job with no log output produced.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,46,2017-05-19T21:17:26Z,2017-05-19T21:38:51Z,2017-05-20T19:53:56Z,MERGED,True,2,2,2,https://github.com/tituschow,ELEC-160: Fixed GDB target,2,[],https://github.com/uw-midsun/firmware/pull/46,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/46,GDB_TARGET was being evaluated before PLATFORM_EXT was assigned. Switched to lazy evaluation to fix it.,GDB_TARGET was being evaluated before PLATFORM_EXT was assigned. Switched to lazy evaluation to fix it.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,47,2017-05-20T16:29:40Z,2017-05-20T18:43:29Z,2017-05-20T19:54:05Z,MERGED,True,3981,3925,1,https://github.com/ckitagawa,ELEC-40 Fix malformed regex,1,[],https://github.com/uw-midsun/firmware/pull/47,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/47,Fixed malformed regex for the #endif comment lint category and also applied pylint PEP-8 styling to the file. Blocking ELEC-93 due to CI issues ATM.,Fixed malformed regex for the #endif comment lint category and also applied pylint PEP-8 styling to the file. Blocking ELEC-93 due to CI issues ATM.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,48,2017-05-25T19:31:26Z,2017-05-25T21:26:44Z,2017-05-25T21:27:19Z,MERGED,True,302,4,6,https://github.com/tituschow,ELEC-179: FIFO,8,[],https://github.com/uw-midsun/firmware/pull/48,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/48,"Implemented a basic FIFO using a ring buffer. I'm planning on using this for UART and CAN.
Tested on x86 and STM32F0xx.","Implemented a basic FIFO using a ring buffer. I'm planning on using this for UART and CAN.
Tested on x86 and STM32F0xx.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,49,2017-06-03T18:01:51Z,2017-06-03T20:43:53Z,2017-06-03T20:43:56Z,MERGED,True,251,27,6,https://github.com/tituschow,ELEC-107: UART driver for STM32F0x,8,[],https://github.com/uw-midsun/firmware/pull/49,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/49,"Adds non-blocking driver for STM32F0x. Uses 2 FIFOs, one for RX and one for TX.
Tested with USART1 on the discovery board.","Adds non-blocking driver for STM32F0x. Uses 2 FIFOs, one for RX and one for TX.
Tested with USART1 on the discovery board.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,49,2017-06-03T18:01:51Z,2017-06-03T20:43:53Z,2017-06-03T20:43:56Z,MERGED,True,251,27,6,https://github.com/tituschow,ELEC-107: UART driver for STM32F0x,8,[],https://github.com/uw-midsun/firmware/pull/49,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/49#issuecomment-305993047,"Adds non-blocking driver for STM32F0x. Uses 2 FIFOs, one for RX and one for TX.
Tested with USART1 on the discovery board.",Travis CI is failing because uart.c should live under libraries/ms-common/src/stm32f0xx/uart.c and you need a stubbed out version for x86. Fix please!,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,50,2017-06-04T01:01:18Z,2017-06-04T04:17:14Z,2017-06-04T04:25:22Z,MERGED,True,164,0,5,https://github.com/karlding,ELEC-193: Add CRC15 implementation used for the LTC6804-1,7,[],https://github.com/uw-midsun/firmware/pull/50,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/50,"Adding the CRC15 implementation used for the PEC used in the LTC6804-1's SPI commands.
I ripped off a bunch of data from the examples in the datasheet for these unit tests (I also suspect one of the examples is incorrect, since all the other examples work, and half a byte differs in the test case that fails, but I haven't verified that manually yet).","Adding the CRC15 implementation used for the PEC used in the LTC6804-1's SPI commands.
I ripped off a bunch of data from the examples in the datasheet for these unit tests (I also suspect one of the examples is incorrect, since all the other examples work, and half a byte differs in the test case that fails, but I haven't verified that manually yet).",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,51,2017-06-11T03:53:14Z,2017-06-11T16:11:58Z,2017-06-11T16:12:01Z,MERGED,True,308,381,9,https://github.com/tituschow,ELEC-195: Fixed soft timers,10,[],https://github.com/uw-midsun/firmware/pull/51,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/51,"No idea what the difference between this implementation and @ckitagawa's is, but I rewrote the STM32 implementation and it seems to work now.
Tested on STM32F0xx, x86. Test cases were rewritten as part of the fix, but both the test cases and implementation are functionally equivalent to the original. The x86 implementation was not touched.","No idea what the difference between this implementation and @ckitagawa's is, but I rewrote the STM32 implementation and it seems to work now.
Tested on STM32F0xx, x86. Test cases were rewritten as part of the fix, but both the test cases and implementation are functionally equivalent to the original. The x86 implementation was not touched.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,52,2017-06-12T02:16:24Z,2017-06-19T21:25:30Z,2017-06-19T21:25:34Z,MERGED,True,1473,18,31,https://github.com/tituschow,ELEC-55: STM32F0xx CAN support,33,[],https://github.com/uw-midsun/firmware/pull/52,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/52,"This is a big dump of CAN. I will most likely split this into multiple PRs for ease of understanding, but this is here for context.
The idea is that there is a low-level HW layer and a high-level network layer. The HW layer is platform-specific and handles raw CAN messages. The network layer handles device/message IDs, RX/TX queues, RX handlers, and ACK requests.
The idea behind the network layer is that RX/TX queues should be used to buffer CAN messages. RX messages are buffered until an RX FSM is used to process received messages (passing it to a registered handler) or handle ACK responses (finding the corresponding pending ACK request).
TODO: I don't have a good way to determine which messages require ACKs. I think the easiest way to do this is to either reserve a bit for ""ACK requested"" or build a minimum ID into the codegen.","This is a big dump of CAN. I will most likely split this into multiple PRs for ease of understanding, but this is here for context.
The idea is that there is a low-level HW layer and a high-level network layer. The HW layer is platform-specific and handles raw CAN messages. The network layer handles device/message IDs, RX/TX queues, RX handlers, and ACK requests.
The idea behind the network layer is that RX/TX queues should be used to buffer CAN messages. RX messages are buffered until an RX FSM is used to process received messages (passing it to a registered handler) or handle ACK responses (finding the corresponding pending ACK request).
TODO: I don't have a good way to determine which messages require ACKs. I think the easiest way to do this is to either reserve a bit for ""ACK requested"" or build a minimum ID into the codegen.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,52,2017-06-12T02:16:24Z,2017-06-19T21:25:30Z,2017-06-19T21:25:34Z,MERGED,True,1473,18,31,https://github.com/tituschow,ELEC-55: STM32F0xx CAN support,33,[],https://github.com/uw-midsun/firmware/pull/52,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/52#issuecomment-309307565,"This is a big dump of CAN. I will most likely split this into multiple PRs for ease of understanding, but this is here for context.
The idea is that there is a low-level HW layer and a high-level network layer. The HW layer is platform-specific and handles raw CAN messages. The network layer handles device/message IDs, RX/TX queues, RX handlers, and ACK requests.
The idea behind the network layer is that RX/TX queues should be used to buffer CAN messages. RX messages are buffered until an RX FSM is used to process received messages (passing it to a registered handler) or handle ACK responses (finding the corresponding pending ACK request).
TODO: I don't have a good way to determine which messages require ACKs. I think the easiest way to do this is to either reserve a bit for ""ACK requested"" or build a minimum ID into the codegen.",I've addressed the comments and created another ticket (ELEC-202) to track critical messages. ELEC-203 tracks the case where we might want to switch to the indexed method.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,52,2017-06-12T02:16:24Z,2017-06-19T21:25:30Z,2017-06-19T21:25:34Z,MERGED,True,1473,18,31,https://github.com/tituschow,ELEC-55: STM32F0xx CAN support,33,[],https://github.com/uw-midsun/firmware/pull/52,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/52#issuecomment-309337816,"This is a big dump of CAN. I will most likely split this into multiple PRs for ease of understanding, but this is here for context.
The idea is that there is a low-level HW layer and a high-level network layer. The HW layer is platform-specific and handles raw CAN messages. The network layer handles device/message IDs, RX/TX queues, RX handlers, and ACK requests.
The idea behind the network layer is that RX/TX queues should be used to buffer CAN messages. RX messages are buffered until an RX FSM is used to process received messages (passing it to a registered handler) or handle ACK responses (finding the corresponding pending ACK request).
TODO: I don't have a good way to determine which messages require ACKs. I think the easiest way to do this is to either reserve a bit for ""ACK requested"" or build a minimum ID into the codegen.",@karlding - Any other concerns?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,53,2017-06-13T00:07:31Z,2017-06-17T02:27:35Z,2017-06-17T02:27:38Z,MERGED,True,87,42,12,https://github.com/tituschow,ELEC-159: Support excluding tests per-platform,6,[],https://github.com/uw-midsun/firmware/pull/53,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/53,Supports filtering out tests. I plan on using this to exclude tests by checking for the current platform and defining $(T)_EXCLUDE_TESTS := can can_rx ....,Supports filtering out tests. I plan on using this to exclude tests by checking for the current platform and defining $(T)_EXCLUDE_TESTS := can can_rx ....,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,54,2017-06-13T01:15:14Z,2017-06-13T18:56:06Z,2017-06-13T18:56:09Z,MERGED,True,48,7,4,https://github.com/tituschow,ELEC-200: Added FSM transitions,1,[],https://github.com/uw-midsun/firmware/pull/54,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/54,"Adds support for basic FSM transition guards. I haven't fully fleshed out what information guards should have, but I'd like to limit them to the minimum.","Adds support for basic FSM transition guards. I haven't fully fleshed out what information guards should have, but I'd like to limit them to the minimum.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,55,2017-06-19T21:32:03Z,2017-07-05T16:14:41Z,2017-07-05T16:15:50Z,MERGED,True,501,1,7,https://github.com/Derpalooza,ELEC-164: STM32F0xx ADC driver,48,[],https://github.com/uw-midsun/firmware/pull/55,https://github.com/Derpalooza,1,https://github.com/uw-midsun/firmware/pull/55,A driver for the STM32f0xx's Analog-to-Digital Converter. Supports both conversions in single and continuous modes.,A driver for the STM32f0xx's Analog-to-Digital Converter. Supports both conversions in single and continuous modes.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,55,2017-06-19T21:32:03Z,2017-07-05T16:14:41Z,2017-07-05T16:15:50Z,MERGED,True,501,1,7,https://github.com/Derpalooza,ELEC-164: STM32F0xx ADC driver,48,[],https://github.com/uw-midsun/firmware/pull/55,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/55#issuecomment-309797540,A driver for the STM32f0xx's Analog-to-Digital Converter. Supports both conversions in single and continuous modes.,"I think you're missing the actual source file. Also, is there a reason you removed the test project?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,55,2017-06-19T21:32:03Z,2017-07-05T16:14:41Z,2017-07-05T16:15:50Z,MERGED,True,501,1,7,https://github.com/Derpalooza,ELEC-164: STM32F0xx ADC driver,48,[],https://github.com/uw-midsun/firmware/pull/55,https://github.com/karlding,3,https://github.com/uw-midsun/firmware/pull/55#issuecomment-309798365,A driver for the STM32f0xx's Analog-to-Digital Converter. Supports both conversions in single and continuous modes.,"The reason why your build hasn't run is because of the merge conflict. Travis uses the merge commit for a PR to do the build.
Once you fix the merge conflict in project/test_project/rules.mk, Travis should successfully run.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,55,2017-06-19T21:32:03Z,2017-07-05T16:14:41Z,2017-07-05T16:15:50Z,MERGED,True,501,1,7,https://github.com/Derpalooza,ELEC-164: STM32F0xx ADC driver,48,[],https://github.com/uw-midsun/firmware/pull/55,https://github.com/Derpalooza,4,https://github.com/uw-midsun/firmware/pull/55#issuecomment-311163325,A driver for the STM32f0xx's Analog-to-Digital Converter. Supports both conversions in single and continuous modes.,"The ADC Driver has been reworked to use interrupts to record readings, as this would better allow it to take advantage of the ADC's continuous mode. The API also no longer requires the user to present pin addresses to work with, as the channels are already mapped to specific pins on the STM32.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,55,2017-06-19T21:32:03Z,2017-07-05T16:14:41Z,2017-07-05T16:15:50Z,MERGED,True,501,1,7,https://github.com/Derpalooza,ELEC-164: STM32F0xx ADC driver,48,[],https://github.com/uw-midsun/firmware/pull/55,https://github.com/karlding,5,https://github.com/uw-midsun/firmware/pull/55#issuecomment-311717758,A driver for the STM32f0xx's Analog-to-Digital Converter. Supports both conversions in single and continuous modes.,"@Derpalooza, if you need some help on how to restore the test project, you can follow these instructions. First find the commit that still contains the project/test_project/src/main.c file by looking through the commit history.
git log -- project/test_project/src/main.c
Look for the commit before the one where you made your changes. This gives you commit hash 67760ab66a3300740d52ab3f1c61797933d75a01.
Then checkout the file revision at that commit.
git checkout 67760ab66a3300740d52ab3f1c61797933d75a01 project/test_project/src/main.c",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,55,2017-06-19T21:32:03Z,2017-07-05T16:14:41Z,2017-07-05T16:15:50Z,MERGED,True,501,1,7,https://github.com/Derpalooza,ELEC-164: STM32F0xx ADC driver,48,[],https://github.com/uw-midsun/firmware/pull/55,https://github.com/tituschow,6,https://github.com/uw-midsun/firmware/pull/55#issuecomment-311723112,A driver for the STM32f0xx's Analog-to-Digital Converter. Supports both conversions in single and continuous modes.,I'm pretty sure you could just git checkout master project/test_project or something like that.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,56,2017-07-06T23:26:52Z,2017-07-07T14:03:25Z,2017-07-07T14:03:29Z,MERGED,True,87,11,7,https://github.com/ckitagawa,ELEC-210: Delay and wait module,3,[],https://github.com/uw-midsun/firmware/pull/56,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/56,"Modules to allow delaying for a set period of time in microseconds, milliseconds or seconds backed by the soft timer module. A wait function is also provided to set the stm32f0xx to wait until an interrupt is triggered.","Modules to allow delaying for a set period of time in microseconds, milliseconds or seconds backed by the soft timer module. A wait function is also provided to set the stm32f0xx to wait until an interrupt is triggered.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,57,2017-07-06T23:33:44Z,2017-07-07T14:45:11Z,2017-07-07T14:45:29Z,MERGED,True,178,0,5,https://github.com/ckitagawa,ELEC-205: PWM driver implementation for TIM3 for stm32f0xx,3,[],https://github.com/uw-midsun/firmware/pull/57,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/57,"PWM output module. Reading functionality is not a requirement right now so this is not provided.
stm32f0xx: backed by TIM3 on Channels 1-4 so not all pins can use this but currently this is sufficient for fans on Chaos. The implementation may need adjustment later dependent on where we use PWM and what pins these PWM peripherals are attached to.
x86: Stubbed implementation with guard clauses to pass tests.
Initialization sets the global PWM period and all outputs use the same duty cycle for the sake of simplicity. More fine grain control is possible per channel but has been elided for the sake of interface simplicity.","PWM output module. Reading functionality is not a requirement right now so this is not provided.
stm32f0xx: backed by TIM3 on Channels 1-4 so not all pins can use this but currently this is sufficient for fans on Chaos. The implementation may need adjustment later dependent on where we use PWM and what pins these PWM peripherals are attached to.
x86: Stubbed implementation with guard clauses to pass tests.
Initialization sets the global PWM period and all outputs use the same duty cycle for the sake of simplicity. More fine grain control is possible per channel but has been elided for the sake of interface simplicity.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,58,2017-07-12T17:47:46Z,2017-07-19T04:46:01Z,2017-07-19T04:46:04Z,MERGED,True,210,3,8,https://github.com/tituschow,ELEC-206: I2C driver for STM32F0xx,15,[],https://github.com/uw-midsun/firmware/pull/58,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/58,"Blocking I2C driver - tested with I2C1 at standard and fast modes.
Successfully communicated with MCP23008 and TLV493D.
No test because I'm not really sure how we'd test this driver. I'll be adding functional testing for the I2C slaves later on, so hopefully that's enough.","Blocking I2C driver - tested with I2C1 at standard and fast modes.
Successfully communicated with MCP23008 and TLV493D.
No test because I'm not really sure how we'd test this driver. I'll be adding functional testing for the I2C slaves later on, so hopefully that's enough.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,59,2017-07-12T19:15:12Z,2017-07-18T21:10:31Z,2017-07-18T21:10:37Z,MERGED,True,122,29,15,https://github.com/tituschow,ELEC-145: Added make target for new projects/libraries,4,[],https://github.com/uw-midsun/firmware/pull/59,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/59,Use make new PROJECT=... or make new LIBRARY=... to create the folder structure and rules.mk for a new project or library. Also cleaned up the argument filters and renamed the project folder to projects.,Use make new PROJECT=... or make new LIBRARY=... to create the folder structure and rules.mk for a new project or library. Also cleaned up the argument filters and renamed the project folder to projects.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,59,2017-07-12T19:15:12Z,2017-07-18T21:10:31Z,2017-07-18T21:10:37Z,MERGED,True,122,29,15,https://github.com/tituschow,ELEC-145: Added make target for new projects/libraries,4,[],https://github.com/uw-midsun/firmware/pull/59,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/59#issuecomment-315114785,Use make new PROJECT=... or make new LIBRARY=... to create the folder structure and rules.mk for a new project or library. Also cleaned up the argument filters and renamed the project folder to projects.,"Apparently people find it difficult to make new projects because they keep overwriting the test project. ):
Yeah I agree on a standard for Python. I'll switch to 4 space tabs and add docstrings.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,60,2017-07-12T21:24:16Z,2017-07-13T15:32:15Z,2017-07-13T15:32:23Z,MERGED,True,18,11,11,https://github.com/tituschow,ELEC-219: Added module dependencies,1,[],https://github.com/uw-midsun/firmware/pull/60,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/60,"Turns out most modules just rely on interrupts, GPIO, and soft timers to be initialized.
I also switched CAN to use the interrupt module.","Turns out most modules just rely on interrupts, GPIO, and soft timers to be initialized.
I also switched CAN to use the interrupt module.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,61,2017-07-12T23:09:57Z,2017-07-26T19:41:07Z,2017-07-26T19:41:12Z,MERGED,True,1667,36,28,https://github.com/Derpalooza,ELEC-198: Refactor Driver Control Code,187,[],https://github.com/uw-midsun/firmware/pull/61,https://github.com/Derpalooza,1,https://github.com/uw-midsun/firmware/pull/61,"The system waits for events from the user. Once an event has been detected, an ISR will be triggered in order to identify the event and raise it under the correct ID. A series of FSMs is used to manage the raised events.
There can exist interdependencies between separate FSMs. As a result, when an event is processed, all active FSMs must observe the event and determine if it is okay to be processed while the FSM is in its current state. This design allows the program to manage inter-FSM dependencies while keeping individual FSM implementations separate.","The system waits for events from the user. Once an event has been detected, an ISR will be triggered in order to identify the event and raise it under the correct ID. A series of FSMs is used to manage the raised events.
There can exist interdependencies between separate FSMs. As a result, when an event is processed, all active FSMs must observe the event and determine if it is okay to be processed while the FSM is in its current state. This design allows the program to manage inter-FSM dependencies while keeping individual FSM implementations separate.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,61,2017-07-12T23:09:57Z,2017-07-26T19:41:07Z,2017-07-26T19:41:12Z,MERGED,True,1667,36,28,https://github.com/Derpalooza,ELEC-198: Refactor Driver Control Code,187,[],https://github.com/uw-midsun/firmware/pull/61,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/61#issuecomment-317222117,"The system waits for events from the user. Once an event has been detected, an ISR will be triggered in order to identify the event and raise it under the correct ID. A series of FSMs is used to manage the raised events.
There can exist interdependencies between separate FSMs. As a result, when an event is processed, all active FSMs must observe the event and determine if it is okay to be processed while the FSM is in its current state. This design allows the program to manage inter-FSM dependencies while keeping individual FSM implementations separate.","For cleanliness and simplicity I recommend you try to separate the CAN message handling from the FSM as much as possible. To do so rely on the global even queue instead of intermixing the code like you are currently doing. For Power Distribution I am planning to achieve this by raising an event specifically for CAN messages that need to be sent and using event_raise(CAN_EVENT, data) this way you can raise a CAN message from the FSM without overlapping the modules. Then in your main loop where you process your events simply pass the event to both FSMs, the CAN one will transition and since you don't register the CAN_EVENT with the main FSM nothing will happen.
e.g.
static void prv_example_fsm_state(struct FSM *fsm, const Event *e, void *context) {
  // Regular state output.

  // Raise the CAN_EVENT (if needed).
  event_raise(CAN_EVENT, some_data).

  // Do more stuff as needed.
}

int main() {
  while(true) {
    Event e;
    event_process(&e);
    // Pass the event to the main FSM.
    fsm_process_event(FSM, &e);
    // Pass the event to the CAN FSM.
    can_process_event(&e);
  }

  return EXIT_SUCCESS;
}
This handles your messages to be sent async and between state transitions. So things will only be sent when you aren't prioritizing state transitions or handling higher priority events. This may cause issues if you need to wait on a message to be sent/acked before ending your transition. However, if that is the case you can still simplify most cases where you don't need an ack before finishing the transition.",True,{'THUMBS_UP': ['https://github.com/tituschow']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,62,2017-07-20T21:08:38Z,2017-07-20T21:12:19Z,2017-07-21T00:17:20Z,CLOSED,False,1058,0,23,https://github.com/Derpalooza,ELEC-229: Event Generator,117,[],https://github.com/uw-midsun/firmware/pull/62,https://github.com/Derpalooza,1,https://github.com/uw-midsun/firmware/pull/62,Split the event generator code into modules for both digital and analog inputs.,Split the event generator code into modules for both digital and analog inputs.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,63,2017-07-21T00:18:52Z,2017-07-21T17:23:35Z,2017-07-21T17:23:41Z,MERGED,True,320,0,12,https://github.com/Derpalooza,ELEC-229: Driver Controls Event Generator,13,[],https://github.com/uw-midsun/firmware/pull/63,https://github.com/Derpalooza,1,https://github.com/uw-midsun/firmware/pull/63,Split the event generator code into modules for both digital and analog inputs.,Split the event generator code into modules for both digital and analog inputs.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,64,2017-07-23T07:05:25Z,2017-07-28T17:31:57Z,2017-07-28T17:31:57Z,CLOSED,False,316,233,16,https://github.com/tituschow,ELEC-203: Updated CAN to settings/storage paradigm.,6,[],https://github.com/uw-midsun/firmware/pull/64,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/64,"I've updated CAN and CAN HW to use the settings/storage paradigms. I think it's much cleaner now that we don't need to mess around with passing what ended up being a global variable anyways.
Also fixed makefile variable filtering, added the ability to build libraries individually, and added GPIO init.
TODO:

 Actually test to make sure GPIO was initialized properly (Will complete on Monday)","I've updated CAN and CAN HW to use the settings/storage paradigms. I think it's much cleaner now that we don't need to mess around with passing what ended up being a global variable anyways.
Also fixed makefile variable filtering, added the ability to build libraries individually, and added GPIO init.
TODO:

 Actually test to make sure GPIO was initialized properly (Will complete on Monday)",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,64,2017-07-23T07:05:25Z,2017-07-28T17:31:57Z,2017-07-28T17:31:57Z,CLOSED,False,316,233,16,https://github.com/tituschow,ELEC-203: Updated CAN to settings/storage paradigm.,6,[],https://github.com/uw-midsun/firmware/pull/64,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/64#issuecomment-318244609,"I've updated CAN and CAN HW to use the settings/storage paradigms. I think it's much cleaner now that we don't need to mess around with passing what ended up being a global variable anyways.
Also fixed makefile variable filtering, added the ability to build libraries individually, and added GPIO init.
TODO:

 Actually test to make sure GPIO was initialized properly (Will complete on Monday)","So I tested this and at higher transmit rates (i.e. trying to flood the network), we run into problems with the transmit itself taking too long. I'm probably going to switch to an event-driven transmit to prevent that from happening. It'll act as a rate-limiter and keep transmits from occupying too much time.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,65,2017-07-26T19:38:39Z,2017-08-23T07:05:42Z,2017-09-11T07:05:48Z,MERGED,True,728,32,12,https://github.com/karlding,ELEC-65: Add LTC6804-1 driver,88,[],https://github.com/uw-midsun/firmware/pull/65,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/65,"I'm not too attached to naming, so feel free to suggest things (it gets pretty ridiculous with things like LTCAFEADCMode tbh).","I'm not too attached to naming, so feel free to suggest things (it gets pretty ridiculous with things like LTCAFEADCMode tbh).",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,65,2017-07-26T19:38:39Z,2017-08-23T07:05:42Z,2017-09-11T07:05:48Z,MERGED,True,728,32,12,https://github.com/karlding,ELEC-65: Add LTC6804-1 driver,88,[],https://github.com/uw-midsun/firmware/pull/65,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/65#issuecomment-318160600,"I'm not too attached to naming, so feel free to suggest things (it gets pretty ridiculous with things like LTCAFEADCMode tbh).","Fantastic commit messages - please tag your commits with the ticket number.
RE: naming - I'm fine with LtcAfeModuleName. It was the function naming where you mixed PascalCase and snake_case in the same function that I didn't like.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,65,2017-07-26T19:38:39Z,2017-08-23T07:05:42Z,2017-09-11T07:05:48Z,MERGED,True,728,32,12,https://github.com/karlding,ELEC-65: Add LTC6804-1 driver,88,[],https://github.com/uw-midsun/firmware/pull/65,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/65#issuecomment-318164678,"I'm not too attached to naming, so feel free to suggest things (it gets pretty ridiculous with things like LTCAFEADCMode tbh).","Also, just a general comment - if you want to shorten the names, afe_x instead of ltc_afe_x is probably fine.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,65,2017-07-26T19:38:39Z,2017-08-23T07:05:42Z,2017-09-11T07:05:48Z,MERGED,True,728,32,12,https://github.com/karlding,ELEC-65: Add LTC6804-1 driver,88,[],https://github.com/uw-midsun/firmware/pull/65,https://github.com/karlding,4,https://github.com/uw-midsun/firmware/pull/65#issuecomment-323228679,"I'm not too attached to naming, so feel free to suggest things (it gets pretty ridiculous with things like LTCAFEADCMode tbh).","Sure, I'll wait on @ckitagawa to give it a once over.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,65,2017-07-26T19:38:39Z,2017-08-23T07:05:42Z,2017-09-11T07:05:48Z,MERGED,True,728,32,12,https://github.com/karlding,ELEC-65: Add LTC6804-1 driver,88,[],https://github.com/uw-midsun/firmware/pull/65,https://github.com/karlding,5,https://github.com/uw-midsun/firmware/pull/65#issuecomment-323876585,"I'm not too attached to naming, so feel free to suggest things (it gets pretty ridiculous with things like LTCAFEADCMode tbh).","Made the change for the STATUS_CODE_CRC_MISMATCH status. I also ran clang-format over my project files:
find projects/plutus/ -iname *.h -o -iname *.c | xargs clang-format -i
Also made a comment about the looping thing you pointed out @ckitagawa, let me know if you want that changed.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,65,2017-07-26T19:38:39Z,2017-08-23T07:05:42Z,2017-09-11T07:05:48Z,MERGED,True,728,32,12,https://github.com/karlding,ELEC-65: Add LTC6804-1 driver,88,[],https://github.com/uw-midsun/firmware/pull/65,https://github.com/tituschow,6,https://github.com/uw-midsun/firmware/pull/65#issuecomment-323883130,"I'm not too attached to naming, so feel free to suggest things (it gets pretty ridiculous with things like LTCAFEADCMode tbh).",Please run make format before merging just in case :),True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,65,2017-07-26T19:38:39Z,2017-08-23T07:05:42Z,2017-09-11T07:05:48Z,MERGED,True,728,32,12,https://github.com/karlding,ELEC-65: Add LTC6804-1 driver,88,[],https://github.com/uw-midsun/firmware/pull/65,https://github.com/karlding,7,https://github.com/uw-midsun/firmware/pull/65#issuecomment-324240937,"I'm not too attached to naming, so feel free to suggest things (it gets pretty ridiculous with things like LTCAFEADCMode tbh).",Just realized this was ELEC-65 and PR 65... 🤔,True,{'LAUGH': ['https://github.com/tituschow']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,66,2017-08-03T14:58:09Z,2017-08-08T17:06:42Z,2017-08-08T17:06:45Z,MERGED,True,282,1,6,https://github.com/Derpalooza,ELEC-215: MCP23008 Driver,18,[],https://github.com/uw-midsun/firmware/pull/66,https://github.com/Derpalooza,1,https://github.com/uw-midsun/firmware/pull/66,Simple driver for the MCP23008 GPIO expander.,Simple driver for the MCP23008 GPIO expander.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,66,2017-08-03T14:58:09Z,2017-08-08T17:06:42Z,2017-08-08T17:06:45Z,MERGED,True,282,1,6,https://github.com/Derpalooza,ELEC-215: MCP23008 Driver,18,[],https://github.com/uw-midsun/firmware/pull/66,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/66#issuecomment-320029821,Simple driver for the MCP23008 GPIO expander.,Please add a test.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,67,2017-08-04T19:26:27Z,2017-08-08T16:37:55Z,2017-08-08T16:38:23Z,MERGED,True,23,13,2,https://github.com/tituschow,ELEC-253: Fixed build ordering,2,[],https://github.com/uw-midsun/firmware/pull/67,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/67,"Actually resolves dependencies in the correct order for build_all.
Also doesn't include everything single project header folder","Actually resolves dependencies in the correct order for build_all.
Also doesn't include everything single project header folder",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,68,2017-08-10T16:28:08Z,2017-08-11T18:59:23Z,2017-08-11T18:59:27Z,MERGED,True,155,1,5,https://github.com/Derpalooza,ELEC-216: TLV493D Driver,27,[],https://github.com/uw-midsun/firmware/pull/68,https://github.com/Derpalooza,1,https://github.com/uw-midsun/firmware/pull/68,"For the purposes of driver controls, there doesn't seem to be much need for any features aside from reading magnetic field data, as we will only be using the driver for angle sensing.
Since I wasn't sure how the driver could be tested beyond successful i2c transfers and useful values, the tests aren't very comprehensive.","For the purposes of driver controls, there doesn't seem to be much need for any features aside from reading magnetic field data, as we will only be using the driver for angle sensing.
Since I wasn't sure how the driver could be tested beyond successful i2c transfers and useful values, the tests aren't very comprehensive.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,69,2017-08-14T23:31:01Z,2017-08-15T17:49:15Z,2017-08-15T17:49:22Z,MERGED,True,82,63,26,https://github.com/ckitagawa,ELEC-257 LSC: Remove cyclic dependencies in libraries,6,[],https://github.com/uw-midsun/firmware/pull/69,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/69,"Remove cyclic dependencies bewteen libraries.
This was achieved by moving the enums for interrupt.h and the status module to a new library called libcore which encompasses code shared between x86, STDPeriphLib and ms-common libraries. I have run all the tests on x86 and will ensure all stm32f0xx tests pass when I am working in the bay tomorrow before merging.
The alternative solution if there are concerns about the scale/impact of this change is to:

Remove the dependency on status from the files in question and use integers instead.
Manually redefine the enums for interrupt priority, type and edge in their respective architecture interrupt files. (I would rather not do this as it requires more guard clauses but I would be willing to do it if it was significantly preferred).

Both would be acceptable to me although I find this solution to be simpler and allows the use of status in other libraries which I find appealing.","Remove cyclic dependencies bewteen libraries.
This was achieved by moving the enums for interrupt.h and the status module to a new library called libcore which encompasses code shared between x86, STDPeriphLib and ms-common libraries. I have run all the tests on x86 and will ensure all stm32f0xx tests pass when I am working in the bay tomorrow before merging.
The alternative solution if there are concerns about the scale/impact of this change is to:

Remove the dependency on status from the files in question and use integers instead.
Manually redefine the enums for interrupt priority, type and edge in their respective architecture interrupt files. (I would rather not do this as it requires more guard clauses but I would be willing to do it if it was significantly preferred).

Both would be acceptable to me although I find this solution to be simpler and allows the use of status in other libraries which I find appealing.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,69,2017-08-14T23:31:01Z,2017-08-15T17:49:15Z,2017-08-15T17:49:22Z,MERGED,True,82,63,26,https://github.com/ckitagawa,ELEC-257 LSC: Remove cyclic dependencies in libraries,6,[],https://github.com/uw-midsun/firmware/pull/69,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/69#issuecomment-322337959,"Remove cyclic dependencies bewteen libraries.
This was achieved by moving the enums for interrupt.h and the status module to a new library called libcore which encompasses code shared between x86, STDPeriphLib and ms-common libraries. I have run all the tests on x86 and will ensure all stm32f0xx tests pass when I am working in the bay tomorrow before merging.
The alternative solution if there are concerns about the scale/impact of this change is to:

Remove the dependency on status from the files in question and use integers instead.
Manually redefine the enums for interrupt priority, type and edge in their respective architecture interrupt files. (I would rather not do this as it requires more guard clauses but I would be willing to do it if it was significantly preferred).

Both would be acceptable to me although I find this solution to be simpler and allows the use of status in other libraries which I find appealing.","I think a shared core library makes sense to me. I think data structures that don't rely on anything else (FSM, FIFOs, etc.) could probably belong there too. We could just use a config header to define critical sections.
edit: One thing to consider is where to draw the line - what belongs in ms-common vs. libcore?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,69,2017-08-14T23:31:01Z,2017-08-15T17:49:15Z,2017-08-15T17:49:22Z,MERGED,True,82,63,26,https://github.com/ckitagawa,ELEC-257 LSC: Remove cyclic dependencies in libraries,6,[],https://github.com/uw-midsun/firmware/pull/69,https://github.com/ckitagawa,3,https://github.com/uw-midsun/firmware/pull/69#issuecomment-322339031,"Remove cyclic dependencies bewteen libraries.
This was achieved by moving the enums for interrupt.h and the status module to a new library called libcore which encompasses code shared between x86, STDPeriphLib and ms-common libraries. I have run all the tests on x86 and will ensure all stm32f0xx tests pass when I am working in the bay tomorrow before merging.
The alternative solution if there are concerns about the scale/impact of this change is to:

Remove the dependency on status from the files in question and use integers instead.
Manually redefine the enums for interrupt priority, type and edge in their respective architecture interrupt files. (I would rather not do this as it requires more guard clauses but I would be willing to do it if it was significantly preferred).

Both would be acceptable to me although I find this solution to be simpler and allows the use of status in other libraries which I find appealing.",When I do the library cleanup/documentation PRs I will consider moving some of the data structures over as well in that case :),True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,69,2017-08-14T23:31:01Z,2017-08-15T17:49:15Z,2017-08-15T17:49:22Z,MERGED,True,82,63,26,https://github.com/ckitagawa,ELEC-257 LSC: Remove cyclic dependencies in libraries,6,[],https://github.com/uw-midsun/firmware/pull/69,https://github.com/tituschow,4,https://github.com/uw-midsun/firmware/pull/69#issuecomment-322339320,"Remove cyclic dependencies bewteen libraries.
This was achieved by moving the enums for interrupt.h and the status module to a new library called libcore which encompasses code shared between x86, STDPeriphLib and ms-common libraries. I have run all the tests on x86 and will ensure all stm32f0xx tests pass when I am working in the bay tomorrow before merging.
The alternative solution if there are concerns about the scale/impact of this change is to:

Remove the dependency on status from the files in question and use integers instead.
Manually redefine the enums for interrupt priority, type and edge in their respective architecture interrupt files. (I would rather not do this as it requires more guard clauses but I would be willing to do it if it was significantly preferred).

Both would be acceptable to me although I find this solution to be simpler and allows the use of status in other libraries which I find appealing.","Saw this in your build log for stm32f0xx: Might want to double check and make sure this isn't breaking anything.
/usr/bin/../lib/gcc/arm-none-eabi/6.3.1/../../../../arm-none-eabi/bin/ld: warning: cannot find entry symbol Reset_Handler; defaulting to 0000000008000000",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,69,2017-08-14T23:31:01Z,2017-08-15T17:49:15Z,2017-08-15T17:49:22Z,MERGED,True,82,63,26,https://github.com/ckitagawa,ELEC-257 LSC: Remove cyclic dependencies in libraries,6,[],https://github.com/uw-midsun/firmware/pull/69,https://github.com/ckitagawa,5,https://github.com/uw-midsun/firmware/pull/69#issuecomment-322339594,"Remove cyclic dependencies bewteen libraries.
This was achieved by moving the enums for interrupt.h and the status module to a new library called libcore which encompasses code shared between x86, STDPeriphLib and ms-common libraries. I have run all the tests on x86 and will ensure all stm32f0xx tests pass when I am working in the bay tomorrow before merging.
The alternative solution if there are concerns about the scale/impact of this change is to:

Remove the dependency on status from the files in question and use integers instead.
Manually redefine the enums for interrupt priority, type and edge in their respective architecture interrupt files. (I would rather not do this as it requires more guard clauses but I would be willing to do it if it was significantly preferred).

Both would be acceptable to me although I find this solution to be simpler and allows the use of status in other libraries which I find appealing.","Noted, I will investigate tomorrow since I left my STM hardware in the bay.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,69,2017-08-14T23:31:01Z,2017-08-15T17:49:15Z,2017-08-15T17:49:22Z,MERGED,True,82,63,26,https://github.com/ckitagawa,ELEC-257 LSC: Remove cyclic dependencies in libraries,6,[],https://github.com/uw-midsun/firmware/pull/69,https://github.com/ckitagawa,6,https://github.com/uw-midsun/firmware/pull/69#issuecomment-322535764,"Remove cyclic dependencies bewteen libraries.
This was achieved by moving the enums for interrupt.h and the status module to a new library called libcore which encompasses code shared between x86, STDPeriphLib and ms-common libraries. I have run all the tests on x86 and will ensure all stm32f0xx tests pass when I am working in the bay tomorrow before merging.
The alternative solution if there are concerns about the scale/impact of this change is to:

Remove the dependency on status from the files in question and use integers instead.
Manually redefine the enums for interrupt priority, type and edge in their respective architecture interrupt files. (I would rather not do this as it requires more guard clauses but I would be willing to do it if it was significantly preferred).

Both would be acceptable to me although I find this solution to be simpler and allows the use of status in other libraries which I find appealing.","Updates:

Moved tests in libcore to ms-common as stm32f0xx needs to be built prior to any tests as the stm32f0xx_startup.s file needs to be linked first. This would result in a circular dependency once again if the tests did not remain in ms-common or another library that is built after the $(PLATFORM_LIB) is included.
Fixed test_soft_timers.c on stm32f0xx which had a bug with a missing critical section.
Fixed test_gpio.c on stm32f0xx which was testing an undefined hardware behavior.
Moved misc.h to libcore.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,70,2017-08-15T19:20:42Z,2017-08-19T18:00:27Z,2017-08-21T16:10:20Z,MERGED,True,84,71,24,https://github.com/ckitagawa,ELEC-259: Documentation Improvements and Const Correctness in Interfaces,4,[],https://github.com/uw-midsun/firmware/pull/70,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/70,"This PR is the first in what will likely be a series of PRs that cleanup the ms-common library prior to the start of the new term.
Issues addressed in this PR:

""Const Correctness"" --- adding the const modifier to places where it is applicable especially in interfaces.
Documentation in *.h files is lacking in some places. I also fixed any spelling or grammatical errors I found. This is likely to be an ongoing project.

Issues to consider in a future PR:

Move generic data structures such as objpool, queues and FSM to libcore.
Move other generic code such as log to libcore.

Moving things to libcore will entail keeping their tests in ms-common or in a new library of just tests for libcore. This is because the tests need to be built after the platform libs are built hence why I am hesitant to outright move everything to it immediately.
Suggestions on other possible improvements are welcome :)","This PR is the first in what will likely be a series of PRs that cleanup the ms-common library prior to the start of the new term.
Issues addressed in this PR:

""Const Correctness"" --- adding the const modifier to places where it is applicable especially in interfaces.
Documentation in *.h files is lacking in some places. I also fixed any spelling or grammatical errors I found. This is likely to be an ongoing project.

Issues to consider in a future PR:

Move generic data structures such as objpool, queues and FSM to libcore.
Move other generic code such as log to libcore.

Moving things to libcore will entail keeping their tests in ms-common or in a new library of just tests for libcore. This is because the tests need to be built after the platform libs are built hence why I am hesitant to outright move everything to it immediately.
Suggestions on other possible improvements are welcome :)",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,70,2017-08-15T19:20:42Z,2017-08-19T18:00:27Z,2017-08-21T16:10:20Z,MERGED,True,84,71,24,https://github.com/ckitagawa,ELEC-259: Documentation Improvements and Const Correctness in Interfaces,4,[],https://github.com/uw-midsun/firmware/pull/70,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/70#issuecomment-322665880,"This PR is the first in what will likely be a series of PRs that cleanup the ms-common library prior to the start of the new term.
Issues addressed in this PR:

""Const Correctness"" --- adding the const modifier to places where it is applicable especially in interfaces.
Documentation in *.h files is lacking in some places. I also fixed any spelling or grammatical errors I found. This is likely to be an ongoing project.

Issues to consider in a future PR:

Move generic data structures such as objpool, queues and FSM to libcore.
Move other generic code such as log to libcore.

Moving things to libcore will entail keeping their tests in ms-common or in a new library of just tests for libcore. This is because the tests need to be built after the platform libs are built hence why I am hesitant to outright move everything to it immediately.
Suggestions on other possible improvements are welcome :)","Yeah, needing to keep libcore tests in ms-common is kinda weird. I'm not a huge fan of that. I believe we could force the platform lib to be included twice when linking (once at the very beginning and once in the actual dependency chain), and that should solve the problem.
edit: Completely untested, but I think you should be able to initialize $(T)_DEPS := $(PLATFORM_LIB).
RE: suggestions for possible improvements - I think officially supporting clang-format or some other way of properly formatting + linting our code would be beneficial for new members. A lot of @Derpalooza's first PR comments were mostly style things. There are also a few compiler flags we should look at for things such as disallowing integers as enums without an explicit cast.
@karlding also suggested moving some of our documentation to github.
One thing that I've noticed is that there isn't a clear distinction between resources and getting started guides. I think that most of our pages currently explain how things work and why we've chosen them, which is fantastic for understanding things more in-depth. However, I think basic tutorials for new members would also be beneficial, as I think there's so much information at this point that people don't really know where to look. I think an updated version of software 101 that really focuses on our workflow with clear, step-by-step examples would be nice for new members to follow.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,70,2017-08-15T19:20:42Z,2017-08-19T18:00:27Z,2017-08-21T16:10:20Z,MERGED,True,84,71,24,https://github.com/ckitagawa,ELEC-259: Documentation Improvements and Const Correctness in Interfaces,4,[],https://github.com/uw-midsun/firmware/pull/70,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/70#issuecomment-323142159,"This PR is the first in what will likely be a series of PRs that cleanup the ms-common library prior to the start of the new term.
Issues addressed in this PR:

""Const Correctness"" --- adding the const modifier to places where it is applicable especially in interfaces.
Documentation in *.h files is lacking in some places. I also fixed any spelling or grammatical errors I found. This is likely to be an ongoing project.

Issues to consider in a future PR:

Move generic data structures such as objpool, queues and FSM to libcore.
Move other generic code such as log to libcore.

Moving things to libcore will entail keeping their tests in ms-common or in a new library of just tests for libcore. This is because the tests need to be built after the platform libs are built hence why I am hesitant to outright move everything to it immediately.
Suggestions on other possible improvements are welcome :)","Oh, another requested change: Be consistent about named structs/enums. I think naming both the struct and typedef is useful.
edit: Also making NUM_x consistent about whether it should be plural or singular.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,70,2017-08-15T19:20:42Z,2017-08-19T18:00:27Z,2017-08-21T16:10:20Z,MERGED,True,84,71,24,https://github.com/ckitagawa,ELEC-259: Documentation Improvements and Const Correctness in Interfaces,4,[],https://github.com/uw-midsun/firmware/pull/70,https://github.com/tituschow,4,https://github.com/uw-midsun/firmware/pull/70#issuecomment-323537751,"This PR is the first in what will likely be a series of PRs that cleanup the ms-common library prior to the start of the new term.
Issues addressed in this PR:

""Const Correctness"" --- adding the const modifier to places where it is applicable especially in interfaces.
Documentation in *.h files is lacking in some places. I also fixed any spelling or grammatical errors I found. This is likely to be an ongoing project.

Issues to consider in a future PR:

Move generic data structures such as objpool, queues and FSM to libcore.
Move other generic code such as log to libcore.

Moving things to libcore will entail keeping their tests in ms-common or in a new library of just tests for libcore. This is because the tests need to be built after the platform libs are built hence why I am hesitant to outright move everything to it immediately.
Suggestions on other possible improvements are welcome :)",I think you can use a custom format style with break after brace for structs?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,70,2017-08-15T19:20:42Z,2017-08-19T18:00:27Z,2017-08-21T16:10:20Z,MERGED,True,84,71,24,https://github.com/ckitagawa,ELEC-259: Documentation Improvements and Const Correctness in Interfaces,4,[],https://github.com/uw-midsun/firmware/pull/70,https://github.com/ckitagawa,5,https://github.com/uw-midsun/firmware/pull/70#issuecomment-323538362,"This PR is the first in what will likely be a series of PRs that cleanup the ms-common library prior to the start of the new term.
Issues addressed in this PR:

""Const Correctness"" --- adding the const modifier to places where it is applicable especially in interfaces.
Documentation in *.h files is lacking in some places. I also fixed any spelling or grammatical errors I found. This is likely to be an ongoing project.

Issues to consider in a future PR:

Move generic data structures such as objpool, queues and FSM to libcore.
Move other generic code such as log to libcore.

Moving things to libcore will entail keeping their tests in ms-common or in a new library of just tests for libcore. This is because the tests need to be built after the platform libs are built hence why I am hesitant to outright move everything to it immediately.
Suggestions on other possible improvements are welcome :)","Okay so here are the follow up changes I am going to do in another couple PRs:
PR 1

Create a .clang-format file and run it on the entire repo. I'm going to do my best to configure it in such as way as to minimize the total changes to the existing repo. If anything becomes impossible due to some limitation of the tool I may ask for opinions on modifying the style guide slightly to support the changes.

PR 2

Use clang-rename to update struct and enum names to be consistent across the repo. Including the plurality of NUM_*

PR 3

I don't think $(T)_DEPS := $(PLATFORM_LIB) will work since stm32f0xx lib depends on the STM32F0xx_StdPeriph_driver which contains code which references libcore resulting in a circular dependency... So I will work on figuring out a way to fix this and then move tests and generic code to libcore.

I'll make the documentation changes to Confluence starting next week but I agree we should maybe move some of it here. Or at least reference it from this repo.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,71,2017-08-16T20:44:20Z,2017-10-14T21:40:00Z,2017-10-14T21:40:00Z,CLOSED,False,310,1,5,https://github.com/Derpalooza,ELEC-217: ADS1015 Driver,19,[],https://github.com/uw-midsun/firmware/pull/71,https://github.com/Derpalooza,1,https://github.com/uw-midsun/firmware/pull/71,Non-blocking driver for the ADS1015 ADC,Non-blocking driver for the ADS1015 ADC,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,72,2017-08-18T05:57:10Z,2017-08-19T18:25:06Z,2017-08-19T18:25:11Z,MERGED,True,10,11,5,https://github.com/tituschow,ELEC-260: Fix libcore tests,4,[],https://github.com/uw-midsun/firmware/pull/72,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/72,"Adds PLATFORM_LIB as a dependency to unity with the assumption that all tests require the platform lib to work. This properly links in the platform lib for tests without circular dependencies.
Also fixed build target for libraries - will now also build target tests as well.","Adds PLATFORM_LIB as a dependency to unity with the assumption that all tests require the platform lib to work. This properly links in the platform lib for tests without circular dependencies.
Also fixed build target for libraries - will now also build target tests as well.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,73,2017-08-19T20:50:06Z,2017-08-21T16:28:48Z,2017-08-21T20:15:13Z,MERGED,True,895,630,87,https://github.com/ckitagawa,ELEC-259: Proposal to support clang-format,10,[],https://github.com/uw-midsun/firmware/pull/73,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/73,"TL;DR: Added clang-format it caused a few common changes I couldn't figure out how to avoid. Let's discuss if we are OK with them. If not how do we want to move forward.
Clang-Format Documentation for those interested.
I'm fine with people pulling, modifying and committing the .clang-format file in this branch if they want to try to avoid any of these changes.
Added a .clang-format file to root directory. It is based on the Google style clang-format with modifications that support some of our coding conventions as outlined on Confluence. Specifically, it modifies:

ColumnLimit: 100
PointerAlignment: Right
Cpp11BracedListStyle: false

Major deviations from current style
// Empty Loops
while (cond) { }
// becomes
while (cond) {
}

// Space in Empty Braces
void func(void) { }
// becomes
void func(void) {}

// Designated Struct Initializers
typedef struct TestStruct {
  int test1;
  int test2;
} TestStruct;

const static TestStruct ts = {
  .test1 = 1
};
// becomes
const static TestStruct ts = {.test1 = 1 };  
// Note: that the {. without a space is fixed by an LLVM patch which has yet to be released: 
// https://reviews.llvm.org/rL305696#9b94b34f
// This can be fixed with a trailing comma. 
const static TestStruct ts = {
  .test1 = 1,
};
// but poses a different problem as
const static TestStruct ts = {
  .test1 = 1,
  .test2 = 2,
};
// becomes
const static TestStruct ts = {
  .test1 = 1, .test2 = 2,
};
// If the designated initializers manage to fit on one line.
Common changes not mentioned in the style guide

Strictly orders header includes to be: corresponding header if a *.c file, <*.h>, ""*.h"". This is a feature I wanted anyway :p
BinPacking and argument alignment in function definitions. (I don't think we should care since this doesn't have significant effect).
Right aligning the multiline character \. (Mainly in macros).
Indentation in macros starting at 2 spaces instead of none

#define MY_MACRO(x)                                                            \
do_something((x))
\\ becomes
#define MY_MACRO(x)                                                            \
  do_something((x))
Summary
I'm personally in favor of this change to using .clang-format as it just makes everything simpler and more consistent. No more discussion of style and since the linter already supports most of these changes we can save time by using it. Moreover, clang-format has built-in support in most common editors.
Personally, I am fine with the few minor changes this causes but I know others may not be. Let's discuss concerns here and work towards a way to use this tool or another like it to simplify reviews by being able to trust the style is being followed.
@tituschow I've tried the BreakBeforeBraces: Custom and BraceWrapping: AfterStruct: true but it doesn't do what you would think:
typedef struct hello {
  int hi;
} hello;
\\ becomes
typedef struct hello
{
  int hi;
} hello;","TL;DR: Added clang-format it caused a few common changes I couldn't figure out how to avoid. Let's discuss if we are OK with them. If not how do we want to move forward.
Clang-Format Documentation for those interested.
I'm fine with people pulling, modifying and committing the .clang-format file in this branch if they want to try to avoid any of these changes.
Added a .clang-format file to root directory. It is based on the Google style clang-format with modifications that support some of our coding conventions as outlined on Confluence. Specifically, it modifies:

ColumnLimit: 100
PointerAlignment: Right
Cpp11BracedListStyle: false

Major deviations from current style
// Empty Loops
while (cond) { }
// becomes
while (cond) {
}

// Space in Empty Braces
void func(void) { }
// becomes
void func(void) {}

// Designated Struct Initializers
typedef struct TestStruct {
  int test1;
  int test2;
} TestStruct;

const static TestStruct ts = {
  .test1 = 1
};
// becomes
const static TestStruct ts = {.test1 = 1 };  
// Note: that the {. without a space is fixed by an LLVM patch which has yet to be released: 
// https://reviews.llvm.org/rL305696#9b94b34f
// This can be fixed with a trailing comma. 
const static TestStruct ts = {
  .test1 = 1,
};
// but poses a different problem as
const static TestStruct ts = {
  .test1 = 1,
  .test2 = 2,
};
// becomes
const static TestStruct ts = {
  .test1 = 1, .test2 = 2,
};
// If the designated initializers manage to fit on one line.
Common changes not mentioned in the style guide

Strictly orders header includes to be: corresponding header if a *.c file, <*.h>, ""*.h"". This is a feature I wanted anyway :p
BinPacking and argument alignment in function definitions. (I don't think we should care since this doesn't have significant effect).
Right aligning the multiline character \. (Mainly in macros).
Indentation in macros starting at 2 spaces instead of none

#define MY_MACRO(x)                                                            \
do_something((x))
\\ becomes
#define MY_MACRO(x)                                                            \
  do_something((x))
Summary
I'm personally in favor of this change to using .clang-format as it just makes everything simpler and more consistent. No more discussion of style and since the linter already supports most of these changes we can save time by using it. Moreover, clang-format has built-in support in most common editors.
Personally, I am fine with the few minor changes this causes but I know others may not be. Let's discuss concerns here and work towards a way to use this tool or another like it to simplify reviews by being able to trust the style is being followed.
@tituschow I've tried the BreakBeforeBraces: Custom and BraceWrapping: AfterStruct: true but it doesn't do what you would think:
typedef struct hello {
  int hi;
} hello;
\\ becomes
typedef struct hello
{
  int hi;
} hello;",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,73,2017-08-19T20:50:06Z,2017-08-21T16:28:48Z,2017-08-21T20:15:13Z,MERGED,True,895,630,87,https://github.com/ckitagawa,ELEC-259: Proposal to support clang-format,10,[],https://github.com/uw-midsun/firmware/pull/73,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/73#issuecomment-323547476,"TL;DR: Added clang-format it caused a few common changes I couldn't figure out how to avoid. Let's discuss if we are OK with them. If not how do we want to move forward.
Clang-Format Documentation for those interested.
I'm fine with people pulling, modifying and committing the .clang-format file in this branch if they want to try to avoid any of these changes.
Added a .clang-format file to root directory. It is based on the Google style clang-format with modifications that support some of our coding conventions as outlined on Confluence. Specifically, it modifies:

ColumnLimit: 100
PointerAlignment: Right
Cpp11BracedListStyle: false

Major deviations from current style
// Empty Loops
while (cond) { }
// becomes
while (cond) {
}

// Space in Empty Braces
void func(void) { }
// becomes
void func(void) {}

// Designated Struct Initializers
typedef struct TestStruct {
  int test1;
  int test2;
} TestStruct;

const static TestStruct ts = {
  .test1 = 1
};
// becomes
const static TestStruct ts = {.test1 = 1 };  
// Note: that the {. without a space is fixed by an LLVM patch which has yet to be released: 
// https://reviews.llvm.org/rL305696#9b94b34f
// This can be fixed with a trailing comma. 
const static TestStruct ts = {
  .test1 = 1,
};
// but poses a different problem as
const static TestStruct ts = {
  .test1 = 1,
  .test2 = 2,
};
// becomes
const static TestStruct ts = {
  .test1 = 1, .test2 = 2,
};
// If the designated initializers manage to fit on one line.
Common changes not mentioned in the style guide

Strictly orders header includes to be: corresponding header if a *.c file, <*.h>, ""*.h"". This is a feature I wanted anyway :p
BinPacking and argument alignment in function definitions. (I don't think we should care since this doesn't have significant effect).
Right aligning the multiline character \. (Mainly in macros).
Indentation in macros starting at 2 spaces instead of none

#define MY_MACRO(x)                                                            \
do_something((x))
\\ becomes
#define MY_MACRO(x)                                                            \
  do_something((x))
Summary
I'm personally in favor of this change to using .clang-format as it just makes everything simpler and more consistent. No more discussion of style and since the linter already supports most of these changes we can save time by using it. Moreover, clang-format has built-in support in most common editors.
Personally, I am fine with the few minor changes this causes but I know others may not be. Let's discuss concerns here and work towards a way to use this tool or another like it to simplify reviews by being able to trust the style is being followed.
@tituschow I've tried the BreakBeforeBraces: Custom and BraceWrapping: AfterStruct: true but it doesn't do what you would think:
typedef struct hello {
  int hi;
} hello;
\\ becomes
typedef struct hello
{
  int hi;
} hello;",Not sure what's up with the lint errors... It has to do with @Derpalooza 's method for casting initializer stucts in digital_io.c. I'll look into it but I may just end up rewriting that bit...,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,73,2017-08-19T20:50:06Z,2017-08-21T16:28:48Z,2017-08-21T20:15:13Z,MERGED,True,895,630,87,https://github.com/ckitagawa,ELEC-259: Proposal to support clang-format,10,[],https://github.com/uw-midsun/firmware/pull/73,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/73#issuecomment-323559006,"TL;DR: Added clang-format it caused a few common changes I couldn't figure out how to avoid. Let's discuss if we are OK with them. If not how do we want to move forward.
Clang-Format Documentation for those interested.
I'm fine with people pulling, modifying and committing the .clang-format file in this branch if they want to try to avoid any of these changes.
Added a .clang-format file to root directory. It is based on the Google style clang-format with modifications that support some of our coding conventions as outlined on Confluence. Specifically, it modifies:

ColumnLimit: 100
PointerAlignment: Right
Cpp11BracedListStyle: false

Major deviations from current style
// Empty Loops
while (cond) { }
// becomes
while (cond) {
}

// Space in Empty Braces
void func(void) { }
// becomes
void func(void) {}

// Designated Struct Initializers
typedef struct TestStruct {
  int test1;
  int test2;
} TestStruct;

const static TestStruct ts = {
  .test1 = 1
};
// becomes
const static TestStruct ts = {.test1 = 1 };  
// Note: that the {. without a space is fixed by an LLVM patch which has yet to be released: 
// https://reviews.llvm.org/rL305696#9b94b34f
// This can be fixed with a trailing comma. 
const static TestStruct ts = {
  .test1 = 1,
};
// but poses a different problem as
const static TestStruct ts = {
  .test1 = 1,
  .test2 = 2,
};
// becomes
const static TestStruct ts = {
  .test1 = 1, .test2 = 2,
};
// If the designated initializers manage to fit on one line.
Common changes not mentioned in the style guide

Strictly orders header includes to be: corresponding header if a *.c file, <*.h>, ""*.h"". This is a feature I wanted anyway :p
BinPacking and argument alignment in function definitions. (I don't think we should care since this doesn't have significant effect).
Right aligning the multiline character \. (Mainly in macros).
Indentation in macros starting at 2 spaces instead of none

#define MY_MACRO(x)                                                            \
do_something((x))
\\ becomes
#define MY_MACRO(x)                                                            \
  do_something((x))
Summary
I'm personally in favor of this change to using .clang-format as it just makes everything simpler and more consistent. No more discussion of style and since the linter already supports most of these changes we can save time by using it. Moreover, clang-format has built-in support in most common editors.
Personally, I am fine with the few minor changes this causes but I know others may not be. Let's discuss concerns here and work towards a way to use this tool or another like it to simplify reviews by being able to trust the style is being followed.
@tituschow I've tried the BreakBeforeBraces: Custom and BraceWrapping: AfterStruct: true but it doesn't do what you would think:
typedef struct hello {
  int hi;
} hello;
\\ becomes
typedef struct hello
{
  int hi;
} hello;","Yeah, dealing with initializers is kinda weird. Is there no way to keep the current style or at least add a new line for each member?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,73,2017-08-19T20:50:06Z,2017-08-21T16:28:48Z,2017-08-21T20:15:13Z,MERGED,True,895,630,87,https://github.com/ckitagawa,ELEC-259: Proposal to support clang-format,10,[],https://github.com/uw-midsun/firmware/pull/73,https://github.com/tituschow,4,https://github.com/uw-midsun/firmware/pull/73#issuecomment-323559317,"TL;DR: Added clang-format it caused a few common changes I couldn't figure out how to avoid. Let's discuss if we are OK with them. If not how do we want to move forward.
Clang-Format Documentation for those interested.
I'm fine with people pulling, modifying and committing the .clang-format file in this branch if they want to try to avoid any of these changes.
Added a .clang-format file to root directory. It is based on the Google style clang-format with modifications that support some of our coding conventions as outlined on Confluence. Specifically, it modifies:

ColumnLimit: 100
PointerAlignment: Right
Cpp11BracedListStyle: false

Major deviations from current style
// Empty Loops
while (cond) { }
// becomes
while (cond) {
}

// Space in Empty Braces
void func(void) { }
// becomes
void func(void) {}

// Designated Struct Initializers
typedef struct TestStruct {
  int test1;
  int test2;
} TestStruct;

const static TestStruct ts = {
  .test1 = 1
};
// becomes
const static TestStruct ts = {.test1 = 1 };  
// Note: that the {. without a space is fixed by an LLVM patch which has yet to be released: 
// https://reviews.llvm.org/rL305696#9b94b34f
// This can be fixed with a trailing comma. 
const static TestStruct ts = {
  .test1 = 1,
};
// but poses a different problem as
const static TestStruct ts = {
  .test1 = 1,
  .test2 = 2,
};
// becomes
const static TestStruct ts = {
  .test1 = 1, .test2 = 2,
};
// If the designated initializers manage to fit on one line.
Common changes not mentioned in the style guide

Strictly orders header includes to be: corresponding header if a *.c file, <*.h>, ""*.h"". This is a feature I wanted anyway :p
BinPacking and argument alignment in function definitions. (I don't think we should care since this doesn't have significant effect).
Right aligning the multiline character \. (Mainly in macros).
Indentation in macros starting at 2 spaces instead of none

#define MY_MACRO(x)                                                            \
do_something((x))
\\ becomes
#define MY_MACRO(x)                                                            \
  do_something((x))
Summary
I'm personally in favor of this change to using .clang-format as it just makes everything simpler and more consistent. No more discussion of style and since the linter already supports most of these changes we can save time by using it. Moreover, clang-format has built-in support in most common editors.
Personally, I am fine with the few minor changes this causes but I know others may not be. Let's discuss concerns here and work towards a way to use this tool or another like it to simplify reviews by being able to trust the style is being followed.
@tituschow I've tried the BreakBeforeBraces: Custom and BraceWrapping: AfterStruct: true but it doesn't do what you would think:
typedef struct hello {
  int hi;
} hello;
\\ becomes
typedef struct hello
{
  int hi;
} hello;","Overall, I'm a fan of using tools to enforce our style instead of relying on code review - it looks pretty decent so far! The only thing that's consistently inconsistent are initializers, which is too bad.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,73,2017-08-19T20:50:06Z,2017-08-21T16:28:48Z,2017-08-21T20:15:13Z,MERGED,True,895,630,87,https://github.com/ckitagawa,ELEC-259: Proposal to support clang-format,10,[],https://github.com/uw-midsun/firmware/pull/73,https://github.com/ckitagawa,5,https://github.com/uw-midsun/firmware/pull/73#issuecomment-323787947,"TL;DR: Added clang-format it caused a few common changes I couldn't figure out how to avoid. Let's discuss if we are OK with them. If not how do we want to move forward.
Clang-Format Documentation for those interested.
I'm fine with people pulling, modifying and committing the .clang-format file in this branch if they want to try to avoid any of these changes.
Added a .clang-format file to root directory. It is based on the Google style clang-format with modifications that support some of our coding conventions as outlined on Confluence. Specifically, it modifies:

ColumnLimit: 100
PointerAlignment: Right
Cpp11BracedListStyle: false

Major deviations from current style
// Empty Loops
while (cond) { }
// becomes
while (cond) {
}

// Space in Empty Braces
void func(void) { }
// becomes
void func(void) {}

// Designated Struct Initializers
typedef struct TestStruct {
  int test1;
  int test2;
} TestStruct;

const static TestStruct ts = {
  .test1 = 1
};
// becomes
const static TestStruct ts = {.test1 = 1 };  
// Note: that the {. without a space is fixed by an LLVM patch which has yet to be released: 
// https://reviews.llvm.org/rL305696#9b94b34f
// This can be fixed with a trailing comma. 
const static TestStruct ts = {
  .test1 = 1,
};
// but poses a different problem as
const static TestStruct ts = {
  .test1 = 1,
  .test2 = 2,
};
// becomes
const static TestStruct ts = {
  .test1 = 1, .test2 = 2,
};
// If the designated initializers manage to fit on one line.
Common changes not mentioned in the style guide

Strictly orders header includes to be: corresponding header if a *.c file, <*.h>, ""*.h"". This is a feature I wanted anyway :p
BinPacking and argument alignment in function definitions. (I don't think we should care since this doesn't have significant effect).
Right aligning the multiline character \. (Mainly in macros).
Indentation in macros starting at 2 spaces instead of none

#define MY_MACRO(x)                                                            \
do_something((x))
\\ becomes
#define MY_MACRO(x)                                                            \
  do_something((x))
Summary
I'm personally in favor of this change to using .clang-format as it just makes everything simpler and more consistent. No more discussion of style and since the linter already supports most of these changes we can save time by using it. Moreover, clang-format has built-in support in most common editors.
Personally, I am fine with the few minor changes this causes but I know others may not be. Let's discuss concerns here and work towards a way to use this tool or another like it to simplify reviews by being able to trust the style is being followed.
@tituschow I've tried the BreakBeforeBraces: Custom and BraceWrapping: AfterStruct: true but it doesn't do what you would think:
typedef struct hello {
  int hi;
} hello;
\\ becomes
typedef struct hello
{
  int hi;
} hello;","I've gone and fixed what I think are all the blocking issues with initializer formatting and added documentation in the .clang-format file.
If I missed any cases with initializers just comment them and I'll get them fixed. Otherwise this should be everything if we are OK with the other changes.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,74,2017-08-21T16:17:57Z,2017-08-21T23:58:43Z,2017-08-21T23:58:46Z,MERGED,True,644,650,55,https://github.com/tituschow,ELEC-261: Actually use GCC's warnings,20,[],https://github.com/uw-midsun/firmware/pull/74,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/74,"So I always wondered why GCC wasn't catching things like functions that should have return types. It turns out I suppressed warnings back when I first built the build system.
This PR fixes that, adds -Wextra and some other flags I thought were useful, upgrades to C11, and fixes all the bugs that GCC actually caught but we ignored. The main question I have is what flags are actually useful - I've disabled void pointer arithmetic, which adds a lot of casts to the code. I tried adding -Wconversion and that was completely useless due to the bitfields.
Changes tested on both x86 and STM32F0xx.","So I always wondered why GCC wasn't catching things like functions that should have return types. It turns out I suppressed warnings back when I first built the build system.
This PR fixes that, adds -Wextra and some other flags I thought were useful, upgrades to C11, and fixes all the bugs that GCC actually caught but we ignored. The main question I have is what flags are actually useful - I've disabled void pointer arithmetic, which adds a lot of casts to the code. I tried adding -Wconversion and that was completely useless due to the bitfields.
Changes tested on both x86 and STM32F0xx.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,74,2017-08-21T16:17:57Z,2017-08-21T23:58:43Z,2017-08-21T23:58:46Z,MERGED,True,644,650,55,https://github.com/tituschow,ELEC-261: Actually use GCC's warnings,20,[],https://github.com/uw-midsun/firmware/pull/74,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/74#issuecomment-323841677,"So I always wondered why GCC wasn't catching things like functions that should have return types. It turns out I suppressed warnings back when I first built the build system.
This PR fixes that, adds -Wextra and some other flags I thought were useful, upgrades to C11, and fixes all the bugs that GCC actually caught but we ignored. The main question I have is what flags are actually useful - I've disabled void pointer arithmetic, which adds a lot of casts to the code. I tried adding -Wconversion and that was completely useless due to the bitfields.
Changes tested on both x86 and STM32F0xx.","Should be good. Driver controls needs some cleanup, pushed to ELEC-262.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,74,2017-08-21T16:17:57Z,2017-08-21T23:58:43Z,2017-08-21T23:58:46Z,MERGED,True,644,650,55,https://github.com/tituschow,ELEC-261: Actually use GCC's warnings,20,[],https://github.com/uw-midsun/firmware/pull/74,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/74#issuecomment-323848054,"So I always wondered why GCC wasn't catching things like functions that should have return types. It turns out I suppressed warnings back when I first built the build system.
This PR fixes that, adds -Wextra and some other flags I thought were useful, upgrades to C11, and fixes all the bugs that GCC actually caught but we ignored. The main question I have is what flags are actually useful - I've disabled void pointer arithmetic, which adds a lot of casts to the code. I tried adding -Wconversion and that was completely useless due to the bitfields.
Changes tested on both x86 and STM32F0xx.",@ckitagawa / @karlding - seems like Travis uses an older version of GCC.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,74,2017-08-21T16:17:57Z,2017-08-21T23:58:43Z,2017-08-21T23:58:46Z,MERGED,True,644,650,55,https://github.com/tituschow,ELEC-261: Actually use GCC's warnings,20,[],https://github.com/uw-midsun/firmware/pull/74,https://github.com/tituschow,4,https://github.com/uw-midsun/firmware/pull/74#issuecomment-323877043,"So I always wondered why GCC wasn't catching things like functions that should have return types. It turns out I suppressed warnings back when I first built the build system.
This PR fixes that, adds -Wextra and some other flags I thought were useful, upgrades to C11, and fixes all the bugs that GCC actually caught but we ignored. The main question I have is what flags are actually useful - I've disabled void pointer arithmetic, which adds a lot of casts to the code. I tried adding -Wconversion and that was completely useless due to the bitfields.
Changes tested on both x86 and STM32F0xx.",I'll wait until @karlding has approved the travis changes,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,74,2017-08-21T16:17:57Z,2017-08-21T23:58:43Z,2017-08-21T23:58:46Z,MERGED,True,644,650,55,https://github.com/tituschow,ELEC-261: Actually use GCC's warnings,20,[],https://github.com/uw-midsun/firmware/pull/74,https://github.com/karlding,5,https://github.com/uw-midsun/firmware/pull/74#issuecomment-323877163,"So I always wondered why GCC wasn't catching things like functions that should have return types. It turns out I suppressed warnings back when I first built the build system.
This PR fixes that, adds -Wextra and some other flags I thought were useful, upgrades to C11, and fixes all the bugs that GCC actually caught but we ignored. The main question I have is what flags are actually useful - I've disabled void pointer arithmetic, which adds a lot of casts to the code. I tried adding -Wconversion and that was completely useless due to the bitfields.
Changes tested on both x86 and STM32F0xx.",I made the version bump in #65 😢,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,74,2017-08-21T16:17:57Z,2017-08-21T23:58:43Z,2017-08-21T23:58:46Z,MERGED,True,644,650,55,https://github.com/tituschow,ELEC-261: Actually use GCC's warnings,20,[],https://github.com/uw-midsun/firmware/pull/74,https://github.com/tituschow,6,https://github.com/uw-midsun/firmware/pull/74#issuecomment-323877218,"So I always wondered why GCC wasn't catching things like functions that should have return types. It turns out I suppressed warnings back when I first built the build system.
This PR fixes that, adds -Wextra and some other flags I thought were useful, upgrades to C11, and fixes all the bugs that GCC actually caught but we ignored. The main question I have is what flags are actually useful - I've disabled void pointer arithmetic, which adds a lot of casts to the code. I tried adding -Wconversion and that was completely useless due to the bitfields.
Changes tested on both x86 and STM32F0xx.","huehuehue
I needed it for _Generic",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,75,2017-08-23T17:13:43Z,2017-08-28T18:40:12Z,2017-08-28T18:40:16Z,MERGED,True,181,83,8,https://github.com/ckitagawa,ELEC-263: Improve PWM module by supporting different hardware timers.,7,[],https://github.com/uw-midsun/firmware/pull/75,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/75,"This is a relatively simple PR to remove the restriction that TIM3 is the only timer that can be used on the stm32f0xx architecture for PWM output. I plan to manually perform functional testing for all 6 timers supporting PWM output this afternoon I just wanted to put this up for PR ahead of time. (DONE). Currently, nothing depends on PWM so it would be nice to get this API change in before anything starts relying on it.","This is a relatively simple PR to remove the restriction that TIM3 is the only timer that can be used on the stm32f0xx architecture for PWM output. I plan to manually perform functional testing for all 6 timers supporting PWM output this afternoon I just wanted to put this up for PR ahead of time. (DONE). Currently, nothing depends on PWM so it would be nice to get this API change in before anything starts relying on it.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,76,2017-08-23T21:06:19Z,2017-10-20T18:21:11Z,2017-10-20T18:21:17Z,MERGED,True,661,607,26,https://github.com/Derpalooza,ELEC-262: Driver Controls Cleanup,65,[],https://github.com/uw-midsun/firmware/pull/76,https://github.com/Derpalooza,1,https://github.com/uw-midsun/firmware/pull/76,"This PR is to address some of the problems that went uncaught during the original driver controls review. Also, since there wasn't an enforced standard between FSMs on how to prepare data for CAN, I created a new function for the FSMs to delegate CAN event creation to.","This PR is to address some of the problems that went uncaught during the original driver controls review. Also, since there wasn't an enforced standard between FSMs on how to prepare data for CAN, I created a new function for the FSMs to delegate CAN event creation to.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,76,2017-08-23T21:06:19Z,2017-10-20T18:21:11Z,2017-10-20T18:21:17Z,MERGED,True,661,607,26,https://github.com/Derpalooza,ELEC-262: Driver Controls Cleanup,65,[],https://github.com/uw-midsun/firmware/pull/76,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/76#issuecomment-324524026,"This PR is to address some of the problems that went uncaught during the original driver controls review. Also, since there wasn't an enforced standard between FSMs on how to prepare data for CAN, I created a new function for the FSMs to delegate CAN event creation to.",We have make format for most of our style concerns now. :),True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,77,2017-08-27T19:32:25Z,2017-08-27T20:07:18Z,2017-08-27T20:07:21Z,MERGED,True,15,4,1,https://github.com/ckitagawa,ELEC-227: Improve readability of GPIO OD logic,1,[],https://github.com/uw-midsun/firmware/pull/77,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/77,This change is essentially trivial it just makes some of the OD logic on the stm32f0xx implementation more explicit/clear to the reader. Functionally this is the same as it was before I just used if statements as IMO they are more readable than conditionals and I wasn't comfortable with an implicit cast that was occurring. Feel free to reject this change as it is mainly stylistic.,This change is essentially trivial it just makes some of the OD logic on the stm32f0xx implementation more explicit/clear to the reader. Functionally this is the same as it was before I just used if statements as IMO they are more readable than conditionals and I wasn't comfortable with an implicit cast that was occurring. Feel free to reject this change as it is mainly stylistic.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,78,2017-08-27T20:47:14Z,2017-08-28T19:34:37Z,2017-08-28T19:36:32Z,MERGED,True,136,131,26,https://github.com/ckitagawa,ELEC-259: Make enum naming consistent,6,[],https://github.com/uw-midsun/firmware/pull/78,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/78,"This PR cleans up every instance of an enum primarily fixing the inconsistency of naming of NUM* used in guard clauses. The new standard is NUM_MODULE_SPECIFIER where the specifier is pluralized.
I also added guard clauses to i2c.c and spi.c and cleaned up various other minor issues with documentation, use of status.h and some struct initializers. Suggestions of how to test i2c and spi are appreciated seeing as they don't have tests at the moment.","This PR cleans up every instance of an enum primarily fixing the inconsistency of naming of NUM* used in guard clauses. The new standard is NUM_MODULE_SPECIFIER where the specifier is pluralized.
I also added guard clauses to i2c.c and spi.c and cleaned up various other minor issues with documentation, use of status.h and some struct initializers. Suggestions of how to test i2c and spi are appreciated seeing as they don't have tests at the moment.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,78,2017-08-27T20:47:14Z,2017-08-28T19:34:37Z,2017-08-28T19:36:32Z,MERGED,True,136,131,26,https://github.com/ckitagawa,ELEC-259: Make enum naming consistent,6,[],https://github.com/uw-midsun/firmware/pull/78,https://github.com/karlding,2,https://github.com/uw-midsun/firmware/pull/78#issuecomment-325225824,"This PR cleans up every instance of an enum primarily fixing the inconsistency of naming of NUM* used in guard clauses. The new standard is NUM_MODULE_SPECIFIER where the specifier is pluralized.
I also added guard clauses to i2c.c and spi.c and cleaned up various other minor issues with documentation, use of status.h and some struct initializers. Suggestions of how to test i2c and spi are appreciated seeing as they don't have tests at the moment.","I thought the test_project was basically a SPI integration test, depending on which LED is on?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,78,2017-08-27T20:47:14Z,2017-08-28T19:34:37Z,2017-08-28T19:36:32Z,MERGED,True,136,131,26,https://github.com/ckitagawa,ELEC-259: Make enum naming consistent,6,[],https://github.com/uw-midsun/firmware/pull/78,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/78#issuecomment-325227867,"This PR cleans up every instance of an enum primarily fixing the inconsistency of naming of NUM* used in guard clauses. The new standard is NUM_MODULE_SPECIFIER where the specifier is pluralized.
I also added guard clauses to i2c.c and spi.c and cleaned up various other minor issues with documentation, use of status.h and some struct initializers. Suggestions of how to test i2c and spi are appreciated seeing as they don't have tests at the moment.","@karlding - test_project is currently an integration test, but I'm honestly not a huge fan of it. If we defined a ""test board"" (probably breakout-based) that had different chips such as I2C/SPI slaves, UART loopback, etc, we could write tests with the assumption that we had these boards attached.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,78,2017-08-27T20:47:14Z,2017-08-28T19:34:37Z,2017-08-28T19:36:32Z,MERGED,True,136,131,26,https://github.com/ckitagawa,ELEC-259: Make enum naming consistent,6,[],https://github.com/uw-midsun/firmware/pull/78,https://github.com/tituschow,4,https://github.com/uw-midsun/firmware/pull/78#issuecomment-325227946,"This PR cleans up every instance of an enum primarily fixing the inconsistency of naming of NUM* used in guard clauses. The new standard is NUM_MODULE_SPECIFIER where the specifier is pluralized.
I also added guard clauses to i2c.c and spi.c and cleaned up various other minor issues with documentation, use of status.h and some struct initializers. Suggestions of how to test i2c and spi are appreciated seeing as they don't have tests at the moment.",@ckitagawa - We should probably replace all the compressed guard checks as well. (i.e. guards within a static function along the lines of prv_is_valid),True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,78,2017-08-27T20:47:14Z,2017-08-28T19:34:37Z,2017-08-28T19:36:32Z,MERGED,True,136,131,26,https://github.com/ckitagawa,ELEC-259: Make enum naming consistent,6,[],https://github.com/uw-midsun/firmware/pull/78,https://github.com/tituschow,5,https://github.com/uw-midsun/firmware/pull/78#issuecomment-325237137,"This PR cleans up every instance of an enum primarily fixing the inconsistency of naming of NUM* used in guard clauses. The new standard is NUM_MODULE_SPECIFIER where the specifier is pluralized.
I also added guard clauses to i2c.c and spi.c and cleaned up various other minor issues with documentation, use of status.h and some struct initializers. Suggestions of how to test i2c and spi are appreciated seeing as they don't have tests at the moment.","Can we add a linter rule for this? Or would that be a lot of work?
A linter rule for module/macro prefixes would be nice too, but probably unrelated.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,78,2017-08-27T20:47:14Z,2017-08-28T19:34:37Z,2017-08-28T19:36:32Z,MERGED,True,136,131,26,https://github.com/ckitagawa,ELEC-259: Make enum naming consistent,6,[],https://github.com/uw-midsun/firmware/pull/78,https://github.com/ckitagawa,6,https://github.com/uw-midsun/firmware/pull/78#issuecomment-325455585,"This PR cleans up every instance of an enum primarily fixing the inconsistency of naming of NUM* used in guard clauses. The new standard is NUM_MODULE_SPECIFIER where the specifier is pluralized.
I also added guard clauses to i2c.c and spi.c and cleaned up various other minor issues with documentation, use of status.h and some struct initializers. Suggestions of how to test i2c and spi are appreciated seeing as they don't have tests at the moment.","Tracking the issue re:linter support at ELEC-267.
This may be a fair amount of work as the current linter has no such functionality. We will need to come up with custom checks (probably regex based and plurality for the enum will be a headache). C++ has namespaces to avoid the module naming issue which arises due to name collisions. Additionally, enum classes in C++ enforce strongly typed enums avoiding the need for the guard clauses. Consequently, the linter never really had any need for either of these functions.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,79,2017-08-28T07:35:54Z,2017-08-29T20:18:46Z,2017-08-29T20:18:49Z,MERGED,True,785,422,34,https://github.com/tituschow,ELEC-203: CAN refactor,30,[],https://github.com/uw-midsun/firmware/pull/79,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/79,"This PR:

Uses the settings/storage paradigm for CAN
Prevents TX from starving the main loop
Adds GPIO init to CAN HW
Renames GPIO functions to be more consistent
Uses FIFOs for CAN instead of priority queues
Uses fixed bitrates instead of calculated settings

Tested with two rev4 controller boards up to 500kbps without any issues. 1mbps I couldn't get RX working, but that's probably because I'm running off of the internal PLL.","This PR:

Uses the settings/storage paradigm for CAN
Prevents TX from starving the main loop
Adds GPIO init to CAN HW
Renames GPIO functions to be more consistent
Uses FIFOs for CAN instead of priority queues
Uses fixed bitrates instead of calculated settings

Tested with two rev4 controller boards up to 500kbps without any issues. 1mbps I couldn't get RX working, but that's probably because I'm running off of the internal PLL.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,80,2017-08-28T20:11:37Z,2017-08-29T18:01:32Z,2017-08-29T18:01:36Z,MERGED,True,13,6,6,https://github.com/ckitagawa,ELEC-268: Move generic code to libcore,2,[],https://github.com/uw-midsun/firmware/pull/80,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/80,"This PR is intended to move what we can of the generic data structures to libcore from ms-common. Unfortunately, most of them depend on critical_section.h which I strongly believe belongs in ms-common and not libcore. Therefore very few modules could be moved. Furthermore, I'm not even sure if moving anything other than log.h and possibly fsm.h is even worthwhile. I do think the move and modification to test_helpers.h as a result creating hal_test_helpers.h is a reasonable change although I would welcome suggestions for better names.
I'm perfectly happy to revert moving any files we decide we don't want to move.","This PR is intended to move what we can of the generic data structures to libcore from ms-common. Unfortunately, most of them depend on critical_section.h which I strongly believe belongs in ms-common and not libcore. Therefore very few modules could be moved. Furthermore, I'm not even sure if moving anything other than log.h and possibly fsm.h is even worthwhile. I do think the move and modification to test_helpers.h as a result creating hal_test_helpers.h is a reasonable change although I would welcome suggestions for better names.
I'm perfectly happy to revert moving any files we decide we don't want to move.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,80,2017-08-28T20:11:37Z,2017-08-29T18:01:32Z,2017-08-29T18:01:36Z,MERGED,True,13,6,6,https://github.com/ckitagawa,ELEC-268: Move generic code to libcore,2,[],https://github.com/uw-midsun/firmware/pull/80,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/80#issuecomment-325472770,"This PR is intended to move what we can of the generic data structures to libcore from ms-common. Unfortunately, most of them depend on critical_section.h which I strongly believe belongs in ms-common and not libcore. Therefore very few modules could be moved. Furthermore, I'm not even sure if moving anything other than log.h and possibly fsm.h is even worthwhile. I do think the move and modification to test_helpers.h as a result creating hal_test_helpers.h is a reasonable change although I would welcome suggestions for better names.
I'm perfectly happy to revert moving any files we decide we don't want to move.","Hmm, that's an interesting point. It does limit what we can actually move. Maybe it would be better to limit libcore to modules that are used in both platform libs. I think it makes sense to try to keep most of our code in one library.
FIFO also requires a critical section - I've added it in my CAN PR. I think the test_helpers change is reasonable.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,80,2017-08-28T20:11:37Z,2017-08-29T18:01:32Z,2017-08-29T18:01:36Z,MERGED,True,13,6,6,https://github.com/ckitagawa,ELEC-268: Move generic code to libcore,2,[],https://github.com/uw-midsun/firmware/pull/80,https://github.com/ckitagawa,3,https://github.com/uw-midsun/firmware/pull/80#issuecomment-325724762,"This PR is intended to move what we can of the generic data structures to libcore from ms-common. Unfortunately, most of them depend on critical_section.h which I strongly believe belongs in ms-common and not libcore. Therefore very few modules could be moved. Furthermore, I'm not even sure if moving anything other than log.h and possibly fsm.h is even worthwhile. I do think the move and modification to test_helpers.h as a result creating hal_test_helpers.h is a reasonable change although I would welcome suggestions for better names.
I'm perfectly happy to revert moving any files we decide we don't want to move.",I've restored fifo and fsm to their original locations. This leaves only the migration of test_helpers and log both of which are useful in testing and debugging any library.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,81,2017-08-29T08:23:19Z,2017-10-20T04:12:05Z,2017-10-20T04:12:05Z,CLOSED,False,199,3,8,https://github.com/tituschow,ELEC-266: TCP server for x86,5,[],https://github.com/uw-midsun/firmware/pull/81,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/81,"This is more of a preliminary investigation into a potential solution than a fleshed-out design.
This PR adds a TCP server running in another thread that listens for registered commands. By default, quit will exit the program. The idea is that modules can register additional command handlers and we can write scripts to run x86 integration testing for application logic. Arguments can be parsed within handlers.
I'm mostly interested in thoughts on the concept and whether it makes sense/is useful.
For testing, telnet localhost 4000 or netcat localhost 4000 will work.
TODO: Add documentation, potentially move to StatusCodes.","This is more of a preliminary investigation into a potential solution than a fleshed-out design.
This PR adds a TCP server running in another thread that listens for registered commands. By default, quit will exit the program. The idea is that modules can register additional command handlers and we can write scripts to run x86 integration testing for application logic. Arguments can be parsed within handlers.
I'm mostly interested in thoughts on the concept and whether it makes sense/is useful.
For testing, telnet localhost 4000 or netcat localhost 4000 will work.
TODO: Add documentation, potentially move to StatusCodes.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,81,2017-08-29T08:23:19Z,2017-10-20T04:12:05Z,2017-10-20T04:12:05Z,CLOSED,False,199,3,8,https://github.com/tituschow,ELEC-266: TCP server for x86,5,[],https://github.com/uw-midsun/firmware/pull/81,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/81#issuecomment-325736078,"This is more of a preliminary investigation into a potential solution than a fleshed-out design.
This PR adds a TCP server running in another thread that listens for registered commands. By default, quit will exit the program. The idea is that modules can register additional command handlers and we can write scripts to run x86 integration testing for application logic. Arguments can be parsed within handlers.
I'm mostly interested in thoughts on the concept and whether it makes sense/is useful.
For testing, telnet localhost 4000 or netcat localhost 4000 will work.
TODO: Add documentation, potentially move to StatusCodes.","A TCP server is probably a reasonable way to handle the IOs. We can just publish the GPIO/I2C/UART/SPI signals and it is reasonably easy to do loopback for testing.
I was considering a different solution which was writing outputs to /dev/tty interfaces and then reading them back to assert on the output for loopback I'll work on a mockup of that concept when I have some time. Also this solution can probably work with some physical hardware as well (at least for UART and it looks like SPI or even i2c if drivers/hardware are provided).
I feel like both of them are acceptable. TCP is probably the way to go just because I think it ought to be easier and it is also more adaptable to other programs/interfaces. That being said I'd like to hear some other people's thoughts on the matter. Thoughts @karlding, @Derpalooza?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,81,2017-08-29T08:23:19Z,2017-10-20T04:12:05Z,2017-10-20T04:12:05Z,CLOSED,False,199,3,8,https://github.com/tituschow,ELEC-266: TCP server for x86,5,[],https://github.com/uw-midsun/firmware/pull/81,https://github.com/karlding,3,https://github.com/uw-midsun/firmware/pull/81#issuecomment-338101320,"This is more of a preliminary investigation into a potential solution than a fleshed-out design.
This PR adds a TCP server running in another thread that listens for registered commands. By default, quit will exit the program. The idea is that modules can register additional command handlers and we can write scripts to run x86 integration testing for application logic. Arguments can be parsed within handlers.
I'm mostly interested in thoughts on the concept and whether it makes sense/is useful.
For testing, telnet localhost 4000 or netcat localhost 4000 will work.
TODO: Add documentation, potentially move to StatusCodes.","I'm going to close this for now, since it's just going to be sitting here and getting stale for the time-being.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,82,2017-08-30T00:24:04Z,2017-08-30T18:06:05Z,2017-08-30T18:06:08Z,MERGED,True,35,18,1,https://github.com/tituschow,ELEC-273: Update docs,3,[],https://github.com/uw-midsun/firmware/pull/82,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/82,"Updates the readme so it's hopefully a little easier to understand.
I'm thinking of adding some quick guides/tutorials to the repo. Maybe something along the lines of ""my first issue"".","Updates the readme so it's hopefully a little easier to understand.
I'm thinking of adding some quick guides/tutorials to the repo. Maybe something along the lines of ""my first issue"".",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,83,2017-08-30T05:01:08Z,2017-10-20T04:11:59Z,2018-02-28T21:11:55Z,CLOSED,False,227,5,9,https://github.com/tituschow,ELEC-218: Telemetry PoC,13,[],https://github.com/uw-midsun/firmware/pull/83,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/83,"Implements a completely untested telemetry PoC and updates test_can for the TX changes made in #79.
Received CAN messages are dumped with the format RX[raw_id data_u32[1] data_u32[0]] and CAN messages will be generated from received messages in the format TX[msg_id data_u32[1] data_u32[0]].
edit: Now tested using UART1. It seems to receive pretty well.
TODO: add TX capability to interface? more of a debugging thing","Implements a completely untested telemetry PoC and updates test_can for the TX changes made in #79.
Received CAN messages are dumped with the format RX[raw_id data_u32[1] data_u32[0]] and CAN messages will be generated from received messages in the format TX[msg_id data_u32[1] data_u32[0]].
edit: Now tested using UART1. It seems to receive pretty well.
TODO: add TX capability to interface? more of a debugging thing",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,83,2017-08-30T05:01:08Z,2017-10-20T04:11:59Z,2018-02-28T21:11:55Z,CLOSED,False,227,5,9,https://github.com/tituschow,ELEC-218: Telemetry PoC,13,[],https://github.com/uw-midsun/firmware/pull/83,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/83#issuecomment-326766815,"Implements a completely untested telemetry PoC and updates test_can for the TX changes made in #79.
Received CAN messages are dumped with the format RX[raw_id data_u32[1] data_u32[0]] and CAN messages will be generated from received messages in the format TX[msg_id data_u32[1] data_u32[0]].
edit: Now tested using UART1. It seems to receive pretty well.
TODO: add TX capability to interface? more of a debugging thing",re: Braces - The idea is that having known start and end characters (especially with a known length) helps us ensure that we didn't miss a byte somewhere or have some extra.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,83,2017-08-30T05:01:08Z,2017-10-20T04:11:59Z,2018-02-28T21:11:55Z,CLOSED,False,227,5,9,https://github.com/tituschow,ELEC-218: Telemetry PoC,13,[],https://github.com/uw-midsun/firmware/pull/83,https://github.com/ckitagawa,3,https://github.com/uw-midsun/firmware/pull/83#issuecomment-326767780,"Implements a completely untested telemetry PoC and updates test_can for the TX changes made in #79.
Received CAN messages are dumped with the format RX[raw_id data_u32[1] data_u32[0]] and CAN messages will be generated from received messages in the format TX[msg_id data_u32[1] data_u32[0]].
edit: Now tested using UART1. It seems to receive pretty well.
TODO: add TX capability to interface? more of a debugging thing","re:Braces - Ok totally understandable, that's what I figured just wanted to confirm.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,83,2017-08-30T05:01:08Z,2017-10-20T04:11:59Z,2018-02-28T21:11:55Z,CLOSED,False,227,5,9,https://github.com/tituschow,ELEC-218: Telemetry PoC,13,[],https://github.com/uw-midsun/firmware/pull/83,https://github.com/karlding,4,https://github.com/uw-midsun/firmware/pull/83#issuecomment-338101310,"Implements a completely untested telemetry PoC and updates test_can for the TX changes made in #79.
Received CAN messages are dumped with the format RX[raw_id data_u32[1] data_u32[0]] and CAN messages will be generated from received messages in the format TX[msg_id data_u32[1] data_u32[0]].
edit: Now tested using UART1. It seems to receive pretty well.
TODO: add TX capability to interface? more of a debugging thing","I'm going to close this for now, since it's just going to be sitting here and getting stale for the time-being.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,84,2017-08-31T10:08:58Z,2017-09-01T22:00:45Z,2017-09-01T22:00:48Z,MERGED,True,266,32,11,https://github.com/tituschow,ELEC-80: SocketCAN x86 Support,12,[],https://github.com/uw-midsun/firmware/pull/84,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/84,"Adds socketCAN-backed CAN HW module. The idea is that we have two additional threads: RX and TX. RX constantly blocks waiting for frames to come in, while TX is used with a FIFO to emulate bus speeds.
Also adds a recursive mutex to critical_section for some thread-safety and fixes test_can.","Adds socketCAN-backed CAN HW module. The idea is that we have two additional threads: RX and TX. RX constantly blocks waiting for frames to come in, while TX is used with a FIFO to emulate bus speeds.
Also adds a recursive mutex to critical_section for some thread-safety and fixes test_can.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,84,2017-08-31T10:08:58Z,2017-09-01T22:00:45Z,2017-09-01T22:00:48Z,MERGED,True,266,32,11,https://github.com/tituschow,ELEC-80: SocketCAN x86 Support,12,[],https://github.com/uw-midsun/firmware/pull/84,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/84#issuecomment-326396271,"Adds socketCAN-backed CAN HW module. The idea is that we have two additional threads: RX and TX. RX constantly blocks waiting for frames to come in, while TX is used with a FIFO to emulate bus speeds.
Also adds a recursive mutex to critical_section for some thread-safety and fixes test_can.",tfw I spend more time trying to get the tests disabled than actually getting it working,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,85,2017-09-01T20:04:13Z,2017-09-02T02:45:23Z,2018-01-13T22:51:52Z,CLOSED,False,66,3,6,https://github.com/ckitagawa,ELEC-275: AltFn Defs,2,[],https://github.com/uw-midsun/firmware/pull/85,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/85,"I'll admit I'm not sure if this is actually what we want as I'm a little uncertain as to the best way to approach this problem. What I did is based on how retarget_cfg.h works but a little more transparent. Feel free to suggest alternatives as I'm not really happy with how this turned out TBH.
In essence the idea is you use the #define corresponding to the GPIO pin or port you want to use for the peripheral and it will return the correct AltFn enum entry. I've included it in the *_mcu.h definitions for the stm32f0xx as these are technically platform specific. This applies to PWM (more broadly timers), I2C and UART as fortunately SPI is all on one Altfn and doesn't require this. Unfortunately, this means that if used in application layer code the x86 build will fail unless it is surrounded with an #ifdef or similar.
Personally, I'm a little conflicted about this change... It seems like less work to just look at the datasheet than attempt to #define all the possible combinations but I suppose it does give some level of insurance regarding the correct port/pin combination for the peripheral. It just seems overkill though. If there is a more elegant solution I'd be a lot more in favor of this change I just can't think of anything that is really nice?","I'll admit I'm not sure if this is actually what we want as I'm a little uncertain as to the best way to approach this problem. What I did is based on how retarget_cfg.h works but a little more transparent. Feel free to suggest alternatives as I'm not really happy with how this turned out TBH.
In essence the idea is you use the #define corresponding to the GPIO pin or port you want to use for the peripheral and it will return the correct AltFn enum entry. I've included it in the *_mcu.h definitions for the stm32f0xx as these are technically platform specific. This applies to PWM (more broadly timers), I2C and UART as fortunately SPI is all on one Altfn and doesn't require this. Unfortunately, this means that if used in application layer code the x86 build will fail unless it is surrounded with an #ifdef or similar.
Personally, I'm a little conflicted about this change... It seems like less work to just look at the datasheet than attempt to #define all the possible combinations but I suppose it does give some level of insurance regarding the correct port/pin combination for the peripheral. It just seems overkill though. If there is a more elegant solution I'd be a lot more in favor of this change I just can't think of anything that is really nice?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,85,2017-09-01T20:04:13Z,2017-09-02T02:45:23Z,2018-01-13T22:51:52Z,CLOSED,False,66,3,6,https://github.com/ckitagawa,ELEC-275: AltFn Defs,2,[],https://github.com/uw-midsun/firmware/pull/85,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/85#issuecomment-326687573,"I'll admit I'm not sure if this is actually what we want as I'm a little uncertain as to the best way to approach this problem. What I did is based on how retarget_cfg.h works but a little more transparent. Feel free to suggest alternatives as I'm not really happy with how this turned out TBH.
In essence the idea is you use the #define corresponding to the GPIO pin or port you want to use for the peripheral and it will return the correct AltFn enum entry. I've included it in the *_mcu.h definitions for the stm32f0xx as these are technically platform specific. This applies to PWM (more broadly timers), I2C and UART as fortunately SPI is all on one Altfn and doesn't require this. Unfortunately, this means that if used in application layer code the x86 build will fail unless it is surrounded with an #ifdef or similar.
Personally, I'm a little conflicted about this change... It seems like less work to just look at the datasheet than attempt to #define all the possible combinations but I suppose it does give some level of insurance regarding the correct port/pin combination for the peripheral. It just seems overkill though. If there is a more elegant solution I'd be a lot more in favor of this change I just can't think of anything that is really nice?","Hmm. Yeah, this seems to clutter things up quite a bit.
I have a few ideas, but ultimately I think it might make more sense to define a few pins as ""PWM"" just as we have with UART, I2C, and SPI. That would probably be a lot easier to manage. In the resources page, I've uploaded an altfn spreadsheet that we can probably move to a confluence table.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,85,2017-09-01T20:04:13Z,2017-09-02T02:45:23Z,2018-01-13T22:51:52Z,CLOSED,False,66,3,6,https://github.com/ckitagawa,ELEC-275: AltFn Defs,2,[],https://github.com/uw-midsun/firmware/pull/85,https://github.com/ckitagawa,3,https://github.com/uw-midsun/firmware/pull/85#issuecomment-326693118,"I'll admit I'm not sure if this is actually what we want as I'm a little uncertain as to the best way to approach this problem. What I did is based on how retarget_cfg.h works but a little more transparent. Feel free to suggest alternatives as I'm not really happy with how this turned out TBH.
In essence the idea is you use the #define corresponding to the GPIO pin or port you want to use for the peripheral and it will return the correct AltFn enum entry. I've included it in the *_mcu.h definitions for the stm32f0xx as these are technically platform specific. This applies to PWM (more broadly timers), I2C and UART as fortunately SPI is all on one Altfn and doesn't require this. Unfortunately, this means that if used in application layer code the x86 build will fail unless it is surrounded with an #ifdef or similar.
Personally, I'm a little conflicted about this change... It seems like less work to just look at the datasheet than attempt to #define all the possible combinations but I suppose it does give some level of insurance regarding the correct port/pin combination for the peripheral. It just seems overkill though. If there is a more elegant solution I'd be a lot more in favor of this change I just can't think of anything that is really nice?","SGTM. So for the definition of pins as ""PWM"" is that something that should occur on the hardware side of things? Or is there somewhere in the repo we explicitly define the pins that I am too blind to see?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,85,2017-09-01T20:04:13Z,2017-09-02T02:45:23Z,2018-01-13T22:51:52Z,CLOSED,False,66,3,6,https://github.com/ckitagawa,ELEC-275: AltFn Defs,2,[],https://github.com/uw-midsun/firmware/pull/85,https://github.com/tituschow,4,https://github.com/uw-midsun/firmware/pull/85#issuecomment-326693361,"I'll admit I'm not sure if this is actually what we want as I'm a little uncertain as to the best way to approach this problem. What I did is based on how retarget_cfg.h works but a little more transparent. Feel free to suggest alternatives as I'm not really happy with how this turned out TBH.
In essence the idea is you use the #define corresponding to the GPIO pin or port you want to use for the peripheral and it will return the correct AltFn enum entry. I've included it in the *_mcu.h definitions for the stm32f0xx as these are technically platform specific. This applies to PWM (more broadly timers), I2C and UART as fortunately SPI is all on one Altfn and doesn't require this. Unfortunately, this means that if used in application layer code the x86 build will fail unless it is surrounded with an #ifdef or similar.
Personally, I'm a little conflicted about this change... It seems like less work to just look at the datasheet than attempt to #define all the possible combinations but I suppose it does give some level of insurance regarding the correct port/pin combination for the peripheral. It just seems overkill though. If there is a more elegant solution I'd be a lot more in favor of this change I just can't think of anything that is really nice?","That would be a hardware thing. It's more of a ""contract"" that we choose to abide by.
@taipingli - Can we add some PWM pins to the mezzanine pinout?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,85,2017-09-01T20:04:13Z,2017-09-02T02:45:23Z,2018-01-13T22:51:52Z,CLOSED,False,66,3,6,https://github.com/ckitagawa,ELEC-275: AltFn Defs,2,[],https://github.com/uw-midsun/firmware/pull/85,https://github.com/tituschow,5,https://github.com/uw-midsun/firmware/pull/85#issuecomment-326693679,"I'll admit I'm not sure if this is actually what we want as I'm a little uncertain as to the best way to approach this problem. What I did is based on how retarget_cfg.h works but a little more transparent. Feel free to suggest alternatives as I'm not really happy with how this turned out TBH.
In essence the idea is you use the #define corresponding to the GPIO pin or port you want to use for the peripheral and it will return the correct AltFn enum entry. I've included it in the *_mcu.h definitions for the stm32f0xx as these are technically platform specific. This applies to PWM (more broadly timers), I2C and UART as fortunately SPI is all on one Altfn and doesn't require this. Unfortunately, this means that if used in application layer code the x86 build will fail unless it is surrounded with an #ifdef or similar.
Personally, I'm a little conflicted about this change... It seems like less work to just look at the datasheet than attempt to #define all the possible combinations but I suppose it does give some level of insurance regarding the correct port/pin combination for the peripheral. It just seems overkill though. If there is a more elegant solution I'd be a lot more in favor of this change I just can't think of anything that is really nice?","So maybe something along the lines of
#define UART_PORT_1_TX { gpio }
#define UART_PORT_1_RX { gpio }
#define UART_PORT_1_ALTFN altfn

?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,85,2017-09-01T20:04:13Z,2017-09-02T02:45:23Z,2018-01-13T22:51:52Z,CLOSED,False,66,3,6,https://github.com/ckitagawa,ELEC-275: AltFn Defs,2,[],https://github.com/uw-midsun/firmware/pull/85,https://github.com/taipingli,6,https://github.com/uw-midsun/firmware/pull/85#issuecomment-326697057,"I'll admit I'm not sure if this is actually what we want as I'm a little uncertain as to the best way to approach this problem. What I did is based on how retarget_cfg.h works but a little more transparent. Feel free to suggest alternatives as I'm not really happy with how this turned out TBH.
In essence the idea is you use the #define corresponding to the GPIO pin or port you want to use for the peripheral and it will return the correct AltFn enum entry. I've included it in the *_mcu.h definitions for the stm32f0xx as these are technically platform specific. This applies to PWM (more broadly timers), I2C and UART as fortunately SPI is all on one Altfn and doesn't require this. Unfortunately, this means that if used in application layer code the x86 build will fail unless it is surrounded with an #ifdef or similar.
Personally, I'm a little conflicted about this change... It seems like less work to just look at the datasheet than attempt to #define all the possible combinations but I suppose it does give some level of insurance regarding the correct port/pin combination for the peripheral. It just seems overkill though. If there is a more elegant solution I'd be a lot more in favor of this change I just can't think of anything that is really nice?","@tituschow When you say designate them as PWM pins, do you just want to change the net names to reflect that? or did you want to do anything special with them?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,85,2017-09-01T20:04:13Z,2017-09-02T02:45:23Z,2018-01-13T22:51:52Z,CLOSED,False,66,3,6,https://github.com/ckitagawa,ELEC-275: AltFn Defs,2,[],https://github.com/uw-midsun/firmware/pull/85,https://github.com/tituschow,7,https://github.com/uw-midsun/firmware/pull/85#issuecomment-326697172,"I'll admit I'm not sure if this is actually what we want as I'm a little uncertain as to the best way to approach this problem. What I did is based on how retarget_cfg.h works but a little more transparent. Feel free to suggest alternatives as I'm not really happy with how this turned out TBH.
In essence the idea is you use the #define corresponding to the GPIO pin or port you want to use for the peripheral and it will return the correct AltFn enum entry. I've included it in the *_mcu.h definitions for the stm32f0xx as these are technically platform specific. This applies to PWM (more broadly timers), I2C and UART as fortunately SPI is all on one Altfn and doesn't require this. Unfortunately, this means that if used in application layer code the x86 build will fail unless it is surrounded with an #ifdef or similar.
Personally, I'm a little conflicted about this change... It seems like less work to just look at the datasheet than attempt to #define all the possible combinations but I suppose it does give some level of insurance regarding the correct port/pin combination for the peripheral. It just seems overkill though. If there is a more elegant solution I'd be a lot more in favor of this change I just can't think of anything that is really nice?","Just change the net names, like ADC or SPI.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,85,2017-09-01T20:04:13Z,2017-09-02T02:45:23Z,2018-01-13T22:51:52Z,CLOSED,False,66,3,6,https://github.com/ckitagawa,ELEC-275: AltFn Defs,2,[],https://github.com/uw-midsun/firmware/pull/85,https://github.com/ckitagawa,8,https://github.com/uw-midsun/firmware/pull/85#issuecomment-326717246,"I'll admit I'm not sure if this is actually what we want as I'm a little uncertain as to the best way to approach this problem. What I did is based on how retarget_cfg.h works but a little more transparent. Feel free to suggest alternatives as I'm not really happy with how this turned out TBH.
In essence the idea is you use the #define corresponding to the GPIO pin or port you want to use for the peripheral and it will return the correct AltFn enum entry. I've included it in the *_mcu.h definitions for the stm32f0xx as these are technically platform specific. This applies to PWM (more broadly timers), I2C and UART as fortunately SPI is all on one Altfn and doesn't require this. Unfortunately, this means that if used in application layer code the x86 build will fail unless it is surrounded with an #ifdef or similar.
Personally, I'm a little conflicted about this change... It seems like less work to just look at the datasheet than attempt to #define all the possible combinations but I suppose it does give some level of insurance regarding the correct port/pin combination for the peripheral. It just seems overkill though. If there is a more elegant solution I'd be a lot more in favor of this change I just can't think of anything that is really nice?",Okay so once those changes are in to uw-midsun/hardware I will modify this PR and re-open it.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,86,2017-09-01T22:53:56Z,2017-09-02T01:09:02Z,2017-09-02T01:09:05Z,CLOSED,False,2,2,1,https://github.com/tituschow,ELEC-278: Fix socketcan reinit,1,[],https://github.com/uw-midsun/firmware/pull/86,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/86,Adds || true to socketcan so calling it twice won't fault.,Adds || true to socketcan so calling it twice won't fault.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,86,2017-09-01T22:53:56Z,2017-09-02T01:09:02Z,2017-09-02T01:09:05Z,CLOSED,False,2,2,1,https://github.com/tituschow,ELEC-278: Fix socketcan reinit,1,[],https://github.com/uw-midsun/firmware/pull/86,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/86#issuecomment-326701672,Adds || true to socketcan so calling it twice won't fault.,The socketCAN test seems to hang occasionally on Travis. I can't replicate it on my VM. Might be related to ELEC-277?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,86,2017-09-01T22:53:56Z,2017-09-02T01:09:02Z,2017-09-02T01:09:05Z,CLOSED,False,2,2,1,https://github.com/tituschow,ELEC-278: Fix socketcan reinit,1,[],https://github.com/uw-midsun/firmware/pull/86,https://github.com/ckitagawa,3,https://github.com/uw-midsun/firmware/pull/86#issuecomment-326701928,Adds || true to socketcan so calling it twice won't fault.,Also happened to me just now :/ I suspect it is related to ELEC-277 too.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,86,2017-09-01T22:53:56Z,2017-09-02T01:09:02Z,2017-09-02T01:09:05Z,CLOSED,False,2,2,1,https://github.com/tituschow,ELEC-278: Fix socketcan reinit,1,[],https://github.com/uw-midsun/firmware/pull/86,https://github.com/tituschow,4,https://github.com/uw-midsun/firmware/pull/86#issuecomment-326712256,Adds || true to socketcan so calling it twice won't fault.,Merged as part of #88,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,87,2017-09-01T23:00:30Z,2017-09-02T19:17:20Z,2017-09-02T19:29:07Z,MERGED,True,339,0,6,https://github.com/ckitagawa,ELEC-276: CAN Pack and Unpack implementations,10,[],https://github.com/uw-midsun/firmware/pull/87,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/87,"This PR is the backend (firmware) component of the work required for ELEC-274 which will add templates to codegen to automatically generate boilerplate macros for each message to pack, unpack and transmit using verbose field/message names and automatically masking and populating the message id, source id and type fields. The reason these are *_impl is because they are internals that should not be called in modules other than can_pack and can_unpack which will be generate by templates.
CAN pack is very straightforward other than the fact that the dlc field is set to the minimum required bytes to convey the message. This means if the last fields are 0s they will not be sent. However, since we are using codegen this isn't an issue in determining how large the data field is since when unpacking the receiver will automatically unpack the correct number of fields thanks to the codegen boilerplate.
CAN unpack only unpacks the fields as it is relatively easy to access the ID/source if required by de-referencing the struct. Hopefully, this should be unnecessary as dedicated handlers should be provided for most CAN messages except on driver display and telemetry which will read every message anyway.
The generated transmit macros will build and send the ACK request so the only remaining issue to solve is how the receiver knows to responds to an ACK.","This PR is the backend (firmware) component of the work required for ELEC-274 which will add templates to codegen to automatically generate boilerplate macros for each message to pack, unpack and transmit using verbose field/message names and automatically masking and populating the message id, source id and type fields. The reason these are *_impl is because they are internals that should not be called in modules other than can_pack and can_unpack which will be generate by templates.
CAN pack is very straightforward other than the fact that the dlc field is set to the minimum required bytes to convey the message. This means if the last fields are 0s they will not be sent. However, since we are using codegen this isn't an issue in determining how large the data field is since when unpacking the receiver will automatically unpack the correct number of fields thanks to the codegen boilerplate.
CAN unpack only unpacks the fields as it is relatively easy to access the ID/source if required by de-referencing the struct. Hopefully, this should be unnecessary as dedicated handlers should be provided for most CAN messages except on driver display and telemetry which will read every message anyway.
The generated transmit macros will build and send the ACK request so the only remaining issue to solve is how the receiver knows to responds to an ACK.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,88,2017-09-02T00:39:47Z,2017-09-02T01:08:45Z,2017-09-02T01:08:48Z,MERGED,True,64,17,3,https://github.com/tituschow,ELEC-277: x86 Thread Cleanup,2,[],https://github.com/uw-midsun/firmware/pull/88,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/88,"Uses a mutex to signal when to exit. It now has another failure point where the first test doesn't even pass, but we'll see if Travis ever hits it. I'll try to figure it out before I merge.","Uses a mutex to signal when to exit. It now has another failure point where the first test doesn't even pass, but we'll see if Travis ever hits it. I'll try to figure it out before I merge.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,88,2017-09-02T00:39:47Z,2017-09-02T01:08:45Z,2017-09-02T01:08:48Z,MERGED,True,64,17,3,https://github.com/tituschow,ELEC-277: x86 Thread Cleanup,2,[],https://github.com/uw-midsun/firmware/pull/88,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/88#issuecomment-326710543,"Uses a mutex to signal when to exit. It now has another failure point where the first test doesn't even pass, but we'll see if Travis ever hits it. I'll try to figure it out before I merge.",Going to purposely trigger some more rebuilds,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,89,2017-09-02T20:10:59Z,2017-09-02T22:46:07Z,2017-09-02T22:46:10Z,MERGED,True,27,13,3,https://github.com/tituschow,ELEC-279: Added pylint to lint target,6,[],https://github.com/uw-midsun/firmware/pull/89,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/89,Pretty simple change. Fixed some lint errors in new_target.py as well.,Pretty simple change. Fixed some lint errors in new_target.py as well.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,90,2017-09-02T22:08:25Z,2017-09-02T23:05:35Z,2017-09-02T23:05:38Z,MERGED,True,96,47,5,https://github.com/tituschow,ELEC-280: CAN ACK device bitset,3,[],https://github.com/uw-midsun/firmware/pull/90,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/90,"Switched from num_expected to expected device bitset.
Added variadic macro CAN_ACK_EXPECTED_DEVICES(...) to reduce the number of macros we need. I figure people will get confused and use the wrong macro.","Switched from num_expected to expected device bitset.
Added variadic macro CAN_ACK_EXPECTED_DEVICES(...) to reduce the number of macros we need. I figure people will get confused and use the wrong macro.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,91,2017-09-06T04:53:15Z,2017-09-10T07:41:07Z,2017-09-11T07:05:30Z,MERGED,True,1,1,1,https://github.com/tituschow,ELEC-282: Fixed new target,1,[],https://github.com/uw-midsun/firmware/pull/91,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/91,Fixes something I thought I'd tested. My bad.,Fixes something I thought I'd tested. My bad.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,92,2017-09-10T23:53:02Z,2017-11-11T04:25:16Z,2017-11-11T04:25:20Z,MERGED,True,15,1,3,https://github.com/karlding,ELEC-283: Add test_format target,11,[],https://github.com/uw-midsun/firmware/pull/92,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/92,"Add make test_format target.
Unfortunately, clang-format doesn't seem like it gives you a dry-run option. Instead, the idea behind this is that we'll leverage git diff to do the heavy lifting. Running make format will format any files, if necessary. make format is non-destructive, since it runs on the CI server and changes will not be committed. If files were not formatted (and need to be), then doing the git diff will return a dirty working directory.","Add make test_format target.
Unfortunately, clang-format doesn't seem like it gives you a dry-run option. Instead, the idea behind this is that we'll leverage git diff to do the heavy lifting. Running make format will format any files, if necessary. make format is non-destructive, since it runs on the CI server and changes will not be committed. If files were not formatted (and need to be), then doing the git diff will return a dirty working directory.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,92,2017-09-10T23:53:02Z,2017-11-11T04:25:16Z,2017-11-11T04:25:20Z,MERGED,True,15,1,3,https://github.com/karlding,ELEC-283: Add test_format target,11,[],https://github.com/uw-midsun/firmware/pull/92,https://github.com/karlding,2,https://github.com/uw-midsun/firmware/pull/92#issuecomment-331611766,"Add make test_format target.
Unfortunately, clang-format doesn't seem like it gives you a dry-run option. Instead, the idea behind this is that we'll leverage git diff to do the heavy lifting. Running make format will format any files, if necessary. make format is non-destructive, since it runs on the CI server and changes will not be committed. If files were not formatted (and need to be), then doing the git diff will return a dirty working directory.","Yeah, the third and fourth commits were me verifying that this worked as intended.
I'll hold off on merging this until you merge your clang-format changes.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,92,2017-09-10T23:53:02Z,2017-11-11T04:25:16Z,2017-11-11T04:25:20Z,MERGED,True,15,1,3,https://github.com/karlding,ELEC-283: Add test_format target,11,[],https://github.com/uw-midsun/firmware/pull/92,https://github.com/karlding,3,https://github.com/uw-midsun/firmware/pull/92#issuecomment-342711571,"Add make test_format target.
Unfortunately, clang-format doesn't seem like it gives you a dry-run option. Instead, the idea behind this is that we'll leverage git diff to do the heavy lifting. Running make format will format any files, if necessary. make format is non-destructive, since it runs on the CI server and changes will not be committed. If files were not formatted (and need to be), then doing the git diff will return a dirty working directory.","Made the changes needed to support clang-format-5.0 on Travis. It also now shows the git diff output if the files were changed.
If nobody has any complaints, I'll merge tomorrow morning.
Edit: Actually maybe it makes sense to get the new box released first?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,93,2017-09-15T03:21:35Z,2017-10-08T07:51:34Z,2017-10-08T07:51:40Z,MERGED,True,75,0,1,https://github.com/karlding,ELEC-242: Add DEVELOPING.md,6,[],https://github.com/uw-midsun/firmware/pull/93,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/93,Add instructions that cover setup of the Vagrant development environment to develop firmware.,Add instructions that cover setup of the Vagrant development environment to develop firmware.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,94,2017-09-21T19:46:19Z,2017-09-22T17:50:03Z,2018-01-13T22:51:48Z,CLOSED,False,5,0,1,https://github.com/ckitagawa,ELEC-288: Fix race condition in wait.h for the stm32f0xx,1,[],https://github.com/uw-midsun/firmware/pull/94,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/94,Very simple PR that protects the __WFI() call in stm32f0xx/wait.c by surrounding it in a critical section.,Very simple PR that protects the __WFI() call in stm32f0xx/wait.c by surrounding it in a critical section.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,95,2017-09-21T19:56:30Z,2017-11-02T22:26:38Z,2017-11-02T22:26:38Z,CLOSED,False,186,199,27,https://github.com/ckitagawa,ELEC-289: Run clang-format 5.0.0 over the project,1,[],https://github.com/uw-midsun/firmware/pull/95,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/95,"Ran the latest version of clang-format (5.0.0) over the entire project. If anything changed that we don't like we can discuss modifications to .clang-format and possible hacks to fix things. Otherwise this PR should be accepted without modification as this is just the result of running
make format","Ran the latest version of clang-format (5.0.0) over the entire project. If anything changed that we don't like we can discuss modifications to .clang-format and possible hacks to fix things. Otherwise this PR should be accepted without modification as this is just the result of running
make format",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,95,2017-09-21T19:56:30Z,2017-11-02T22:26:38Z,2017-11-02T22:26:38Z,CLOSED,False,186,199,27,https://github.com/ckitagawa,ELEC-289: Run clang-format 5.0.0 over the project,1,[],https://github.com/uw-midsun/firmware/pull/95,https://github.com/karlding,2,https://github.com/uw-midsun/firmware/pull/95#issuecomment-331468912,"Ran the latest version of clang-format (5.0.0) over the entire project. If anything changed that we don't like we can discuss modifications to .clang-format and possible hacks to fix things. Otherwise this PR should be accepted without modification as this is just the result of running
make format",Are we planning on cutting over to clang-format-5.0?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,95,2017-09-21T19:56:30Z,2017-11-02T22:26:38Z,2017-11-02T22:26:38Z,CLOSED,False,186,199,27,https://github.com/ckitagawa,ELEC-289: Run clang-format 5.0.0 over the project,1,[],https://github.com/uw-midsun/firmware/pull/95,https://github.com/ckitagawa,3,https://github.com/uw-midsun/firmware/pull/95#issuecomment-331515810,"Ran the latest version of clang-format (5.0.0) over the entire project. If anything changed that we don't like we can discuss modifications to .clang-format and possible hacks to fix things. Otherwise this PR should be accepted without modification as this is just the result of running
make format",@karlding that is my plan it fixes almost all the issues we had with clang-format-3/4. Should I be doing anything in Travis? - I already updated the box.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,95,2017-09-21T19:56:30Z,2017-11-02T22:26:38Z,2017-11-02T22:26:38Z,CLOSED,False,186,199,27,https://github.com/ckitagawa,ELEC-289: Run clang-format 5.0.0 over the project,1,[],https://github.com/uw-midsun/firmware/pull/95,https://github.com/karlding,4,https://github.com/uw-midsun/firmware/pull/95#issuecomment-331606756,"Ran the latest version of clang-format (5.0.0) over the entire project. If anything changed that we don't like we can discuss modifications to .clang-format and possible hacks to fix things. Otherwise this PR should be accepted without modification as this is just the result of running
make format","You'll need to add the same PPA and install the newer version of clang (or at least, clang-format-5.0). Currently I believe we're just using the version included in the default Trusty repos.
You might also need to use update-alternatives to update the symlinks—you can take a look at how we install gcc and basically do the same thing here.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,95,2017-09-21T19:56:30Z,2017-11-02T22:26:38Z,2017-11-02T22:26:38Z,CLOSED,False,186,199,27,https://github.com/ckitagawa,ELEC-289: Run clang-format 5.0.0 over the project,1,[],https://github.com/uw-midsun/firmware/pull/95,https://github.com/karlding,5,https://github.com/uw-midsun/firmware/pull/95#issuecomment-331775266,"Ran the latest version of clang-format (5.0.0) over the entire project. If anything changed that we don't like we can discuss modifications to .clang-format and possible hacks to fix things. Otherwise this PR should be accepted without modification as this is just the result of running
make format","A couple of questions about our .clang-format file:

AlignEscapedNewlinesLeft: seems to have been replaced with AlignEscapedNewlines: Left
BreakConstructorInitializersBeforeComma: seems to have been replaced with BreakConstructorInitializers: BeforeComma; the docs seem to indicate that this is for C++ constructors, which shouldn't really affect us anyways?
IndentWrappedFunctionNames: do we want to consider turning this on?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,96,2017-09-21T20:39:07Z,2017-09-22T17:48:49Z,2017-09-22T17:48:53Z,MERGED,True,69,0,2,https://github.com/ckitagawa,ELEC-290: Example project for discovery and controller board,1,[],https://github.com/uw-midsun/firmware/pull/96,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/96,"I wrote this program during the new member training session for this term and felt it was a relatively simple but effective introduction to some of our libraries and coding style. Moreover, it is relatively easy to port between the discovery board and controller board making it a good first program for people to flash onto a board and modify.
By no means do we have to merge this but I thought it might be a nice example to have available. I know that test_project is a more complex example of this but it doesn't work on the controller board. I wanted something that could readily work on either piece of hardware without much configuration or peripherals.","I wrote this program during the new member training session for this term and felt it was a relatively simple but effective introduction to some of our libraries and coding style. Moreover, it is relatively easy to port between the discovery board and controller board making it a good first program for people to flash onto a board and modify.
By no means do we have to merge this but I thought it might be a nice example to have available. I know that test_project is a more complex example of this but it doesn't work on the controller board. I wanted something that could readily work on either piece of hardware without much configuration or peripherals.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,97,2017-10-10T05:00:21Z,2018-01-13T19:24:13Z,2018-06-01T02:01:12Z,CLOSED,False,1041,211,81,https://github.com/mishazharov,ELEC-71: GPS Driver,59,[],https://github.com/uw-midsun/firmware/pull/97,https://github.com/mishazharov,1,https://github.com/uw-midsun/firmware/pull/97,"Added NMEA parser for GGA sentences. This is basically just the parser, looking for feedback
todo

 add code to disable all messages expect GGA and VTG
 add parser for VTG
 Initialization and power off code","Added NMEA parser for GGA sentences. This is basically just the parser, looking for feedback
todo

 add code to disable all messages expect GGA and VTG
 add parser for VTG
 Initialization and power off code",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,97,2017-10-10T05:00:21Z,2018-01-13T19:24:13Z,2018-06-01T02:01:12Z,CLOSED,False,1041,211,81,https://github.com/mishazharov,ELEC-71: GPS Driver,59,[],https://github.com/uw-midsun/firmware/pull/97,https://github.com/mishazharov,2,https://github.com/uw-midsun/firmware/pull/97#issuecomment-335363166,"Added NMEA parser for GGA sentences. This is basically just the parser, looking for feedback
todo

 add code to disable all messages expect GGA and VTG
 add parser for VTG
 Initialization and power off code","Will try again after fixing x86 build, lint and x86 tests from travis
https://travis-ci.org/uw-midsun/firmware/builds/285894911",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,97,2017-10-10T05:00:21Z,2018-01-13T19:24:13Z,2018-06-01T02:01:12Z,CLOSED,False,1041,211,81,https://github.com/mishazharov,ELEC-71: GPS Driver,59,[],https://github.com/uw-midsun/firmware/pull/97,https://github.com/mishazharov,3,https://github.com/uw-midsun/firmware/pull/97#issuecomment-341911402,"Added NMEA parser for GGA sentences. This is basically just the parser, looking for feedback
todo

 add code to disable all messages expect GGA and VTG
 add parser for VTG
 Initialization and power off code","Are we assuming that the hardware team takes care of page 10 and 11 of https://www.linxtechnologies.com/wp/wp-content/uploads/rxm-gps-f4.pdf ? (initialization of the GPS chip)
Edit: The firmware team should do this, so we will put this in evm_gps_init",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,97,2017-10-10T05:00:21Z,2018-01-13T19:24:13Z,2018-06-01T02:01:12Z,CLOSED,False,1041,211,81,https://github.com/mishazharov,ELEC-71: GPS Driver,59,[],https://github.com/uw-midsun/firmware/pull/97,https://github.com/mishazharov,4,https://github.com/uw-midsun/firmware/pull/97#issuecomment-341911744,"Added NMEA parser for GGA sentences. This is basically just the parser, looking for feedback
todo

 add code to disable all messages expect GGA and VTG
 add parser for VTG
 Initialization and power off code",Also we should implement rate control pretty soon (page 22),True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,97,2017-10-10T05:00:21Z,2018-01-13T19:24:13Z,2018-06-01T02:01:12Z,CLOSED,False,1041,211,81,https://github.com/mishazharov,ELEC-71: GPS Driver,59,[],https://github.com/uw-midsun/firmware/pull/97,https://github.com/karlding,5,https://github.com/uw-midsun/firmware/pull/97#issuecomment-342057827,"Added NMEA parser for GGA sentences. This is basically just the parser, looking for feedback
todo

 add code to disable all messages expect GGA and VTG
 add parser for VTG
 Initialization and power off code","Not sure if you're looking for comments (since there's no reviewers attached), but I thought I might give a bit of feedback before you guys keep going.
I like the idea you have of separating the parsing logic (nmea.h) from obtaining the data (gps.c)—I think this is reasonable in providing a logical breakdown between how we obtain the data and how we parse it. We can probably split this into 2 PRs if it makes working on things easier—one for the module containing the parser, and the other for the UART data handlers/callback functions.
I'm curious of your reasoning behind going with callbacks/handlers that handles the parsed data, vs exposing a getter interface that a user of the library calls to get updated data from.
To make this cleaner, maybe consider having separate parsers for each sentence type, and then calling that parsing function instead of doing it all in here? This will also allow you to test each parser individually, and should make writing tests easier.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,97,2017-10-10T05:00:21Z,2018-01-13T19:24:13Z,2018-06-01T02:01:12Z,CLOSED,False,1041,211,81,https://github.com/mishazharov,ELEC-71: GPS Driver,59,[],https://github.com/uw-midsun/firmware/pull/97,https://github.com/mishazharov,6,https://github.com/uw-midsun/firmware/pull/97#issuecomment-342253998,"Added NMEA parser for GGA sentences. This is basically just the parser, looking for feedback
todo

 add code to disable all messages expect GGA and VTG
 add parser for VTG
 Initialization and power off code","Thanks for the feedback!
I didn't feel like we needed to split this issue into 2 PR's because it would be a bit harder to simultaneously work on both, leaving a small integration challenge. We could if it becomes necessary in the future or if anyone wants to now.
The reason we're using callbacks right now is because the GPS returns data regularly but not instantly. Once the chip boots it just continually sends data around every second. I'm planning on adding getters by caching the results for a while, but we'll probably leave the handlers there too.
I agree with having separate parsers for different sentences, we'll refactor that, and it should also make some other issues go away.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,97,2017-10-10T05:00:21Z,2018-01-13T19:24:13Z,2018-06-01T02:01:12Z,CLOSED,False,1041,211,81,https://github.com/mishazharov,ELEC-71: GPS Driver,59,[],https://github.com/uw-midsun/firmware/pull/97,https://github.com/neilparikh,7,https://github.com/uw-midsun/firmware/pull/97#issuecomment-342358041,"Added NMEA parser for GGA sentences. This is basically just the parser, looking for feedback
todo

 add code to disable all messages expect GGA and VTG
 add parser for VTG
 Initialization and power off code","Adding onto @mikzharov's answer, from what I understand of this project, the way the GPS data is going to be used is that it'll just be logged for later. In that case, have a handler makes it easier, since the logging function can be registered and then called for every data point, rather than having to set up a timer to call it regularly.
If it's actually going to used on the spot to compute something/take some action, a getter based is probably better.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,97,2017-10-10T05:00:21Z,2018-01-13T19:24:13Z,2018-06-01T02:01:12Z,CLOSED,False,1041,211,81,https://github.com/mishazharov,ELEC-71: GPS Driver,59,[],https://github.com/uw-midsun/firmware/pull/97,https://github.com/mishazharov,8,https://github.com/uw-midsun/firmware/pull/97#issuecomment-353236607,"Added NMEA parser for GGA sentences. This is basically just the parser, looking for feedback
todo

 add code to disable all messages expect GGA and VTG
 add parser for VTG
 Initialization and power off code",I think I finished the power down and most of the initialization parts for the chip. Still need to test it on the real chip though,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,97,2017-10-10T05:00:21Z,2018-01-13T19:24:13Z,2018-06-01T02:01:12Z,CLOSED,False,1041,211,81,https://github.com/mishazharov,ELEC-71: GPS Driver,59,[],https://github.com/uw-midsun/firmware/pull/97,https://github.com/mishazharov,9,https://github.com/uw-midsun/firmware/pull/97#issuecomment-357459482,"Added NMEA parser for GGA sentences. This is basically just the parser, looking for feedback
todo

 add code to disable all messages expect GGA and VTG
 add parser for VTG
 Initialization and power off code",Check out #112,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,98,2017-10-14T19:47:06Z,2018-01-23T00:03:44Z,2018-06-11T07:48:17Z,CLOSED,False,754,386,78,https://github.com/Derpalooza,ELEC-235: Steering Wheel Event Generator,86,[],https://github.com/uw-midsun/firmware/pull/98,https://github.com/Derpalooza,1,https://github.com/uw-midsun/firmware/pull/98,"Integrated the driver for the GPIO expander into the main driver controls system. Additionally, further testing revealed that bouncing could actually cause problems with reading input data and that the interrupt capture register alone could not eliminate the problem. This and other bugs were fixed with this PR.
Additionally, it might be cleaner to split the digital_io module into separate modules for the console and steering wheel inputs respectively.","Integrated the driver for the GPIO expander into the main driver controls system. Additionally, further testing revealed that bouncing could actually cause problems with reading input data and that the interrupt capture register alone could not eliminate the problem. This and other bugs were fixed with this PR.
Additionally, it might be cleaner to split the digital_io module into separate modules for the console and steering wheel inputs respectively.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,98,2017-10-14T19:47:06Z,2018-01-23T00:03:44Z,2018-06-11T07:48:17Z,CLOSED,False,754,386,78,https://github.com/Derpalooza,ELEC-235: Steering Wheel Event Generator,86,[],https://github.com/uw-midsun/firmware/pull/98,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/98#issuecomment-343314903,"Integrated the driver for the GPIO expander into the main driver controls system. Additionally, further testing revealed that bouncing could actually cause problems with reading input data and that the interrupt capture register alone could not eliminate the problem. This and other bugs were fixed with this PR.
Additionally, it might be cleaner to split the digital_io module into separate modules for the console and steering wheel inputs respectively.",@Derpalooza status on this?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,98,2017-10-14T19:47:06Z,2018-01-23T00:03:44Z,2018-06-11T07:48:17Z,CLOSED,False,754,386,78,https://github.com/Derpalooza,ELEC-235: Steering Wheel Event Generator,86,[],https://github.com/uw-midsun/firmware/pull/98,https://github.com/Derpalooza,3,https://github.com/uw-midsun/firmware/pull/98#issuecomment-343362742,"Integrated the driver for the GPIO expander into the main driver controls system. Additionally, further testing revealed that bouncing could actually cause problems with reading input data and that the interrupt capture register alone could not eliminate the problem. This and other bugs were fixed with this PR.
Additionally, it might be cleaner to split the digital_io module into separate modules for the console and steering wheel inputs respectively.",@ckitagawa It's ready for review,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,98,2017-10-14T19:47:06Z,2018-01-23T00:03:44Z,2018-06-11T07:48:17Z,CLOSED,False,754,386,78,https://github.com/Derpalooza,ELEC-235: Steering Wheel Event Generator,86,[],https://github.com/uw-midsun/firmware/pull/98,https://github.com/karlding,4,https://github.com/uw-midsun/firmware/pull/98#issuecomment-355667965,"Integrated the driver for the GPIO expander into the main driver controls system. Additionally, further testing revealed that bouncing could actually cause problems with reading input data and that the interrupt capture register alone could not eliminate the problem. This and other bugs were fixed with this PR.
Additionally, it might be cleaner to split the digital_io module into separate modules for the console and steering wheel inputs respectively.",@Derpalooza is this something that we still need to get merged?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,99,2017-10-20T01:31:10Z,2017-11-04T19:07:29Z,2017-11-04T19:07:29Z,CLOSED,False,0,0,0,https://github.com/ckitagawa,ELEC-284 Integrate Codegen,0,[],https://github.com/uw-midsun/firmware/pull/99,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/99,"I wanted to get this in a lot earlier but I was struggling to come up with an elegant way to do it. This is what I came up with but we can discuss alternatives if people don't like this method.
What this PR implements is per library pre-build hooks. Basically, a python file named prebuild_hook.py located in the root of a library can be executed to update or otherwise initialize the library prior to being built. There were a few reasons for doing this and this may not be the best solution but I think it works well.
First a justification for not doing the alternatives:

Git submodule, the most obvious and easiest but also annoying. I find remembering to git init submodules and update the submodule periodically to be a little inconvenient and even if we did include codegen-tooling as a submodule we would need to figure out how to run its build system from our current build system requiring a special build hook for the library and even then its outputs are all dumped to a single folder which isn't in line with how our current build structure works.
Static output files: this is nice but it is hard to remember to update and not automatic. A PR is required to do the update and copy paste based version control isn't ideal as mistakes can happen.

Now for the solution:
Git releases, basically all that has to happen on the firmware side is adding a pre-build hook script which fetches the latest release build artifacts and replaces the existing one if there is a newer version. This is nice for a few reasons
Advantages:

It is automatic on the firmware side and we can configure Travis to automatically release on the codegen-tooling side making this an entirely automated process.
The first PR post-release ought to update the static version and hash file in the firmware repo so there will always be a local static copy if we have to develop without internet.
It is generic, we could easily update our other static libraries with pre-build hooks as well. It is basically a lightweight vendoring system built-in to the tool since we could write scripts that freeze releases until we update them. (Not required for codegen-tooling probably).

Downsides:

Overhead of maintaining hook scripts. I want this to be write once and forget type deal so I feel this is justifiable but let me know if you think otherwise.
Any changes needed to the local copies then require manually making changes upstream for the next release. This is the biggest downside of this strategy and probably the biggest advantage of a git submodule.

This is mainly a proposal for this solution so if people object I am open to discussing and going with alternatives. I just want to get this finished and this solution seems really sleek to me since it can be automated end to end.","I wanted to get this in a lot earlier but I was struggling to come up with an elegant way to do it. This is what I came up with but we can discuss alternatives if people don't like this method.
What this PR implements is per library pre-build hooks. Basically, a python file named prebuild_hook.py located in the root of a library can be executed to update or otherwise initialize the library prior to being built. There were a few reasons for doing this and this may not be the best solution but I think it works well.
First a justification for not doing the alternatives:

Git submodule, the most obvious and easiest but also annoying. I find remembering to git init submodules and update the submodule periodically to be a little inconvenient and even if we did include codegen-tooling as a submodule we would need to figure out how to run its build system from our current build system requiring a special build hook for the library and even then its outputs are all dumped to a single folder which isn't in line with how our current build structure works.
Static output files: this is nice but it is hard to remember to update and not automatic. A PR is required to do the update and copy paste based version control isn't ideal as mistakes can happen.

Now for the solution:
Git releases, basically all that has to happen on the firmware side is adding a pre-build hook script which fetches the latest release build artifacts and replaces the existing one if there is a newer version. This is nice for a few reasons
Advantages:

It is automatic on the firmware side and we can configure Travis to automatically release on the codegen-tooling side making this an entirely automated process.
The first PR post-release ought to update the static version and hash file in the firmware repo so there will always be a local static copy if we have to develop without internet.
It is generic, we could easily update our other static libraries with pre-build hooks as well. It is basically a lightweight vendoring system built-in to the tool since we could write scripts that freeze releases until we update them. (Not required for codegen-tooling probably).

Downsides:

Overhead of maintaining hook scripts. I want this to be write once and forget type deal so I feel this is justifiable but let me know if you think otherwise.
Any changes needed to the local copies then require manually making changes upstream for the next release. This is the biggest downside of this strategy and probably the biggest advantage of a git submodule.

This is mainly a proposal for this solution so if people object I am open to discussing and going with alternatives. I just want to get this finished and this solution seems really sleek to me since it can be automated end to end.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,99,2017-10-20T01:31:10Z,2017-11-04T19:07:29Z,2017-11-04T19:07:29Z,CLOSED,False,0,0,0,https://github.com/ckitagawa,ELEC-284 Integrate Codegen,0,[],https://github.com/uw-midsun/firmware/pull/99,https://github.com/karlding,2,https://github.com/uw-midsun/firmware/pull/99#issuecomment-338100677,"I wanted to get this in a lot earlier but I was struggling to come up with an elegant way to do it. This is what I came up with but we can discuss alternatives if people don't like this method.
What this PR implements is per library pre-build hooks. Basically, a python file named prebuild_hook.py located in the root of a library can be executed to update or otherwise initialize the library prior to being built. There were a few reasons for doing this and this may not be the best solution but I think it works well.
First a justification for not doing the alternatives:

Git submodule, the most obvious and easiest but also annoying. I find remembering to git init submodules and update the submodule periodically to be a little inconvenient and even if we did include codegen-tooling as a submodule we would need to figure out how to run its build system from our current build system requiring a special build hook for the library and even then its outputs are all dumped to a single folder which isn't in line with how our current build structure works.
Static output files: this is nice but it is hard to remember to update and not automatic. A PR is required to do the update and copy paste based version control isn't ideal as mistakes can happen.

Now for the solution:
Git releases, basically all that has to happen on the firmware side is adding a pre-build hook script which fetches the latest release build artifacts and replaces the existing one if there is a newer version. This is nice for a few reasons
Advantages:

It is automatic on the firmware side and we can configure Travis to automatically release on the codegen-tooling side making this an entirely automated process.
The first PR post-release ought to update the static version and hash file in the firmware repo so there will always be a local static copy if we have to develop without internet.
It is generic, we could easily update our other static libraries with pre-build hooks as well. It is basically a lightweight vendoring system built-in to the tool since we could write scripts that freeze releases until we update them. (Not required for codegen-tooling probably).

Downsides:

Overhead of maintaining hook scripts. I want this to be write once and forget type deal so I feel this is justifiable but let me know if you think otherwise.
Any changes needed to the local copies then require manually making changes upstream for the next release. This is the biggest downside of this strategy and probably the biggest advantage of a git submodule.

This is mainly a proposal for this solution so if people object I am open to discussing and going with alternatives. I just want to get this finished and this solution seems really sleek to me since it can be automated end to end.","Nice! This is pretty slick, and the idea makes sense. I've also been wrangling with build systems and codegen at work lately, so I had a few questions:

I know you said you didn't like the whole submodule approach, and I can totally get behind that. But is there a reason why you didn't consider subtrees? You don't need to git init anything, but you'd still need to pull in changes periodically. And they've been integrated in git now, so there's no need for wrapper scripts. There's also the option of adding a post-checkout hook that runs git submodule update, which works if you're not doing submodule development and changing branches.
I think I was the one who checked in the generated output files, but is there a strong reason for staying with that route? Seems like it'd be easier to run the build step in each project's build. And if it doesn't make sense for codegen to dump all the files to an output directory, maybe it's worth modifying codegen to take a template and output directory, instead of generating everything?
How does the developer workflow look like when they're trying to add a new template/generated file? From what I understand, in order to test, they'd clone codegen, and run it either with the output directory set to the library folder, or copy and paste the files in as needed. The hashpicker wouldn't overwrite their changes, since it stored the last release (which is a good thing!). I was going to suggest ""vendoring"" just the tool, but then I realized that we need to share the codegen source data so that each project can generate their output.

It's unfortunate that we haven't been able to talk in person—hopefully this doesn't change too much of what you already have.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,99,2017-10-20T01:31:10Z,2017-11-04T19:07:29Z,2017-11-04T19:07:29Z,CLOSED,False,0,0,0,https://github.com/ckitagawa,ELEC-284 Integrate Codegen,0,[],https://github.com/uw-midsun/firmware/pull/99,https://github.com/karlding,3,https://github.com/uw-midsun/firmware/pull/99#issuecomment-338247708,"I wanted to get this in a lot earlier but I was struggling to come up with an elegant way to do it. This is what I came up with but we can discuss alternatives if people don't like this method.
What this PR implements is per library pre-build hooks. Basically, a python file named prebuild_hook.py located in the root of a library can be executed to update or otherwise initialize the library prior to being built. There were a few reasons for doing this and this may not be the best solution but I think it works well.
First a justification for not doing the alternatives:

Git submodule, the most obvious and easiest but also annoying. I find remembering to git init submodules and update the submodule periodically to be a little inconvenient and even if we did include codegen-tooling as a submodule we would need to figure out how to run its build system from our current build system requiring a special build hook for the library and even then its outputs are all dumped to a single folder which isn't in line with how our current build structure works.
Static output files: this is nice but it is hard to remember to update and not automatic. A PR is required to do the update and copy paste based version control isn't ideal as mistakes can happen.

Now for the solution:
Git releases, basically all that has to happen on the firmware side is adding a pre-build hook script which fetches the latest release build artifacts and replaces the existing one if there is a newer version. This is nice for a few reasons
Advantages:

It is automatic on the firmware side and we can configure Travis to automatically release on the codegen-tooling side making this an entirely automated process.
The first PR post-release ought to update the static version and hash file in the firmware repo so there will always be a local static copy if we have to develop without internet.
It is generic, we could easily update our other static libraries with pre-build hooks as well. It is basically a lightweight vendoring system built-in to the tool since we could write scripts that freeze releases until we update them. (Not required for codegen-tooling probably).

Downsides:

Overhead of maintaining hook scripts. I want this to be write once and forget type deal so I feel this is justifiable but let me know if you think otherwise.
Any changes needed to the local copies then require manually making changes upstream for the next release. This is the biggest downside of this strategy and probably the biggest advantage of a git submodule.

This is mainly a proposal for this solution so if people object I am open to discussing and going with alternatives. I just want to get this finished and this solution seems really sleek to me since it can be automated end to end.",Also weird that the CAN HW tests are sometimes going past Travis's 10 minute timeout for no log output. I kicked off another build and that one passed.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,100,2017-11-02T22:35:35Z,2017-11-02T23:17:33Z,2017-11-02T23:17:37Z,MERGED,True,181,199,27,https://github.com/ckitagawa,ELEC-289: Run clang-format 5.0.0 over the project,2,[],https://github.com/uw-midsun/firmware/pull/100,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/100,Closed old PR (#95) and updated .clang-format based on @karlding 's comments. Just to get rid of the mess of merge conflicts I was dealing with. Box should already be updated as I updated it after clang-format updated.,Closed old PR (#95) and updated .clang-format based on @karlding 's comments. Just to get rid of the mess of merge conflicts I was dealing with. Box should already be updated as I updated it after clang-format updated.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,101,2017-11-04T19:34:00Z,2017-11-11T19:08:26Z,2017-11-11T19:08:40Z,MERGED,True,746,1,10,https://github.com/ckitagawa,ELEC-284: Integrate Codegen,14,[],https://github.com/uw-midsun/firmware/pull/101,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/101,"The diff for (#99) made no sense. I am very confused about what happened when I merged master. Regardless to fix this I closed the PR and opened this one and now the diff makes sense again? Shrug.
This responds to Karl's comments by making the script and its args be defined in the libraries rules.mk file. I made the script now support both Python 2 and 3.
Regarding the workflow for testing codegen-tooling, it does require moving the code into firmware followed by testing then upstreaming any fixes. After that the developer would create a new release and then update firmware. It is a bit painful but I developed the existing templates with just static analysis tools and it seems to be fine. Moreover, we don't have anything else to generate as far as I am aware of (just changes to CAN messages).
From the original PR:

I wanted to get this in a lot earlier but I was struggling to come up with an elegant way to do it. This is what I came up with but we can discuss alternatives if people don't like this method.
What this PR implements is per library pre-build hooks. Basically, a python file named prebuild_hook.py located in the root of a library can be executed to update or otherwise initialize the library prior to being built. There were a few reasons for doing this and this may not be the best solution but I think it works well.
First a justification for not doing the alternatives:

Git submodule, the most obvious and easiest but also annoying. I find remembering to git init submodules and update the submodule periodically to be a little inconvenient and even if we did include codegen-tooling as a submodule we would need to figure out how to run its build system from our current build system requiring a special build hook for the library and even then its outputs are all dumped to a single folder which isn't in line with how our current build structure works.
Static output files: this is nice but it is hard to remember to update and not automatic. A PR is required to do the update and copy paste based version control isn't ideal as mistakes can happen.

Now for the solution:
Git releases, basically all that has to happen on the firmware side is adding a pre-build hook script which fetches the latest release build artifacts and replaces the existing one if there is a newer version. This is nice for a few reasons
Advantages:

It is automatic on the firmware side and we can configure Travis to automatically release on the codegen-tooling side making this an entirely automated process.
The first PR post-release ought to update the static version and hash file in the firmware repo so there will always be a local static copy if we have to develop without internet.
It is generic, we could easily update our other static libraries with pre-build hooks as well. It is basically a lightweight vendoring system built-in to the tool since we could write scripts that freeze releases until we update them. (Not required for codegen-tooling probably).

Downsides:

Overhead of maintaining hook scripts. I want this to be write once and forget type deal so I feel this is justifiable but let me know if you think otherwise.
Any changes needed to the local copies then require manually making changes upstream for the next release. This is the biggest downside of this strategy and probably the biggest advantage of a git submodule.

This is mainly a proposal for this solution so if people object I am open to discussing and going with alternatives. I just want to get this finished and this solution seems really sleek to me since it can be automated end to end.","The diff for (#99) made no sense. I am very confused about what happened when I merged master. Regardless to fix this I closed the PR and opened this one and now the diff makes sense again? Shrug.
This responds to Karl's comments by making the script and its args be defined in the libraries rules.mk file. I made the script now support both Python 2 and 3.
Regarding the workflow for testing codegen-tooling, it does require moving the code into firmware followed by testing then upstreaming any fixes. After that the developer would create a new release and then update firmware. It is a bit painful but I developed the existing templates with just static analysis tools and it seems to be fine. Moreover, we don't have anything else to generate as far as I am aware of (just changes to CAN messages).
From the original PR:

I wanted to get this in a lot earlier but I was struggling to come up with an elegant way to do it. This is what I came up with but we can discuss alternatives if people don't like this method.
What this PR implements is per library pre-build hooks. Basically, a python file named prebuild_hook.py located in the root of a library can be executed to update or otherwise initialize the library prior to being built. There were a few reasons for doing this and this may not be the best solution but I think it works well.
First a justification for not doing the alternatives:

Git submodule, the most obvious and easiest but also annoying. I find remembering to git init submodules and update the submodule periodically to be a little inconvenient and even if we did include codegen-tooling as a submodule we would need to figure out how to run its build system from our current build system requiring a special build hook for the library and even then its outputs are all dumped to a single folder which isn't in line with how our current build structure works.
Static output files: this is nice but it is hard to remember to update and not automatic. A PR is required to do the update and copy paste based version control isn't ideal as mistakes can happen.

Now for the solution:
Git releases, basically all that has to happen on the firmware side is adding a pre-build hook script which fetches the latest release build artifacts and replaces the existing one if there is a newer version. This is nice for a few reasons
Advantages:

It is automatic on the firmware side and we can configure Travis to automatically release on the codegen-tooling side making this an entirely automated process.
The first PR post-release ought to update the static version and hash file in the firmware repo so there will always be a local static copy if we have to develop without internet.
It is generic, we could easily update our other static libraries with pre-build hooks as well. It is basically a lightweight vendoring system built-in to the tool since we could write scripts that freeze releases until we update them. (Not required for codegen-tooling probably).

Downsides:

Overhead of maintaining hook scripts. I want this to be write once and forget type deal so I feel this is justifiable but let me know if you think otherwise.
Any changes needed to the local copies then require manually making changes upstream for the next release. This is the biggest downside of this strategy and probably the biggest advantage of a git submodule.

This is mainly a proposal for this solution so if people object I am open to discussing and going with alternatives. I just want to get this finished and this solution seems really sleek to me since it can be automated end to end.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,102,2017-11-11T20:14:53Z,2018-01-22T20:07:36Z,2018-02-07T14:12:54Z,CLOSED,False,676,199,14,https://github.com/Derpalooza,ELEC-231: Debounce Module,99,[],https://github.com/uw-midsun/firmware/pull/102,https://github.com/Derpalooza,1,https://github.com/uw-midsun/firmware/pull/102,Debouncing module for the center console inputs,Debouncing module for the center console inputs,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,102,2017-11-11T20:14:53Z,2018-01-22T20:07:36Z,2018-02-07T14:12:54Z,CLOSED,False,676,199,14,https://github.com/Derpalooza,ELEC-231: Debounce Module,99,[],https://github.com/uw-midsun/firmware/pull/102,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/102#issuecomment-359548614,Debouncing module for the center console inputs,Closing this PR because it seems to be out of date.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,103,2017-11-22T14:49:36Z,2018-01-05T04:42:21Z,2018-01-05T04:42:27Z,MERGED,True,61,28,1,https://github.com/karlding,ELEC-313: Speed up Travis CI builds,19,[],https://github.com/uw-midsun/firmware/pull/103,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/103,"Pin gcc-arm-none-eabi-6-2017-q2-update
Speed up builds by caching
Speed up builds by removing parallel jobs","Pin gcc-arm-none-eabi-6-2017-q2-update
Speed up builds by caching
Speed up builds by removing parallel jobs",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,103,2017-11-22T14:49:36Z,2018-01-05T04:42:21Z,2018-01-05T04:42:27Z,MERGED,True,61,28,1,https://github.com/karlding,ELEC-313: Speed up Travis CI builds,19,[],https://github.com/uw-midsun/firmware/pull/103,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/103#issuecomment-346715361,"Pin gcc-arm-none-eabi-6-2017-q2-update
Speed up builds by caching
Speed up builds by removing parallel jobs",Just curious what we are benchmarking? Travis build times?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,103,2017-11-22T14:49:36Z,2018-01-05T04:42:21Z,2018-01-05T04:42:27Z,MERGED,True,61,28,1,https://github.com/karlding,ELEC-313: Speed up Travis CI builds,19,[],https://github.com/uw-midsun/firmware/pull/103,https://github.com/karlding,3,https://github.com/uw-midsun/firmware/pull/103#issuecomment-346728000,"Pin gcc-arm-none-eabi-6-2017-q2-update
Speed up builds by caching
Speed up builds by removing parallel jobs","Yessir. I was trying to look at our build times, to see if we can speed them up (or at least, reduce variability in the times it takes).
Basically, I'm looking at potentially speeding things up by:

Putting everything in a ""monolithic"" build instead of running jobs in parallel (since environment setup is the longest in our build step, we don't really get any benefits here from this)
Implementing dependency caching (since downloading dependencies like GCC ARM takes a while)
Looking at switching over to (Travis') container-based architecture, which would decrease the time till a build starts and is picked up (looks like this isn't possible, since we need sudo to load kernel modules for SocketCAN)",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,103,2017-11-22T14:49:36Z,2018-01-05T04:42:21Z,2018-01-05T04:42:27Z,MERGED,True,61,28,1,https://github.com/karlding,ELEC-313: Speed up Travis CI builds,19,[],https://github.com/uw-midsun/firmware/pull/103,https://github.com/ckitagawa,4,https://github.com/uw-midsun/firmware/pull/103#issuecomment-346862815,"Pin gcc-arm-none-eabi-6-2017-q2-update
Speed up builds by caching
Speed up builds by removing parallel jobs","Sounds like a good plan! Have we looked at other sources for the GCC ARM toolchain, or even hosting one ourselves; the PPA seems fairly slow, but I see you are using the ARM developer site now? I think caching and monolithic builds are a good idea though :)",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,103,2017-11-22T14:49:36Z,2018-01-05T04:42:21Z,2018-01-05T04:42:27Z,MERGED,True,61,28,1,https://github.com/karlding,ELEC-313: Speed up Travis CI builds,19,[],https://github.com/uw-midsun/firmware/pull/103,https://github.com/tituschow,5,https://github.com/uw-midsun/firmware/pull/103#issuecomment-355400394,"Pin gcc-arm-none-eabi-6-2017-q2-update
Speed up builds by caching
Speed up builds by removing parallel jobs",@karlding Are you happy with these changes?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,103,2017-11-22T14:49:36Z,2018-01-05T04:42:21Z,2018-01-05T04:42:27Z,MERGED,True,61,28,1,https://github.com/karlding,ELEC-313: Speed up Travis CI builds,19,[],https://github.com/uw-midsun/firmware/pull/103,https://github.com/karlding,6,https://github.com/uw-midsun/firmware/pull/103#issuecomment-355416106,"Pin gcc-arm-none-eabi-6-2017-q2-update
Speed up builds by caching
Speed up builds by removing parallel jobs","Yeah, there isn't much we can do about boot times, aside from switching to another CI provider.
@ckitagawa showed me Semaphore CI at some point last term, which seemed to boot pretty quickly when I played around with it—and it looks like most of the setup should be pretty portable across the two. Not sure if it's worth switching over though, since AFAIK the only benefit is faster boot times, as the build times should be similar?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,104,2017-11-25T20:50:26Z,2017-11-25T20:51:06Z,2018-01-13T22:51:40Z,CLOSED,False,329,43,6,https://github.com/Derpalooza,Sample Pull request,20,[],https://github.com/uw-midsun/firmware/pull/104,https://github.com/Derpalooza,1,https://github.com/uw-midsun/firmware/pull/104,,,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,105,2018-01-05T22:14:28Z,2018-01-06T17:21:57Z,2018-01-06T17:22:01Z,MERGED,True,165,0,5,https://github.com/ckitagawa,ELEC-105: GPIO sequencing for power distribution,6,[],https://github.com/uw-midsun/firmware/pull/105,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/105,Simple PR that allows sequencing of GPIO state changes with delays by looping through arrays. This will be used for the various power sequences required on Chaos such as booting and shutting down the car and transitioning to charging mode. This is relatively generic but will probably only be used by power distribution so there is no need to put it in ms-common.,Simple PR that allows sequencing of GPIO state changes with delays by looping through arrays. This will be used for the various power sequences required on Chaos such as booting and shutting down the car and transitioning to charging mode. This is relatively generic but will probably only be used by power distribution so there is no need to put it in ms-common.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,106,2018-01-06T19:02:53Z,2018-01-06T20:09:20Z,2018-01-06T20:10:46Z,MERGED,True,20,16,1,https://github.com/tituschow,ELEC-303: Reversed CAN HW mutex logic to fix race condition,2,[],https://github.com/uw-midsun/firmware/pull/106,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/106,"Previous implementation would attempt to lock and die if the lock failed, resulting in contention between the TX and RX thread.

Thread A trylock: success
Thread B trylock: fail
Thread B exit
Thread A unlock
Thread B is dead, test hangs

Now locks the mutex at the beginning so trylocks should fail.","Previous implementation would attempt to lock and die if the lock failed, resulting in contention between the TX and RX thread.

Thread A trylock: success
Thread B trylock: fail
Thread B exit
Thread A unlock
Thread B is dead, test hangs

Now locks the mutex at the beginning so trylocks should fail.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,106,2018-01-06T19:02:53Z,2018-01-06T20:09:20Z,2018-01-06T20:10:46Z,MERGED,True,20,16,1,https://github.com/tituschow,ELEC-303: Reversed CAN HW mutex logic to fix race condition,2,[],https://github.com/uw-midsun/firmware/pull/106,https://github.com/karlding,2,https://github.com/uw-midsun/firmware/pull/106#issuecomment-355771786,"Previous implementation would attempt to lock and die if the lock failed, resulting in contention between the TX and RX thread.

Thread A trylock: success
Thread B trylock: fail
Thread B exit
Thread A unlock
Thread B is dead, test hangs

Now locks the mutex at the beginning so trylocks should fail.","So I've reordered the pthread_join and ensured that the RX thread exits before the TX thread.
In 500 runs, I didn't see the error, so it seems like this fix actually does what we want this time.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,107,2018-01-06T19:50:16Z,2018-01-24T04:55:41Z,2018-01-24T04:55:49Z,CLOSED,False,2667,2027,145,https://github.com/GarlandZhang,ELEC-315: [Solar] Solar Master Placeholder code,7,[],https://github.com/uw-midsun/firmware/pull/107,https://github.com/GarlandZhang,1,https://github.com/uw-midsun/firmware/pull/107,"Added solar_master project folder
Added main.c file which holds placeholder code for solar master","Added solar_master project folder
Added main.c file which holds placeholder code for solar master",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,107,2018-01-06T19:50:16Z,2018-01-24T04:55:41Z,2018-01-24T04:55:49Z,CLOSED,False,2667,2027,145,https://github.com/GarlandZhang,ELEC-315: [Solar] Solar Master Placeholder code,7,[],https://github.com/uw-midsun/firmware/pull/107,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/107#issuecomment-357464410,"Added solar_master project folder
Added main.c file which holds placeholder code for solar master",Can you revert your reformat commit? It's adding a lot of noise to the PR.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,108,2018-01-06T20:37:54Z,2018-01-10T01:13:06Z,2018-01-10T01:13:15Z,MERGED,True,334,0,5,https://github.com/ckitagawa,ELEC-105: Chaos Power Path implementation,8,[],https://github.com/uw-midsun/firmware/pull/108,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/108,"This is an implementation of the ""driver"" for the power path IC. Essentially this boils down to two main purposes:

Monitor the UV and OV pin which signals when an over or under voltage occurs by raising an event. This event will be handled by a CAN FSM which will send the message to Telemetry/Driver Display.
Read values using the ADCs periodically for current and voltage of both the Aux Battery and DCDCs. It is possible to request the latest data at any time. I will add a hook later to send a CAN message with this info to telemetry each time it updates.

I also exposed an API to disable monitoring to avoid errors when turning off the DCDCs.
Tested manually on STM32F0xx and passed. x86 test fails as the ADC driver is unimplemented.","This is an implementation of the ""driver"" for the power path IC. Essentially this boils down to two main purposes:

Monitor the UV and OV pin which signals when an over or under voltage occurs by raising an event. This event will be handled by a CAN FSM which will send the message to Telemetry/Driver Display.
Read values using the ADCs periodically for current and voltage of both the Aux Battery and DCDCs. It is possible to request the latest data at any time. I will add a hook later to send a CAN message with this info to telemetry each time it updates.

I also exposed an API to disable monitoring to avoid errors when turning off the DCDCs.
Tested manually on STM32F0xx and passed. x86 test fails as the ADC driver is unimplemented.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,109,2018-01-09T03:01:41Z,2018-01-12T22:44:30Z,2018-01-19T02:17:00Z,MERGED,True,109,40,7,https://github.com/tituschow,ELEC-305: CAN Extended ID Support ,6,[],https://github.com/uw-midsun/firmware/pull/109,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/109,"Adds extended ID support to CAN HW. This will be used for CAN <-> UART interfaces.
Also fixes clang-format not using our format file.","Adds extended ID support to CAN HW. This will be used for CAN <-> UART interfaces.
Also fixes clang-format not using our format file.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,110,2018-01-11T03:55:44Z,2018-01-13T20:16:20Z,2018-02-07T14:13:05Z,CLOSED,False,45,0,1,https://github.com/rhaffar99,<first FSM format>,1,[],https://github.com/uw-midsun/firmware/pull/110,https://github.com/rhaffar99,1,https://github.com/uw-midsun/firmware/pull/110,"Commented my obvious questions about what I need to fill in - just a note that this is a skeleton of what it should be (mainly because I'm not sure where to assign pin/port, and I don't quite know enough yet about how the canbus messaging sends a message to implement a system to take that message in. Once this file is set up to standard, I'll make the other FSMs modeled off this one, and then I'll make the master file that takes the canbus message and loops through all the FSM files.","Commented my obvious questions about what I need to fill in - just a note that this is a skeleton of what it should be (mainly because I'm not sure where to assign pin/port, and I don't quite know enough yet about how the canbus messaging sends a message to implement a system to take that message in. Once this file is set up to standard, I'll make the other FSMs modeled off this one, and then I'll make the master file that takes the canbus message and loops through all the FSM files.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,111,2018-01-12T23:00:22Z,2018-01-16T20:03:57Z,2018-01-19T02:17:02Z,MERGED,True,54,37,2,https://github.com/tituschow,ELEC-252: 32MHz HSE,2,[],https://github.com/uw-midsun/firmware/pull/111,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/111,"Switches the clock source to use the HSE PLL at 48MHz with HSI fallback. Note that some of our timings are off (specifically SPI) so those should be fixed.
Yet to be tested on this branch, but this code worked on the rev6 controller boards.","Switches the clock source to use the HSE PLL at 48MHz with HSI fallback. Note that some of our timings are off (specifically SPI) so those should be fixed.
Yet to be tested on this branch, but this code worked on the rev6 controller boards.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,112,2018-01-13T19:23:34Z,2018-01-13T20:15:57Z,2018-01-27T21:15:44Z,CLOSED,False,635,0,11,https://github.com/mishazharov,ELEC-71: GPS Driver,4,[],https://github.com/uw-midsun/firmware/pull/112,https://github.com/mishazharov,1,https://github.com/uw-midsun/firmware/pull/112,This is the new branch of ELEC-71,This is the new branch of ELEC-71,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,113,2018-01-13T21:20:42Z,2018-01-13T22:22:29Z,2018-01-13T22:40:00Z,MERGED,True,9,18,7,https://github.com/ckitagawa,ELEC-325 Update codegen-tooling library.,8,[],https://github.com/uw-midsun/firmware/pull/113,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/113,Simply rebuilt with make build_all after updating codegen-tooling.,Simply rebuilt with make build_all after updating codegen-tooling.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,113,2018-01-13T21:20:42Z,2018-01-13T22:22:29Z,2018-01-13T22:40:00Z,MERGED,True,9,18,7,https://github.com/ckitagawa,ELEC-325 Update codegen-tooling library.,8,[],https://github.com/uw-midsun/firmware/pull/113,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/113#issuecomment-357470835,Simply rebuilt with make build_all after updating codegen-tooling.,Cherrypicked PR #115 into here to get build to pass without version.txt mismatching.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,114,2018-01-13T21:34:27Z,2018-05-18T02:35:54Z,2018-05-18T04:52:04Z,MERGED,True,199,0,6,https://github.com/neilparikh,ELEC-71: Telemetry - checksum utils,38,[],https://github.com/uw-midsun/firmware/pull/114,https://github.com/neilparikh,1,https://github.com/uw-midsun/firmware/pull/114,"This PR adds a stub telemetry project, as well as some utilities for computing checksums of NMEA messages.","This PR adds a stub telemetry project, as well as some utilities for computing checksums of NMEA messages.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,114,2018-01-13T21:34:27Z,2018-05-18T02:35:54Z,2018-05-18T04:52:04Z,MERGED,True,199,0,6,https://github.com/neilparikh,ELEC-71: Telemetry - checksum utils,38,[],https://github.com/uw-midsun/firmware/pull/114,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/114#issuecomment-362875456,"This PR adds a stub telemetry project, as well as some utilities for computing checksums of NMEA messages.",Just a few minor comments and I think this will be good to go,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,114,2018-01-13T21:34:27Z,2018-05-18T02:35:54Z,2018-05-18T04:52:04Z,MERGED,True,199,0,6,https://github.com/neilparikh,ELEC-71: Telemetry - checksum utils,38,[],https://github.com/uw-midsun/firmware/pull/114,https://github.com/neilparikh,3,https://github.com/uw-midsun/firmware/pull/114#issuecomment-372064221,"This PR adds a stub telemetry project, as well as some utilities for computing checksums of NMEA messages.","@tituschow: addressed all comments except the one about return an int from nmea_compute_checksum, which IMO isn't worth fixing until there are a few more users of that function, which will provide a better idea of which format is needed the most.
EDIT: Will instead return an int from the compute function, then convert the received checksum into an int, and then compare those. When sending messages, will use the %x format specifier.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,115,2018-01-13T22:01:59Z,2018-01-13T22:20:19Z,2018-01-13T22:51:32Z,CLOSED,False,4,9,2,https://github.com/karlding,"ELEC-326, ELEC-327: Fix hash file updating and bump CAN ACK timeout",2,[],https://github.com/uw-midsun/firmware/pull/115,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/115,"Refactor the logic to update the hash file
Bump CAN ACK timeout from 10ms to 15ms","Refactor the logic to update the hash file
Bump CAN ACK timeout from 10ms to 15ms",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,115,2018-01-13T22:01:59Z,2018-01-13T22:20:19Z,2018-01-13T22:51:32Z,CLOSED,False,4,9,2,https://github.com/karlding,"ELEC-326, ELEC-327: Fix hash file updating and bump CAN ACK timeout",2,[],https://github.com/uw-midsun/firmware/pull/115,https://github.com/karlding,2,https://github.com/uw-midsun/firmware/pull/115#issuecomment-357471724,"Refactor the logic to update the hash file
Bump CAN ACK timeout from 10ms to 15ms",Closing because this is handled in #113,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,116,2018-01-14T06:11:59Z,2018-01-19T02:16:50Z,2018-01-19T02:16:54Z,MERGED,True,41,34,3,https://github.com/tituschow,ELEC-324: Fixed CAN HW extended filters on STM32,8,[],https://github.com/uw-midsun/firmware/pull/116,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/116,"Standard/Extended IDs were flipped and I fixed the initial filter to accept everything. I also added some delays to ensure that messages were TX'd so we didn't fill up our mailboxes.
Tested on STM32.","Standard/Extended IDs were flipped and I fixed the initial filter to accept everything. I also added some delays to ensure that messages were TX'd so we didn't fill up our mailboxes.
Tested on STM32.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,117,2018-01-20T21:49:11Z,2018-01-23T17:59:30Z,2018-01-23T17:59:34Z,MERGED,True,9,2,2,https://github.com/tituschow,ELEC-328: Fixed SPI prescaler,3,[],https://github.com/uw-midsun/firmware/pull/117,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/117,"I was using ffs when I should've been using clz. Now properly calculates a reasonable prescaler.
Note that there a limited number of supported baudrates - i.e. 1MHz will actually be 48MHz/32 = 1.5MHz. I was thinking of just making those enums so it's more clear, but it's dependent on our PCLK frequency.","I was using ffs when I should've been using clz. Now properly calculates a reasonable prescaler.
Note that there a limited number of supported baudrates - i.e. 1MHz will actually be 48MHz/32 = 1.5MHz. I was thinking of just making those enums so it's more clear, but it's dependent on our PCLK frequency.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,118,2018-01-22T19:52:02Z,2018-02-03T17:59:52Z,2018-02-03T17:59:56Z,MERGED,True,324,7,12,https://github.com/tituschow,ELEC-300: CAN <-> UART,18,[],https://github.com/uw-midsun/firmware/pull/118,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/118,"Adds a CAN <-> UART protocol module. can_slave is an example project demonstrating the slave side. This project also includes a test script for parsing received messages using the protocol. The master will use can_uart_req_tx and CanUartRxCb rx_cb for messages to/from the slave.
The CAN slave has been tested on STM32. Master has not been tested yet.
Also note that pylint import errors were disabled and a stub for UART x86 was added.","Adds a CAN <-> UART protocol module. can_slave is an example project demonstrating the slave side. This project also includes a test script for parsing received messages using the protocol. The master will use can_uart_req_tx and CanUartRxCb rx_cb for messages to/from the slave.
The CAN slave has been tested on STM32. Master has not been tested yet.
Also note that pylint import errors were disabled and a stub for UART x86 was added.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,118,2018-01-22T19:52:02Z,2018-02-03T17:59:52Z,2018-02-03T17:59:56Z,MERGED,True,324,7,12,https://github.com/tituschow,ELEC-300: CAN <-> UART,18,[],https://github.com/uw-midsun/firmware/pull/118,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/118#issuecomment-362473588,"Adds a CAN <-> UART protocol module. can_slave is an example project demonstrating the slave side. This project also includes a test script for parsing received messages using the protocol. The master will use can_uart_req_tx and CanUartRxCb rx_cb for messages to/from the slave.
The CAN slave has been tested on STM32. Master has not been tested yet.
Also note that pylint import errors were disabled and a stub for UART x86 was added.",I'll wait for a response from @karlding before I merge.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,119,2018-01-25T03:27:34Z,2018-02-25T23:28:36Z,2018-03-09T21:19:06Z,CLOSED,False,117,0,4,https://github.com/GarlandZhang,ELEC-315 committing placeholder solar master code,4,[],https://github.com/uw-midsun/firmware/pull/119,https://github.com/GarlandZhang,1,https://github.com/uw-midsun/firmware/pull/119,Added a projects directory for solar_master and included files for placeholder code for the solar master.,Added a projects directory for solar_master and included files for placeholder code for the solar master.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,119,2018-01-25T03:27:34Z,2018-02-25T23:28:36Z,2018-03-09T21:19:06Z,CLOSED,False,117,0,4,https://github.com/GarlandZhang,ELEC-315 committing placeholder solar master code,4,[],https://github.com/uw-midsun/firmware/pull/119,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/119#issuecomment-360364821,Added a projects directory for solar_master and included files for placeholder code for the solar master.,"Please fix your git config. You need to set your name and email.
Also, please add a description.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,119,2018-01-25T03:27:34Z,2018-02-25T23:28:36Z,2018-03-09T21:19:06Z,CLOSED,False,117,0,4,https://github.com/GarlandZhang,ELEC-315 committing placeholder solar master code,4,[],https://github.com/uw-midsun/firmware/pull/119,https://github.com/GarlandZhang,3,https://github.com/uw-midsun/firmware/pull/119#issuecomment-360365317,Added a projects directory for solar_master and included files for placeholder code for the solar master.,Just when I thought I finally did something xD,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,119,2018-01-25T03:27:34Z,2018-02-25T23:28:36Z,2018-03-09T21:19:06Z,CLOSED,False,117,0,4,https://github.com/GarlandZhang,ELEC-315 committing placeholder solar master code,4,[],https://github.com/uw-midsun/firmware/pull/119,https://github.com/tituschow,4,https://github.com/uw-midsun/firmware/pull/119#issuecomment-368355375,Added a projects directory for solar_master and included files for placeholder code for the solar master.,Closing because we've changed how the solar slaves work,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,120,2018-01-25T16:38:29Z,2018-01-29T21:31:58Z,2018-01-29T21:32:18Z,MERGED,True,175,0,10,https://github.com/a3farmah,ELEC-231: GPIO Debouncer,14,[],https://github.com/uw-midsun/firmware/pull/120,https://github.com/a3farmah,1,https://github.com/uw-midsun/firmware/pull/120,"Modules have now moved to ms-helper library.
Documentation has been improved","Modules have now moved to ms-helper library.
Documentation has been improved",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,120,2018-01-25T16:38:29Z,2018-01-29T21:31:58Z,2018-01-29T21:32:18Z,MERGED,True,175,0,10,https://github.com/a3farmah,ELEC-231: GPIO Debouncer,14,[],https://github.com/uw-midsun/firmware/pull/120,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/120#issuecomment-360624768,"Modules have now moved to ms-helper library.
Documentation has been improved",It helps a lot if you reply to our comments as you get them done - it makes it obvious if you've addressed them.,True,{'THUMBS_UP': ['https://github.com/ckitagawa']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,121,2018-01-26T03:22:12Z,2018-01-28T05:32:48Z,2018-02-01T20:59:06Z,MERGED,True,405,9,11,https://github.com/karlding,ELEC-319: LTC2484 ADC Driver,17,[],https://github.com/uw-midsun/firmware/pull/121,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/121,"Add LTC 2484 driver
Fix the build system","Add LTC 2484 driver
Fix the build system",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,122,2018-02-06T01:17:43Z,2018-02-10T18:33:11Z,2018-02-10T18:33:16Z,MERGED,True,319,4,8,https://github.com/tituschow,ELEC-333: Flash API,9,[],https://github.com/uw-midsun/firmware/pull/122,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/122,"Supports accessing and modifying the MCU's flash memory. Also includes an x86 emulation layer that recreates the behavior of the STM32.
Note that I needed to use malloc for the flash API because of the linter - originally, I was using VLAs. Also, I don't close the file pointer properly on program exit. However, since we rarely properly exit a program anyways and it should be handled by the OS, I don't think it's a big deal.
I plan on using this API to implement a persistence layer for calibration data and other interesting information.","Supports accessing and modifying the MCU's flash memory. Also includes an x86 emulation layer that recreates the behavior of the STM32.
Note that I needed to use malloc for the flash API because of the linter - originally, I was using VLAs. Also, I don't close the file pointer properly on program exit. However, since we rarely properly exit a program anyways and it should be handled by the OS, I don't think it's a big deal.
I plan on using this API to implement a persistence layer for calibration data and other interesting information.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,123,2018-02-09T01:32:21Z,2018-02-22T18:47:37Z,2018-02-22T20:10:19Z,MERGED,True,583,2,8,https://github.com/a3farmah,ELEC-217: ADS1015,33,[],https://github.com/uw-midsun/firmware/pull/123,https://github.com/a3farmah,1,https://github.com/uw-midsun/firmware/pull/123,"Adds support for ADS1015 which will be used for measuring voltage coming from the pedals.
Tested for STM32.","Adds support for ADS1015 which will be used for measuring voltage coming from the pedals.
Tested for STM32.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,123,2018-02-09T01:32:21Z,2018-02-22T18:47:37Z,2018-02-22T20:10:19Z,MERGED,True,583,2,8,https://github.com/a3farmah,ELEC-217: ADS1015,33,[],https://github.com/uw-midsun/firmware/pull/123,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/123#issuecomment-364345340,"Adds support for ADS1015 which will be used for measuring voltage coming from the pedals.
Tested for STM32.","Great progress! Don't be intimidated by the number of comments. They're mostly formatting, StatusCode, requests for comments, magic numbers, and requesting more descriptive names.",True,{'LAUGH': ['https://github.com/a3farmah']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,123,2018-02-09T01:32:21Z,2018-02-22T18:47:37Z,2018-02-22T20:10:19Z,MERGED,True,583,2,8,https://github.com/a3farmah,ELEC-217: ADS1015,33,[],https://github.com/uw-midsun/firmware/pull/123,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/123#issuecomment-364616238,"Adds support for ADS1015 which will be used for measuring voltage coming from the pedals.
Tested for STM32.",You seem to have included a file called core by accident. Can you make sure that's removed?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,124,2018-02-10T18:24:25Z,2018-02-10T21:24:59Z,2018-02-10T21:25:03Z,MERGED,True,170,33,4,https://github.com/ckitagawa,ELEC-105: [Chaos] Finished Power Path API,7,[],https://github.com/uw-midsun/firmware/pull/124,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/124,"This is the first in a multi-part series of PRs to merge the contents of elec_105_chaos_can into master.
This PR does the following:

Changes errors from raising events to publishing CAN events
Fills in the chaos_events.h file
Updates the test for power_path
Adds an alternative interface to the Power Path API that uses events to make changes (all other modules in Chaos will share the same interface to allow them to all hook into the main event loop)","This is the first in a multi-part series of PRs to merge the contents of elec_105_chaos_can into master.
This PR does the following:

Changes errors from raising events to publishing CAN events
Fills in the chaos_events.h file
Updates the test for power_path
Adds an alternative interface to the Power Path API that uses events to make changes (all other modules in Chaos will share the same interface to allow them to all hook into the main event loop)",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,125,2018-02-10T21:34:25Z,2018-02-24T18:53:42Z,2018-02-24T18:53:47Z,MERGED,True,507,0,6,https://github.com/ckitagawa,ELEC-105: Relay controller for Chaos.,12,[],https://github.com/uw-midsun/firmware/pull/125,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/125,"This is another part of a multi-part series to merge elec_105_chaos_can into master.
This PR adds:

Support for controlling relays over CAN
FSMs that guarantee the state of the relays
Auto-retry closing relays on CAN failure","This is another part of a multi-part series to merge elec_105_chaos_can into master.
This PR adds:

Support for controlling relays over CAN
FSMs that guarantee the state of the relays
Auto-retry closing relays on CAN failure",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,125,2018-02-10T21:34:25Z,2018-02-24T18:53:42Z,2018-02-24T18:53:47Z,MERGED,True,507,0,6,https://github.com/ckitagawa,ELEC-105: Relay controller for Chaos.,12,[],https://github.com/uw-midsun/firmware/pull/125,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/125#issuecomment-365472244,"This is another part of a multi-part series to merge elec_105_chaos_can into master.
This PR adds:

Support for controlling relays over CAN
FSMs that guarantee the state of the relays
Auto-retry closing relays on CAN failure",@karlding Travis keeps crashing on Launchpad...,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,125,2018-02-10T21:34:25Z,2018-02-24T18:53:42Z,2018-02-24T18:53:47Z,MERGED,True,507,0,6,https://github.com/ckitagawa,ELEC-105: Relay controller for Chaos.,12,[],https://github.com/uw-midsun/firmware/pull/125,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/125#issuecomment-365473732,"This is another part of a multi-part series to merge elec_105_chaos_can into master.
This PR adds:

Support for controlling relays over CAN
FSMs that guarantee the state of the relays
Auto-retry closing relays on CAN failure","Looks like we aren't the only ones with this problem (link)
Seems like increasing the timeout and retry count might be a workaround?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,126,2018-02-11T05:27:29Z,2018-02-16T00:10:28Z,2018-02-16T00:10:32Z,MERGED,True,400,6,7,https://github.com/tituschow,ELEC-335: Persist Layer,10,[],https://github.com/uw-midsun/firmware/pull/126,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/126,"Adds a flash-backed persist layer. Tested on x86 and STM32.
The idea is to support arbitrary blobs of data with periodic commits. To support this without a huge number of unnecessary erases, we reserve one page (currently the last page, although it may be cleaner to make this a user-provided parameter?) for persistence.
This page is partitioned into sections, where each section begins with a header consisting of a u32 marker and a u32 size. Thus, each section looks like this:
[ marker (u32) | size (u32) | blob (u32 * n) ]

When first writing to a section, we skip over the marker so that it stays the default value (0xFFFFFFFF), which we consider as ""valid"". When we want to invalidate it, we write 0x0 or some other non-default value to the section's marker, allowing us to invalidate the section without requiring a page erase. Only one section should ever be valid at a time. Once the entire page is full, it is erased and the process begins again.
By encoding the length into the persistence header, we support changing blob formats across resets. If that happens, we just invalidate the old section and start from scratch. Unfortunately, this does mean that we can't upgrade blob data. Thoughts on whether this is desired behavior?
Also fixes a bug where we were trying to access flash memory that was invalid on STM32. Turns out there are only 64 pages. I've added a test to verify that the number of pages is equal to NUM_FLASH_PAGES since I can't do it at compile-time.","Adds a flash-backed persist layer. Tested on x86 and STM32.
The idea is to support arbitrary blobs of data with periodic commits. To support this without a huge number of unnecessary erases, we reserve one page (currently the last page, although it may be cleaner to make this a user-provided parameter?) for persistence.
This page is partitioned into sections, where each section begins with a header consisting of a u32 marker and a u32 size. Thus, each section looks like this:
[ marker (u32) | size (u32) | blob (u32 * n) ]

When first writing to a section, we skip over the marker so that it stays the default value (0xFFFFFFFF), which we consider as ""valid"". When we want to invalidate it, we write 0x0 or some other non-default value to the section's marker, allowing us to invalidate the section without requiring a page erase. Only one section should ever be valid at a time. Once the entire page is full, it is erased and the process begins again.
By encoding the length into the persistence header, we support changing blob formats across resets. If that happens, we just invalidate the old section and start from scratch. Unfortunately, this does mean that we can't upgrade blob data. Thoughts on whether this is desired behavior?
Also fixes a bug where we were trying to access flash memory that was invalid on STM32. Turns out there are only 64 pages. I've added a test to verify that the number of pages is equal to NUM_FLASH_PAGES since I can't do it at compile-time.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,126,2018-02-11T05:27:29Z,2018-02-16T00:10:28Z,2018-02-16T00:10:32Z,MERGED,True,400,6,7,https://github.com/tituschow,ELEC-335: Persist Layer,10,[],https://github.com/uw-midsun/firmware/pull/126,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/126#issuecomment-365118304,"Adds a flash-backed persist layer. Tested on x86 and STM32.
The idea is to support arbitrary blobs of data with periodic commits. To support this without a huge number of unnecessary erases, we reserve one page (currently the last page, although it may be cleaner to make this a user-provided parameter?) for persistence.
This page is partitioned into sections, where each section begins with a header consisting of a u32 marker and a u32 size. Thus, each section looks like this:
[ marker (u32) | size (u32) | blob (u32 * n) ]

When first writing to a section, we skip over the marker so that it stays the default value (0xFFFFFFFF), which we consider as ""valid"". When we want to invalidate it, we write 0x0 or some other non-default value to the section's marker, allowing us to invalidate the section without requiring a page erase. Only one section should ever be valid at a time. Once the entire page is full, it is erased and the process begins again.
By encoding the length into the persistence header, we support changing blob formats across resets. If that happens, we just invalidate the old section and start from scratch. Unfortunately, this does mean that we can't upgrade blob data. Thoughts on whether this is desired behavior?
Also fixes a bug where we were trying to access flash memory that was invalid on STM32. Turns out there are only 64 pages. I've added a test to verify that the number of pages is equal to NUM_FLASH_PAGES since I can't do it at compile-time.",Looks good so far. I have some questions though. :),True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,126,2018-02-11T05:27:29Z,2018-02-16T00:10:28Z,2018-02-16T00:10:32Z,MERGED,True,400,6,7,https://github.com/tituschow,ELEC-335: Persist Layer,10,[],https://github.com/uw-midsun/firmware/pull/126,https://github.com/ckitagawa,3,https://github.com/uw-midsun/firmware/pull/126#issuecomment-365473517,"Adds a flash-backed persist layer. Tested on x86 and STM32.
The idea is to support arbitrary blobs of data with periodic commits. To support this without a huge number of unnecessary erases, we reserve one page (currently the last page, although it may be cleaner to make this a user-provided parameter?) for persistence.
This page is partitioned into sections, where each section begins with a header consisting of a u32 marker and a u32 size. Thus, each section looks like this:
[ marker (u32) | size (u32) | blob (u32 * n) ]

When first writing to a section, we skip over the marker so that it stays the default value (0xFFFFFFFF), which we consider as ""valid"". When we want to invalidate it, we write 0x0 or some other non-default value to the section's marker, allowing us to invalidate the section without requiring a page erase. Only one section should ever be valid at a time. Once the entire page is full, it is erased and the process begins again.
By encoding the length into the persistence header, we support changing blob formats across resets. If that happens, we just invalidate the old section and start from scratch. Unfortunately, this does mean that we can't upgrade blob data. Thoughts on whether this is desired behavior?
Also fixes a bug where we were trying to access flash memory that was invalid on STM32. Turns out there are only 64 pages. I've added a test to verify that the number of pages is equal to NUM_FLASH_PAGES since I can't do it at compile-time.","LGTM, I want to take a quick look once the hash layer is in but otherwise this should be good to merge.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,127,2018-02-13T04:58:00Z,2018-02-14T05:44:04Z,2018-02-14T05:44:07Z,MERGED,True,136,0,4,https://github.com/tituschow,ELEC-352: CRC32,3,[],https://github.com/uw-midsun/firmware/pull/127,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/127,"Adds support for CRC32 over arrays. Uses the standard CRC32 model. Tested on STM32 and x86.
Uses the hardware CRC peripheral on STM32 and a table-driven model on x86.","Adds support for CRC32 over arrays. Uses the standard CRC32 model. Tested on STM32 and x86.
Uses the hardware CRC peripheral on STM32 and a table-driven model on x86.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,128,2018-02-14T19:17:34Z,2018-03-19T02:10:34Z,2018-09-13T07:12:25Z,CLOSED,False,1250,213,25,https://github.com/ArshanKhanifar,ELEC-165: Lights Control,21,[],https://github.com/uw-midsun/firmware/pull/128,https://github.com/ArshanKhanifar,1,https://github.com/uw-midsun/firmware/pull/128,"This will be my first pull request! YAY!
What this pull request contains so far:
Modules:
main: main loop of program and initializations
lights_periph: contains initialization of the peripherals, and sending commands to them (so far only contains lights_periph_simple which is used for simple peripherals that have one of the ON or OFF states. Used for: headlights, horn, strobelight, and brake lights)
process_event: takes event as the input and takes action based on the event type
can_setup: sets up CAN communication, receives CAN messages and raises events.
Tests:
Only can_setup has tests so far.
Next Steps:

add tests for the rest of the existing modules
think about implementing how to control the signal lights.","This will be my first pull request! YAY!
What this pull request contains so far:
Modules:
main: main loop of program and initializations
lights_periph: contains initialization of the peripherals, and sending commands to them (so far only contains lights_periph_simple which is used for simple peripherals that have one of the ON or OFF states. Used for: headlights, horn, strobelight, and brake lights)
process_event: takes event as the input and takes action based on the event type
can_setup: sets up CAN communication, receives CAN messages and raises events.
Tests:
Only can_setup has tests so far.
Next Steps:

add tests for the rest of the existing modules
think about implementing how to control the signal lights.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,128,2018-02-14T19:17:34Z,2018-03-19T02:10:34Z,2018-09-13T07:12:25Z,CLOSED,False,1250,213,25,https://github.com/ArshanKhanifar,ELEC-165: Lights Control,21,[],https://github.com/uw-midsun/firmware/pull/128,https://github.com/karlding,2,https://github.com/uw-midsun/firmware/pull/128#issuecomment-366473758,"This will be my first pull request! YAY!
What this pull request contains so far:
Modules:
main: main loop of program and initializations
lights_periph: contains initialization of the peripherals, and sending commands to them (so far only contains lights_periph_simple which is used for simple peripherals that have one of the ON or OFF states. Used for: headlights, horn, strobelight, and brake lights)
process_event: takes event as the input and takes action based on the event type
can_setup: sets up CAN communication, receives CAN messages and raises events.
Tests:
Only can_setup has tests so far.
Next Steps:

add tests for the rest of the existing modules
think about implementing how to control the signal lights.","Good start! I made a few general comments about the overall design of the code. There's a bunch of style things, but let's work through the bigger picture things first so you don't end up fixing style issues that might get removed as the code changes.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,128,2018-02-14T19:17:34Z,2018-03-19T02:10:34Z,2018-09-13T07:12:25Z,CLOSED,False,1250,213,25,https://github.com/ArshanKhanifar,ELEC-165: Lights Control,21,[],https://github.com/uw-midsun/firmware/pull/128,https://github.com/ArshanKhanifar,3,https://github.com/uw-midsun/firmware/pull/128#issuecomment-367205045,"This will be my first pull request! YAY!
What this pull request contains so far:
Modules:
main: main loop of program and initializations
lights_periph: contains initialization of the peripherals, and sending commands to them (so far only contains lights_periph_simple which is used for simple peripherals that have one of the ON or OFF states. Used for: headlights, horn, strobelight, and brake lights)
process_event: takes event as the input and takes action based on the event type
can_setup: sets up CAN communication, receives CAN messages and raises events.
Tests:
Only can_setup has tests so far.
Next Steps:

add tests for the rest of the existing modules
think about implementing how to control the signal lights.","After a detailed discussion with @tituschow  I got a better idea as to how to organize my code. I've updated the wiki page with a better description of what each module should do. The overall picture is pretty much there. I still need to update the wiki as I think I came up with how to sync the boards.
One module as of now is completely written and tested:
lights_can",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,129,2018-02-16T02:11:35Z,2018-02-24T18:12:02Z,2018-02-24T18:19:35Z,MERGED,True,205,0,5,https://github.com/ckitagawa,ELEC-105: GPIO FSM for Chaos,4,[],https://github.com/uw-midsun/firmware/pull/129,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/129,"Simple module that handle GPIO transitions for groups of pins depending on the state the car is in.
Feel free to discuss rationale behind pin order. I'll fill in the specific pin/ports before merging.","Simple module that handle GPIO transitions for groups of pins depending on the state the car is in.
Feel free to discuss rationale behind pin order. I'll fill in the specific pin/ports before merging.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,130,2018-02-16T02:17:57Z,2018-02-25T16:09:56Z,2018-02-25T16:10:53Z,CLOSED,False,282,8,4,https://github.com/ckitagawa,ELEC-105: Chaos CAN FSM,6,[],https://github.com/uw-midsun/firmware/pull/130,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/130,Simple CAN FSM configuration for CAN. It only handles state change messages for now but it should also handle Charger related messages in the future.,Simple CAN FSM configuration for CAN. It only handles state change messages for now but it should also handle Charger related messages in the future.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,130,2018-02-16T02:17:57Z,2018-02-25T16:09:56Z,2018-02-25T16:10:53Z,CLOSED,False,282,8,4,https://github.com/ckitagawa,ELEC-105: Chaos CAN FSM,6,[],https://github.com/uw-midsun/firmware/pull/130,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/130#issuecomment-366464793,Simple CAN FSM configuration for CAN. It only handles state change messages for now but it should also handle Charger related messages in the future.,This will branch will fail Travis until we do a roll of codegen-tooling for updating some of the CAN messages.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,130,2018-02-16T02:17:57Z,2018-02-25T16:09:56Z,2018-02-25T16:10:53Z,CLOSED,False,282,8,4,https://github.com/ckitagawa,ELEC-105: Chaos CAN FSM,6,[],https://github.com/uw-midsun/firmware/pull/130,https://github.com/ckitagawa,3,https://github.com/uw-midsun/firmware/pull/130#issuecomment-368321525,Simple CAN FSM configuration for CAN. It only handles state change messages for now but it should also handle Charger related messages in the future.,"Temporary closing in order to add support for

Powertrain Heartbeat
Plutus (BPS) Heartbeat
Charger Requests",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,131,2018-02-16T02:32:19Z,2018-02-25T16:11:07Z,2018-02-25T16:11:36Z,CLOSED,False,262,0,3,https://github.com/ckitagawa,ELEC-105: Chaos Sequencer,1,[],https://github.com/uw-midsun/firmware/pull/131,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/131,"Blocked by #125
Does event sequencing for Chaos based on the previous event that occurred. Basically a streamlined event producer/FSM that requires less boilerplate.
This is the last PR required to make Chaos functional but it will be followed by PRs to integrate the charger.
Note: build is expected to fail until relays are merged in.","Blocked by #125
Does event sequencing for Chaos based on the previous event that occurred. Basically a streamlined event producer/FSM that requires less boilerplate.
This is the last PR required to make Chaos functional but it will be followed by PRs to integrate the charger.
Note: build is expected to fail until relays are merged in.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,131,2018-02-16T02:32:19Z,2018-02-25T16:11:07Z,2018-02-25T16:11:36Z,CLOSED,False,262,0,3,https://github.com/ckitagawa,ELEC-105: Chaos Sequencer,1,[],https://github.com/uw-midsun/firmware/pull/131,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/131#issuecomment-368321580,"Blocked by #125
Does event sequencing for Chaos based on the previous event that occurred. Basically a streamlined event producer/FSM that requires less boilerplate.
This is the last PR required to make Chaos functional but it will be followed by PRs to integrate the charger.
Note: build is expected to fail until relays are merged in.",Closing until I add support for the emergency shutdown mode.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,132,2018-02-17T20:04:31Z,2018-02-17T20:31:37Z,2018-02-17T20:31:41Z,MERGED,True,21,23,11,https://github.com/ckitagawa,ELEC-321: LSC Unify Callback Style,3,[],https://github.com/uw-midsun/firmware/pull/132,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/132,"Unifies the callback declaration style across libraries and projects that we own to be CamelCase.
This was done using the following method:
Find the type definitions using:
$ rg 'typedef .* ('
rg
Fix using sed to (don't run in directory with .git or it will corrupt the log):
$ find . -type -exec sed -i 's/<before>/<after>/g' {} +
For now acronyms will remain the UPPERCASE style until that can be hopefully fixed with clang-rename.","Unifies the callback declaration style across libraries and projects that we own to be CamelCase.
This was done using the following method:
Find the type definitions using:
$ rg 'typedef .* ('
rg
Fix using sed to (don't run in directory with .git or it will corrupt the log):
$ find . -type -exec sed -i 's/<before>/<after>/g' {} +
For now acronyms will remain the UPPERCASE style until that can be hopefully fixed with clang-rename.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,133,2018-02-17T22:20:03Z,2018-02-17T23:10:44Z,2018-02-17T23:10:46Z,MERGED,True,268,215,7,https://github.com/ckitagawa,ELEC-353: Rollforward codegen-tooling fixing namespace issue,3,[],https://github.com/uw-midsun/firmware/pull/133,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/133,"Semi-automated roll of codegen-tooling to fix namespacing issue, empty packing and update messages.","Semi-automated roll of codegen-tooling to fix namespacing issue, empty packing and update messages.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,134,2018-02-18T03:40:04Z,2018-02-19T06:05:10Z,2018-02-19T06:05:44Z,MERGED,True,19,15,5,https://github.com/karlding,ELEC-128: Roll codegen-tooling forward to latest (v0.0.6),2,[],https://github.com/uw-midsun/firmware/pull/134,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/134,"Roll codegen-tooling forward to latest release (v0.0.6)
Force curl to use curl User-Agent and not whatever is specified in ~/.curlrc

Not sure if we want the second change, but I was running into an issue where I had the following set in my ~/.curlrc file
# Send a fake UA string for the HTTP servers that sniff it
# Pretend to be IE 9 on Windows 7
user-agent = ""Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)""

# Wait 60 seconds before timing out
connect-timeout = 60

# When following a redirect, automatically set the previous URL as referer
referer = "";auto""

# Show error messages
show-error

And because my User-Agent string doesn't contain curl, GitHub seems to minify the  JSON response. I've basically fixed this by forcing the User-Agent to be curl, but maybe that's the wrong approach?
Here's the JSON response without curl in the header
 → TITANIC@firmware (elec_128_update_codegen_tooling) $ curl -s https://api.github.com/repos/uw-midsun/codegen-tooling/releases/latest

{""url"":""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/9722717"",""assets_url"":""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/9722717/assets"",""upload_url"":""https://uploads.github.com/repos/uw-midsun/codegen-tooling/releases/9722717/assets{?name,label}"",""html_url"":""https://github.com/uw-midsun/codegen-tooling/releases/tag/v0.0.6"",""id"":9722717,""tag_name"":""v0.0.6"",""target_commitish"":""master"",""name"":""Fix Motor Controls message field numbering in asciipb file"",""draft"":false,""author"":{""login"":""karlding"",""id"":6836385,""avatar_url"":""https://avatars2.githubusercontent.com/u/6836385?v=4"",""gravatar_id"":"""",""url"":""https://api.github.com/users/karlding"",""html_url"":""https://github.com/karlding"",""followers_url"":""https://api.github.com/users/karlding/followers"",""following_url"":""https://api.github.com/users/karlding/following{/other_user}"",""gists_url"":""https://api.github.com/users/karlding/gists{/gist_id}"",""starred_url"":""https://api.github.com/users/karlding/starred{/owner}{/repo}"",""subscriptions_url"":""https://api.github.com/users/karlding/subscriptions"",""organizations_url"":""https://api.github.com/users/karlding/orgs"",""repos_url"":""https://api.github.com/users/karlding/repos"",""events_url"":""https://api.github.com/users/karlding/events{/privacy}"",""received_events_url"":""https://api.github.com/users/karlding/received_events"",""type"":""User"",""site_admin"":false},""prerelease"":false,""created_at"":""2018-02-18T03:04:15Z"",""published_at"":""2018-02-18T03:08:10Z"",""assets"":[{""url"":""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/assets/6246507"",""id"":6246507,""name"":""codegen-tooling-out.zip"",""label"":null,""uploader"":{""login"":""karlding"",""id"":6836385,""avatar_url"":""https://avatars2.githubusercontent.com/u/6836385?v=4"",""gravatar_id"":"""",""url"":""https://api.github.com/users/karlding"",""html_url"":""https://github.com/karlding"",""followers_url"":""https://api.github.com/users/karlding/followers"",""following_url"":""https://api.github.com/users/karlding/following{/other_user}"",""gists_url"":""https://api.github.com/users/karlding/gists{/gist_id}"",""starred_url"":""https://api.github.com/users/karlding/starred{/owner}{/repo}"",""subscriptions_url"":""https://api.github.com/users/karlding/subscriptions"",""organizations_url"":""https://api.github.com/users/karlding/orgs"",""repos_url"":""https://api.github.com/users/karlding/repos"",""events_url"":""https://api.github.com/users/karlding/events{/privacy}"",""received_events_url"":""https://api.github.com/users/karlding/received_events"",""type"":""User"",""site_admin"":false},""content_type"":""application/zip"",""state"":""uploaded"",""size"":5896,""download_count"":18,""created_at"":""2018-02-18T03:13:01Z"",""updated_at"":""2018-02-18T03:13:02Z"",""browser_download_url"":""https://github.com/uw-midsun/codegen-tooling/releases/download/v0.0.6/codegen-tooling-out.zip""}],""tarball_url"":""https://api.github.com/repos/uw-midsun/codegen-tooling/tarball/v0.0.6"",""zipball_url"":""https://api.github.com/repos/uw-midsun/codegen-tooling/zipball/v0.0.6"",""body"":""""}

Here's the JSON response when adding curl to the header
 → TITANIC@firmware (elec_128_update_codegen_tooling) $ curl -A 'curl' -s https://api.github.com/repos/uw-midsun/codegen-tooling/releases/latest

{
  ""url"": ""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/9722717"",
  ""assets_url"": ""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/9722717/assets"",
  ""upload_url"": ""https://uploads.github.com/repos/uw-midsun/codegen-tooling/releases/9722717/assets{?name,label}"",
  ""html_url"": ""https://github.com/uw-midsun/codegen-tooling/releases/tag/v0.0.6"",
  ""id"": 9722717,
  ""tag_name"": ""v0.0.6"",
  ""target_commitish"": ""master"",
  ""name"": ""Fix Motor Controls message field numbering in asciipb file"",
  ""draft"": false,
  ""author"": {
    ""login"": ""karlding"",
    ""id"": 6836385,
    ""avatar_url"": ""https://avatars2.githubusercontent.com/u/6836385?v=4"",
    ""gravatar_id"": """",
    ""url"": ""https://api.github.com/users/karlding"",
    ""html_url"": ""https://github.com/karlding"",
    ""followers_url"": ""https://api.github.com/users/karlding/followers"",
    ""following_url"": ""https://api.github.com/users/karlding/following{/other_user}"",
    ""gists_url"": ""https://api.github.com/users/karlding/gists{/gist_id}"",
    ""starred_url"": ""https://api.github.com/users/karlding/starred{/owner}{/repo}"",
    ""subscriptions_url"": ""https://api.github.com/users/karlding/subscriptions"",
    ""organizations_url"": ""https://api.github.com/users/karlding/orgs"",
    ""repos_url"": ""https://api.github.com/users/karlding/repos"",
    ""events_url"": ""https://api.github.com/users/karlding/events{/privacy}"",
    ""received_events_url"": ""https://api.github.com/users/karlding/received_events"",
    ""type"": ""User"",
    ""site_admin"": false
  },
  ""prerelease"": false,
  ""created_at"": ""2018-02-18T03:04:15Z"",
  ""published_at"": ""2018-02-18T03:08:10Z"",
  ""assets"": [
    {
      ""url"": ""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/assets/6246507"",
      ""id"": 6246507,
      ""name"": ""codegen-tooling-out.zip"",
      ""label"": null,
      ""uploader"": {
        ""login"": ""karlding"",
        ""id"": 6836385,
        ""avatar_url"": ""https://avatars2.githubusercontent.com/u/6836385?v=4"",
        ""gravatar_id"": """",
        ""url"": ""https://api.github.com/users/karlding"",
        ""html_url"": ""https://github.com/karlding"",
        ""followers_url"": ""https://api.github.com/users/karlding/followers"",
        ""following_url"": ""https://api.github.com/users/karlding/following{/other_user}"",
        ""gists_url"": ""https://api.github.com/users/karlding/gists{/gist_id}"",
        ""starred_url"": ""https://api.github.com/users/karlding/starred{/owner}{/repo}"",
        ""subscriptions_url"": ""https://api.github.com/users/karlding/subscriptions"",
        ""organizations_url"": ""https://api.github.com/users/karlding/orgs"",
        ""repos_url"": ""https://api.github.com/users/karlding/repos"",
        ""events_url"": ""https://api.github.com/users/karlding/events{/privacy}"",
        ""received_events_url"": ""https://api.github.com/users/karlding/received_events"",
        ""type"": ""User"",
        ""site_admin"": false
      },
      ""content_type"": ""application/zip"",
      ""state"": ""uploaded"",
      ""size"": 5896,
      ""download_count"": 18,
      ""created_at"": ""2018-02-18T03:13:01Z"",
      ""updated_at"": ""2018-02-18T03:13:02Z"",
      ""browser_download_url"": ""https://github.com/uw-midsun/codegen-tooling/releases/download/v0.0.6/codegen-tooling-out.zip""
    }
  ],
  ""tarball_url"": ""https://api.github.com/repos/uw-midsun/codegen-tooling/tarball/v0.0.6"",
  ""zipball_url"": ""https://api.github.com/repos/uw-midsun/codegen-tooling/zipball/v0.0.6"",
  ""body"": """"
}

Edit: You can probably change the curl and grep chain to be something like this
curl -s https://api.github.com/repos/uw-midsun/codegen-tooling/releases/latest | grep -Eo '""browser_download_url""\:.*codegen-tooling-out.zip""' | grep -Eo 'https://.*\.zip'
and then pipe that into wget","Roll codegen-tooling forward to latest release (v0.0.6)
Force curl to use curl User-Agent and not whatever is specified in ~/.curlrc

Not sure if we want the second change, but I was running into an issue where I had the following set in my ~/.curlrc file
# Send a fake UA string for the HTTP servers that sniff it
# Pretend to be IE 9 on Windows 7
user-agent = ""Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)""

# Wait 60 seconds before timing out
connect-timeout = 60

# When following a redirect, automatically set the previous URL as referer
referer = "";auto""

# Show error messages
show-error

And because my User-Agent string doesn't contain curl, GitHub seems to minify the  JSON response. I've basically fixed this by forcing the User-Agent to be curl, but maybe that's the wrong approach?
Here's the JSON response without curl in the header
 → TITANIC@firmware (elec_128_update_codegen_tooling) $ curl -s https://api.github.com/repos/uw-midsun/codegen-tooling/releases/latest

{""url"":""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/9722717"",""assets_url"":""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/9722717/assets"",""upload_url"":""https://uploads.github.com/repos/uw-midsun/codegen-tooling/releases/9722717/assets{?name,label}"",""html_url"":""https://github.com/uw-midsun/codegen-tooling/releases/tag/v0.0.6"",""id"":9722717,""tag_name"":""v0.0.6"",""target_commitish"":""master"",""name"":""Fix Motor Controls message field numbering in asciipb file"",""draft"":false,""author"":{""login"":""karlding"",""id"":6836385,""avatar_url"":""https://avatars2.githubusercontent.com/u/6836385?v=4"",""gravatar_id"":"""",""url"":""https://api.github.com/users/karlding"",""html_url"":""https://github.com/karlding"",""followers_url"":""https://api.github.com/users/karlding/followers"",""following_url"":""https://api.github.com/users/karlding/following{/other_user}"",""gists_url"":""https://api.github.com/users/karlding/gists{/gist_id}"",""starred_url"":""https://api.github.com/users/karlding/starred{/owner}{/repo}"",""subscriptions_url"":""https://api.github.com/users/karlding/subscriptions"",""organizations_url"":""https://api.github.com/users/karlding/orgs"",""repos_url"":""https://api.github.com/users/karlding/repos"",""events_url"":""https://api.github.com/users/karlding/events{/privacy}"",""received_events_url"":""https://api.github.com/users/karlding/received_events"",""type"":""User"",""site_admin"":false},""prerelease"":false,""created_at"":""2018-02-18T03:04:15Z"",""published_at"":""2018-02-18T03:08:10Z"",""assets"":[{""url"":""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/assets/6246507"",""id"":6246507,""name"":""codegen-tooling-out.zip"",""label"":null,""uploader"":{""login"":""karlding"",""id"":6836385,""avatar_url"":""https://avatars2.githubusercontent.com/u/6836385?v=4"",""gravatar_id"":"""",""url"":""https://api.github.com/users/karlding"",""html_url"":""https://github.com/karlding"",""followers_url"":""https://api.github.com/users/karlding/followers"",""following_url"":""https://api.github.com/users/karlding/following{/other_user}"",""gists_url"":""https://api.github.com/users/karlding/gists{/gist_id}"",""starred_url"":""https://api.github.com/users/karlding/starred{/owner}{/repo}"",""subscriptions_url"":""https://api.github.com/users/karlding/subscriptions"",""organizations_url"":""https://api.github.com/users/karlding/orgs"",""repos_url"":""https://api.github.com/users/karlding/repos"",""events_url"":""https://api.github.com/users/karlding/events{/privacy}"",""received_events_url"":""https://api.github.com/users/karlding/received_events"",""type"":""User"",""site_admin"":false},""content_type"":""application/zip"",""state"":""uploaded"",""size"":5896,""download_count"":18,""created_at"":""2018-02-18T03:13:01Z"",""updated_at"":""2018-02-18T03:13:02Z"",""browser_download_url"":""https://github.com/uw-midsun/codegen-tooling/releases/download/v0.0.6/codegen-tooling-out.zip""}],""tarball_url"":""https://api.github.com/repos/uw-midsun/codegen-tooling/tarball/v0.0.6"",""zipball_url"":""https://api.github.com/repos/uw-midsun/codegen-tooling/zipball/v0.0.6"",""body"":""""}

Here's the JSON response when adding curl to the header
 → TITANIC@firmware (elec_128_update_codegen_tooling) $ curl -A 'curl' -s https://api.github.com/repos/uw-midsun/codegen-tooling/releases/latest

{
  ""url"": ""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/9722717"",
  ""assets_url"": ""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/9722717/assets"",
  ""upload_url"": ""https://uploads.github.com/repos/uw-midsun/codegen-tooling/releases/9722717/assets{?name,label}"",
  ""html_url"": ""https://github.com/uw-midsun/codegen-tooling/releases/tag/v0.0.6"",
  ""id"": 9722717,
  ""tag_name"": ""v0.0.6"",
  ""target_commitish"": ""master"",
  ""name"": ""Fix Motor Controls message field numbering in asciipb file"",
  ""draft"": false,
  ""author"": {
    ""login"": ""karlding"",
    ""id"": 6836385,
    ""avatar_url"": ""https://avatars2.githubusercontent.com/u/6836385?v=4"",
    ""gravatar_id"": """",
    ""url"": ""https://api.github.com/users/karlding"",
    ""html_url"": ""https://github.com/karlding"",
    ""followers_url"": ""https://api.github.com/users/karlding/followers"",
    ""following_url"": ""https://api.github.com/users/karlding/following{/other_user}"",
    ""gists_url"": ""https://api.github.com/users/karlding/gists{/gist_id}"",
    ""starred_url"": ""https://api.github.com/users/karlding/starred{/owner}{/repo}"",
    ""subscriptions_url"": ""https://api.github.com/users/karlding/subscriptions"",
    ""organizations_url"": ""https://api.github.com/users/karlding/orgs"",
    ""repos_url"": ""https://api.github.com/users/karlding/repos"",
    ""events_url"": ""https://api.github.com/users/karlding/events{/privacy}"",
    ""received_events_url"": ""https://api.github.com/users/karlding/received_events"",
    ""type"": ""User"",
    ""site_admin"": false
  },
  ""prerelease"": false,
  ""created_at"": ""2018-02-18T03:04:15Z"",
  ""published_at"": ""2018-02-18T03:08:10Z"",
  ""assets"": [
    {
      ""url"": ""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/assets/6246507"",
      ""id"": 6246507,
      ""name"": ""codegen-tooling-out.zip"",
      ""label"": null,
      ""uploader"": {
        ""login"": ""karlding"",
        ""id"": 6836385,
        ""avatar_url"": ""https://avatars2.githubusercontent.com/u/6836385?v=4"",
        ""gravatar_id"": """",
        ""url"": ""https://api.github.com/users/karlding"",
        ""html_url"": ""https://github.com/karlding"",
        ""followers_url"": ""https://api.github.com/users/karlding/followers"",
        ""following_url"": ""https://api.github.com/users/karlding/following{/other_user}"",
        ""gists_url"": ""https://api.github.com/users/karlding/gists{/gist_id}"",
        ""starred_url"": ""https://api.github.com/users/karlding/starred{/owner}{/repo}"",
        ""subscriptions_url"": ""https://api.github.com/users/karlding/subscriptions"",
        ""organizations_url"": ""https://api.github.com/users/karlding/orgs"",
        ""repos_url"": ""https://api.github.com/users/karlding/repos"",
        ""events_url"": ""https://api.github.com/users/karlding/events{/privacy}"",
        ""received_events_url"": ""https://api.github.com/users/karlding/received_events"",
        ""type"": ""User"",
        ""site_admin"": false
      },
      ""content_type"": ""application/zip"",
      ""state"": ""uploaded"",
      ""size"": 5896,
      ""download_count"": 18,
      ""created_at"": ""2018-02-18T03:13:01Z"",
      ""updated_at"": ""2018-02-18T03:13:02Z"",
      ""browser_download_url"": ""https://github.com/uw-midsun/codegen-tooling/releases/download/v0.0.6/codegen-tooling-out.zip""
    }
  ],
  ""tarball_url"": ""https://api.github.com/repos/uw-midsun/codegen-tooling/tarball/v0.0.6"",
  ""zipball_url"": ""https://api.github.com/repos/uw-midsun/codegen-tooling/zipball/v0.0.6"",
  ""body"": """"
}

Edit: You can probably change the curl and grep chain to be something like this
curl -s https://api.github.com/repos/uw-midsun/codegen-tooling/releases/latest | grep -Eo '""browser_download_url""\:.*codegen-tooling-out.zip""' | grep -Eo 'https://.*\.zip'
and then pipe that into wget",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,134,2018-02-18T03:40:04Z,2018-02-19T06:05:10Z,2018-02-19T06:05:44Z,MERGED,True,19,15,5,https://github.com/karlding,ELEC-128: Roll codegen-tooling forward to latest (v0.0.6),2,[],https://github.com/uw-midsun/firmware/pull/134,https://github.com/karlding,2,https://github.com/uw-midsun/firmware/pull/134#issuecomment-366490216,"Roll codegen-tooling forward to latest release (v0.0.6)
Force curl to use curl User-Agent and not whatever is specified in ~/.curlrc

Not sure if we want the second change, but I was running into an issue where I had the following set in my ~/.curlrc file
# Send a fake UA string for the HTTP servers that sniff it
# Pretend to be IE 9 on Windows 7
user-agent = ""Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)""

# Wait 60 seconds before timing out
connect-timeout = 60

# When following a redirect, automatically set the previous URL as referer
referer = "";auto""

# Show error messages
show-error

And because my User-Agent string doesn't contain curl, GitHub seems to minify the  JSON response. I've basically fixed this by forcing the User-Agent to be curl, but maybe that's the wrong approach?
Here's the JSON response without curl in the header
 → TITANIC@firmware (elec_128_update_codegen_tooling) $ curl -s https://api.github.com/repos/uw-midsun/codegen-tooling/releases/latest

{""url"":""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/9722717"",""assets_url"":""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/9722717/assets"",""upload_url"":""https://uploads.github.com/repos/uw-midsun/codegen-tooling/releases/9722717/assets{?name,label}"",""html_url"":""https://github.com/uw-midsun/codegen-tooling/releases/tag/v0.0.6"",""id"":9722717,""tag_name"":""v0.0.6"",""target_commitish"":""master"",""name"":""Fix Motor Controls message field numbering in asciipb file"",""draft"":false,""author"":{""login"":""karlding"",""id"":6836385,""avatar_url"":""https://avatars2.githubusercontent.com/u/6836385?v=4"",""gravatar_id"":"""",""url"":""https://api.github.com/users/karlding"",""html_url"":""https://github.com/karlding"",""followers_url"":""https://api.github.com/users/karlding/followers"",""following_url"":""https://api.github.com/users/karlding/following{/other_user}"",""gists_url"":""https://api.github.com/users/karlding/gists{/gist_id}"",""starred_url"":""https://api.github.com/users/karlding/starred{/owner}{/repo}"",""subscriptions_url"":""https://api.github.com/users/karlding/subscriptions"",""organizations_url"":""https://api.github.com/users/karlding/orgs"",""repos_url"":""https://api.github.com/users/karlding/repos"",""events_url"":""https://api.github.com/users/karlding/events{/privacy}"",""received_events_url"":""https://api.github.com/users/karlding/received_events"",""type"":""User"",""site_admin"":false},""prerelease"":false,""created_at"":""2018-02-18T03:04:15Z"",""published_at"":""2018-02-18T03:08:10Z"",""assets"":[{""url"":""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/assets/6246507"",""id"":6246507,""name"":""codegen-tooling-out.zip"",""label"":null,""uploader"":{""login"":""karlding"",""id"":6836385,""avatar_url"":""https://avatars2.githubusercontent.com/u/6836385?v=4"",""gravatar_id"":"""",""url"":""https://api.github.com/users/karlding"",""html_url"":""https://github.com/karlding"",""followers_url"":""https://api.github.com/users/karlding/followers"",""following_url"":""https://api.github.com/users/karlding/following{/other_user}"",""gists_url"":""https://api.github.com/users/karlding/gists{/gist_id}"",""starred_url"":""https://api.github.com/users/karlding/starred{/owner}{/repo}"",""subscriptions_url"":""https://api.github.com/users/karlding/subscriptions"",""organizations_url"":""https://api.github.com/users/karlding/orgs"",""repos_url"":""https://api.github.com/users/karlding/repos"",""events_url"":""https://api.github.com/users/karlding/events{/privacy}"",""received_events_url"":""https://api.github.com/users/karlding/received_events"",""type"":""User"",""site_admin"":false},""content_type"":""application/zip"",""state"":""uploaded"",""size"":5896,""download_count"":18,""created_at"":""2018-02-18T03:13:01Z"",""updated_at"":""2018-02-18T03:13:02Z"",""browser_download_url"":""https://github.com/uw-midsun/codegen-tooling/releases/download/v0.0.6/codegen-tooling-out.zip""}],""tarball_url"":""https://api.github.com/repos/uw-midsun/codegen-tooling/tarball/v0.0.6"",""zipball_url"":""https://api.github.com/repos/uw-midsun/codegen-tooling/zipball/v0.0.6"",""body"":""""}

Here's the JSON response when adding curl to the header
 → TITANIC@firmware (elec_128_update_codegen_tooling) $ curl -A 'curl' -s https://api.github.com/repos/uw-midsun/codegen-tooling/releases/latest

{
  ""url"": ""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/9722717"",
  ""assets_url"": ""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/9722717/assets"",
  ""upload_url"": ""https://uploads.github.com/repos/uw-midsun/codegen-tooling/releases/9722717/assets{?name,label}"",
  ""html_url"": ""https://github.com/uw-midsun/codegen-tooling/releases/tag/v0.0.6"",
  ""id"": 9722717,
  ""tag_name"": ""v0.0.6"",
  ""target_commitish"": ""master"",
  ""name"": ""Fix Motor Controls message field numbering in asciipb file"",
  ""draft"": false,
  ""author"": {
    ""login"": ""karlding"",
    ""id"": 6836385,
    ""avatar_url"": ""https://avatars2.githubusercontent.com/u/6836385?v=4"",
    ""gravatar_id"": """",
    ""url"": ""https://api.github.com/users/karlding"",
    ""html_url"": ""https://github.com/karlding"",
    ""followers_url"": ""https://api.github.com/users/karlding/followers"",
    ""following_url"": ""https://api.github.com/users/karlding/following{/other_user}"",
    ""gists_url"": ""https://api.github.com/users/karlding/gists{/gist_id}"",
    ""starred_url"": ""https://api.github.com/users/karlding/starred{/owner}{/repo}"",
    ""subscriptions_url"": ""https://api.github.com/users/karlding/subscriptions"",
    ""organizations_url"": ""https://api.github.com/users/karlding/orgs"",
    ""repos_url"": ""https://api.github.com/users/karlding/repos"",
    ""events_url"": ""https://api.github.com/users/karlding/events{/privacy}"",
    ""received_events_url"": ""https://api.github.com/users/karlding/received_events"",
    ""type"": ""User"",
    ""site_admin"": false
  },
  ""prerelease"": false,
  ""created_at"": ""2018-02-18T03:04:15Z"",
  ""published_at"": ""2018-02-18T03:08:10Z"",
  ""assets"": [
    {
      ""url"": ""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/assets/6246507"",
      ""id"": 6246507,
      ""name"": ""codegen-tooling-out.zip"",
      ""label"": null,
      ""uploader"": {
        ""login"": ""karlding"",
        ""id"": 6836385,
        ""avatar_url"": ""https://avatars2.githubusercontent.com/u/6836385?v=4"",
        ""gravatar_id"": """",
        ""url"": ""https://api.github.com/users/karlding"",
        ""html_url"": ""https://github.com/karlding"",
        ""followers_url"": ""https://api.github.com/users/karlding/followers"",
        ""following_url"": ""https://api.github.com/users/karlding/following{/other_user}"",
        ""gists_url"": ""https://api.github.com/users/karlding/gists{/gist_id}"",
        ""starred_url"": ""https://api.github.com/users/karlding/starred{/owner}{/repo}"",
        ""subscriptions_url"": ""https://api.github.com/users/karlding/subscriptions"",
        ""organizations_url"": ""https://api.github.com/users/karlding/orgs"",
        ""repos_url"": ""https://api.github.com/users/karlding/repos"",
        ""events_url"": ""https://api.github.com/users/karlding/events{/privacy}"",
        ""received_events_url"": ""https://api.github.com/users/karlding/received_events"",
        ""type"": ""User"",
        ""site_admin"": false
      },
      ""content_type"": ""application/zip"",
      ""state"": ""uploaded"",
      ""size"": 5896,
      ""download_count"": 18,
      ""created_at"": ""2018-02-18T03:13:01Z"",
      ""updated_at"": ""2018-02-18T03:13:02Z"",
      ""browser_download_url"": ""https://github.com/uw-midsun/codegen-tooling/releases/download/v0.0.6/codegen-tooling-out.zip""
    }
  ],
  ""tarball_url"": ""https://api.github.com/repos/uw-midsun/codegen-tooling/tarball/v0.0.6"",
  ""zipball_url"": ""https://api.github.com/repos/uw-midsun/codegen-tooling/zipball/v0.0.6"",
  ""body"": """"
}

Edit: You can probably change the curl and grep chain to be something like this
curl -s https://api.github.com/repos/uw-midsun/codegen-tooling/releases/latest | grep -Eo '""browser_download_url""\:.*codegen-tooling-out.zip""' | grep -Eo 'https://.*\.zip'
and then pipe that into wget",I can also revert the User-Agent change if we just want to get the codegen-tooling changes in first.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,134,2018-02-18T03:40:04Z,2018-02-19T06:05:10Z,2018-02-19T06:05:44Z,MERGED,True,19,15,5,https://github.com/karlding,ELEC-128: Roll codegen-tooling forward to latest (v0.0.6),2,[],https://github.com/uw-midsun/firmware/pull/134,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/134#issuecomment-366491305,"Roll codegen-tooling forward to latest release (v0.0.6)
Force curl to use curl User-Agent and not whatever is specified in ~/.curlrc

Not sure if we want the second change, but I was running into an issue where I had the following set in my ~/.curlrc file
# Send a fake UA string for the HTTP servers that sniff it
# Pretend to be IE 9 on Windows 7
user-agent = ""Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)""

# Wait 60 seconds before timing out
connect-timeout = 60

# When following a redirect, automatically set the previous URL as referer
referer = "";auto""

# Show error messages
show-error

And because my User-Agent string doesn't contain curl, GitHub seems to minify the  JSON response. I've basically fixed this by forcing the User-Agent to be curl, but maybe that's the wrong approach?
Here's the JSON response without curl in the header
 → TITANIC@firmware (elec_128_update_codegen_tooling) $ curl -s https://api.github.com/repos/uw-midsun/codegen-tooling/releases/latest

{""url"":""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/9722717"",""assets_url"":""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/9722717/assets"",""upload_url"":""https://uploads.github.com/repos/uw-midsun/codegen-tooling/releases/9722717/assets{?name,label}"",""html_url"":""https://github.com/uw-midsun/codegen-tooling/releases/tag/v0.0.6"",""id"":9722717,""tag_name"":""v0.0.6"",""target_commitish"":""master"",""name"":""Fix Motor Controls message field numbering in asciipb file"",""draft"":false,""author"":{""login"":""karlding"",""id"":6836385,""avatar_url"":""https://avatars2.githubusercontent.com/u/6836385?v=4"",""gravatar_id"":"""",""url"":""https://api.github.com/users/karlding"",""html_url"":""https://github.com/karlding"",""followers_url"":""https://api.github.com/users/karlding/followers"",""following_url"":""https://api.github.com/users/karlding/following{/other_user}"",""gists_url"":""https://api.github.com/users/karlding/gists{/gist_id}"",""starred_url"":""https://api.github.com/users/karlding/starred{/owner}{/repo}"",""subscriptions_url"":""https://api.github.com/users/karlding/subscriptions"",""organizations_url"":""https://api.github.com/users/karlding/orgs"",""repos_url"":""https://api.github.com/users/karlding/repos"",""events_url"":""https://api.github.com/users/karlding/events{/privacy}"",""received_events_url"":""https://api.github.com/users/karlding/received_events"",""type"":""User"",""site_admin"":false},""prerelease"":false,""created_at"":""2018-02-18T03:04:15Z"",""published_at"":""2018-02-18T03:08:10Z"",""assets"":[{""url"":""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/assets/6246507"",""id"":6246507,""name"":""codegen-tooling-out.zip"",""label"":null,""uploader"":{""login"":""karlding"",""id"":6836385,""avatar_url"":""https://avatars2.githubusercontent.com/u/6836385?v=4"",""gravatar_id"":"""",""url"":""https://api.github.com/users/karlding"",""html_url"":""https://github.com/karlding"",""followers_url"":""https://api.github.com/users/karlding/followers"",""following_url"":""https://api.github.com/users/karlding/following{/other_user}"",""gists_url"":""https://api.github.com/users/karlding/gists{/gist_id}"",""starred_url"":""https://api.github.com/users/karlding/starred{/owner}{/repo}"",""subscriptions_url"":""https://api.github.com/users/karlding/subscriptions"",""organizations_url"":""https://api.github.com/users/karlding/orgs"",""repos_url"":""https://api.github.com/users/karlding/repos"",""events_url"":""https://api.github.com/users/karlding/events{/privacy}"",""received_events_url"":""https://api.github.com/users/karlding/received_events"",""type"":""User"",""site_admin"":false},""content_type"":""application/zip"",""state"":""uploaded"",""size"":5896,""download_count"":18,""created_at"":""2018-02-18T03:13:01Z"",""updated_at"":""2018-02-18T03:13:02Z"",""browser_download_url"":""https://github.com/uw-midsun/codegen-tooling/releases/download/v0.0.6/codegen-tooling-out.zip""}],""tarball_url"":""https://api.github.com/repos/uw-midsun/codegen-tooling/tarball/v0.0.6"",""zipball_url"":""https://api.github.com/repos/uw-midsun/codegen-tooling/zipball/v0.0.6"",""body"":""""}

Here's the JSON response when adding curl to the header
 → TITANIC@firmware (elec_128_update_codegen_tooling) $ curl -A 'curl' -s https://api.github.com/repos/uw-midsun/codegen-tooling/releases/latest

{
  ""url"": ""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/9722717"",
  ""assets_url"": ""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/9722717/assets"",
  ""upload_url"": ""https://uploads.github.com/repos/uw-midsun/codegen-tooling/releases/9722717/assets{?name,label}"",
  ""html_url"": ""https://github.com/uw-midsun/codegen-tooling/releases/tag/v0.0.6"",
  ""id"": 9722717,
  ""tag_name"": ""v0.0.6"",
  ""target_commitish"": ""master"",
  ""name"": ""Fix Motor Controls message field numbering in asciipb file"",
  ""draft"": false,
  ""author"": {
    ""login"": ""karlding"",
    ""id"": 6836385,
    ""avatar_url"": ""https://avatars2.githubusercontent.com/u/6836385?v=4"",
    ""gravatar_id"": """",
    ""url"": ""https://api.github.com/users/karlding"",
    ""html_url"": ""https://github.com/karlding"",
    ""followers_url"": ""https://api.github.com/users/karlding/followers"",
    ""following_url"": ""https://api.github.com/users/karlding/following{/other_user}"",
    ""gists_url"": ""https://api.github.com/users/karlding/gists{/gist_id}"",
    ""starred_url"": ""https://api.github.com/users/karlding/starred{/owner}{/repo}"",
    ""subscriptions_url"": ""https://api.github.com/users/karlding/subscriptions"",
    ""organizations_url"": ""https://api.github.com/users/karlding/orgs"",
    ""repos_url"": ""https://api.github.com/users/karlding/repos"",
    ""events_url"": ""https://api.github.com/users/karlding/events{/privacy}"",
    ""received_events_url"": ""https://api.github.com/users/karlding/received_events"",
    ""type"": ""User"",
    ""site_admin"": false
  },
  ""prerelease"": false,
  ""created_at"": ""2018-02-18T03:04:15Z"",
  ""published_at"": ""2018-02-18T03:08:10Z"",
  ""assets"": [
    {
      ""url"": ""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/assets/6246507"",
      ""id"": 6246507,
      ""name"": ""codegen-tooling-out.zip"",
      ""label"": null,
      ""uploader"": {
        ""login"": ""karlding"",
        ""id"": 6836385,
        ""avatar_url"": ""https://avatars2.githubusercontent.com/u/6836385?v=4"",
        ""gravatar_id"": """",
        ""url"": ""https://api.github.com/users/karlding"",
        ""html_url"": ""https://github.com/karlding"",
        ""followers_url"": ""https://api.github.com/users/karlding/followers"",
        ""following_url"": ""https://api.github.com/users/karlding/following{/other_user}"",
        ""gists_url"": ""https://api.github.com/users/karlding/gists{/gist_id}"",
        ""starred_url"": ""https://api.github.com/users/karlding/starred{/owner}{/repo}"",
        ""subscriptions_url"": ""https://api.github.com/users/karlding/subscriptions"",
        ""organizations_url"": ""https://api.github.com/users/karlding/orgs"",
        ""repos_url"": ""https://api.github.com/users/karlding/repos"",
        ""events_url"": ""https://api.github.com/users/karlding/events{/privacy}"",
        ""received_events_url"": ""https://api.github.com/users/karlding/received_events"",
        ""type"": ""User"",
        ""site_admin"": false
      },
      ""content_type"": ""application/zip"",
      ""state"": ""uploaded"",
      ""size"": 5896,
      ""download_count"": 18,
      ""created_at"": ""2018-02-18T03:13:01Z"",
      ""updated_at"": ""2018-02-18T03:13:02Z"",
      ""browser_download_url"": ""https://github.com/uw-midsun/codegen-tooling/releases/download/v0.0.6/codegen-tooling-out.zip""
    }
  ],
  ""tarball_url"": ""https://api.github.com/repos/uw-midsun/codegen-tooling/tarball/v0.0.6"",
  ""zipball_url"": ""https://api.github.com/repos/uw-midsun/codegen-tooling/zipball/v0.0.6"",
  ""body"": """"
}

Edit: You can probably change the curl and grep chain to be something like this
curl -s https://api.github.com/repos/uw-midsun/codegen-tooling/releases/latest | grep -Eo '""browser_download_url""\:.*codegen-tooling-out.zip""' | grep -Eo 'https://.*\.zip'
and then pipe that into wget",Feels a little odd to be using shell commands in a python script. Is there a reason we don't just use the JSON and requests libraries?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,134,2018-02-18T03:40:04Z,2018-02-19T06:05:10Z,2018-02-19T06:05:44Z,MERGED,True,19,15,5,https://github.com/karlding,ELEC-128: Roll codegen-tooling forward to latest (v0.0.6),2,[],https://github.com/uw-midsun/firmware/pull/134,https://github.com/ckitagawa,4,https://github.com/uw-midsun/firmware/pull/134#issuecomment-366493339,"Roll codegen-tooling forward to latest release (v0.0.6)
Force curl to use curl User-Agent and not whatever is specified in ~/.curlrc

Not sure if we want the second change, but I was running into an issue where I had the following set in my ~/.curlrc file
# Send a fake UA string for the HTTP servers that sniff it
# Pretend to be IE 9 on Windows 7
user-agent = ""Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)""

# Wait 60 seconds before timing out
connect-timeout = 60

# When following a redirect, automatically set the previous URL as referer
referer = "";auto""

# Show error messages
show-error

And because my User-Agent string doesn't contain curl, GitHub seems to minify the  JSON response. I've basically fixed this by forcing the User-Agent to be curl, but maybe that's the wrong approach?
Here's the JSON response without curl in the header
 → TITANIC@firmware (elec_128_update_codegen_tooling) $ curl -s https://api.github.com/repos/uw-midsun/codegen-tooling/releases/latest

{""url"":""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/9722717"",""assets_url"":""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/9722717/assets"",""upload_url"":""https://uploads.github.com/repos/uw-midsun/codegen-tooling/releases/9722717/assets{?name,label}"",""html_url"":""https://github.com/uw-midsun/codegen-tooling/releases/tag/v0.0.6"",""id"":9722717,""tag_name"":""v0.0.6"",""target_commitish"":""master"",""name"":""Fix Motor Controls message field numbering in asciipb file"",""draft"":false,""author"":{""login"":""karlding"",""id"":6836385,""avatar_url"":""https://avatars2.githubusercontent.com/u/6836385?v=4"",""gravatar_id"":"""",""url"":""https://api.github.com/users/karlding"",""html_url"":""https://github.com/karlding"",""followers_url"":""https://api.github.com/users/karlding/followers"",""following_url"":""https://api.github.com/users/karlding/following{/other_user}"",""gists_url"":""https://api.github.com/users/karlding/gists{/gist_id}"",""starred_url"":""https://api.github.com/users/karlding/starred{/owner}{/repo}"",""subscriptions_url"":""https://api.github.com/users/karlding/subscriptions"",""organizations_url"":""https://api.github.com/users/karlding/orgs"",""repos_url"":""https://api.github.com/users/karlding/repos"",""events_url"":""https://api.github.com/users/karlding/events{/privacy}"",""received_events_url"":""https://api.github.com/users/karlding/received_events"",""type"":""User"",""site_admin"":false},""prerelease"":false,""created_at"":""2018-02-18T03:04:15Z"",""published_at"":""2018-02-18T03:08:10Z"",""assets"":[{""url"":""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/assets/6246507"",""id"":6246507,""name"":""codegen-tooling-out.zip"",""label"":null,""uploader"":{""login"":""karlding"",""id"":6836385,""avatar_url"":""https://avatars2.githubusercontent.com/u/6836385?v=4"",""gravatar_id"":"""",""url"":""https://api.github.com/users/karlding"",""html_url"":""https://github.com/karlding"",""followers_url"":""https://api.github.com/users/karlding/followers"",""following_url"":""https://api.github.com/users/karlding/following{/other_user}"",""gists_url"":""https://api.github.com/users/karlding/gists{/gist_id}"",""starred_url"":""https://api.github.com/users/karlding/starred{/owner}{/repo}"",""subscriptions_url"":""https://api.github.com/users/karlding/subscriptions"",""organizations_url"":""https://api.github.com/users/karlding/orgs"",""repos_url"":""https://api.github.com/users/karlding/repos"",""events_url"":""https://api.github.com/users/karlding/events{/privacy}"",""received_events_url"":""https://api.github.com/users/karlding/received_events"",""type"":""User"",""site_admin"":false},""content_type"":""application/zip"",""state"":""uploaded"",""size"":5896,""download_count"":18,""created_at"":""2018-02-18T03:13:01Z"",""updated_at"":""2018-02-18T03:13:02Z"",""browser_download_url"":""https://github.com/uw-midsun/codegen-tooling/releases/download/v0.0.6/codegen-tooling-out.zip""}],""tarball_url"":""https://api.github.com/repos/uw-midsun/codegen-tooling/tarball/v0.0.6"",""zipball_url"":""https://api.github.com/repos/uw-midsun/codegen-tooling/zipball/v0.0.6"",""body"":""""}

Here's the JSON response when adding curl to the header
 → TITANIC@firmware (elec_128_update_codegen_tooling) $ curl -A 'curl' -s https://api.github.com/repos/uw-midsun/codegen-tooling/releases/latest

{
  ""url"": ""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/9722717"",
  ""assets_url"": ""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/9722717/assets"",
  ""upload_url"": ""https://uploads.github.com/repos/uw-midsun/codegen-tooling/releases/9722717/assets{?name,label}"",
  ""html_url"": ""https://github.com/uw-midsun/codegen-tooling/releases/tag/v0.0.6"",
  ""id"": 9722717,
  ""tag_name"": ""v0.0.6"",
  ""target_commitish"": ""master"",
  ""name"": ""Fix Motor Controls message field numbering in asciipb file"",
  ""draft"": false,
  ""author"": {
    ""login"": ""karlding"",
    ""id"": 6836385,
    ""avatar_url"": ""https://avatars2.githubusercontent.com/u/6836385?v=4"",
    ""gravatar_id"": """",
    ""url"": ""https://api.github.com/users/karlding"",
    ""html_url"": ""https://github.com/karlding"",
    ""followers_url"": ""https://api.github.com/users/karlding/followers"",
    ""following_url"": ""https://api.github.com/users/karlding/following{/other_user}"",
    ""gists_url"": ""https://api.github.com/users/karlding/gists{/gist_id}"",
    ""starred_url"": ""https://api.github.com/users/karlding/starred{/owner}{/repo}"",
    ""subscriptions_url"": ""https://api.github.com/users/karlding/subscriptions"",
    ""organizations_url"": ""https://api.github.com/users/karlding/orgs"",
    ""repos_url"": ""https://api.github.com/users/karlding/repos"",
    ""events_url"": ""https://api.github.com/users/karlding/events{/privacy}"",
    ""received_events_url"": ""https://api.github.com/users/karlding/received_events"",
    ""type"": ""User"",
    ""site_admin"": false
  },
  ""prerelease"": false,
  ""created_at"": ""2018-02-18T03:04:15Z"",
  ""published_at"": ""2018-02-18T03:08:10Z"",
  ""assets"": [
    {
      ""url"": ""https://api.github.com/repos/uw-midsun/codegen-tooling/releases/assets/6246507"",
      ""id"": 6246507,
      ""name"": ""codegen-tooling-out.zip"",
      ""label"": null,
      ""uploader"": {
        ""login"": ""karlding"",
        ""id"": 6836385,
        ""avatar_url"": ""https://avatars2.githubusercontent.com/u/6836385?v=4"",
        ""gravatar_id"": """",
        ""url"": ""https://api.github.com/users/karlding"",
        ""html_url"": ""https://github.com/karlding"",
        ""followers_url"": ""https://api.github.com/users/karlding/followers"",
        ""following_url"": ""https://api.github.com/users/karlding/following{/other_user}"",
        ""gists_url"": ""https://api.github.com/users/karlding/gists{/gist_id}"",
        ""starred_url"": ""https://api.github.com/users/karlding/starred{/owner}{/repo}"",
        ""subscriptions_url"": ""https://api.github.com/users/karlding/subscriptions"",
        ""organizations_url"": ""https://api.github.com/users/karlding/orgs"",
        ""repos_url"": ""https://api.github.com/users/karlding/repos"",
        ""events_url"": ""https://api.github.com/users/karlding/events{/privacy}"",
        ""received_events_url"": ""https://api.github.com/users/karlding/received_events"",
        ""type"": ""User"",
        ""site_admin"": false
      },
      ""content_type"": ""application/zip"",
      ""state"": ""uploaded"",
      ""size"": 5896,
      ""download_count"": 18,
      ""created_at"": ""2018-02-18T03:13:01Z"",
      ""updated_at"": ""2018-02-18T03:13:02Z"",
      ""browser_download_url"": ""https://github.com/uw-midsun/codegen-tooling/releases/download/v0.0.6/codegen-tooling-out.zip""
    }
  ],
  ""tarball_url"": ""https://api.github.com/repos/uw-midsun/codegen-tooling/tarball/v0.0.6"",
  ""zipball_url"": ""https://api.github.com/repos/uw-midsun/codegen-tooling/zipball/v0.0.6"",
  ""body"": """"
}

Edit: You can probably change the curl and grep chain to be something like this
curl -s https://api.github.com/repos/uw-midsun/codegen-tooling/releases/latest | grep -Eo '""browser_download_url""\:.*codegen-tooling-out.zip""' | grep -Eo 'https://.*\.zip'
and then pipe that into wget","I agree with @tituschow moving away from sys/shell calls. We can also replace the sha256 sum call with hashlib.
This was mostly just a kludge to get this working. I would suggest refactoring but it shouldn't be a priority. For now let's just focus on getting the boards for the car working.
We should create a JIRA ticket though.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,135,2018-02-24T19:06:58Z,2018-02-24T19:13:17Z,2018-02-24T19:13:20Z,MERGED,True,28,8,5,https://github.com/ckitagawa,ELEC-105: Roll heartbeats for Chaos,1,[],https://github.com/uw-midsun/firmware/pull/135,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/135,Semi-automatic roll of codegen-tooling to update heartbeats for Chaos.,Semi-automatic roll of codegen-tooling to update heartbeats for Chaos.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,136,2018-03-05T20:07:32Z,2018-03-19T15:33:36Z,2018-03-19T15:34:37Z,CLOSED,False,486,53,10,https://github.com/a3farmah,ELEC-350: Throttle,35,[],https://github.com/uw-midsun/firmware/pull/136,https://github.com/a3farmah,1,https://github.com/uw-midsun/firmware/pull/136,"The throttle module for integrating pedal readings into driver controls.
I haven't created the tests yet. Also there is a need for a calibration routine for the pedal to set the thresholds for each of the zones(brake, coast, accelerate) which will be implemented soon!","The throttle module for integrating pedal readings into driver controls.
I haven't created the tests yet. Also there is a need for a calibration routine for the pedal to set the thresholds for each of the zones(brake, coast, accelerate) which will be implemented soon!",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,136,2018-03-05T20:07:32Z,2018-03-19T15:33:36Z,2018-03-19T15:34:37Z,CLOSED,False,486,53,10,https://github.com/a3farmah,ELEC-350: Throttle,35,[],https://github.com/uw-midsun/firmware/pull/136,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/136#issuecomment-373881625,"The throttle module for integrating pedal readings into driver controls.
I haven't created the tests yet. Also there is a need for a calibration routine for the pedal to set the thresholds for each of the zones(brake, coast, accelerate) which will be implemented soon!",I don't think you actually merged properly. Your PR is full of changes from master.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,137,2018-03-07T17:36:15Z,2018-03-15T20:41:42Z,2018-03-15T20:41:48Z,MERGED,True,161,52,5,https://github.com/a3farmah,ELEC-366: ADS1015 on x86,24,[],https://github.com/uw-midsun/firmware/pull/137,https://github.com/a3farmah,1,https://github.com/uw-midsun/firmware/pull/137,"This branch adds the source file for ADS1015 on x86 platform. The program imitates the interrupt on the ALERT/RDY Pin with the use of soft timers that periodically update the readings to some value(0) and call the channel callbacks.
Passed all the tests made for STM32.","This branch adds the source file for ADS1015 on x86 platform. The program imitates the interrupt on the ALERT/RDY Pin with the use of soft timers that periodically update the readings to some value(0) and call the channel callbacks.
Passed all the tests made for STM32.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,138,2018-03-10T22:51:46Z,2018-03-20T19:26:28Z,2018-06-11T07:48:01Z,CLOSED,False,1113,528,35,https://github.com/tituschow,ELEC-354: Driver Controls MVP/Cleanup,12,[],https://github.com/uw-midsun/firmware/pull/138,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/138,"This PR aims to clean up some of the harder to understand code and flesh out some details we missed.
I realize this is a massive PR so I might break this down into a series of PRs. The major changes:

Event arbiter has been reorganized and output data removed
CAN output has been disabled
Added cruise module
Added drive output module - outputs drive commands on CAN periodically in response to pedal FSM changes
Pedal FSM now handles cruise properly and has more robust testing
Moved FSMs into their own folder

Note that the build will not pass yet because there a bunch of TODOs.","This PR aims to clean up some of the harder to understand code and flesh out some details we missed.
I realize this is a massive PR so I might break this down into a series of PRs. The major changes:

Event arbiter has been reorganized and output data removed
CAN output has been disabled
Added cruise module
Added drive output module - outputs drive commands on CAN periodically in response to pedal FSM changes
Pedal FSM now handles cruise properly and has more robust testing
Moved FSMs into their own folder

Note that the build will not pass yet because there a bunch of TODOs.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,138,2018-03-10T22:51:46Z,2018-03-20T19:26:28Z,2018-06-11T07:48:01Z,CLOSED,False,1113,528,35,https://github.com/tituschow,ELEC-354: Driver Controls MVP/Cleanup,12,[],https://github.com/uw-midsun/firmware/pull/138,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/138#issuecomment-374726027,"This PR aims to clean up some of the harder to understand code and flesh out some details we missed.
I realize this is a massive PR so I might break this down into a series of PRs. The major changes:

Event arbiter has been reorganized and output data removed
CAN output has been disabled
Added cruise module
Added drive output module - outputs drive commands on CAN periodically in response to pedal FSM changes
Pedal FSM now handles cruise properly and has more robust testing
Moved FSMs into their own folder

Note that the build will not pass yet because there a bunch of TODOs.",Now out-of-date - closing,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,139,2018-03-11T01:53:09Z,2018-03-11T02:06:09Z,2018-03-11T02:06:12Z,MERGED,True,1,1,1,https://github.com/ckitagawa,ELEC-370: Fix issue with implict cast in flash.c,2,[],https://github.com/uw-midsun/firmware/pull/139,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/139,Trivial change but it broke clang-asan compiles.,Trivial change but it broke clang-asan compiles.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,140,2018-03-11T02:00:02Z,2018-03-26T23:54:15Z,2018-03-26T23:54:18Z,MERGED,True,724,0,15,https://github.com/ckitagawa,ELEC-355: Add generic can abstraction,23,[],https://github.com/uw-midsun/firmware/pull/140,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/140,"An abstraction of CAN using dynamic dispatch to provide an interchangeable interface between CAN (Network layer), CAN HW and CAN UART.
This could be moved to ms-helpers depending on if others would use it.","An abstraction of CAN using dynamic dispatch to provide an interchangeable interface between CAN (Network layer), CAN HW and CAN UART.
This could be moved to ms-helpers depending on if others would use it.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,140,2018-03-11T02:00:02Z,2018-03-26T23:54:15Z,2018-03-26T23:54:18Z,MERGED,True,724,0,15,https://github.com/ckitagawa,ELEC-355: Add generic can abstraction,23,[],https://github.com/uw-midsun/firmware/pull/140,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/140#issuecomment-373585531,"An abstraction of CAN using dynamic dispatch to provide an interchangeable interface between CAN (Network layer), CAN HW and CAN UART.
This could be moved to ms-helpers depending on if others would use it.",I'll work on cleaning this up for Saturday.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,140,2018-03-11T02:00:02Z,2018-03-26T23:54:15Z,2018-03-26T23:54:18Z,MERGED,True,724,0,15,https://github.com/ckitagawa,ELEC-355: Add generic can abstraction,23,[],https://github.com/uw-midsun/firmware/pull/140,https://github.com/ckitagawa,3,https://github.com/uw-midsun/firmware/pull/140#issuecomment-375897662,"An abstraction of CAN using dynamic dispatch to provide an interchangeable interface between CAN (Network layer), CAN HW and CAN UART.
This could be moved to ms-helpers depending on if others would use it.","As per offline discussion:

generic_can_network will live only in projects/charger everything else will be move to ms-helper
I've refactored everything as per your comments. LMK if there is anything else that needs changing.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,140,2018-03-11T02:00:02Z,2018-03-26T23:54:15Z,2018-03-26T23:54:18Z,MERGED,True,724,0,15,https://github.com/ckitagawa,ELEC-355: Add generic can abstraction,23,[],https://github.com/uw-midsun/firmware/pull/140,https://github.com/ckitagawa,4,https://github.com/uw-midsun/firmware/pull/140#issuecomment-375977969,"An abstraction of CAN using dynamic dispatch to provide an interchangeable interface between CAN (Network layer), CAN HW and CAN UART.
This could be moved to ms-helpers depending on if others would use it.",@tituschow  I'll merge with master by end of day if there are no further concerns.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,141,2018-03-11T02:03:33Z,2018-03-16T02:23:43Z,2018-03-16T02:23:46Z,MERGED,True,143,0,7,https://github.com/ckitagawa,ELEC-355: Charger Connection Pin,6,[],https://github.com/uw-midsun/firmware/pull/141,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/141,A interrupt driven GPIO pin for detecting if a charger is attached to the car.,A interrupt driven GPIO pin for detecting if a charger is attached to the car.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,142,2018-03-11T02:12:17Z,2018-05-18T02:51:20Z,2018-09-16T18:19:54Z,CLOSED,False,2264,0,34,https://github.com/ckitagawa,ELEC-355: Complete Charger Code (For reference only when reviewing child PRs),7,[],https://github.com/uw-midsun/firmware/pull/142,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/142,"This is to give an idea of the overall design of the charger for reference if necessary when reviewing any of the child PRs that this spawns.
DO NOT BOTHER REVIEWING THIS AS ONE PR! REVIEW THE CHILD PRs INSTEAD!","This is to give an idea of the overall design of the charger for reference if necessary when reviewing any of the child PRs that this spawns.
DO NOT BOTHER REVIEWING THIS AS ONE PR! REVIEW THE CHILD PRs INSTEAD!",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,142,2018-03-11T02:12:17Z,2018-05-18T02:51:20Z,2018-09-16T18:19:54Z,CLOSED,False,2264,0,34,https://github.com/ckitagawa,ELEC-355: Complete Charger Code (For reference only when reviewing child PRs),7,[],https://github.com/uw-midsun/firmware/pull/142,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/142#issuecomment-390078811,"This is to give an idea of the overall design of the charger for reference if necessary when reviewing any of the child PRs that this spawns.
DO NOT BOTHER REVIEWING THIS AS ONE PR! REVIEW THE CHILD PRs INSTEAD!",This is 90% merged and the rest is up for review so I'm closing it.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,143,2018-03-11T02:23:34Z,2018-03-20T19:26:05Z,2018-03-20T19:26:11Z,MERGED,True,178,862,25,https://github.com/tituschow,ELEC-354: Event Arbiter,13,[],https://github.com/uw-midsun/firmware/pull/143,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/143,"Cleanup of the event arbiter - removes data output from FSMs, removed driver FSM and CAN output tests for now.
Note that the only real changes that needs to be reviewed are in (test_)?event_arbiter.[ch]
See #138 for context.","Cleanup of the event arbiter - removes data output from FSMs, removed driver FSM and CAN output tests for now.
Note that the only real changes that needs to be reviewed are in (test_)?event_arbiter.[ch]
See #138 for context.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,143,2018-03-11T02:23:34Z,2018-03-20T19:26:05Z,2018-03-20T19:26:11Z,MERGED,True,178,862,25,https://github.com/tituschow,ELEC-354: Event Arbiter,13,[],https://github.com/uw-midsun/firmware/pull/143,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/143#issuecomment-373956427,"Cleanup of the event arbiter - removes data output from FSMs, removed driver FSM and CAN output tests for now.
Note that the only real changes that needs to be reviewed are in (test_)?event_arbiter.[ch]
See #138 for context.",@ckitagawa @karlding Do you guys mind double-checking the new naming scheme and see if it makes sense?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,144,2018-03-11T02:35:42Z,2018-03-17T21:19:35Z,2018-03-17T21:19:42Z,MERGED,True,216,0,3,https://github.com/tituschow,ELEC-354: Drive output module,3,[],https://github.com/uw-midsun/firmware/pull/144,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/144,"The intention of this module is to provide periodic drive commands over CAN safely. The idea is that there is a watchdog built into the module that requires the data to be updated frequently.
Currently, it's updated mainly through the pedal FSM. See #138 for more context.","The intention of this module is to provide periodic drive commands over CAN safely. The idea is that there is a watchdog built into the module that requires the data to be updated frequently.
Currently, it's updated mainly through the pedal FSM. See #138 for more context.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,145,2018-03-14T01:55:58Z,2018-05-26T19:31:41Z,2018-05-26T19:31:48Z,CLOSED,False,383,0,8,https://github.com/ArshanKhanifar,ELEC-372: Lights CAN.,13,['enhancement'],https://github.com/uw-midsun/firmware/pull/145,https://github.com/ArshanKhanifar,1,https://github.com/uw-midsun/firmware/pull/145,"lights_can module handles receiving and sending messages through the can network. It then raises Events which will be processed later by the other modules in lights control board.
It's responsibilities:

The module knows whether it's at the front board or at the back board.
Receive can messages.
Raise events based on those messages.
The only occasion where it sends a can message is a sync signal to the other board.","lights_can module handles receiving and sending messages through the can network. It then raises Events which will be processed later by the other modules in lights control board.
It's responsibilities:

The module knows whether it's at the front board or at the back board.
Receive can messages.
Raise events based on those messages.
The only occasion where it sends a can message is a sync signal to the other board.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,145,2018-03-14T01:55:58Z,2018-05-26T19:31:41Z,2018-05-26T19:31:48Z,CLOSED,False,383,0,8,https://github.com/ArshanKhanifar,ELEC-372: Lights CAN.,13,['enhancement'],https://github.com/uw-midsun/firmware/pull/145,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/145#issuecomment-373604186,"lights_can module handles receiving and sending messages through the can network. It then raises Events which will be processed later by the other modules in lights control board.
It's responsibilities:

The module knows whether it's at the front board or at the back board.
Receive can messages.
Raise events based on those messages.
The only occasion where it sends a can message is a sync signal to the other board.","I've already mentioned this, but you need to fix your naming scheme so it meets the style guide requirements.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,145,2018-03-14T01:55:58Z,2018-05-26T19:31:41Z,2018-05-26T19:31:48Z,CLOSED,False,383,0,8,https://github.com/ArshanKhanifar,ELEC-372: Lights CAN.,13,['enhancement'],https://github.com/uw-midsun/firmware/pull/145,https://github.com/ArshanKhanifar,3,https://github.com/uw-midsun/firmware/pull/145#issuecomment-374069595,"lights_can module handles receiving and sending messages through the can network. It then raises Events which will be processed later by the other modules in lights control board.
It's responsibilities:

The module knows whether it's at the front board or at the back board.
Receive can messages.
Raise events based on those messages.
The only occasion where it sends a can message is a sync signal to the other board.","I renamed all previous commits to follow our commit naming style, that's why they're all appearing after the reviews. I'm getting started with the next module, lights_gpio. Next module isn't that dependent on this one so I won't have much problem managing two pull requests at the same time. Thanks so much for all the feed back so far! I've learned a lot.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,145,2018-03-14T01:55:58Z,2018-05-26T19:31:41Z,2018-05-26T19:31:48Z,CLOSED,False,383,0,8,https://github.com/ArshanKhanifar,ELEC-372: Lights CAN.,13,['enhancement'],https://github.com/uw-midsun/firmware/pull/145,https://github.com/ArshanKhanifar,4,https://github.com/uw-midsun/firmware/pull/145#issuecomment-375125194,"lights_can module handles receiving and sending messages through the can network. It then raises Events which will be processed later by the other modules in lights control board.
It's responsibilities:

The module knows whether it's at the front board or at the back board.
Receive can messages.
Raise events based on those messages.
The only occasion where it sends a can message is a sync signal to the other board.",Merged with master to have the updated version of our codegen-tooling.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,145,2018-03-14T01:55:58Z,2018-05-26T19:31:41Z,2018-05-26T19:31:48Z,CLOSED,False,383,0,8,https://github.com/ArshanKhanifar,ELEC-372: Lights CAN.,13,['enhancement'],https://github.com/uw-midsun/firmware/pull/145,https://github.com/ArshanKhanifar,5,https://github.com/uw-midsun/firmware/pull/145#issuecomment-389252593,"lights_can module handles receiving and sending messages through the can network. It then raises Events which will be processed later by the other modules in lights control board.
It's responsibilities:

The module knows whether it's at the front board or at the back board.
Receive can messages.
Raise events based on those messages.
The only occasion where it sends a can message is a sync signal to the other board.","I've updated this module according to the new event model we have. Sorry for double ELEC-372: prefixes in the commits, I just realized our commits are automated too (cool!).
Please take a look at this whenever you get the time. Thanks.
@tituschow @ckitagawa",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,146,2018-03-16T03:03:47Z,2018-03-24T22:34:06Z,2018-03-24T22:34:11Z,CLOSED,False,26,0,1,https://github.com/ckitagawa,ELEC-337: Fast Soft Timer LLL Fix,1,[],https://github.com/uw-midsun/firmware/pull/146,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/146,"WIP: Don't review.
Initially this PR is just to try to repro the issue in ELEC-337 on Travis since it doesn't occur on my machine. Once I have a repro I can actually verify a fix. Failing to repro on Travis I'll have to try on someone else's machine.
The suspected solution is to move the mutex unlock in x86/critical_section.c forward but this is just speculation at this point.","WIP: Don't review.
Initially this PR is just to try to repro the issue in ELEC-337 on Travis since it doesn't occur on my machine. Once I have a repro I can actually verify a fix. Failing to repro on Travis I'll have to try on someone else's machine.
The suspected solution is to move the mutex unlock in x86/critical_section.c forward but this is just speculation at this point.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,146,2018-03-16T03:03:47Z,2018-03-24T22:34:06Z,2018-03-24T22:34:11Z,CLOSED,False,26,0,1,https://github.com/ckitagawa,ELEC-337: Fast Soft Timer LLL Fix,1,[],https://github.com/uw-midsun/firmware/pull/146,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/146#issuecomment-373589749,"WIP: Don't review.
Initially this PR is just to try to repro the issue in ELEC-337 on Travis since it doesn't occur on my machine. Once I have a repro I can actually verify a fix. Failing to repro on Travis I'll have to try on someone else's machine.
The suspected solution is to move the mutex unlock in x86/critical_section.c forward but this is just speculation at this point.","You can just comment out
branches:
  only:
    - master

in .travis.yml and it'll build your branch without being a PR",True,{'THUMBS_UP': ['https://github.com/ckitagawa']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,147,2018-03-17T15:59:06Z,2018-03-17T17:59:45Z,2018-03-17T17:59:49Z,MERGED,True,14,14,7,https://github.com/ckitagawa,ELEC-40: Disable Derive Pointer Alignment and Reformat all Files,1,[],https://github.com/uw-midsun/firmware/pull/147,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/147,DerivePointerAlignment: false so that we use right aligned pointer always.,DerivePointerAlignment: false so that we use right aligned pointer always.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,147,2018-03-17T15:59:06Z,2018-03-17T17:59:45Z,2018-03-17T17:59:49Z,MERGED,True,14,14,7,https://github.com/ckitagawa,ELEC-40: Disable Derive Pointer Alignment and Reformat all Files,1,[],https://github.com/uw-midsun/firmware/pull/147,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/147#issuecomment-373931075,DerivePointerAlignment: false so that we use right aligned pointer always.,Most of the violations are in files I wrote XD,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,148,2018-03-17T22:53:58Z,2018-05-20T19:20:41Z,2018-05-20T19:23:43Z,CLOSED,False,6565,1911,140,https://github.com/thomaskidd,ELEC-346: x86 UART,38,[],https://github.com/uw-midsun/firmware/pull/148,https://github.com/thomaskidd,1,https://github.com/uw-midsun/firmware/pull/148,"Only the two files mentioned below need to be merged. There are brief comments in the x86 uart.c file which identify the null modem emulator (tty0tty) needed to create the virtual serial ports and the necessary commands to run on startup of vagrant. Let me know if a more comprehensive readme file is needed. tty0tty can be cloned from: https://github.com/freemed/tty0tty
libraries/ms-common/src/x86/uart.c
libraries/ms-common/inc/uart.h","Only the two files mentioned below need to be merged. There are brief comments in the x86 uart.c file which identify the null modem emulator (tty0tty) needed to create the virtual serial ports and the necessary commands to run on startup of vagrant. Let me know if a more comprehensive readme file is needed. tty0tty can be cloned from: https://github.com/freemed/tty0tty
libraries/ms-common/src/x86/uart.c
libraries/ms-common/inc/uart.h",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,148,2018-03-17T22:53:58Z,2018-05-20T19:20:41Z,2018-05-20T19:23:43Z,CLOSED,False,6565,1911,140,https://github.com/thomaskidd,ELEC-346: x86 UART,38,[],https://github.com/uw-midsun/firmware/pull/148,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/148#issuecomment-373961807,"Only the two files mentioned below need to be merged. There are brief comments in the x86 uart.c file which identify the null modem emulator (tty0tty) needed to create the virtual serial ports and the necessary commands to run on startup of vagrant. Let me know if a more comprehensive readme file is needed. tty0tty can be cloned from: https://github.com/freemed/tty0tty
libraries/ms-common/src/x86/uart.c
libraries/ms-common/inc/uart.h","Is there a reason you're using tty0tty? We'd prefer not to pull in external dependencies. I think you could just use TCP or sockets instead.
Also, if you have files that shouldn't be merged, please remove them.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,148,2018-03-17T22:53:58Z,2018-05-20T19:20:41Z,2018-05-20T19:23:43Z,CLOSED,False,6565,1911,140,https://github.com/thomaskidd,ELEC-346: x86 UART,38,[],https://github.com/uw-midsun/firmware/pull/148,https://github.com/thomaskidd,3,https://github.com/uw-midsun/firmware/pull/148#issuecomment-373963206,"Only the two files mentioned below need to be merged. There are brief comments in the x86 uart.c file which identify the null modem emulator (tty0tty) needed to create the virtual serial ports and the necessary commands to run on startup of vagrant. Let me know if a more comprehensive readme file is needed. tty0tty can be cloned from: https://github.com/freemed/tty0tty
libraries/ms-common/src/x86/uart.c
libraries/ms-common/inc/uart.h",After looking into serial emulation on linux I found that tty0tty was by far the most implemented solution for linking two virtual serial ports. And since we have the c source code it is feasible to maintain it. But I understand why uwmidsun wouldn't want to rely on external dependencies so I will look into alternate solutions,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,148,2018-03-17T22:53:58Z,2018-05-20T19:20:41Z,2018-05-20T19:23:43Z,CLOSED,False,6565,1911,140,https://github.com/thomaskidd,ELEC-346: x86 UART,38,[],https://github.com/uw-midsun/firmware/pull/148,https://github.com/tituschow,4,https://github.com/uw-midsun/firmware/pull/148#issuecomment-373965700,"Only the two files mentioned below need to be merged. There are brief comments in the x86 uart.c file which identify the null modem emulator (tty0tty) needed to create the virtual serial ports and the necessary commands to run on startup of vagrant. Let me know if a more comprehensive readme file is needed. tty0tty can be cloned from: https://github.com/freemed/tty0tty
libraries/ms-common/src/x86/uart.c
libraries/ms-common/inc/uart.h","You don't need to overthink it. We don't actually need full serial emulation. We just want the ability to pass information between programs through our UART interface. For example, between two instances of the same program, two different programs, or a python script and a program.
This solution (which is not common - most people just use socat or something similar) requires building and install a kernel module.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,148,2018-03-17T22:53:58Z,2018-05-20T19:20:41Z,2018-05-20T19:23:43Z,CLOSED,False,6565,1911,140,https://github.com/thomaskidd,ELEC-346: x86 UART,38,[],https://github.com/uw-midsun/firmware/pull/148,https://github.com/tituschow,5,https://github.com/uw-midsun/firmware/pull/148#issuecomment-386186444,"Only the two files mentioned below need to be merged. There are brief comments in the x86 uart.c file which identify the null modem emulator (tty0tty) needed to create the virtual serial ports and the necessary commands to run on startup of vagrant. Let me know if a more comprehensive readme file is needed. tty0tty can be cloned from: https://github.com/freemed/tty0tty
libraries/ms-common/src/x86/uart.c
libraries/ms-common/inc/uart.h",Please update this to use the new socket framework. (See x86_socket.h),True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,148,2018-03-17T22:53:58Z,2018-05-20T19:20:41Z,2018-05-20T19:23:43Z,CLOSED,False,6565,1911,140,https://github.com/thomaskidd,ELEC-346: x86 UART,38,[],https://github.com/uw-midsun/firmware/pull/148,https://github.com/tituschow,6,https://github.com/uw-midsun/firmware/pull/148#issuecomment-390093610,"Only the two files mentioned below need to be merged. There are brief comments in the x86 uart.c file which identify the null modem emulator (tty0tty) needed to create the virtual serial ports and the necessary commands to run on startup of vagrant. Let me know if a more comprehensive readme file is needed. tty0tty can be cloned from: https://github.com/freemed/tty0tty
libraries/ms-common/src/x86/uart.c
libraries/ms-common/inc/uart.h","I don't think you merged master properly. It still seems to be out-of-date and you apparently have over 7000 lines of changes.
Since your implementation has changed drastically, do you mind moving your changes to a new branch based on master and opening a new PR with an updated description? It'll be easier to review since we don't need to sort through all the old comments and commits.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,148,2018-03-17T22:53:58Z,2018-05-20T19:20:41Z,2018-05-20T19:23:43Z,CLOSED,False,6565,1911,140,https://github.com/thomaskidd,ELEC-346: x86 UART,38,[],https://github.com/uw-midsun/firmware/pull/148,https://github.com/thomaskidd,7,https://github.com/uw-midsun/firmware/pull/148#issuecomment-390347225,"Only the two files mentioned below need to be merged. There are brief comments in the x86 uart.c file which identify the null modem emulator (tty0tty) needed to create the virtual serial ports and the necessary commands to run on startup of vagrant. Let me know if a more comprehensive readme file is needed. tty0tty can be cloned from: https://github.com/freemed/tty0tty
libraries/ms-common/src/x86/uart.c
libraries/ms-common/inc/uart.h","Yeah, no problem.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,149,2018-03-19T16:20:41Z,2018-04-03T23:01:41Z,2018-04-03T23:01:53Z,MERGED,True,608,86,10,https://github.com/a3farmah,ELEC-350: Throttle,28,[],https://github.com/uw-midsun/firmware/pull/149,https://github.com/a3farmah,1,https://github.com/uw-midsun/firmware/pull/149,"Module for throttle (Remade the branch).
This branch supports the integration of the pedal inputs (ADS1015 readings) into driver controls (mainly raising events for brake, coast, accelerate states).
The testing is not very useful at this point since the calibration routine for the pedal hasn't been implemented yet.","Module for throttle (Remade the branch).
This branch supports the integration of the pedal inputs (ADS1015 readings) into driver controls (mainly raising events for brake, coast, accelerate states).
The testing is not very useful at this point since the calibration routine for the pedal hasn't been implemented yet.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,150,2018-03-20T18:48:24Z,2018-03-20T18:54:57Z,2018-03-20T18:56:18Z,MERGED,True,34,31,5,https://github.com/karlding,ELEC-338: Roll forward codegen-tooling,1,[],https://github.com/uw-midsun/firmware/pull/150,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/150,Roll forward codegen-tooling to pick up Motor Controller message changes.,Roll forward codegen-tooling to pick up Motor Controller message changes.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,150,2018-03-20T18:48:24Z,2018-03-20T18:54:57Z,2018-03-20T18:56:18Z,MERGED,True,34,31,5,https://github.com/karlding,ELEC-338: Roll forward codegen-tooling,1,[],https://github.com/uw-midsun/firmware/pull/150,https://github.com/karlding,2,https://github.com/uw-midsun/firmware/pull/150#issuecomment-374714562,Roll forward codegen-tooling to pick up Motor Controller message changes.,"Also noticed that our git fetch script breaks when I have the following set in my ~/.wgetrc
# Use the server-provided last modification date, if available
timestamping = on

# Do not go up in the directory structure when downloading recursively
no_parent = on

# Wait 60 seconds before timing out. This applies to all timeouts: DNS, connect and read. (The default read timeout is 15 minutes!)
timeout = 60

# Retry a few times when a download fails, but don’t overdo it. (The default is 20!)
tries = 3

# Retry even when the connection was refused
retry_connrefused = on

# Use the last component of a redirection URL for the local file name
trust_server_names = on

# Follow FTP links from HTML documents by default
follow_ftp = on

# Add a `.html` extension to `text/html` or `application/xhtml+xml` files that lack one, or a `.css` extension to `text/css` files that lack one
adjust_extension = on

# Use UTF-8 as the default system encoding
# Disabled as it makes `wget` builds that don’t support this feature unusable.
# Does anyone know how to conditionally configure a wget setting?
# http://unix.stackexchange.com/q/34730/6040
#local_encoding = UTF-8

# Ignore `robots.txt` and `<meta name=robots content=nofollow>`
robots = off

# Print the HTTP and FTP server responses
server_response = on

# Disguise as IE 9 on Windows 7
user_agent = Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)

I'm assuming the issue is the user_agent string",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,150,2018-03-20T18:48:24Z,2018-03-20T18:54:57Z,2018-03-20T18:56:18Z,MERGED,True,34,31,5,https://github.com/karlding,ELEC-338: Roll forward codegen-tooling,1,[],https://github.com/uw-midsun/firmware/pull/150,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/150#issuecomment-374715087,Roll forward codegen-tooling to pick up Motor Controller message changes.,I thought we added something to fix that before?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,150,2018-03-20T18:48:24Z,2018-03-20T18:54:57Z,2018-03-20T18:56:18Z,MERGED,True,34,31,5,https://github.com/karlding,ELEC-338: Roll forward codegen-tooling,1,[],https://github.com/uw-midsun/firmware/pull/150,https://github.com/karlding,4,https://github.com/uw-midsun/firmware/pull/150#issuecomment-374715367,Roll forward codegen-tooling to pick up Motor Controller message changes.,"That was for the curl request to fetch the artifact URL, but we make a separate wget request to download
    popen = subprocess.Popen(
        [
            'curl -A ""curl"" -s {}{} | grep ""{}"" | cut -d : -f 2,3 |tr -d \\"" | wget -qi -'.
            format(url, tag, output_file)
        ],
        shell=True,
        stderr=subprocess.PIPE,
        stdout=subprocess.PIPE)
    _, err = popen.communicate()
    return err```",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,151,2018-03-21T01:30:13Z,2018-03-24T17:21:44Z,2018-03-24T17:22:04Z,MERGED,True,41,7,6,https://github.com/tituschow,ELEC-378: Support mocking in tests,5,[],https://github.com/uw-midsun/firmware/pull/151,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/151,"Adds support for test-specific mocking through the use of GCC's -Wl,wrap with an example. Also fixes x86 flash locations for test_all.
The idea is that $(T)_test_[module]_MOCKS := [func names] can be used to wrap specific functions that need to be mocked, and TEST_MOCK wraps the mocked function name. I wanted to add this for validating modules that depend mostly on external hardware. Mocking would allow us to inject arbitrary data and failure conditions without modifying the hardware module itself.","Adds support for test-specific mocking through the use of GCC's -Wl,wrap with an example. Also fixes x86 flash locations for test_all.
The idea is that $(T)_test_[module]_MOCKS := [func names] can be used to wrap specific functions that need to be mocked, and TEST_MOCK wraps the mocked function name. I wanted to add this for validating modules that depend mostly on external hardware. Mocking would allow us to inject arbitrary data and failure conditions without modifying the hardware module itself.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,152,2018-03-22T00:19:37Z,2018-04-07T23:46:35Z,2018-09-14T03:20:31Z,CLOSED,False,151,0,6,https://github.com/ArshanKhanifar,ELEC-373: lights simple peripherals,4,[],https://github.com/uw-midsun/firmware/pull/152,https://github.com/ArshanKhanifar,1,https://github.com/uw-midsun/firmware/pull/152,"Hey guys,
This is the lights_simple_peripherals module:
Definition: A simple peripheral is defined as any peripheral that has one of on or off states, and doesn't do any blinking or any other complex functionality like that.
Therefore these can be classified as simple peripherals:

High Beams
Low Beams
DRL
Horn
Brake Lights

The callback passed into this module as the init function's argument, has the same interface as lights_gpio_set function in the lights_gpio module which I will make in a future ticket.","Hey guys,
This is the lights_simple_peripherals module:
Definition: A simple peripheral is defined as any peripheral that has one of on or off states, and doesn't do any blinking or any other complex functionality like that.
Therefore these can be classified as simple peripherals:

High Beams
Low Beams
DRL
Horn
Brake Lights

The callback passed into this module as the init function's argument, has the same interface as lights_gpio_set function in the lights_gpio module which I will make in a future ticket.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,152,2018-03-22T00:19:37Z,2018-04-07T23:46:35Z,2018-09-14T03:20:31Z,CLOSED,False,151,0,6,https://github.com/ArshanKhanifar,ELEC-373: lights simple peripherals,4,[],https://github.com/uw-midsun/firmware/pull/152,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/152#issuecomment-375898044,"Hey guys,
This is the lights_simple_peripherals module:
Definition: A simple peripheral is defined as any peripheral that has one of on or off states, and doesn't do any blinking or any other complex functionality like that.
Therefore these can be classified as simple peripherals:

High Beams
Low Beams
DRL
Horn
Brake Lights

The callback passed into this module as the init function's argument, has the same interface as lights_gpio_set function in the lights_gpio module which I will make in a future ticket.",Looks good but I'm a bit confused since this module on its own doesn't really do anything. Why inject a handler rather than just programming directly in this module? Is the intention that front and rear lights have different sets of handlers?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,152,2018-03-22T00:19:37Z,2018-04-07T23:46:35Z,2018-09-14T03:20:31Z,CLOSED,False,151,0,6,https://github.com/ArshanKhanifar,ELEC-373: lights simple peripherals,4,[],https://github.com/uw-midsun/firmware/pull/152,https://github.com/ArshanKhanifar,3,https://github.com/uw-midsun/firmware/pull/152#issuecomment-377709045,"Hey guys,
This is the lights_simple_peripherals module:
Definition: A simple peripheral is defined as any peripheral that has one of on or off states, and doesn't do any blinking or any other complex functionality like that.
Therefore these can be classified as simple peripherals:

High Beams
Low Beams
DRL
Horn
Brake Lights

The callback passed into this module as the init function's argument, has the same interface as lights_gpio_set function in the lights_gpio module which I will make in a future ticket.","@ckitagawa That's mainly for testability. I could've directly put a call to lights_gpio_set() function here, but:

lights_gpio wasn't ready when I was making this module,
Testing it would be dependent on the presence of lights_gpio module. In a unit test, I'd have to first call lights_simple_peripherals_process_event, then read gpio states of the corresponding addresses to assert that this module is working... That sounds more like an end-to-end test for both this module and lights_gpio, rather than a unit test for this module only...",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,152,2018-03-22T00:19:37Z,2018-04-07T23:46:35Z,2018-09-14T03:20:31Z,CLOSED,False,151,0,6,https://github.com/ArshanKhanifar,ELEC-373: lights simple peripherals,4,[],https://github.com/uw-midsun/firmware/pull/152,https://github.com/tituschow,4,https://github.com/uw-midsun/firmware/pull/152#issuecomment-378369465,"Hey guys,
This is the lights_simple_peripherals module:
Definition: A simple peripheral is defined as any peripheral that has one of on or off states, and doesn't do any blinking or any other complex functionality like that.
Therefore these can be classified as simple peripherals:

High Beams
Low Beams
DRL
Horn
Brake Lights

The callback passed into this module as the init function's argument, has the same interface as lights_gpio_set function in the lights_gpio module which I will make in a future ticket.",Is this still necessary?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,152,2018-03-22T00:19:37Z,2018-04-07T23:46:35Z,2018-09-14T03:20:31Z,CLOSED,False,151,0,6,https://github.com/ArshanKhanifar,ELEC-373: lights simple peripherals,4,[],https://github.com/uw-midsun/firmware/pull/152,https://github.com/ArshanKhanifar,5,https://github.com/uw-midsun/firmware/pull/152#issuecomment-379502844,"Hey guys,
This is the lights_simple_peripherals module:
Definition: A simple peripheral is defined as any peripheral that has one of on or off states, and doesn't do any blinking or any other complex functionality like that.
Therefore these can be classified as simple peripherals:

High Beams
Low Beams
DRL
Horn
Brake Lights

The callback passed into this module as the init function's argument, has the same interface as lights_gpio_set function in the lights_gpio module which I will make in a future ticket.","well yeah, it handles all the simple peripherals as opposed to more complex peripherals which need blinking, switching states, etc.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,153,2018-03-24T15:40:55Z,2018-03-24T16:43:53Z,2018-03-24T16:44:01Z,MERGED,True,3,3,3,https://github.com/ckitagawa,ELEC-40: Fix Clang -Wsign-conversion errors,1,[],https://github.com/uw-midsun/firmware/pull/153,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/153,Did a make reallyclean make build_all PLATFORM=x86 COMPILER=clang and found a few trivial cast errors that needed fixing.,Did a make reallyclean make build_all PLATFORM=x86 COMPILER=clang and found a few trivial cast errors that needed fixing.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,154,2018-03-24T16:30:56Z,2018-05-18T06:59:12Z,2018-05-18T06:59:19Z,MERGED,True,601,0,12,https://github.com/ArshanKhanifar,ELEC-376: Lights GPIO,18,[],https://github.com/uw-midsun/firmware/pull/154,https://github.com/ArshanKhanifar,1,https://github.com/uw-midsun/firmware/pull/154,"Hey y'all!
This is the lights_gpio module, it basically initializes all the gpio pins and ports, and provides interface to set them.
Since I wanted only this module to deal with gpio stuff, it will also provide information about which board we're using (front of back), because I had to figure that out reading a gpio pin 😛
It's missing unit tests which I'll provide. But since the module is kinda big, I just thought I'd put it here for now and get roasted a bit, and start working on revisions as I make the unit tests.
Thanks ❤️","Hey y'all!
This is the lights_gpio module, it basically initializes all the gpio pins and ports, and provides interface to set them.
Since I wanted only this module to deal with gpio stuff, it will also provide information about which board we're using (front of back), because I had to figure that out reading a gpio pin 😛
It's missing unit tests which I'll provide. But since the module is kinda big, I just thought I'd put it here for now and get roasted a bit, and start working on revisions as I make the unit tests.
Thanks ❤️",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,154,2018-03-24T16:30:56Z,2018-05-18T06:59:12Z,2018-05-18T06:59:19Z,MERGED,True,601,0,12,https://github.com/ArshanKhanifar,ELEC-376: Lights GPIO,18,[],https://github.com/uw-midsun/firmware/pull/154,https://github.com/ArshanKhanifar,2,https://github.com/uw-midsun/firmware/pull/154#issuecomment-377705743,"Hey y'all!
This is the lights_gpio module, it basically initializes all the gpio pins and ports, and provides interface to set them.
Since I wanted only this module to deal with gpio stuff, it will also provide information about which board we're using (front of back), because I had to figure that out reading a gpio pin 😛
It's missing unit tests which I'll provide. But since the module is kinda big, I just thought I'd put it here for now and get roasted a bit, and start working on revisions as I make the unit tests.
Thanks ❤️","Tests have been added, thanks @tituschow for the suggestion on bitsets! I'd never worked with them but they're cool! lights_events.h has changed, and I'll need to update other PRs with that as well.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,154,2018-03-24T16:30:56Z,2018-05-18T06:59:12Z,2018-05-18T06:59:19Z,MERGED,True,601,0,12,https://github.com/ArshanKhanifar,ELEC-376: Lights GPIO,18,[],https://github.com/uw-midsun/firmware/pull/154,https://github.com/ArshanKhanifar,3,https://github.com/uw-midsun/firmware/pull/154#issuecomment-378266626,"Hey y'all!
This is the lights_gpio module, it basically initializes all the gpio pins and ports, and provides interface to set them.
Since I wanted only this module to deal with gpio stuff, it will also provide information about which board we're using (front of back), because I had to figure that out reading a gpio pin 😛
It's missing unit tests which I'll provide. But since the module is kinda big, I just thought I'd put it here for now and get roasted a bit, and start working on revisions as I make the unit tests.
Thanks ❤️","Do I need to write tests for lights_config module as well? Previously it was only returning a pointer, but now it has one small functionality and that is reading the gpio pin for board type.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,154,2018-03-24T16:30:56Z,2018-05-18T06:59:12Z,2018-05-18T06:59:19Z,MERGED,True,601,0,12,https://github.com/ArshanKhanifar,ELEC-376: Lights GPIO,18,[],https://github.com/uw-midsun/firmware/pull/154,https://github.com/ArshanKhanifar,4,https://github.com/uw-midsun/firmware/pull/154#issuecomment-378269426,"Hey y'all!
This is the lights_gpio module, it basically initializes all the gpio pins and ports, and provides interface to set them.
Since I wanted only this module to deal with gpio stuff, it will also provide information about which board we're using (front of back), because I had to figure that out reading a gpio pin 😛
It's missing unit tests which I'll provide. But since the module is kinda big, I just thought I'd put it here for now and get roasted a bit, and start working on revisions as I make the unit tests.
Thanks ❤️","I hope I covered all of the problems mentioned. The whole thing became much simpler after I moved the addresses and event mapping bitsets and board detection to lights_config module, and have the functions take a config blob. I'm going to get started with handling signals with the hope that this PR wouldn't need massive amounts of changes from this point on :)",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,154,2018-03-24T16:30:56Z,2018-05-18T06:59:12Z,2018-05-18T06:59:19Z,MERGED,True,601,0,12,https://github.com/ArshanKhanifar,ELEC-376: Lights GPIO,18,[],https://github.com/uw-midsun/firmware/pull/154,https://github.com/ArshanKhanifar,5,https://github.com/uw-midsun/firmware/pull/154#issuecomment-387867477,"Hey y'all!
This is the lights_gpio module, it basically initializes all the gpio pins and ports, and provides interface to set them.
Since I wanted only this module to deal with gpio stuff, it will also provide information about which board we're using (front of back), because I had to figure that out reading a gpio pin 😛
It's missing unit tests which I'll provide. But since the module is kinda big, I just thought I'd put it here for now and get roasted a bit, and start working on revisions as I make the unit tests.
Thanks ❤️","I think there's an inconsistency between clang-format and linter we're using. Let's say I have this:
static const LightsGPIOPeripheral s_front_peripherals[] = {
  [LIGHTS_GPIO_CONFIG_FRONT_PERIPHERAL_HORN] = {
    .address = { .port = GPIO_PORT_B, .pin = 11 },
    .polarity = LIGHTS_GPIO_POLARITY_ACTIVE_LOW,
  },
  //
}

clang-format changes it to this:
static const LightsGPIOPeripheral s_front_peripherals[] = {
  [LIGHTS_GPIO_CONFIG_FRONT_PERIPHERAL_HORN] = 
  {
      .address = { .port = GPIO_PORT_B, .pin = 11 },
      .polarity = LIGHTS_GPIO_POLARITY_ACTIVE_LOW,
  },
  //
}

and that's a problem because linter doesn't like opening brackets { to start on a new line.
Just so that the build doesn't fail right now, I added //clang-format off and //clang-format on flags. But this is temporary until this inconsistency is fixed. (Or I'm just wrong, and need to change my code so that it doesn't error...)",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,154,2018-03-24T16:30:56Z,2018-05-18T06:59:12Z,2018-05-18T06:59:19Z,MERGED,True,601,0,12,https://github.com/ArshanKhanifar,ELEC-376: Lights GPIO,18,[],https://github.com/uw-midsun/firmware/pull/154,https://github.com/ArshanKhanifar,6,https://github.com/uw-midsun/firmware/pull/154#issuecomment-388592771,"Hey y'all!
This is the lights_gpio module, it basically initializes all the gpio pins and ports, and provides interface to set them.
Since I wanted only this module to deal with gpio stuff, it will also provide information about which board we're using (front of back), because I had to figure that out reading a gpio pin 😛
It's missing unit tests which I'll provide. But since the module is kinda big, I just thought I'd put it here for now and get roasted a bit, and start working on revisions as I make the unit tests.
Thanks ❤️",@tituschow @ckitagawa Please take a look at this as well. Thanks!,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,154,2018-03-24T16:30:56Z,2018-05-18T06:59:12Z,2018-05-18T06:59:19Z,MERGED,True,601,0,12,https://github.com/ArshanKhanifar,ELEC-376: Lights GPIO,18,[],https://github.com/uw-midsun/firmware/pull/154,https://github.com/ArshanKhanifar,7,https://github.com/uw-midsun/firmware/pull/154#issuecomment-389237624,"Hey y'all!
This is the lights_gpio module, it basically initializes all the gpio pins and ports, and provides interface to set them.
Since I wanted only this module to deal with gpio stuff, it will also provide information about which board we're using (front of back), because I had to figure that out reading a gpio pin 😛
It's missing unit tests which I'll provide. But since the module is kinda big, I just thought I'd put it here for now and get roasted a bit, and start working on revisions as I make the unit tests.
Thanks ❤️",We are GUCCI my dudes 👍,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,155,2018-03-24T22:26:35Z,2018-04-05T01:13:24Z,2018-04-05T01:13:28Z,MERGED,True,598,11,10,https://github.com/ckitagawa,ELEC-105: Chaos Heartbeats,11,[],https://github.com/uw-midsun/firmware/pull/155,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/155,"bps_heartbeat is the handler module for heartbeats from plutus.
powertrain_heartbeat validates that Plutus, Driver Controls and Motor Controller are all responsive in the drive state. It relies on a watchdog which permits 2 failed ACKs (by one or more device) before raising a warning.","bps_heartbeat is the handler module for heartbeats from plutus.
powertrain_heartbeat validates that Plutus, Driver Controls and Motor Controller are all responsive in the drive state. It relies on a watchdog which permits 2 failed ACKs (by one or more device) before raising a warning.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,156,2018-03-27T00:25:49Z,2018-03-29T01:17:19Z,2018-03-29T01:17:23Z,MERGED,True,209,0,3,https://github.com/ckitagawa,ELEC-355: CAN Interval,4,[],https://github.com/uw-midsun/firmware/pull/156,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/156,"A module built on top of GenericCan for sending CAN messages a fix intervals.
In addition to the obvious use it supports:

On demand send can_interval_send_now in the event a state change needs to be broadcast immediately (i.e. immediately signalling a failure on an otherwise a periodic heartbeat).
Cancelling can_interval_disable in the event one state broadcasts the message and another doesn't.
Deletion can_interval_free (primarily for cleanup in testing).

To create and use:
CanInterval *interval;
can_interval_factory(&interval, ...);

// Starting requires a separate call in-case initialization is done outside
// the main loop.

can_interval_enable(interval);
Note: this is not intended to be used with CAN Network layer and as such has relatively limited use outside of boards using CAN UART. Although ""dumb"" data collection boards could in theory use the CAN Hw layer since they don't need to be fault tolerant. That said, ideally a similar implementation to this should be added to the network layer when bandwidth permits.","A module built on top of GenericCan for sending CAN messages a fix intervals.
In addition to the obvious use it supports:

On demand send can_interval_send_now in the event a state change needs to be broadcast immediately (i.e. immediately signalling a failure on an otherwise a periodic heartbeat).
Cancelling can_interval_disable in the event one state broadcasts the message and another doesn't.
Deletion can_interval_free (primarily for cleanup in testing).

To create and use:
CanInterval *interval;
can_interval_factory(&interval, ...);

// Starting requires a separate call in-case initialization is done outside
// the main loop.

can_interval_enable(interval);
Note: this is not intended to be used with CAN Network layer and as such has relatively limited use outside of boards using CAN UART. Although ""dumb"" data collection boards could in theory use the CAN Hw layer since they don't need to be fault tolerant. That said, ideally a similar implementation to this should be added to the network layer when bandwidth permits.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,157,2018-03-29T01:43:11Z,2018-04-21T21:22:25Z,2018-04-21T21:22:30Z,MERGED,True,421,2,5,https://github.com/ckitagawa,ELEC-355: Controller module for Charger via CAN,11,[],https://github.com/uw-midsun/firmware/pull/157,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/157,"This module is responsible for conversing with the Charger itself over CAN. It has a few responsibilities.
When signaled by Power Distribution to do so:

Send periodic charging request with voltage and current limits (these are fixed
for now but could be dynamic).
Send stop charging requests when the car exits the Charge state.

It also monitors messages sent by the Charger for a fault and exposes this fault information to its caller. The idea here is that if the charger faults we should stop charging. The point of exposing the status is to prevent re-entry into the Charging state in the event the bad status persists. The reason to attempt to re-enter the charging state is that it is possible for the fault to clear naturally. An example of a valid case for this would be a temporary over-temperature condition which will naturally clear eventually.
As for the CAN interface between power distribution and the charger; the charger will notify power distribution it is connected. At this point power distribution will either already be charging. Or will attempt to transition to charging (only works if in idle). Once in charging power distribution will signal the charger to ""close"". This will cause the charger to act as if it were a ""best-effort"" relay which attempts to charge when ""closed"" but has the potential to ""open"" itself on a fault. While it is ""open"" but power distribution has told it to ""close"" it will attempt to re-enter charging periodically but will only do so successfully if the fault clears. Signaling the charger to ""open"" is always successful.
See #124 for more context although permission is out of date.","This module is responsible for conversing with the Charger itself over CAN. It has a few responsibilities.
When signaled by Power Distribution to do so:

Send periodic charging request with voltage and current limits (these are fixed
for now but could be dynamic).
Send stop charging requests when the car exits the Charge state.

It also monitors messages sent by the Charger for a fault and exposes this fault information to its caller. The idea here is that if the charger faults we should stop charging. The point of exposing the status is to prevent re-entry into the Charging state in the event the bad status persists. The reason to attempt to re-enter the charging state is that it is possible for the fault to clear naturally. An example of a valid case for this would be a temporary over-temperature condition which will naturally clear eventually.
As for the CAN interface between power distribution and the charger; the charger will notify power distribution it is connected. At this point power distribution will either already be charging. Or will attempt to transition to charging (only works if in idle). Once in charging power distribution will signal the charger to ""close"". This will cause the charger to act as if it were a ""best-effort"" relay which attempts to charge when ""closed"" but has the potential to ""open"" itself on a fault. While it is ""open"" but power distribution has told it to ""close"" it will attempt to re-enter charging periodically but will only do so successfully if the fault clears. Signaling the charger to ""open"" is always successful.
See #124 for more context although permission is out of date.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,157,2018-03-29T01:43:11Z,2018-04-21T21:22:25Z,2018-04-21T21:22:30Z,MERGED,True,421,2,5,https://github.com/ckitagawa,ELEC-355: Controller module for Charger via CAN,11,[],https://github.com/uw-midsun/firmware/pull/157,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/157#issuecomment-379494288,"This module is responsible for conversing with the Charger itself over CAN. It has a few responsibilities.
When signaled by Power Distribution to do so:

Send periodic charging request with voltage and current limits (these are fixed
for now but could be dynamic).
Send stop charging requests when the car exits the Charge state.

It also monitors messages sent by the Charger for a fault and exposes this fault information to its caller. The idea here is that if the charger faults we should stop charging. The point of exposing the status is to prevent re-entry into the Charging state in the event the bad status persists. The reason to attempt to re-enter the charging state is that it is possible for the fault to clear naturally. An example of a valid case for this would be a temporary over-temperature condition which will naturally clear eventually.
As for the CAN interface between power distribution and the charger; the charger will notify power distribution it is connected. At this point power distribution will either already be charging. Or will attempt to transition to charging (only works if in idle). Once in charging power distribution will signal the charger to ""close"". This will cause the charger to act as if it were a ""best-effort"" relay which attempts to charge when ""closed"" but has the potential to ""open"" itself on a fault. While it is ""open"" but power distribution has told it to ""close"" it will attempt to re-enter charging periodically but will only do so successfully if the fault clears. Signaling the charger to ""open"" is always successful.
See #124 for more context although permission is out of date.","I was only planning to turn this board on when the car is in charging mode. In that case the charger will always be powered (as far as I know) so it will either be. I could always add a third state which is ""OFF"" which doesn't send if sending messages to an empty bus will cause an issue?

Disconnected: just sends stop charging signals since the status will be invalid.
Connected: also sends stop signals since Chaos hasn't notified it to charge.
Charging: send start signals while the status remains ok.

Since none of the messages depend on acks then sending messages at the expected period all the time is fine. Unless I'm missing something.
On the system CAN network (main Bus) side. I was planning to add status messages which are only sent periodically while charging.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,157,2018-03-29T01:43:11Z,2018-04-21T21:22:25Z,2018-04-21T21:22:30Z,MERGED,True,421,2,5,https://github.com/ckitagawa,ELEC-355: Controller module for Charger via CAN,11,[],https://github.com/uw-midsun/firmware/pull/157,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/157#issuecomment-379495037,"This module is responsible for conversing with the Charger itself over CAN. It has a few responsibilities.
When signaled by Power Distribution to do so:

Send periodic charging request with voltage and current limits (these are fixed
for now but could be dynamic).
Send stop charging requests when the car exits the Charge state.

It also monitors messages sent by the Charger for a fault and exposes this fault information to its caller. The idea here is that if the charger faults we should stop charging. The point of exposing the status is to prevent re-entry into the Charging state in the event the bad status persists. The reason to attempt to re-enter the charging state is that it is possible for the fault to clear naturally. An example of a valid case for this would be a temporary over-temperature condition which will naturally clear eventually.
As for the CAN interface between power distribution and the charger; the charger will notify power distribution it is connected. At this point power distribution will either already be charging. Or will attempt to transition to charging (only works if in idle). Once in charging power distribution will signal the charger to ""close"". This will cause the charger to act as if it were a ""best-effort"" relay which attempts to charge when ""closed"" but has the potential to ""open"" itself on a fault. While it is ""open"" but power distribution has told it to ""close"" it will attempt to re-enter charging periodically but will only do so successfully if the fault clears. Signaling the charger to ""open"" is always successful.
See #124 for more context although permission is out of date.",AFAIK the charger's CAN interface is only powered when it's plugged in. Sending messages to an empty bus will cause CAN to repeatedly transmit the same message since there are no ACKs on the low-level protocol (not our network protocol). Theoretically it should cause a bus error after a number of failed TXs?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,157,2018-03-29T01:43:11Z,2018-04-21T21:22:25Z,2018-04-21T21:22:30Z,MERGED,True,421,2,5,https://github.com/ckitagawa,ELEC-355: Controller module for Charger via CAN,11,[],https://github.com/uw-midsun/firmware/pull/157,https://github.com/ckitagawa,4,https://github.com/uw-midsun/firmware/pull/157#issuecomment-383314229,"This module is responsible for conversing with the Charger itself over CAN. It has a few responsibilities.
When signaled by Power Distribution to do so:

Send periodic charging request with voltage and current limits (these are fixed
for now but could be dynamic).
Send stop charging requests when the car exits the Charge state.

It also monitors messages sent by the Charger for a fault and exposes this fault information to its caller. The idea here is that if the charger faults we should stop charging. The point of exposing the status is to prevent re-entry into the Charging state in the event the bad status persists. The reason to attempt to re-enter the charging state is that it is possible for the fault to clear naturally. An example of a valid case for this would be a temporary over-temperature condition which will naturally clear eventually.
As for the CAN interface between power distribution and the charger; the charger will notify power distribution it is connected. At this point power distribution will either already be charging. Or will attempt to transition to charging (only works if in idle). Once in charging power distribution will signal the charger to ""close"". This will cause the charger to act as if it were a ""best-effort"" relay which attempts to charge when ""closed"" but has the potential to ""open"" itself on a fault. While it is ""open"" but power distribution has told it to ""close"" it will attempt to re-enter charging periodically but will only do so successfully if the fault clears. Signaling the charger to ""open"" is always successful.
See #124 for more context although permission is out of date.",I've addressed the issue of possibly causing a CAN bus fault. This required making some tiny modifications to the can_interval functions to just silently pass if the interval is already in a state. Otherwise it was just a bit more state logic. I've added a testcase for it. I'll merge this in the next couple days if there are no concerns with the changes.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,158,2018-03-30T01:04:53Z,2018-04-21T18:55:15Z,2018-04-21T18:55:19Z,MERGED,True,166,113,4,https://github.com/karlding,ELEC-316: Update current sense driver to work with isoSPI,14,[],https://github.com/uw-midsun/firmware/pull/158,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/158,"The LTC6820 requires a clock signal to encode a change in state on the
MISO pin. Since the LTC2484 uses the MISO pin to signal End of
Conversion, we are unable to test that correctly, and thus we are forced
to delay for the maximum conversion time before performing another read.
The solution is to basically add a delay so that there is no way we can
read a bad value.
Changes:

Update API to reflect the fact that we're buffering values now
Update test to use the new API
Update the code to work with isoSPI

[0] projects/plutus/test/test_adc.c:58: [0/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [10/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [20/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [30/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [40/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [50/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [60/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [70/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [80/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [90/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [100/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [110/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [120/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [130/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [140/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [150/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [160/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [170/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [180/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [190/200] Samples taken
[0] projects/plutus/test/test_adc.c:62: Min: 0
[0] projects/plutus/test/test_adc.c:63: Max: 837
[0] projects/plutus/test/test_adc.c:64: Ripple: 837
projects/plutus/test/test_adc.c:37:test_ltc_adc_characterize_ripple:PASS

-----------------------
1 Tests 0 Failures 0 Ignored
OK","The LTC6820 requires a clock signal to encode a change in state on the
MISO pin. Since the LTC2484 uses the MISO pin to signal End of
Conversion, we are unable to test that correctly, and thus we are forced
to delay for the maximum conversion time before performing another read.
The solution is to basically add a delay so that there is no way we can
read a bad value.
Changes:

Update API to reflect the fact that we're buffering values now
Update test to use the new API
Update the code to work with isoSPI

[0] projects/plutus/test/test_adc.c:58: [0/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [10/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [20/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [30/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [40/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [50/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [60/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [70/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [80/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [90/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [100/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [110/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [120/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [130/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [140/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [150/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [160/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [170/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [180/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [190/200] Samples taken
[0] projects/plutus/test/test_adc.c:62: Min: 0
[0] projects/plutus/test/test_adc.c:63: Max: 837
[0] projects/plutus/test/test_adc.c:64: Ripple: 837
projects/plutus/test/test_adc.c:37:test_ltc_adc_characterize_ripple:PASS

-----------------------
1 Tests 0 Failures 0 Ignored
OK",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,158,2018-03-30T01:04:53Z,2018-04-21T18:55:15Z,2018-04-21T18:55:19Z,MERGED,True,166,113,4,https://github.com/karlding,ELEC-316: Update current sense driver to work with isoSPI,14,[],https://github.com/uw-midsun/firmware/pull/158,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/158#issuecomment-377438207,"The LTC6820 requires a clock signal to encode a change in state on the
MISO pin. Since the LTC2484 uses the MISO pin to signal End of
Conversion, we are unable to test that correctly, and thus we are forced
to delay for the maximum conversion time before performing another read.
The solution is to basically add a delay so that there is no way we can
read a bad value.
Changes:

Update API to reflect the fact that we're buffering values now
Update test to use the new API
Update the code to work with isoSPI

[0] projects/plutus/test/test_adc.c:58: [0/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [10/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [20/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [30/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [40/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [50/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [60/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [70/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [80/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [90/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [100/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [110/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [120/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [130/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [140/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [150/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [160/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [170/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [180/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [190/200] Samples taken
[0] projects/plutus/test/test_adc.c:62: Min: 0
[0] projects/plutus/test/test_adc.c:63: Max: 837
[0] projects/plutus/test/test_adc.c:64: Ripple: 837
projects/plutus/test/test_adc.c:37:test_ltc_adc_characterize_ripple:PASS

-----------------------
1 Tests 0 Failures 0 Ignored
OK","I find it a little suspicious that the min value is exactly 0. Can you set your ""invalid"" value to something arbitrary?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,158,2018-03-30T01:04:53Z,2018-04-21T18:55:15Z,2018-04-21T18:55:19Z,MERGED,True,166,113,4,https://github.com/karlding,ELEC-316: Update current sense driver to work with isoSPI,14,[],https://github.com/uw-midsun/firmware/pull/158,https://github.com/karlding,3,https://github.com/uw-midsun/firmware/pull/158#issuecomment-377717384,"The LTC6820 requires a clock signal to encode a change in state on the
MISO pin. Since the LTC2484 uses the MISO pin to signal End of
Conversion, we are unable to test that correctly, and thus we are forced
to delay for the maximum conversion time before performing another read.
The solution is to basically add a delay so that there is no way we can
read a bad value.
Changes:

Update API to reflect the fact that we're buffering values now
Update test to use the new API
Update the code to work with isoSPI

[0] projects/plutus/test/test_adc.c:58: [0/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [10/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [20/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [30/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [40/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [50/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [60/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [70/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [80/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [90/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [100/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [110/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [120/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [130/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [140/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [150/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [160/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [170/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [180/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [190/200] Samples taken
[0] projects/plutus/test/test_adc.c:62: Min: 0
[0] projects/plutus/test/test_adc.c:63: Max: 837
[0] projects/plutus/test/test_adc.c:64: Ripple: 837
projects/plutus/test/test_adc.c:37:test_ltc_adc_characterize_ripple:PASS

-----------------------
1 Tests 0 Failures 0 Ignored
OK","[0] projects/plutus/test/test_adc.c:58: [10/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [20/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [30/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [40/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [50/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [60/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [70/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [80/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [90/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [100/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [110/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [120/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [130/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [140/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [150/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [160/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [170/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [180/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [190/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [200/200] Samples taken
[0] projects/plutus/test/test_adc.c:62: Min: -1504
[0] projects/plutus/test/test_adc.c:63: Max: -1185
[0] projects/plutus/test/test_adc.c:64: Ripple: 319
projects/plutus/test/test_adc.c:37:test_ltc_adc_characterize_ripple:PASS

-----------------------
1 Tests 0 Failures 0 Ignored
OK",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,158,2018-03-30T01:04:53Z,2018-04-21T18:55:15Z,2018-04-21T18:55:19Z,MERGED,True,166,113,4,https://github.com/karlding,ELEC-316: Update current sense driver to work with isoSPI,14,[],https://github.com/uw-midsun/firmware/pull/158,https://github.com/tituschow,4,https://github.com/uw-midsun/firmware/pull/158#issuecomment-377741402,"The LTC6820 requires a clock signal to encode a change in state on the
MISO pin. Since the LTC2484 uses the MISO pin to signal End of
Conversion, we are unable to test that correctly, and thus we are forced
to delay for the maximum conversion time before performing another read.
The solution is to basically add a delay so that there is no way we can
read a bad value.
Changes:

Update API to reflect the fact that we're buffering values now
Update test to use the new API
Update the code to work with isoSPI

[0] projects/plutus/test/test_adc.c:58: [0/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [10/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [20/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [30/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [40/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [50/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [60/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [70/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [80/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [90/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [100/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [110/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [120/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [130/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [140/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [150/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [160/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [170/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [180/200] Samples taken
[0] projects/plutus/test/test_adc.c:58: [190/200] Samples taken
[0] projects/plutus/test/test_adc.c:62: Min: 0
[0] projects/plutus/test/test_adc.c:63: Max: 837
[0] projects/plutus/test/test_adc.c:64: Ripple: 837
projects/plutus/test/test_adc.c:37:test_ltc_adc_characterize_ripple:PASS

-----------------------
1 Tests 0 Failures 0 Ignored
OK","Can you make a ticket for the current module + offset?
Probably want to add callbacks to this module so we don't need to poll for new data.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,159,2018-03-31T19:19:10Z,2018-05-03T01:24:18Z,2018-05-03T01:24:21Z,MERGED,True,670,354,21,https://github.com/tituschow,ELEC-354: Driver Controls FSMs,17,[],https://github.com/uw-midsun/firmware/pull/159,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/159,"Adds cruise control handling, reworked FSMs, added drive output, and more tests.
This isn't fully complete, but I'm putting this up for preliminary review.","Adds cruise control handling, reworked FSMs, added drive output, and more tests.
This isn't fully complete, but I'm putting this up for preliminary review.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,159,2018-03-31T19:19:10Z,2018-05-03T01:24:18Z,2018-05-03T01:24:21Z,MERGED,True,670,354,21,https://github.com/tituschow,ELEC-354: Driver Controls FSMs,17,[],https://github.com/uw-midsun/firmware/pull/159,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/159#issuecomment-383746666,"Adds cruise control handling, reworked FSMs, added drive output, and more tests.
This isn't fully complete, but I'm putting this up for preliminary review.",I removed the power state blocking and neutral state to simplify the state interactions and I think it's a lot more straightforward now.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,159,2018-03-31T19:19:10Z,2018-05-03T01:24:18Z,2018-05-03T01:24:21Z,MERGED,True,670,354,21,https://github.com/tituschow,ELEC-354: Driver Controls FSMs,17,[],https://github.com/uw-midsun/firmware/pull/159,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/159#issuecomment-386028716,"Adds cruise control handling, reworked FSMs, added drive output, and more tests.
This isn't fully complete, but I'm putting this up for preliminary review.",Added documentation and addressed comments. I'll merge tonight if no one has any concerns. @ckitagawa @karlding,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,160,2018-03-31T20:25:06Z,2018-05-28T22:46:07Z,2018-05-28T22:46:07Z,CLOSED,False,481,43,14,https://github.com/Derpalooza,ELEC-266: x86 gpio visualizer,15,[],https://github.com/uw-midsun/firmware/pull/160,https://github.com/Derpalooza,1,https://github.com/uw-midsun/firmware/pull/160,"Socket-based emulator for the gpio peripheral. Allows for easier testing on x86 with the use of scripts to edit pin values externally.
Will create a confluence page documenting the format for the gpio message buffers.","Socket-based emulator for the gpio peripheral. Allows for easier testing on x86 with the use of scripts to edit pin values externally.
Will create a confluence page documenting the format for the gpio message buffers.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,160,2018-03-31T20:25:06Z,2018-05-28T22:46:07Z,2018-05-28T22:46:07Z,CLOSED,False,481,43,14,https://github.com/Derpalooza,ELEC-266: x86 gpio visualizer,15,[],https://github.com/uw-midsun/firmware/pull/160,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/160#issuecomment-386186429,"Socket-based emulator for the gpio peripheral. Allows for easier testing on x86 with the use of scripts to edit pin values externally.
Will create a confluence page documenting the format for the gpio message buffers.",Please update this to use the new socket framework. (See x86_socket.h),True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,161,2018-04-01T01:23:08Z,2018-04-04T16:20:06Z,2018-04-04T16:20:09Z,MERGED,True,1,1,1,https://github.com/karlding,ELEC-347: Fix crc15_calculate call to use the proper register data,2,[],https://github.com/uw-midsun/firmware/pull/161,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/161,"Use the correct set of device register data to calculate the PEC.
Previously, we were always calculating PEC using the first device's
data, which would obviously fail for the other devices in the daisy
chain.","Use the correct set of device register data to calculate the PEC.
Previously, we were always calculating PEC using the first device's
data, which would obviously fail for the other devices in the daisy
chain.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,162,2018-04-07T18:27:14Z,2018-04-07T19:44:03Z,2018-04-07T19:44:06Z,MERGED,True,48,9,3,https://github.com/ckitagawa,ELEC-105: GPIO Emergency State,1,[],https://github.com/uw-midsun/firmware/pull/162,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/162,"Simply adds an EMERGENCY State to the GPIO FSM.

To transition out of emergency to DRIVE or CHARGE again the FSM needs to go through IDLE
Any state can enter emergency since it is always possible for Plutus to signal a fault or for the Emergency switch to be hit.

I'd appreciate any feedback on the additional hardware pins (I failed to take notes last time it was discussed) and when they should turn on/off. Also @karlding are we now planning to leave Plutus on all the time?","Simply adds an EMERGENCY State to the GPIO FSM.

To transition out of emergency to DRIVE or CHARGE again the FSM needs to go through IDLE
Any state can enter emergency since it is always possible for Plutus to signal a fault or for the Emergency switch to be hit.

I'd appreciate any feedback on the additional hardware pins (I failed to take notes last time it was discussed) and when they should turn on/off. Also @karlding are we now planning to leave Plutus on all the time?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,163,2018-04-07T19:34:05Z,2018-05-05T18:48:45Z,2018-05-05T18:48:53Z,MERGED,True,717,6,7,https://github.com/ckitagawa,ELEC-105: Chaos Sequencer,19,[],https://github.com/uw-midsun/firmware/pull/163,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/163,"This is the Chaos Sequencer module which schedules core FSM events (those dictated by the power state) via the main event loop. This is to avoid a single large FSM. Instead each module acts like a standalone FSM and subscribes to events on the loop. However, in order to enforce a strict ordering on actions (particularly important for power and relay sequencing which may need retries) the sequencer is used to publish the next event required for the transition when the previous event is successfully processed.
Remaining work after this PR:

Configure Pins
Main Loop
CAN Handlers for messages from Driver Controls
Charger Notification handler module.","This is the Chaos Sequencer module which schedules core FSM events (those dictated by the power state) via the main event loop. This is to avoid a single large FSM. Instead each module acts like a standalone FSM and subscribes to events on the loop. However, in order to enforce a strict ordering on actions (particularly important for power and relay sequencing which may need retries) the sequencer is used to publish the next event required for the transition when the previous event is successfully processed.
Remaining work after this PR:

Configure Pins
Main Loop
CAN Handlers for messages from Driver Controls
Charger Notification handler module.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,163,2018-04-07T19:34:05Z,2018-05-05T18:48:45Z,2018-05-05T18:48:53Z,MERGED,True,717,6,7,https://github.com/ckitagawa,ELEC-105: Chaos Sequencer,19,[],https://github.com/uw-midsun/firmware/pull/163,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/163#issuecomment-385197623,"This is the Chaos Sequencer module which schedules core FSM events (those dictated by the power state) via the main event loop. This is to avoid a single large FSM. Instead each module acts like a standalone FSM and subscribes to events on the loop. However, in order to enforce a strict ordering on actions (particularly important for power and relay sequencing which may need retries) the sequencer is used to publish the next event required for the transition when the previous event is successfully processed.
Remaining work after this PR:

Configure Pins
Main Loop
CAN Handlers for messages from Driver Controls
Charger Notification handler module.",As discussed this has been updated to use pairs of events instead. The logic is much more readable now (hopefully) and the tests have also been modified slightly to be more understandable.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,164,2018-04-08T02:18:23Z,2018-05-26T01:56:24Z,2018-05-26T01:56:30Z,MERGED,True,293,7,7,https://github.com/ArshanKhanifar,ELEC-383: Lights Blinker,22,[],https://github.com/uw-midsun/firmware/pull/164,https://github.com/ArshanKhanifar,1,https://github.com/uw-midsun/firmware/pull/164,"Hey y'all.
This is the blinker module.
User will have to provide storage for the blinker instance. When blinker gets turned on, it will periodically raise events with alternating data fields. This will get used by the lights_strobe module and lights_signals module to blink the lights.","Hey y'all.
This is the blinker module.
User will have to provide storage for the blinker instance. When blinker gets turned on, it will periodically raise events with alternating data fields. This will get used by the lights_strobe module and lights_signals module to blink the lights.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,164,2018-04-08T02:18:23Z,2018-05-26T01:56:24Z,2018-05-26T01:56:30Z,MERGED,True,293,7,7,https://github.com/ArshanKhanifar,ELEC-383: Lights Blinker,22,[],https://github.com/uw-midsun/firmware/pull/164,https://github.com/ArshanKhanifar,2,https://github.com/uw-midsun/firmware/pull/164#issuecomment-386663732,"Hey y'all.
This is the blinker module.
User will have to provide storage for the blinker instance. When blinker gets turned on, it will periodically raise events with alternating data fields. This will get used by the lights_strobe module and lights_signals module to blink the lights.","I just realized, there's ambiguity between the ON and OFF states, and turning the blinker on and off. I'm thinking changing these function names:
lights_blinker_on -> lights_blinker_activate
lights_blinker_off -> lights_blinker_deactivate
lights_blinker_inuse -> lights_blinker_is_active",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,164,2018-04-08T02:18:23Z,2018-05-26T01:56:24Z,2018-05-26T01:56:30Z,MERGED,True,293,7,7,https://github.com/ArshanKhanifar,ELEC-383: Lights Blinker,22,[],https://github.com/uw-midsun/firmware/pull/164,https://github.com/ArshanKhanifar,3,https://github.com/uw-midsun/firmware/pull/164#issuecomment-386669232,"Hey y'all.
This is the blinker module.
User will have to provide storage for the blinker instance. When blinker gets turned on, it will periodically raise events with alternating data fields. This will get used by the lights_strobe module and lights_signals module to blink the lights.",I still need to figure out interrupt-proofing my functions.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,164,2018-04-08T02:18:23Z,2018-05-26T01:56:24Z,2018-05-26T01:56:30Z,MERGED,True,293,7,7,https://github.com/ArshanKhanifar,ELEC-383: Lights Blinker,22,[],https://github.com/uw-midsun/firmware/pull/164,https://github.com/ArshanKhanifar,4,https://github.com/uw-midsun/firmware/pull/164#issuecomment-387858707,"Hey y'all.
This is the blinker module.
User will have to provide storage for the blinker instance. When blinker gets turned on, it will periodically raise events with alternating data fields. This will get used by the lights_strobe module and lights_signals module to blink the lights.","Commit 480c39d makes lights_blinker_deactivate interrupt-safe. This is because no timer interrupt can interrupt its execution after the soft_timer_cancel() call, which cancels the scheduled timer. Soft-timer callbacks can interrupt the function before that point, but all they do is that they schedule another timer, and update blinker->timer_id. This technically doesn't cause any issue, as the updated soft_timer gets cancelled soon as the interrupt execution finishes.

Therefore, a deactivated blinker is safely assumed to have no scheduled timers.
lights_blinker_activate will call lights_blinker_deactivate first thing, so it's interrupt-free as well.
lights_sync_on also cancels the soft_timer, so it's interrupt free.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,164,2018-04-08T02:18:23Z,2018-05-26T01:56:24Z,2018-05-26T01:56:30Z,MERGED,True,293,7,7,https://github.com/ArshanKhanifar,ELEC-383: Lights Blinker,22,[],https://github.com/uw-midsun/firmware/pull/164,https://github.com/ArshanKhanifar,5,https://github.com/uw-midsun/firmware/pull/164#issuecomment-388592745,"Hey y'all.
This is the blinker module.
User will have to provide storage for the blinker instance. When blinker gets turned on, it will periodically raise events with alternating data fields. This will get used by the lights_strobe module and lights_signals module to blink the lights.",It's been a wild ride! @ckitagawa's nits are also addressed. Please do a final check and let's get this bish merged in! Whohooooo!!,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,164,2018-04-08T02:18:23Z,2018-05-26T01:56:24Z,2018-05-26T01:56:30Z,MERGED,True,293,7,7,https://github.com/ArshanKhanifar,ELEC-383: Lights Blinker,22,[],https://github.com/uw-midsun/firmware/pull/164,https://github.com/ArshanKhanifar,6,https://github.com/uw-midsun/firmware/pull/164#issuecomment-389242088,"Hey y'all.
This is the blinker module.
User will have to provide storage for the blinker instance. When blinker gets turned on, it will periodically raise events with alternating data fields. This will get used by the lights_strobe module and lights_signals module to blink the lights.",Corrected tests for lights_gpio too.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,165,2018-04-09T20:04:43Z,2018-05-06T20:33:59Z,2018-05-06T20:34:06Z,CLOSED,False,635,50,13,https://github.com/a3farmah,ELEC-382: Pedal Calibration Routine,22,[],https://github.com/uw-midsun/firmware/pull/165,https://github.com/a3farmah,1,https://github.com/uw-midsun/firmware/pull/165,"We are still discussing of how to exactly do the calibration. For now the code has functions that read data from both channels for full throttle and full brake positions and then uses this information to initialize the calibration storage held in throttle storage. Calibration is done in test_pedal_calibration.
One question is how to make sure the main channel and secondary channel are not mixed up. Probably, have to remove channel parameters from throttle_init function and just have them initialized by the calibration routine (Only calibration can determine the channel with higher resolution).
Other question is how to have the user talk to calibration since there are multiple steps where user has to press/release the pedal.","We are still discussing of how to exactly do the calibration. For now the code has functions that read data from both channels for full throttle and full brake positions and then uses this information to initialize the calibration storage held in throttle storage. Calibration is done in test_pedal_calibration.
One question is how to make sure the main channel and secondary channel are not mixed up. Probably, have to remove channel parameters from throttle_init function and just have them initialized by the calibration routine (Only calibration can determine the channel with higher resolution).
Other question is how to have the user talk to calibration since there are multiple steps where user has to press/release the pedal.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,165,2018-04-09T20:04:43Z,2018-05-06T20:33:59Z,2018-05-06T20:34:06Z,CLOSED,False,635,50,13,https://github.com/a3farmah,ELEC-382: Pedal Calibration Routine,22,[],https://github.com/uw-midsun/firmware/pull/165,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/165#issuecomment-386911055,"We are still discussing of how to exactly do the calibration. For now the code has functions that read data from both channels for full throttle and full brake positions and then uses this information to initialize the calibration storage held in throttle storage. Calibration is done in test_pedal_calibration.
One question is how to make sure the main channel and secondary channel are not mixed up. Probably, have to remove channel parameters from throttle_init function and just have them initialized by the calibration routine (Only calibration can determine the channel with higher resolution).
Other question is how to have the user talk to calibration since there are multiple steps where user has to press/release the pedal.","See #178 - I've already fixed most of the outstanding issues, so there's no need to duplicate work.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,166,2018-04-21T20:25:35Z,2018-04-21T20:55:42Z,2018-04-21T20:55:45Z,MERGED,True,12,26,1,https://github.com/tituschow,ELEC-386: Fixed x86 CAN HW deadlock,3,[],https://github.com/uw-midsun/firmware/pull/166,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/166,"There was a deadlock between the CAN TX thread and can_hw_transmit called from the soft timer signal handler.

The TX thread is holding the TX mutex while the critical section mutex is held by the main thread in the soft timer signal handler. This causes a deadlock because the TX thread attempts to acquire the critical section mutex to process the FIFO while the main thread attempts to acquire the TX mutex to push data using can_hw_transmit.

This fix removes the TX mutex entirely and replaces it with a semaphore since this is a producer/consumer scenario.","There was a deadlock between the CAN TX thread and can_hw_transmit called from the soft timer signal handler.

The TX thread is holding the TX mutex while the critical section mutex is held by the main thread in the soft timer signal handler. This causes a deadlock because the TX thread attempts to acquire the critical section mutex to process the FIFO while the main thread attempts to acquire the TX mutex to push data using can_hw_transmit.

This fix removes the TX mutex entirely and replaces it with a semaphore since this is a producer/consumer scenario.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,167,2018-04-21T20:33:46Z,2018-04-21T20:40:28Z,2018-04-21T20:40:35Z,MERGED,True,12,0,1,https://github.com/ckitagawa,ELEC-386: Mask signal handling in CAN RX/TX Threads,1,[],https://github.com/uw-midsun/firmware/pull/167,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/167,"According to signal (7), signals are indeterminate in which thread of a particular process they trigger. As a result the CAN TX or RX threads often handled the signal. This isn't good since it can lead to some strange behaviors regarding mutex ownership. To get around this we mask the pthreads individually from receiving signals as they are spawned via pthread_sigmask.
Since CAN Hardware is the only location we use pthreads we can limit the change to this module. We could make this a function under interrupt.h if we expect it to be more widely used.","According to signal (7), signals are indeterminate in which thread of a particular process they trigger. As a result the CAN TX or RX threads often handled the signal. This isn't good since it can lead to some strange behaviors regarding mutex ownership. To get around this we mask the pthreads individually from receiving signals as they are spawned via pthread_sigmask.
Since CAN Hardware is the only location we use pthreads we can limit the change to this module. We could make this a function under interrupt.h if we expect it to be more widely used.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,168,2018-04-24T02:17:38Z,2018-05-04T22:28:42Z,2018-05-04T22:28:45Z,MERGED,True,148,117,3,https://github.com/tituschow,ELEC-389: GPIO Expander,6,[],https://github.com/uw-midsun/firmware/pull/168,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/168,"Adds support for multiple instances of the GPIO expander. Also uses GPIO instead of INTCAP to ensure we always get the latest state.
Note that this code is untested.","Adds support for multiple instances of the GPIO expander. Also uses GPIO instead of INTCAP to ensure we always get the latest state.
Note that this code is untested.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,168,2018-04-24T02:17:38Z,2018-05-04T22:28:42Z,2018-05-04T22:28:45Z,MERGED,True,148,117,3,https://github.com/tituschow,ELEC-389: GPIO Expander,6,[],https://github.com/uw-midsun/firmware/pull/168,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/168#issuecomment-385223894,"Adds support for multiple instances of the GPIO expander. Also uses GPIO instead of INTCAP to ensure we always get the latest state.
Note that this code is untested.",I'll probably wait until I can test this on hardware before I merge.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,168,2018-04-24T02:17:38Z,2018-05-04T22:28:42Z,2018-05-04T22:28:45Z,MERGED,True,148,117,3,https://github.com/tituschow,ELEC-389: GPIO Expander,6,[],https://github.com/uw-midsun/firmware/pull/168,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/168#issuecomment-385225591,"Adds support for multiple instances of the GPIO expander. Also uses GPIO instead of INTCAP to ensure we always get the latest state.
Note that this code is untested.","Test failure seems to be due to ELEC-394 (#172), unrelated to my code",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,169,2018-04-24T22:11:45Z,2018-04-25T03:37:39Z,2018-04-25T22:56:35Z,MERGED,True,5,4,3,https://github.com/karlding,ELEC-393: Remove git fetch prebuild command from codegen-tooling,3,[],https://github.com/uw-midsun/firmware/pull/169,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/169,"This seems to confuse people when we roll forward codegen-tooling, since
their builds break and then they run into merge conflicts whenever this
happens.
Instead, we'll add an explicit update_codegen target that allows us to still
easily update the library, but it won't cause all the errors people are
confused about.","This seems to confuse people when we roll forward codegen-tooling, since
their builds break and then they run into merge conflicts whenever this
happens.
Instead, we'll add an explicit update_codegen target that allows us to still
easily update the library, but it won't cause all the errors people are
confused about.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,169,2018-04-24T22:11:45Z,2018-04-25T03:37:39Z,2018-04-25T22:56:35Z,MERGED,True,5,4,3,https://github.com/karlding,ELEC-393: Remove git fetch prebuild command from codegen-tooling,3,[],https://github.com/uw-midsun/firmware/pull/169,https://github.com/karlding,2,https://github.com/uw-midsun/firmware/pull/169#issuecomment-384104557,"This seems to confuse people when we roll forward codegen-tooling, since
their builds break and then they run into merge conflicts whenever this
happens.
Instead, we'll add an explicit update_codegen target that allows us to still
easily update the library, but it won't cause all the errors people are
confused about.",Creating ELEC-394 to track the signal issue.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,170,2018-04-25T22:26:50Z,2018-05-28T22:47:30Z,2018-09-13T03:48:02Z,CLOSED,False,1227,5,15,https://github.com/karlding,ELEC-338: Add motor controller interface,26,[],https://github.com/uw-midsun/firmware/pull/170,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/170,"I'm putting this up for comments while I figure out how to test this with
the hardware we currently have before I leave. I've outlined the general
idea of how this works in the README.md, but let me know if you think of
a better way to tackle this.
There's a few outstanding TODO items (like configuring the Motor
Controllers), but that should be pretty easy with the Virtual Machine I've
built that packages the CAN USB drivers.","I'm putting this up for comments while I figure out how to test this with
the hardware we currently have before I leave. I've outlined the general
idea of how this works in the README.md, but let me know if you think of
a better way to tackle this.
There's a few outstanding TODO items (like configuring the Motor
Controllers), but that should be pretty easy with the Virtual Machine I've
built that packages the CAN USB drivers.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,171,2018-04-27T01:36:18Z,2018-04-28T09:24:29Z,2018-04-28T09:24:32Z,MERGED,True,29,31,5,https://github.com/karlding,ELEC-392: Roll forward codegen,1,[],https://github.com/uw-midsun/firmware/pull/171,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/171,Roll forward codegen.,Roll forward codegen.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,172,2018-04-28T02:23:49Z,2018-04-29T15:33:34Z,2018-04-29T15:33:37Z,MERGED,True,118,35,4,https://github.com/ckitagawa,ELEC-394: Signal Handler,7,[],https://github.com/uw-midsun/firmware/pull/172,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/172,"This fixes the deadlock issues by doing the following:

Creating a function to block all interrupts which is to be called as pthreads are spawned. This will prevent them from handling any signals.
Make the main thread the only handler of signals. This keeps the behavior of interrupts since the main thread is the one stopping to handle the signal. A separate signal handler doesn't actually achieve this without a lot of locks and complexity. Moreover, since both the main thread and signal handler call the critical section deadlocks are prone to occur. This is both cleaner and easier to reason about.
Use a signal handler to enable and disable interrupts on the main thread.","This fixes the deadlock issues by doing the following:

Creating a function to block all interrupts which is to be called as pthreads are spawned. This will prevent them from handling any signals.
Make the main thread the only handler of signals. This keeps the behavior of interrupts since the main thread is the one stopping to handle the signal. A separate signal handler doesn't actually achieve this without a lot of locks and complexity. Moreover, since both the main thread and signal handler call the critical section deadlocks are prone to occur. This is both cleaner and easier to reason about.
Use a signal handler to enable and disable interrupts on the main thread.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,172,2018-04-28T02:23:49Z,2018-04-29T15:33:34Z,2018-04-29T15:33:37Z,MERGED,True,118,35,4,https://github.com/ckitagawa,ELEC-394: Signal Handler,7,[],https://github.com/uw-midsun/firmware/pull/172,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/172#issuecomment-385133054,"This fixes the deadlock issues by doing the following:

Creating a function to block all interrupts which is to be called as pthreads are spawned. This will prevent them from handling any signals.
Make the main thread the only handler of signals. This keeps the behavior of interrupts since the main thread is the one stopping to handle the signal. A separate signal handler doesn't actually achieve this without a lot of locks and complexity. Moreover, since both the main thread and signal handler call the critical section deadlocks are prone to occur. This is both cleaner and easier to reason about.
Use a signal handler to enable and disable interrupts on the main thread.",I think I missed some cleanup between the first and second commit. (See the first commit for the separate handler thread implementation that had issues). I'll get to that tomorrow.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,172,2018-04-28T02:23:49Z,2018-04-29T15:33:34Z,2018-04-29T15:33:37Z,MERGED,True,118,35,4,https://github.com/ckitagawa,ELEC-394: Signal Handler,7,[],https://github.com/uw-midsun/firmware/pull/172,https://github.com/karlding,3,https://github.com/uw-midsun/firmware/pull/172#issuecomment-385139273,"This fixes the deadlock issues by doing the following:

Creating a function to block all interrupts which is to be called as pthreads are spawned. This will prevent them from handling any signals.
Make the main thread the only handler of signals. This keeps the behavior of interrupts since the main thread is the one stopping to handle the signal. A separate signal handler doesn't actually achieve this without a lot of locks and complexity. Moreover, since both the main thread and signal handler call the critical section deadlocks are prone to occur. This is both cleaner and easier to reason about.
Use a signal handler to enable and disable interrupts on the main thread.","So, to clarify that I understand the control flow here, is it correct to say that:

A critical section starts
x86_interrupt_mask is called, which signals SIGRTMIN + NUM_INTERRUPT_PRIORITIES
The signal handler for SIGRTMIN + NUM_INTERRUPT_PRIORITIES (prv_sig_state_handler) is called on the main thread
prv_sig_state_handler allows SIGRTMIN + INTERRUPT_PRIORITY_LOW, SIGRTMIN + INTERRUPT_PRIORITY_NORMAL and SIGRTMIN + INTERRUPT_PRIORITY_HIGH to be accepted
prv_sig_handler is called from the signal handler and looks up the correct callback",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,172,2018-04-28T02:23:49Z,2018-04-29T15:33:34Z,2018-04-29T15:33:37Z,MERGED,True,118,35,4,https://github.com/ckitagawa,ELEC-394: Signal Handler,7,[],https://github.com/uw-midsun/firmware/pull/172,https://github.com/tituschow,4,https://github.com/uw-midsun/firmware/pull/172#issuecomment-385184977,"This fixes the deadlock issues by doing the following:

Creating a function to block all interrupts which is to be called as pthreads are spawned. This will prevent them from handling any signals.
Make the main thread the only handler of signals. This keeps the behavior of interrupts since the main thread is the one stopping to handle the signal. A separate signal handler doesn't actually achieve this without a lot of locks and complexity. Moreover, since both the main thread and signal handler call the critical section deadlocks are prone to occur. This is both cleaner and easier to reason about.
Use a signal handler to enable and disable interrupts on the main thread.","The separate signal thread should've just use sigwait or something similar so signals aren't handled async, but I see that you've removed it.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,172,2018-04-28T02:23:49Z,2018-04-29T15:33:34Z,2018-04-29T15:33:37Z,MERGED,True,118,35,4,https://github.com/ckitagawa,ELEC-394: Signal Handler,7,[],https://github.com/uw-midsun/firmware/pull/172,https://github.com/ckitagawa,5,https://github.com/uw-midsun/firmware/pull/172#issuecomment-385185493,"This fixes the deadlock issues by doing the following:

Creating a function to block all interrupts which is to be called as pthreads are spawned. This will prevent them from handling any signals.
Make the main thread the only handler of signals. This keeps the behavior of interrupts since the main thread is the one stopping to handle the signal. A separate signal handler doesn't actually achieve this without a lot of locks and complexity. Moreover, since both the main thread and signal handler call the critical section deadlocks are prone to occur. This is both cleaner and easier to reason about.
Use a signal handler to enable and disable interrupts on the main thread.","@karlding
Sort of let me elaborate:

A critical section starts:
x86_interrupt_mask is called which signals SIGRTMIN + NUM_INTERRUPT_PRIORITIES
prv_sig_state_handler is called on the main thread (masks all other signals we use via sa_mask) and alters the ucontext_t (stores previous context). In this way the context restore manipulates the actual sigset_t of the underlying thread even after the sa_mask is removed otherwise calling pthread_sigmask inside the handler gets removed on context switch.
The opposite of 1-3 occur on critical section end.

I made a mistake regarding not masking sig_state_handler's other interrupts originally.
For interrupts themselves

prv_sig_state_handler allows SIGRTMIN + INTERRUPT_PRIORITY_LOW, SIGRTMIN + INTERRUPT_PRIORITY_NORMAL and SIGRTMIN + INTERRUPT_PRIORITY_HIGH to be accepted. This also masks any lower priority signals once entered.
Any callbacks are run.
The handler exits.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,172,2018-04-28T02:23:49Z,2018-04-29T15:33:34Z,2018-04-29T15:33:37Z,MERGED,True,118,35,4,https://github.com/ckitagawa,ELEC-394: Signal Handler,7,[],https://github.com/uw-midsun/firmware/pull/172,https://github.com/ckitagawa,6,https://github.com/uw-midsun/firmware/pull/172#issuecomment-385186623,"This fixes the deadlock issues by doing the following:

Creating a function to block all interrupts which is to be called as pthreads are spawned. This will prevent them from handling any signals.
Make the main thread the only handler of signals. This keeps the behavior of interrupts since the main thread is the one stopping to handle the signal. A separate signal handler doesn't actually achieve this without a lot of locks and complexity. Moreover, since both the main thread and signal handler call the critical section deadlocks are prone to occur. This is both cleaner and easier to reason about.
Use a signal handler to enable and disable interrupts on the main thread.","It appears downloading the build infrastructure is failing on Travis CI... @karlding do we need to roll to clang-6?
EDIT: nvm looks like some kind of issue with the PPA again.",True,{'THUMBS_UP': ['https://github.com/karlding']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,172,2018-04-28T02:23:49Z,2018-04-29T15:33:34Z,2018-04-29T15:33:37Z,MERGED,True,118,35,4,https://github.com/ckitagawa,ELEC-394: Signal Handler,7,[],https://github.com/uw-midsun/firmware/pull/172,https://github.com/ckitagawa,7,https://github.com/uw-midsun/firmware/pull/172#issuecomment-385256875,"This fixes the deadlock issues by doing the following:

Creating a function to block all interrupts which is to be called as pthreads are spawned. This will prevent them from handling any signals.
Make the main thread the only handler of signals. This keeps the behavior of interrupts since the main thread is the one stopping to handle the signal. A separate signal handler doesn't actually achieve this without a lot of locks and complexity. Moreover, since both the main thread and signal handler call the critical section deadlocks are prone to occur. This is both cleaner and easier to reason about.
Use a signal handler to enable and disable interrupts on the main thread.",That sounds possible... If we start seeing that behavior we can revisit how that mutex works in a critical section. One option might be to use a thread_local static variable to tag the thread that owns the handler and set it in x86_interrupt_init(). That way if x86_interrupt_in_handler() == true but  thread_local bool is_handler == false the thread will block until the critical section is over?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,172,2018-04-28T02:23:49Z,2018-04-29T15:33:34Z,2018-04-29T15:33:37Z,MERGED,True,118,35,4,https://github.com/ckitagawa,ELEC-394: Signal Handler,7,[],https://github.com/uw-midsun/firmware/pull/172,https://github.com/tituschow,8,https://github.com/uw-midsun/firmware/pull/172#issuecomment-385258614,"This fixes the deadlock issues by doing the following:

Creating a function to block all interrupts which is to be called as pthreads are spawned. This will prevent them from handling any signals.
Make the main thread the only handler of signals. This keeps the behavior of interrupts since the main thread is the one stopping to handle the signal. A separate signal handler doesn't actually achieve this without a lot of locks and complexity. Moreover, since both the main thread and signal handler call the critical section deadlocks are prone to occur. This is both cleaner and easier to reason about.
Use a signal handler to enable and disable interrupts on the main thread.","I think we're pretty much implementing a lock at that point :P
That might solve the long-running issue (signal handler already in critical section) but I think there's still a race condition if both threads attempt to enter the critical section at the same time.
The issue is that it might be pretty difficult to actually identify this as the cause since we'll get data corruption/race conditions. We should be able to build a minimal test case pretty easily to confirm that this problem exists. Maybe just add a comment for the future?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,173,2018-04-30T05:02:28Z,2018-05-03T04:04:19Z,2018-05-03T04:04:22Z,MERGED,True,264,0,4,https://github.com/tituschow,ELEC-395: Socket Framework,10,[],https://github.com/uw-midsun/firmware/pull/173,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/173,"The idea behind this framework is to provide a simple layer for modules that would like to communicate with the outside world. On init, a new server thread is created that listens on an abstract UNIX domain socket on \0[pid]/[program name]/[module]. The program name isn't strictly necessary, but I added it to make it easier to find through netstat or similar. Using the PID as a namespace allows multiple instances of the program to be launched and handled independently.","The idea behind this framework is to provide a simple layer for modules that would like to communicate with the outside world. On init, a new server thread is created that listens on an abstract UNIX domain socket on \0[pid]/[program name]/[module]. The program name isn't strictly necessary, but I added it to make it easier to find through netstat or similar. Using the PID as a namespace allows multiple instances of the program to be launched and handled independently.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,174,2018-04-30T17:26:25Z,2018-05-17T00:46:46Z,2018-05-17T00:46:46Z,CLOSED,False,692,0,10,https://github.com/mishazharov,ELEC-71: GPS Driver,87,[],https://github.com/uw-midsun/firmware/pull/174,https://github.com/mishazharov,1,https://github.com/uw-midsun/firmware/pull/174,This is all the code for the GPS driver including the NMEA parser but excluding the checksum utils. Will split the GPS driver and NMEA parser into separate pull requests,This is all the code for the GPS driver including the NMEA parser but excluding the checksum utils. Will split the GPS driver and NMEA parser into separate pull requests,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,174,2018-04-30T17:26:25Z,2018-05-17T00:46:46Z,2018-05-17T00:46:46Z,CLOSED,False,692,0,10,https://github.com/mishazharov,ELEC-71: GPS Driver,87,[],https://github.com/uw-midsun/firmware/pull/174,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/174#issuecomment-388530178,This is all the code for the GPS driver including the NMEA parser but excluding the checksum utils. Will split the GPS driver and NMEA parser into separate pull requests,"Just so you know - you don't need to keep updating it. Since this PR should be split, this branch can probably just be left alone.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,174,2018-04-30T17:26:25Z,2018-05-17T00:46:46Z,2018-05-17T00:46:46Z,CLOSED,False,692,0,10,https://github.com/mishazharov,ELEC-71: GPS Driver,87,[],https://github.com/uw-midsun/firmware/pull/174,https://github.com/mishazharov,3,https://github.com/uw-midsun/firmware/pull/174#issuecomment-389709518,This is all the code for the GPS driver including the NMEA parser but excluding the checksum utils. Will split the GPS driver and NMEA parser into separate pull requests,Closing PR since it will be split anyway,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,175,2018-05-03T21:13:26Z,2018-05-04T04:47:16Z,2018-05-04T04:47:20Z,MERGED,True,53,1,5,https://github.com/tituschow,ELEC-390: Git Hooks,24,[],https://github.com/uw-midsun/firmware/pull/175,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/175,"People on git 2.9 can use core.hooksPath to set the githooks path to the hooks folder.
Adds 3 hooks:

pre-push: Formats and lints
prepare-commit-msg: Prepends the commit message with ELEC-#:  if the branch begins with elec_#
pre-commit: Prevents people from committing with their name set as vagrant","People on git 2.9 can use core.hooksPath to set the githooks path to the hooks folder.
Adds 3 hooks:

pre-push: Formats and lints
prepare-commit-msg: Prepends the commit message with ELEC-#:  if the branch begins with elec_#
pre-commit: Prevents people from committing with their name set as vagrant",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,176,2018-05-04T21:25:30Z,2018-05-05T02:43:10Z,2018-05-05T02:43:13Z,MERGED,True,0,0,3,https://github.com/tituschow,ELEC-390: Add executable flag on hooks,2,[],https://github.com/uw-midsun/firmware/pull/176,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/176,This sets the executable flag on our hooks so they don't lose it every time we move branches.,This sets the executable flag on our hooks so they don't lose it every time we move branches.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,177,2018-05-06T06:18:27Z,2018-05-11T23:00:19Z,2018-05-11T23:00:22Z,MERGED,True,36,0,1,https://github.com/tituschow,ELEC-405: Add workaround for programmer on macOS hosts,5,[],https://github.com/uw-midsun/firmware/pull/177,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/177,"Tested on a new Vagrant box in conjunction with the macOS USB Workaround.
It just sets up a key-based ssh server on the host that the box can SSH into for flashing and debugging. Seems to work relatively well. Due to time sync issues, the test target may trigger two builds, but it's not that big of a deal and keeps the user in vagrant for most of the work. They'll still need to be in macOS to run minicom, but it's better than nothing.
Edit: I've fixed the double build by forcing make to consider the debug target to be old. I'm only going to bother supporting running one test.
We may want to add the script to the box repo?","Tested on a new Vagrant box in conjunction with the macOS USB Workaround.
It just sets up a key-based ssh server on the host that the box can SSH into for flashing and debugging. Seems to work relatively well. Due to time sync issues, the test target may trigger two builds, but it's not that big of a deal and keeps the user in vagrant for most of the work. They'll still need to be in macOS to run minicom, but it's better than nothing.
Edit: I've fixed the double build by forcing make to consider the debug target to be old. I'm only going to bother supporting running one test.
We may want to add the script to the box repo?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,177,2018-05-06T06:18:27Z,2018-05-11T23:00:19Z,2018-05-11T23:00:22Z,MERGED,True,36,0,1,https://github.com/tituschow,ELEC-405: Add workaround for programmer on macOS hosts,5,[],https://github.com/uw-midsun/firmware/pull/177,https://github.com/ArshanKhanifar,2,https://github.com/uw-midsun/firmware/pull/177#issuecomment-386884894,"Tested on a new Vagrant box in conjunction with the macOS USB Workaround.
It just sets up a key-based ssh server on the host that the box can SSH into for flashing and debugging. Seems to work relatively well. Due to time sync issues, the test target may trigger two builds, but it's not that big of a deal and keeps the user in vagrant for most of the work. They'll still need to be in macOS to run minicom, but it's better than nothing.
Edit: I've fixed the double build by forcing make to consider the debug target to be old. I'm only going to bother supporting running one test.
We may want to add the script to the box repo?","From what I remember, when running make program from my Mac, there files get rebuilt, even though I had just built the project in vagrant. This for me resulted in segfault cuz I had  arm gcc v7. But I'm guessing the intent here is to do the building on vagrant and only the flashing on Mac right?
Idk what exactly triggers a rebuild on the Mac side. I'm guessing it's probably because the difference in the system clock between my mac and vagrant?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,177,2018-05-06T06:18:27Z,2018-05-11T23:00:19Z,2018-05-11T23:00:22Z,MERGED,True,36,0,1,https://github.com/tituschow,ELEC-405: Add workaround for programmer on macOS hosts,5,[],https://github.com/uw-midsun/firmware/pull/177,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/177#issuecomment-386891325,"Tested on a new Vagrant box in conjunction with the macOS USB Workaround.
It just sets up a key-based ssh server on the host that the box can SSH into for flashing and debugging. Seems to work relatively well. Due to time sync issues, the test target may trigger two builds, but it's not that big of a deal and keeps the user in vagrant for most of the work. They'll still need to be in macOS to run minicom, but it's better than nothing.
Edit: I've fixed the double build by forcing make to consider the debug target to be old. I'm only going to bother supporting running one test.
We may want to add the script to the box repo?","No, this builds on mac. I install gcc-arm-embedded 6-2017-q2-update.",True,{'THUMBS_UP': ['https://github.com/ArshanKhanifar']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,177,2018-05-06T06:18:27Z,2018-05-11T23:00:19Z,2018-05-11T23:00:22Z,MERGED,True,36,0,1,https://github.com/tituschow,ELEC-405: Add workaround for programmer on macOS hosts,5,[],https://github.com/uw-midsun/firmware/pull/177,https://github.com/ArshanKhanifar,4,https://github.com/uw-midsun/firmware/pull/177#issuecomment-386891570,"Tested on a new Vagrant box in conjunction with the macOS USB Workaround.
It just sets up a key-based ssh server on the host that the box can SSH into for flashing and debugging. Seems to work relatively well. Due to time sync issues, the test target may trigger two builds, but it's not that big of a deal and keeps the user in vagrant for most of the work. They'll still need to be in macOS to run minicom, but it's better than nothing.
Edit: I've fixed the double build by forcing make to consider the debug target to be old. I'm only going to bother supporting running one test.
We may want to add the script to the box repo?",What's the benefit of this? Consistency in vagrant for multiple platforms?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,177,2018-05-06T06:18:27Z,2018-05-11T23:00:19Z,2018-05-11T23:00:22Z,MERGED,True,36,0,1,https://github.com/tituschow,ELEC-405: Add workaround for programmer on macOS hosts,5,[],https://github.com/uw-midsun/firmware/pull/177,https://github.com/tituschow,5,https://github.com/uw-midsun/firmware/pull/177#issuecomment-386892463,"Tested on a new Vagrant box in conjunction with the macOS USB Workaround.
It just sets up a key-based ssh server on the host that the box can SSH into for flashing and debugging. Seems to work relatively well. Due to time sync issues, the test target may trigger two builds, but it's not that big of a deal and keeps the user in vagrant for most of the work. They'll still need to be in macOS to run minicom, but it's better than nothing.
Edit: I've fixed the double build by forcing make to consider the debug target to be old. I'm only going to bother supporting running one test.
We may want to add the script to the box repo?",You can't program or debug in vagrant on mac hosts without this. Please see ELEC-405 for context.,True,{'THUMBS_UP': ['https://github.com/ArshanKhanifar']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,177,2018-05-06T06:18:27Z,2018-05-11T23:00:19Z,2018-05-11T23:00:22Z,MERGED,True,36,0,1,https://github.com/tituschow,ELEC-405: Add workaround for programmer on macOS hosts,5,[],https://github.com/uw-midsun/firmware/pull/177,https://github.com/tituschow,6,https://github.com/uw-midsun/firmware/pull/177#issuecomment-387609331,"Tested on a new Vagrant box in conjunction with the macOS USB Workaround.
It just sets up a key-based ssh server on the host that the box can SSH into for flashing and debugging. Seems to work relatively well. Due to time sync issues, the test target may trigger two builds, but it's not that big of a deal and keeps the user in vagrant for most of the work. They'll still need to be in macOS to run minicom, but it's better than nothing.
Edit: I've fixed the double build by forcing make to consider the debug target to be old. I'm only going to bother supporting running one test.
We may want to add the script to the box repo?",Thoughts on adding the script to the box repo @ckitagawa @karlding?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,178,2018-05-06T20:29:10Z,2018-05-12T18:55:38Z,2018-06-11T07:48:02Z,CLOSED,False,684,54,12,https://github.com/tituschow,ELEC-382: Pedal Calibration (Updated),30,[],https://github.com/uw-midsun/firmware/pull/178,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/178,"Cleaned up some parts of the pedal calibration. Adds a new bounds tolerance value and desync counter to handle rapid pedal changes.
The general idea is that given two points of measurement, we can find the slope equations for both channels of the pedal. Since there's the potential for ripple and rounding error in our measurements, we select the channel with a larger range to be the primary channel and record the min/max for each point. That line is used to determine the pedal percentage and the secondary channel is used to validate it using the min/max as a tolerance.
I found that rapid pedal changes can cause the reading to go slightly out-of-bounds or desync briefly due to the separate channel readings.
Some things to be fixed:

 Validating settings
 Fixing tolerance calculation - with the desync counter, the width value should hopefully work? It needs to be greater than 0 though
 Test needs to be fixed
 Remove throttle storage from calibration storage","Cleaned up some parts of the pedal calibration. Adds a new bounds tolerance value and desync counter to handle rapid pedal changes.
The general idea is that given two points of measurement, we can find the slope equations for both channels of the pedal. Since there's the potential for ripple and rounding error in our measurements, we select the channel with a larger range to be the primary channel and record the min/max for each point. That line is used to determine the pedal percentage and the secondary channel is used to validate it using the min/max as a tolerance.
I found that rapid pedal changes can cause the reading to go slightly out-of-bounds or desync briefly due to the separate channel readings.
Some things to be fixed:

 Validating settings
 Fixing tolerance calculation - with the desync counter, the width value should hopefully work? It needs to be greater than 0 though
 Test needs to be fixed
 Remove throttle storage from calibration storage",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,179,2018-05-06T23:09:23Z,2018-05-09T05:01:54Z,2018-05-09T05:01:57Z,MERGED,True,172,19,10,https://github.com/tituschow,ELEC-402: x86 external command server,9,[],https://github.com/uw-midsun/firmware/pull/179,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/179,"Adds support for external commands using the socket framework.
It uses the GCC constructor so it's started as long as the command framework is linked in somewhere.","Adds support for external commands using the socket framework.
It uses the GCC constructor so it's started as long as the command framework is linked in somewhere.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,180,2018-05-08T02:05:34Z,2018-05-27T04:09:50Z,2018-05-27T04:09:58Z,MERGED,True,387,15,6,https://github.com/ArshanKhanifar,ELEC-384: Lights Signal,15,['enhancement'],https://github.com/uw-midsun/firmware/pull/180,https://github.com/ArshanKhanifar,1,https://github.com/uw-midsun/firmware/pull/180,This module is an FSM for signal lights. It's pretty straightforward. Tests needed.,This module is an FSM for signal lights. It's pretty straightforward. Tests needed.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,181,2018-05-09T04:05:00Z,2018-05-10T01:03:40Z,2018-05-10T01:03:44Z,MERGED,True,32,25,6,https://github.com/ckitagawa,ELEC-355: Update codegen-tooling for Charger,3,[],https://github.com/uw-midsun/firmware/pull/181,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/181,See uw-midsun/codegen-tooling for update. Also added a line to the Makefile instructions as it was missing.,See uw-midsun/codegen-tooling for update. Also added a line to the Makefile instructions as it was missing.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,182,2018-05-09T22:09:42Z,2018-06-02T16:41:07Z,2018-06-02T16:41:11Z,MERGED,True,109,4,5,https://github.com/ArshanKhanifar,ELEC-409: Lights Strobe,10,['enhancement'],https://github.com/uw-midsun/firmware/pull/182,https://github.com/ArshanKhanifar,1,https://github.com/uw-midsun/firmware/pull/182,"This is the lights_strobe module, it uses lights_blinker. It's pretty simple, and contains tests.","This is the lights_strobe module, it uses lights_blinker. It's pretty simple, and contains tests.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,183,2018-05-10T01:35:12Z,2018-05-12T20:35:06Z,2018-05-12T20:35:09Z,MERGED,True,489,0,10,https://github.com/ckitagawa,ELEC-355: Charger Notify-Command,14,[],https://github.com/uw-midsun/firmware/pull/183,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/183,"This PR fills in both sides of the connection between Chaos and the Charger. The exchange is as follows:

Charger is connected and notifies Chaos it is connected at some interval. This is periodic to avoid Chaos having to know at what period the charger is expecting responses such that the Charger watchdog doesn't fire. Instead Chaos just responds to every message with a command of whether or not to charge. Since the charger will only be connected in situations where the car is presumably at a charging station this will not flood the CAN bus.
Once Chaos is in the charging state it responds to these requests with a command to close the relay.
If Chaos exits charging it sends a disconnect message instead of a connect message when responding to notifications.
Once the Charger is disconnected it sends a single disconnect to signal it is finished. This is primarily for telemetry purposes.

From the perspective of Chaos the Charger is essentially a ""Smart Relay"" with the ability to open itself in an emergency or if disconnected.","This PR fills in both sides of the connection between Chaos and the Charger. The exchange is as follows:

Charger is connected and notifies Chaos it is connected at some interval. This is periodic to avoid Chaos having to know at what period the charger is expecting responses such that the Charger watchdog doesn't fire. Instead Chaos just responds to every message with a command of whether or not to charge. Since the charger will only be connected in situations where the car is presumably at a charging station this will not flood the CAN bus.
Once Chaos is in the charging state it responds to these requests with a command to close the relay.
If Chaos exits charging it sends a disconnect message instead of a connect message when responding to notifications.
Once the Charger is disconnected it sends a single disconnect to signal it is finished. This is primarily for telemetry purposes.

From the perspective of Chaos the Charger is essentially a ""Smart Relay"" with the ability to open itself in an emergency or if disconnected.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,183,2018-05-10T01:35:12Z,2018-05-12T20:35:06Z,2018-05-12T20:35:09Z,MERGED,True,489,0,10,https://github.com/ckitagawa,ELEC-355: Charger Notify-Command,14,[],https://github.com/uw-midsun/firmware/pull/183,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/183#issuecomment-388174202,"This PR fills in both sides of the connection between Chaos and the Charger. The exchange is as follows:

Charger is connected and notifies Chaos it is connected at some interval. This is periodic to avoid Chaos having to know at what period the charger is expecting responses such that the Charger watchdog doesn't fire. Instead Chaos just responds to every message with a command of whether or not to charge. Since the charger will only be connected in situations where the car is presumably at a charging station this will not flood the CAN bus.
Once Chaos is in the charging state it responds to these requests with a command to close the relay.
If Chaos exits charging it sends a disconnect message instead of a connect message when responding to notifications.
Once the Charger is disconnected it sends a single disconnect to signal it is finished. This is primarily for telemetry purposes.

From the perspective of Chaos the Charger is essentially a ""Smart Relay"" with the ability to open itself in an emergency or if disconnected.",Could we write an integration test to verify behavior between programs? We have the x86 command server now.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,184,2018-05-12T18:54:40Z,2018-05-15T01:22:38Z,2018-05-15T01:22:41Z,MERGED,True,462,76,11,https://github.com/tituschow,ELEC-382: Pedal Calibration,11,[],https://github.com/uw-midsun/firmware/pull/184,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/184,"Uses the same idea as previous implementation. From the header:
// Module goals:
// * Determine primary (higher resolution) channel
// * Find equation for voltage/LSB -> percentage (two-point form)
// * Calculate sync tolerance for secondary (lower resolution) channel
// * Calculate maximum bounds of each zone
//
// Tolerances:
// * Sync tolerance: Maximum difference between calculated percentages of the channels
//                   due to precision errors - note that this only handles steady-state error
//                   and we allow some amount of desync while the pedal is changing rapidly.
// * Sync tolerance safety factor: Additional multiplier to the tolerance value
// * Bounds tolerance: Additional percentage extension to the valid zones of our endpoints to
//                     account for observed over/undervoltage conditions in rapid position changes.

To run, flash test_throttle_calibration. There's another test test_throttle_calibration_math that I found useful for sanity-checking.
Persistance will probably come later.","Uses the same idea as previous implementation. From the header:
// Module goals:
// * Determine primary (higher resolution) channel
// * Find equation for voltage/LSB -> percentage (two-point form)
// * Calculate sync tolerance for secondary (lower resolution) channel
// * Calculate maximum bounds of each zone
//
// Tolerances:
// * Sync tolerance: Maximum difference between calculated percentages of the channels
//                   due to precision errors - note that this only handles steady-state error
//                   and we allow some amount of desync while the pedal is changing rapidly.
// * Sync tolerance safety factor: Additional multiplier to the tolerance value
// * Bounds tolerance: Additional percentage extension to the valid zones of our endpoints to
//                     account for observed over/undervoltage conditions in rapid position changes.

To run, flash test_throttle_calibration. There's another test test_throttle_calibration_math that I found useful for sanity-checking.
Persistance will probably come later.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,185,2018-05-12T21:33:52Z,2018-06-24T17:00:43Z,2018-06-24T17:00:47Z,MERGED,True,596,33,11,https://github.com/Derpalooza,ELEC-387: Current Module Calibration,77,[],https://github.com/uw-midsun/firmware/pull/185,https://github.com/Derpalooza,1,https://github.com/uw-midsun/firmware/pull/185,"Module to correct the voltage offset for the LTC ADC, and calculate current using the calibrated voltage.","Module to correct the voltage offset for the LTC ADC, and calculate current using the calibrated voltage.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,185,2018-05-12T21:33:52Z,2018-06-24T17:00:43Z,2018-06-24T17:00:47Z,MERGED,True,596,33,11,https://github.com/Derpalooza,ELEC-387: Current Module Calibration,77,[],https://github.com/uw-midsun/firmware/pull/185,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/185#issuecomment-388673645,"Module to correct the voltage offset for the LTC ADC, and calculate current using the calibrated voltage.","Please add a test that demonstrates example usage.
The goal of this module should be to easily provide current values so we can test it for overcurrent conditions or output the value for telemetry. Also, a calibration process is preferred over a hardcoded value.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,185,2018-05-12T21:33:52Z,2018-06-24T17:00:43Z,2018-06-24T17:00:47Z,MERGED,True,596,33,11,https://github.com/Derpalooza,ELEC-387: Current Module Calibration,77,[],https://github.com/uw-midsun/firmware/pull/185,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/185#issuecomment-396026928,"Module to correct the voltage offset for the LTC ADC, and calculate current using the calibrated voltage.",Note that I've seen the zero point change when the chip is reset. I would suggest supporting zeroing the current in the application. We know 0A are flowing when the relays are open.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,186,2018-05-15T01:19:52Z,2018-05-19T21:12:08Z,2018-05-19T21:12:11Z,MERGED,True,469,14,9,https://github.com/ckitagawa,ELEC-355: Finish Charger,9,[],https://github.com/uw-midsun/firmware/pull/186,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/186,"This PR implements the main() of the Charger, adds Configuration files and adds the global control FSM.
With this the bulk of the charger firmware is finished. The remaining details require finalized hardware specs and designs.
Note that the following are still not finalized:

Transmission period for notify/command
Whether to re-broadcast status messages from the charger over Network CAN.
charger_pin.h will need modification as it may require an ADC or PWM input rather than being interrupt driven for status reasons. (Although CAN already has all this data so this is wholly redundant).
Whether an external Relay control (not over CAN) is necessary. If so this is a simple addition of a GPIO pin which can either be added directly to the FSM or merged into charger_controller

@taipingli do you have any of these details finalized?","This PR implements the main() of the Charger, adds Configuration files and adds the global control FSM.
With this the bulk of the charger firmware is finished. The remaining details require finalized hardware specs and designs.
Note that the following are still not finalized:

Transmission period for notify/command
Whether to re-broadcast status messages from the charger over Network CAN.
charger_pin.h will need modification as it may require an ADC or PWM input rather than being interrupt driven for status reasons. (Although CAN already has all this data so this is wholly redundant).
Whether an external Relay control (not over CAN) is necessary. If so this is a simple addition of a GPIO pin which can either be added directly to the FSM or merged into charger_controller

@taipingli do you have any of these details finalized?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,186,2018-05-15T01:19:52Z,2018-05-19T21:12:08Z,2018-05-19T21:12:11Z,MERGED,True,469,14,9,https://github.com/ckitagawa,ELEC-355: Finish Charger,9,[],https://github.com/uw-midsun/firmware/pull/186,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/186#issuecomment-389520550,"This PR implements the main() of the Charger, adds Configuration files and adds the global control FSM.
With this the bulk of the charger firmware is finished. The remaining details require finalized hardware specs and designs.
Note that the following are still not finalized:

Transmission period for notify/command
Whether to re-broadcast status messages from the charger over Network CAN.
charger_pin.h will need modification as it may require an ADC or PWM input rather than being interrupt driven for status reasons. (Although CAN already has all this data so this is wholly redundant).
Whether an external Relay control (not over CAN) is necessary. If so this is a simple addition of a GPIO pin which can either be added directly to the FSM or merged into charger_controller

@taipingli do you have any of these details finalized?",The charger board should be controlling its own relay that connects/disconnects the vehicle charger to/from the HV system.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,186,2018-05-15T01:19:52Z,2018-05-19T21:12:08Z,2018-05-19T21:12:11Z,MERGED,True,469,14,9,https://github.com/ckitagawa,ELEC-355: Finish Charger,9,[],https://github.com/uw-midsun/firmware/pull/186,https://github.com/ckitagawa,3,https://github.com/uw-midsun/firmware/pull/186#issuecomment-390424344,"This PR implements the main() of the Charger, adds Configuration files and adds the global control FSM.
With this the bulk of the charger firmware is finished. The remaining details require finalized hardware specs and designs.
Note that the following are still not finalized:

Transmission period for notify/command
Whether to re-broadcast status messages from the charger over Network CAN.
charger_pin.h will need modification as it may require an ADC or PWM input rather than being interrupt driven for status reasons. (Although CAN already has all this data so this is wholly redundant).
Whether an external Relay control (not over CAN) is necessary. If so this is a simple addition of a GPIO pin which can either be added directly to the FSM or merged into charger_controller

@taipingli do you have any of these details finalized?",Added relay support as mentioned to charger_controller.c.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,187,2018-05-15T02:08:54Z,2018-05-16T01:09:07Z,2018-05-16T01:09:13Z,MERGED,True,2,0,1,https://github.com/ckitagawa,ELEC-105: Fix error in test_charger.c,1,[],https://github.com/uw-midsun/firmware/pull/187,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/187,I have no idea how this was passing Travis or on my machine previously. The latest glibc on my machine (as of yesterday) just segfaults when I forget to init timers...,I have no idea how this was passing Travis or on my machine previously. The latest glibc on my machine (as of yesterday) just segfaults when I forget to init timers...,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,188,2018-05-19T19:11:57Z,2018-05-21T21:34:43Z,2018-05-21T21:34:45Z,MERGED,True,250,0,3,https://github.com/ckitagawa,ELEC-423: Relay RX,6,[],https://github.com/uw-midsun/firmware/pull/188,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/188,"A generic Relay RX module that allows for easy registry of Relay RX handlers which handle a simple single field uint8_t CAN message. If the state is valid the registered handler will run. It is expected that the handler will usually trigger one or more GPIO pins although this isn't dictated as it may be useful for other purposes. This is really just a fancy wrapper over can_register_rx_handler specialized for the purposes of a relay.
The reason this isn't a simple GPIO pin state over CAN protocol is that some modules may have multiple GPIO pins to trigger or may want to raise an event or save state when the relay changes.","A generic Relay RX module that allows for easy registry of Relay RX handlers which handle a simple single field uint8_t CAN message. If the state is valid the registered handler will run. It is expected that the handler will usually trigger one or more GPIO pins although this isn't dictated as it may be useful for other purposes. This is really just a fancy wrapper over can_register_rx_handler specialized for the purposes of a relay.
The reason this isn't a simple GPIO pin state over CAN protocol is that some modules may have multiple GPIO pins to trigger or may want to raise an event or save state when the relay changes.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,189,2018-05-19T20:17:27Z,2018-05-21T18:28:10Z,2018-05-21T18:28:16Z,MERGED,True,187,0,3,https://github.com/ckitagawa,ELEC-424: Heartbeat Handler,5,[],https://github.com/uw-midsun/firmware/pull/189,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/189,A simple module to register a handler for heartbeats. This simply reduces the heartbeat handling to a single handler which must be registers. In most cases returning true from the handler is sufficient (use heartbeat_rx_auto_ack). If more complex behavior is required a custom handler can be registered.,A simple module to register a handler for heartbeats. This simply reduces the heartbeat handling to a single handler which must be registers. In most cases returning true from the handler is sufficient (use heartbeat_rx_auto_ack). If more complex behavior is required a custom handler can be registered.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,190,2018-05-19T21:40:05Z,2018-06-01T00:24:25Z,2018-06-01T00:24:25Z,CLOSED,False,488,77,19,https://github.com/ckitagawa,ELEC-105: Chaos <-> Driver Controls CAN interface,25,[],https://github.com/uw-midsun/firmware/pull/190,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/190,"This PR adds the state handler for driver controls messages to Chaos and adds a corresponding controller to Driver Controls.
It also cleans up a rather significant preemption bug with the sequencer wherein it was possible for the Emergency state to start a transition in the middle of another state transition resulting in a possibly invalid state. This also allows for safely queuing state events from driver controls.
During the process of fixing preemption I cleaned up a number of tests, closed a number of TODOs, and updated sequences.
Remaining Chaos Tasks:

Main loop
Configuration of pins","This PR adds the state handler for driver controls messages to Chaos and adds a corresponding controller to Driver Controls.
It also cleans up a rather significant preemption bug with the sequencer wherein it was possible for the Emergency state to start a transition in the middle of another state transition resulting in a possibly invalid state. This also allows for safely queuing state events from driver controls.
During the process of fixing preemption I cleaned up a number of tests, closed a number of TODOs, and updated sequences.
Remaining Chaos Tasks:

Main loop
Configuration of pins",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,190,2018-05-19T21:40:05Z,2018-06-01T00:24:25Z,2018-06-01T00:24:25Z,CLOSED,False,488,77,19,https://github.com/ckitagawa,ELEC-105: Chaos <-> Driver Controls CAN interface,25,[],https://github.com/uw-midsun/firmware/pull/190,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/190#issuecomment-391198510,"This PR adds the state handler for driver controls messages to Chaos and adds a corresponding controller to Driver Controls.
It also cleans up a rather significant preemption bug with the sequencer wherein it was possible for the Emergency state to start a transition in the middle of another state transition resulting in a possibly invalid state. This also allows for safely queuing state events from driver controls.
During the process of fixing preemption I cleaned up a number of tests, closed a number of TODOs, and updated sequences.
Remaining Chaos Tasks:

Main loop
Configuration of pins","With this new update note that Chaos utilizes 3 tiers of events:

HIGH Emergency state.
NORMAL FSM transition behaviors and CAN (although TX should maybe be HIGH as discussed).
LOW Sequence transitions other than emergency.

When an Emergency preempts another transition midway through the following occurs:

The sequencer will transition to EMERGENCY.
The first event of that type will be raised this is now a unique sentinel value to look for in the event_queue
The sequencer will await that sentinel event effectively flushing any events stuck in the event_queue from the previous transition.

This is much cleaner than previous messiness with the guarded raise.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,190,2018-05-19T21:40:05Z,2018-06-01T00:24:25Z,2018-06-01T00:24:25Z,CLOSED,False,488,77,19,https://github.com/ckitagawa,ELEC-105: Chaos <-> Driver Controls CAN interface,25,[],https://github.com/uw-midsun/firmware/pull/190,https://github.com/ckitagawa,3,https://github.com/uw-midsun/firmware/pull/190#issuecomment-391198583,"This PR adds the state handler for driver controls messages to Chaos and adds a corresponding controller to Driver Controls.
It also cleans up a rather significant preemption bug with the sequencer wherein it was possible for the Emergency state to start a transition in the middle of another state transition resulting in a possibly invalid state. This also allows for safely queuing state events from driver controls.
During the process of fixing preemption I cleaned up a number of tests, closed a number of TODOs, and updated sequences.
Remaining Chaos Tasks:

Main loop
Configuration of pins",@tituschow this is ready for re-review.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,190,2018-05-19T21:40:05Z,2018-06-01T00:24:25Z,2018-06-01T00:24:25Z,CLOSED,False,488,77,19,https://github.com/ckitagawa,ELEC-105: Chaos <-> Driver Controls CAN interface,25,[],https://github.com/uw-midsun/firmware/pull/190,https://github.com/ckitagawa,4,https://github.com/uw-midsun/firmware/pull/190#issuecomment-393722548,"This PR adds the state handler for driver controls messages to Chaos and adds a corresponding controller to Driver Controls.
It also cleans up a rather significant preemption bug with the sequencer wherein it was possible for the Emergency state to start a transition in the middle of another state transition resulting in a possibly invalid state. This also allows for safely queuing state events from driver controls.
During the process of fixing preemption I cleaned up a number of tests, closed a number of TODOs, and updated sequences.
Remaining Chaos Tasks:

Main loop
Configuration of pins",Closing to do a rather large refactoring.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,191,2018-05-19T22:34:18Z,2018-11-17T18:09:13Z,2018-11-17T18:09:21Z,MERGED,True,599,19,5,https://github.com/mishazharov,ELEC-71: Adding NMEA parser,28,[],https://github.com/uw-midsun/firmware/pull/191,https://github.com/mishazharov,1,https://github.com/uw-midsun/firmware/pull/191,Adding a NMEA parser for the GPS driver,Adding a NMEA parser for the GPS driver,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,191,2018-05-19T22:34:18Z,2018-11-17T18:09:13Z,2018-11-17T18:09:21Z,MERGED,True,599,19,5,https://github.com/mishazharov,ELEC-71: Adding NMEA parser,28,[],https://github.com/uw-midsun/firmware/pull/191,https://github.com/mishazharov,2,https://github.com/uw-midsun/firmware/pull/191#issuecomment-392297961,Adding a NMEA parser for the GPS driver,"I see the build error, will fix tomorrow",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,191,2018-05-19T22:34:18Z,2018-11-17T18:09:13Z,2018-11-17T18:09:21Z,MERGED,True,599,19,5,https://github.com/mishazharov,ELEC-71: Adding NMEA parser,28,[],https://github.com/uw-midsun/firmware/pull/191,https://github.com/mishazharov,3,https://github.com/uw-midsun/firmware/pull/191#issuecomment-393384729,Adding a NMEA parser for the GPS driver,"EDIT: We decided to keep parsing on the telemetry board, see the relevant discussions below
So I'm going to rework this module with the following changes:

The NMEA structs will have a copy of the original message
Fields will not longer be parsed into their appropriate data types, I will keep them as strings with the exception of:

UTC time
Position
Direction + Speed
Position fix / validity of data



This is because we don't need all the data types / fields on the controller board since telemetry data will be sent to the chase car anyway. The real parsing can then be done on the telemetry server. I'm going to implement these changes soon (so please don't review my last commit, it will be superseded soon). Just sent it up to keep the other changes in git history",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,191,2018-05-19T22:34:18Z,2018-11-17T18:09:13Z,2018-11-17T18:09:21Z,MERGED,True,599,19,5,https://github.com/mishazharov,ELEC-71: Adding NMEA parser,28,[],https://github.com/uw-midsun/firmware/pull/191,https://github.com/tituschow,4,https://github.com/uw-midsun/firmware/pull/191#issuecomment-393397410,Adding a NMEA parser for the GPS driver,Is there a reason why any fields should be parsed if you're just sending it to the chase car?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,191,2018-05-19T22:34:18Z,2018-11-17T18:09:13Z,2018-11-17T18:09:21Z,MERGED,True,599,19,5,https://github.com/mishazharov,ELEC-71: Adding NMEA parser,28,[],https://github.com/uw-midsun/firmware/pull/191,https://github.com/mishazharov,5,https://github.com/uw-midsun/firmware/pull/191#issuecomment-393734252,Adding a NMEA parser for the GPS driver,"After a quick discussion, we decided that there will be no parsing or checksum computations on the controller board",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,191,2018-05-19T22:34:18Z,2018-11-17T18:09:13Z,2018-11-17T18:09:21Z,MERGED,True,599,19,5,https://github.com/mishazharov,ELEC-71: Adding NMEA parser,28,[],https://github.com/uw-midsun/firmware/pull/191,https://github.com/myh999,6,https://github.com/uw-midsun/firmware/pull/191#issuecomment-435640412,Adding a NMEA parser for the GPS driver,"Re-opening this PR to allow for NMEA parsing on the board.
Relevant discussion",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,191,2018-05-19T22:34:18Z,2018-11-17T18:09:13Z,2018-11-17T18:09:21Z,MERGED,True,599,19,5,https://github.com/mishazharov,ELEC-71: Adding NMEA parser,28,[],https://github.com/uw-midsun/firmware/pull/191,https://github.com/ashraf2047,7,https://github.com/uw-midsun/firmware/pull/191#issuecomment-439636182,Adding a NMEA parser for the GPS driver,LGTM,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,192,2018-05-19T22:54:57Z,2019-03-25T00:15:35Z,2019-03-25T00:15:35Z,CLOSED,False,204,3,3,https://github.com/thomaskidd,ELEC-346: x86 UART,11,[],https://github.com/uw-midsun/firmware/pull/192,https://github.com/thomaskidd,1,https://github.com/uw-midsun/firmware/pull/192,"The x86 version of uart.c and the new python script, which handles the external connections (libraries/ms-common/test/test_x86_uart.py, not sure if this is in the right location), are the only files needed to emulate serial communication. Users specify which programs and which uart ports they want to connect in the python file.","The x86 version of uart.c and the new python script, which handles the external connections (libraries/ms-common/test/test_x86_uart.py, not sure if this is in the right location), are the only files needed to emulate serial communication. Users specify which programs and which uart ports they want to connect in the python file.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,192,2018-05-19T22:54:57Z,2019-03-25T00:15:35Z,2019-03-25T00:15:35Z,CLOSED,False,204,3,3,https://github.com/thomaskidd,ELEC-346: x86 UART,11,[],https://github.com/uw-midsun/firmware/pull/192,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/192#issuecomment-390517177,"The x86 version of uart.c and the new python script, which handles the external connections (libraries/ms-common/test/test_x86_uart.py, not sure if this is in the right location), are the only files needed to emulate serial communication. Users specify which programs and which uart ports they want to connect in the python file.",Please make sure your build passes. We generally don't review until build passes because it catches simple mistakes so we don't waste time commenting on things you need to fix to make the build pass.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,192,2018-05-19T22:54:57Z,2019-03-25T00:15:35Z,2019-03-25T00:15:35Z,CLOSED,False,204,3,3,https://github.com/thomaskidd,ELEC-346: x86 UART,11,[],https://github.com/uw-midsun/firmware/pull/192,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/192#issuecomment-392614366,"The x86 version of uart.c and the new python script, which handles the external connections (libraries/ms-common/test/test_x86_uart.py, not sure if this is in the right location), are the only files needed to emulate serial communication. Users specify which programs and which uart ports they want to connect in the python file.","If the priority is to get this merged in, you can move the python script to a new PR. It would be nice to have a unit test just as an example.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,192,2018-05-19T22:54:57Z,2019-03-25T00:15:35Z,2019-03-25T00:15:35Z,CLOSED,False,204,3,3,https://github.com/thomaskidd,ELEC-346: x86 UART,11,[],https://github.com/uw-midsun/firmware/pull/192,https://github.com/ashraf2047,4,https://github.com/uw-midsun/firmware/pull/192#issuecomment-456965221,"The x86 version of uart.c and the new python script, which handles the external connections (libraries/ms-common/test/test_x86_uart.py, not sure if this is in the right location), are the only files needed to emulate serial communication. Users specify which programs and which uart ports they want to connect in the python file.",@thomaskidd what is the status of this PR? could you revisit it and address any outstanding reviews/comments when you get the chance?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,193,2018-05-21T23:39:28Z,2018-05-22T00:11:02Z,2018-05-22T00:11:07Z,MERGED,True,91,25,5,https://github.com/ckitagawa,ELEC-425: Priority FIFO Event Queue,3,[],https://github.com/uw-midsun/firmware/pull/193,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/193,"This change make the previously priority queue based event_queue module into a tiered priority FIFO queue.
The new behavior is as follows:

event_raise is now just a FIFO of NORMAL priority.
event_raise_priority allows events to be enqueued into one of five different priority FIFOs: LOWEST, LOW, NORMAL, HIGH, HIGHEST.
event_process extracts an event from the highest priority FIFO that contains an event.
event_queue_init is unchanged in it's behavior.

This has affected a single test which is updated with a fix.
It should be noted that CAN should be modified to allow events to be raised into a selected priority of event queue not just the NORMAL level (alternatively HIGH by default maybe?). This requires widespread changes to lots of locations as CANSettings structs across the codebase will need updating. I propose doing this in a separate change. The queue project may also require updates.
Other than this it appears all uses of event_queue are in projects which are not expecting specific priority queue behavior (i.e. they either expected a FIFO to start with or the tests behave normally with a single FIFO) . Chaos obviously being the exception that I am aware of.","This change make the previously priority queue based event_queue module into a tiered priority FIFO queue.
The new behavior is as follows:

event_raise is now just a FIFO of NORMAL priority.
event_raise_priority allows events to be enqueued into one of five different priority FIFOs: LOWEST, LOW, NORMAL, HIGH, HIGHEST.
event_process extracts an event from the highest priority FIFO that contains an event.
event_queue_init is unchanged in it's behavior.

This has affected a single test which is updated with a fix.
It should be noted that CAN should be modified to allow events to be raised into a selected priority of event queue not just the NORMAL level (alternatively HIGH by default maybe?). This requires widespread changes to lots of locations as CANSettings structs across the codebase will need updating. I propose doing this in a separate change. The queue project may also require updates.
Other than this it appears all uses of event_queue are in projects which are not expecting specific priority queue behavior (i.e. they either expected a FIFO to start with or the tests behave normally with a single FIFO) . Chaos obviously being the exception that I am aware of.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,193,2018-05-21T23:39:28Z,2018-05-22T00:11:02Z,2018-05-22T00:11:07Z,MERGED,True,91,25,5,https://github.com/ckitagawa,ELEC-425: Priority FIFO Event Queue,3,[],https://github.com/uw-midsun/firmware/pull/193,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/193#issuecomment-390817635,"This change make the previously priority queue based event_queue module into a tiered priority FIFO queue.
The new behavior is as follows:

event_raise is now just a FIFO of NORMAL priority.
event_raise_priority allows events to be enqueued into one of five different priority FIFOs: LOWEST, LOW, NORMAL, HIGH, HIGHEST.
event_process extracts an event from the highest priority FIFO that contains an event.
event_queue_init is unchanged in it's behavior.

This has affected a single test which is updated with a fix.
It should be noted that CAN should be modified to allow events to be raised into a selected priority of event queue not just the NORMAL level (alternatively HIGH by default maybe?). This requires widespread changes to lots of locations as CANSettings structs across the codebase will need updating. I propose doing this in a separate change. The queue project may also require updates.
Other than this it appears all uses of event_queue are in projects which are not expecting specific priority queue behavior (i.e. they either expected a FIFO to start with or the tests behave normally with a single FIFO) . Chaos obviously being the exception that I am aware of.","@tituschow @karlding @Derpalooza I propose making event_raise within CAN into event_raise_priority(EVENT_PRIORITY_HIGH, ...); as I don't really want to mess with a large number of CANSettings and it makes sense for CAN to usually be higher priority. However, I'm open to discussion.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,193,2018-05-21T23:39:28Z,2018-05-22T00:11:02Z,2018-05-22T00:11:07Z,MERGED,True,91,25,5,https://github.com/ckitagawa,ELEC-425: Priority FIFO Event Queue,3,[],https://github.com/uw-midsun/firmware/pull/193,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/193#issuecomment-390818320,"This change make the previously priority queue based event_queue module into a tiered priority FIFO queue.
The new behavior is as follows:

event_raise is now just a FIFO of NORMAL priority.
event_raise_priority allows events to be enqueued into one of five different priority FIFOs: LOWEST, LOW, NORMAL, HIGH, HIGHEST.
event_process extracts an event from the highest priority FIFO that contains an event.
event_queue_init is unchanged in it's behavior.

This has affected a single test which is updated with a fix.
It should be noted that CAN should be modified to allow events to be raised into a selected priority of event queue not just the NORMAL level (alternatively HIGH by default maybe?). This requires widespread changes to lots of locations as CANSettings structs across the codebase will need updating. I propose doing this in a separate change. The queue project may also require updates.
Other than this it appears all uses of event_queue are in projects which are not expecting specific priority queue behavior (i.e. they either expected a FIFO to start with or the tests behave normally with a single FIFO) . Chaos obviously being the exception that I am aware of.","Yeah, I doubt anyone will bother changing the priority. I'm a little wary of making CAN high priority, since that would make it possible to flood the event queue and block all normal priority events. Is there a reason CAN processing needs to be high priority?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,193,2018-05-21T23:39:28Z,2018-05-22T00:11:02Z,2018-05-22T00:11:07Z,MERGED,True,91,25,5,https://github.com/ckitagawa,ELEC-425: Priority FIFO Event Queue,3,[],https://github.com/uw-midsun/firmware/pull/193,https://github.com/ckitagawa,4,https://github.com/uw-midsun/firmware/pull/193#issuecomment-390819749,"This change make the previously priority queue based event_queue module into a tiered priority FIFO queue.
The new behavior is as follows:

event_raise is now just a FIFO of NORMAL priority.
event_raise_priority allows events to be enqueued into one of five different priority FIFOs: LOWEST, LOW, NORMAL, HIGH, HIGHEST.
event_process extracts an event from the highest priority FIFO that contains an event.
event_queue_init is unchanged in it's behavior.

This has affected a single test which is updated with a fix.
It should be noted that CAN should be modified to allow events to be raised into a selected priority of event queue not just the NORMAL level (alternatively HIGH by default maybe?). This requires widespread changes to lots of locations as CANSettings structs across the codebase will need updating. I propose doing this in a separate change. The queue project may also require updates.
Other than this it appears all uses of event_queue are in projects which are not expecting specific priority queue behavior (i.e. they either expected a FIFO to start with or the tests behave normally with a single FIFO) . Chaos obviously being the exception that I am aware of.",For Chaos this used to be important due to the relay retry logic to take precedence over everything else although now that it is a FIFO I suppose making it NORMAL priority is fine? Now the logic is more that I expect that as soon as I request a CAN TX its the first thing that happens is the TX. It is rather unintuitive that a bunch of other stuff might happen beforehand. I suppose the same was true before but I always made the CAN events have very low IDs for this reason.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,193,2018-05-21T23:39:28Z,2018-05-22T00:11:02Z,2018-05-22T00:11:07Z,MERGED,True,91,25,5,https://github.com/ckitagawa,ELEC-425: Priority FIFO Event Queue,3,[],https://github.com/uw-midsun/firmware/pull/193,https://github.com/tituschow,5,https://github.com/uw-midsun/firmware/pull/193#issuecomment-390820835,"This change make the previously priority queue based event_queue module into a tiered priority FIFO queue.
The new behavior is as follows:

event_raise is now just a FIFO of NORMAL priority.
event_raise_priority allows events to be enqueued into one of five different priority FIFOs: LOWEST, LOW, NORMAL, HIGH, HIGHEST.
event_process extracts an event from the highest priority FIFO that contains an event.
event_queue_init is unchanged in it's behavior.

This has affected a single test which is updated with a fix.
It should be noted that CAN should be modified to allow events to be raised into a selected priority of event queue not just the NORMAL level (alternatively HIGH by default maybe?). This requires widespread changes to lots of locations as CANSettings structs across the codebase will need updating. I propose doing this in a separate change. The queue project may also require updates.
Other than this it appears all uses of event_queue are in projects which are not expecting specific priority queue behavior (i.e. they either expected a FIFO to start with or the tests behave normally with a single FIFO) . Chaos obviously being the exception that I am aware of.","Hmm, we could make CAN TX high priority and RX normal priority? I'm assuming that if we manage to generate enough CAN TX events to flood the event queue the main firmware is also locked up. The concern was mostly RX events and their handlers blocking other events.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,193,2018-05-21T23:39:28Z,2018-05-22T00:11:02Z,2018-05-22T00:11:07Z,MERGED,True,91,25,5,https://github.com/ckitagawa,ELEC-425: Priority FIFO Event Queue,3,[],https://github.com/uw-midsun/firmware/pull/193,https://github.com/ckitagawa,6,https://github.com/uw-midsun/firmware/pull/193#issuecomment-390822038,"This change make the previously priority queue based event_queue module into a tiered priority FIFO queue.
The new behavior is as follows:

event_raise is now just a FIFO of NORMAL priority.
event_raise_priority allows events to be enqueued into one of five different priority FIFOs: LOWEST, LOW, NORMAL, HIGH, HIGHEST.
event_process extracts an event from the highest priority FIFO that contains an event.
event_queue_init is unchanged in it's behavior.

This has affected a single test which is updated with a fix.
It should be noted that CAN should be modified to allow events to be raised into a selected priority of event queue not just the NORMAL level (alternatively HIGH by default maybe?). This requires widespread changes to lots of locations as CANSettings structs across the codebase will need updating. I propose doing this in a separate change. The queue project may also require updates.
Other than this it appears all uses of event_queue are in projects which are not expecting specific priority queue behavior (i.e. they either expected a FIFO to start with or the tests behave normally with a single FIFO) . Chaos obviously being the exception that I am aware of.",Let's make the TX a high priority then. I'll do that in a followup PR.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,194,2018-05-22T00:05:42Z,2018-05-26T20:50:14Z,2018-05-26T20:56:56Z,MERGED,True,341,9,8,https://github.com/tituschow,ELEC-406: Control stalk event generator,14,[],https://github.com/uw-midsun/firmware/pull/194,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/194,"This adds a module for creating events in response to control stalk changes. I haven't bothered to hook the new events into the actual FSMs yet due to FSM changes that are required.
Note that I've observed a potential issue with the GPIO interrupt for the MCP23008 not being processed. I have a feeling it might have to do with trying to make I2C interrupt-safe.
TODO: Add digital horn input","This adds a module for creating events in response to control stalk changes. I haven't bothered to hook the new events into the actual FSMs yet due to FSM changes that are required.
Note that I've observed a potential issue with the GPIO interrupt for the MCP23008 not being processed. I have a feeling it might have to do with trying to make I2C interrupt-safe.
TODO: Add digital horn input",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,194,2018-05-22T00:05:42Z,2018-05-26T20:50:14Z,2018-05-26T20:56:56Z,MERGED,True,341,9,8,https://github.com/tituschow,ELEC-406: Control stalk event generator,14,[],https://github.com/uw-midsun/firmware/pull/194,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/194#issuecomment-391936385,"This adds a module for creating events in response to control stalk changes. I haven't bothered to hook the new events into the actual FSMs yet due to FSM changes that are required.
Note that I've observed a potential issue with the GPIO interrupt for the MCP23008 not being processed. I have a feeling it might have to do with trying to make I2C interrupt-safe.
TODO: Add digital horn input",@ckitagawa nits have been addressed and the auto-cleanup I2C seems to be working great :),True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,195,2018-05-22T05:08:29Z,2018-05-25T04:12:12Z,2018-05-25T04:12:18Z,MERGED,True,69,18,10,https://github.com/tituschow,ELEC-430: Critical section auto-cleanup,8,[],https://github.com/uw-midsun/firmware/pull/195,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/195,"This adds a macro CRITICAL_SECTION_AUTOEND which is intended to automatically end the critical section after it loses scope. My initial implementation supported explicit critical section control as well, but I've decided to preserve the current API. The only supported usage is a single marker at the beginning of the function.
Tested on x86 and STM32. It seems that the cleanup function is only called if the the variable is actually initialized, which is good. I was worried compiler optimizations might reorder the variable declaration and initialization.
Please provide feedback on the name. I'm not a huge fan of it as is.","This adds a macro CRITICAL_SECTION_AUTOEND which is intended to automatically end the critical section after it loses scope. My initial implementation supported explicit critical section control as well, but I've decided to preserve the current API. The only supported usage is a single marker at the beginning of the function.
Tested on x86 and STM32. It seems that the cleanup function is only called if the the variable is actually initialized, which is good. I was worried compiler optimizations might reorder the variable declaration and initialization.
Please provide feedback on the name. I'm not a huge fan of it as is.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,195,2018-05-22T05:08:29Z,2018-05-25T04:12:12Z,2018-05-25T04:12:18Z,MERGED,True,69,18,10,https://github.com/tituschow,ELEC-430: Critical section auto-cleanup,8,[],https://github.com/uw-midsun/firmware/pull/195,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/195#issuecomment-391206829,"This adds a macro CRITICAL_SECTION_AUTOEND which is intended to automatically end the critical section after it loses scope. My initial implementation supported explicit critical section control as well, but I've decided to preserve the current API. The only supported usage is a single marker at the beginning of the function.
Tested on x86 and STM32. It seems that the cleanup function is only called if the the variable is actually initialized, which is good. I was worried compiler optimizations might reorder the variable declaration and initialization.
Please provide feedback on the name. I'm not a huge fan of it as is.",I'll merge once I've tested I2C and made sure the modified test passes on STM32.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,196,2018-05-23T01:01:32Z,2018-05-23T01:14:02Z,2018-05-23T01:14:06Z,MERGED,True,199,121,12,https://github.com/ckitagawa,ELEC-428: Update Codegen,1,[],https://github.com/uw-midsun/firmware/pull/196,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/196,"Updates codegen-tooling to release 0.0.11
Also reorders Chaos sequences and updates Chaos relay code to have consistent naming.","Updates codegen-tooling to release 0.0.11
Also reorders Chaos sequences and updates Chaos relay code to have consistent naming.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,197,2018-05-26T19:33:50Z,2018-06-02T04:49:48Z,2018-06-02T04:49:51Z,MERGED,True,280,6,7,https://github.com/ArshanKhanifar,ELEC-372: Lights CAN,16,['enhancement'],https://github.com/uw-midsun/firmware/pull/197,https://github.com/ArshanKhanifar,1,https://github.com/uw-midsun/firmware/pull/197,This is the lights_can module. It receives can messages and raises events for other modules to consume.,This is the lights_can module. It receives can messages and raises events for other modules to consume.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,197,2018-05-26T19:33:50Z,2018-06-02T04:49:48Z,2018-06-02T04:49:51Z,MERGED,True,280,6,7,https://github.com/ArshanKhanifar,ELEC-372: Lights CAN,16,['enhancement'],https://github.com/uw-midsun/firmware/pull/197,https://github.com/ArshanKhanifar,2,https://github.com/uw-midsun/firmware/pull/197#issuecomment-392283485,This is the lights_can module. It receives can messages and raises events for other modules to consume.,"The commit message has double ELEC-372: prefixes, my bad. I'll remember not to type it manually next time.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,197,2018-05-26T19:33:50Z,2018-06-02T04:49:48Z,2018-06-02T04:49:51Z,MERGED,True,280,6,7,https://github.com/ArshanKhanifar,ELEC-372: Lights CAN,16,['enhancement'],https://github.com/uw-midsun/firmware/pull/197,https://github.com/ArshanKhanifar,3,https://github.com/uw-midsun/firmware/pull/197#issuecomment-392304184,This is the lights_can module. It receives can messages and raises events for other modules to consume.,"I know I've changed some codegen-tooling files but my intent was to show what I think would be a good way to categorize lights can messages... Since CAN messages are in a pretty dynamic phase where there's lots of changes are happening, I'm hoping some of the codegen tooling can be modified so that lights code is in turn simpler.
If you feel they don't make sense, I can change it.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,198,2018-05-26T22:52:01Z,2018-05-29T03:34:30Z,2018-05-29T03:34:33Z,MERGED,True,341,305,26,https://github.com/tituschow,ELEC-431: Updated cruise behavior,14,[],https://github.com/uw-midsun/firmware/pull/198,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/198,"Adds proper cruise behavior - it has been split into its own FSM. See README.md in projects/driver_controls for FSM interaction documentation.
We now rely on motor controller interface to properly handle mechanical brake/throttle/cruise interactions since it'd be nice for telemetry to be aware of throttle/mech brake positions at all times. This also simplifies the logic in driver controls.
I may remove the ""drive output update"" event from pedal/mech brake FSMs since we should only have transitions using events that have data.
@ckitagawa I think we need to add a ""target cruise speed"" message for driver display.","Adds proper cruise behavior - it has been split into its own FSM. See README.md in projects/driver_controls for FSM interaction documentation.
We now rely on motor controller interface to properly handle mechanical brake/throttle/cruise interactions since it'd be nice for telemetry to be aware of throttle/mech brake positions at all times. This also simplifies the logic in driver controls.
I may remove the ""drive output update"" event from pedal/mech brake FSMs since we should only have transitions using events that have data.
@ckitagawa I think we need to add a ""target cruise speed"" message for driver display.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,199,2018-05-27T20:34:32Z,2018-06-02T15:38:16Z,2018-06-02T16:23:04Z,CLOSED,False,116,0,4,https://github.com/andyjiin,ELEC 434: photodiode brightness values to screen GPIO,3,[],https://github.com/uw-midsun/firmware/pull/199,https://github.com/andyjiin,1,https://github.com/uw-midsun/firmware/pull/199,"CHECKING IF CODE STRUCTURE IS CORRECT (NOT FINAL)

Read value through adc from photodiode
Mapped adc readings to brightness value
Currently printing values read over serial but will soon output to gpio in order to control screen brightness
Need to implement delay due to oversensitive photodiode","CHECKING IF CODE STRUCTURE IS CORRECT (NOT FINAL)

Read value through adc from photodiode
Mapped adc readings to brightness value
Currently printing values read over serial but will soon output to gpio in order to control screen brightness
Need to implement delay due to oversensitive photodiode",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,200,2018-05-27T21:00:56Z,2018-06-01T22:18:29Z,2018-06-01T22:18:34Z,CLOSED,False,193,0,5,https://github.com/ArshanKhanifar,ELEC-436: Lights Watchdog,1,['enhancement'],https://github.com/uw-midsun/firmware/pull/200,https://github.com/ArshanKhanifar,1,https://github.com/uw-midsun/firmware/pull/200,"This module is a watchdog timer for BPS heartbeat events. If it doesn't receive a BPS heartbeat event after a specified timeout, it will turn on the strobe lights. i.e It will raise a LIGHTS_EVENT_STROBE_ON event.","This module is a watchdog timer for BPS heartbeat events. If it doesn't receive a BPS heartbeat event after a specified timeout, it will turn on the strobe lights. i.e It will raise a LIGHTS_EVENT_STROBE_ON event.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,201,2018-05-28T08:03:03Z,2018-06-02T19:30:24Z,2018-06-02T19:30:26Z,MERGED,True,1111,26,20,https://github.com/tituschow,ELEC-338: Motor Controller Interface,26,[],https://github.com/uw-midsun/firmware/pull/201,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/201,"The idea behind the architecture is to split our drive commands from the motor controller's concept of drive commands. The drive_can module handles basic interlocks such as preventing acceleration during mechanical braking. The motor_controller module is driven by a periodic timer that is used to actually transmit drive commands on the motor CAN bus. For cruise control, we pick an arbitrary motor controller and copy its current setpoint to the other controller.
TODO:

 Add speed measurement
 Drive CAN input validation
 Add main
 Handle relays","The idea behind the architecture is to split our drive commands from the motor controller's concept of drive commands. The drive_can module handles basic interlocks such as preventing acceleration during mechanical braking. The motor_controller module is driven by a periodic timer that is used to actually transmit drive commands on the motor CAN bus. For cruise control, we pick an arbitrary motor controller and copy its current setpoint to the other controller.
TODO:

 Add speed measurement
 Drive CAN input validation
 Add main
 Handle relays",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,201,2018-05-28T08:03:03Z,2018-06-02T19:30:24Z,2018-06-02T19:30:26Z,MERGED,True,1111,26,20,https://github.com/tituschow,ELEC-338: Motor Controller Interface,26,[],https://github.com/uw-midsun/firmware/pull/201,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/201#issuecomment-393731472,"The idea behind the architecture is to split our drive commands from the motor controller's concept of drive commands. The drive_can module handles basic interlocks such as preventing acceleration during mechanical braking. The motor_controller module is driven by a periodic timer that is used to actually transmit drive commands on the motor CAN bus. For cruise control, we pick an arbitrary motor controller and copy its current setpoint to the other controller.
TODO:

 Add speed measurement
 Drive CAN input validation
 Add main
 Handle relays","@ckitagawa Motor relay RX is lacking a test, but it's so simple I'm not sure there's much value in having a test? It's pretty much just a wrapper for relay_rx.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,202,2018-05-29T03:11:56Z,2018-06-16T07:37:47Z,2018-06-16T07:37:52Z,CLOSED,False,2,2,1,https://github.com/ckitagawa,ELEC-440: Fix soft_timer flake,3,[],https://github.com/uw-midsun/firmware/pull/202,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/202,"I suspect the problem to be that 500 us is too slow on some CPUs due to Spectre/Meltdown remediation but I could be entirely wrong. Let me know if this works on other machines as I am unable to repro locally.
I've doubled the time to 1000 us and am hoping that fixes the issue. I have no idea what else to do in order to resolve the issue as this is very unlike the previous issues where here preemption is explicitly the issue whereas before it was an issue with critical sections.","I suspect the problem to be that 500 us is too slow on some CPUs due to Spectre/Meltdown remediation but I could be entirely wrong. Let me know if this works on other machines as I am unable to repro locally.
I've doubled the time to 1000 us and am hoping that fixes the issue. I have no idea what else to do in order to resolve the issue as this is very unlike the previous issues where here preemption is explicitly the issue whereas before it was an issue with critical sections.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,202,2018-05-29T03:11:56Z,2018-06-16T07:37:47Z,2018-06-16T07:37:52Z,CLOSED,False,2,2,1,https://github.com/ckitagawa,ELEC-440: Fix soft_timer flake,3,[],https://github.com/uw-midsun/firmware/pull/202,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/202#issuecomment-392641942,"I suspect the problem to be that 500 us is too slow on some CPUs due to Spectre/Meltdown remediation but I could be entirely wrong. Let me know if this works on other machines as I am unable to repro locally.
I've doubled the time to 1000 us and am hoping that fixes the issue. I have no idea what else to do in order to resolve the issue as this is very unlike the previous issues where here preemption is explicitly the issue whereas before it was an issue with critical sections.","Hmm, still seeing some failures:
Running test_soft_timer_runner
[0] libraries/x86/src/x86_interrupt.c:87: Main Thread (id:139809139951424)
libraries/ms-common/test/test_soft_timer.c:27:test_soft_timer_basic:PASS
[0] libraries/x86/src/x86_interrupt.c:87: Main Thread (id:139809139951424)
libraries/ms-common/test/test_soft_timer.c:47:test_soft_timer_preempt:PASS
[0] libraries/x86/src/x86_interrupt.c:87: Main Thread (id:139809139951424)
libraries/ms-common/test/test_soft_timer.c:135:test_soft_timer_cancelled_timer:FAIL: Expected Not-Equal
[0] libraries/x86/src/x86_interrupt.c:87: Main Thread (id:139809139951424)
libraries/ms-common/test/test_soft_timer.c:140:test_soft_timer_remaining:PASS
[0] libraries/x86/src/x86_interrupt.c:87: Main Thread (id:139809139951424)
libraries/ms-common/test/test_soft_timer.c:166:test_soft_timer_exhausted:PASS

-----------------------
5 Tests 1 Failures 0 Ignored
FAIL

Running test_soft_timer_runner
[0] libraries/x86/src/x86_interrupt.c:87: Main Thread (id:140262758700864)
libraries/ms-common/test/test_soft_timer.c:27:test_soft_timer_basic:PASS
[0] libraries/x86/src/x86_interrupt.c:87: Main Thread (id:140262758700864)
libraries/ms-common/test/test_soft_timer.c:86:test_soft_timer_preempt:FAIL: Expected Not-Equal
[0] libraries/x86/src/x86_interrupt.c:87: Main Thread (id:140262758700864)
libraries/ms-common/test/test_soft_timer.c:111:test_soft_timer_cancelled_timer:PASS
[0] libraries/x86/src/x86_interrupt.c:87: Main Thread (id:140262758700864)
libraries/ms-common/test/test_soft_timer.c:140:test_soft_timer_remaining:PASS
[0] libraries/x86/src/x86_interrupt.c:87: Main Thread (id:140262758700864)
libraries/ms-common/test/test_soft_timer.c:166:test_soft_timer_exhausted:PASS

-----------------------
5 Tests 1 Failures 0 Ignored
FAIL

~5 failures out of 11 runs?
Fails pretty consistently for me.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,202,2018-05-29T03:11:56Z,2018-06-16T07:37:47Z,2018-06-16T07:37:52Z,CLOSED,False,2,2,1,https://github.com/ckitagawa,ELEC-440: Fix soft_timer flake,3,[],https://github.com/uw-midsun/firmware/pull/202,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/202#issuecomment-397794469,"I suspect the problem to be that 500 us is too slow on some CPUs due to Spectre/Meltdown remediation but I could be entirely wrong. Let me know if this works on other machines as I am unable to repro locally.
I've doubled the time to 1000 us and am hoping that fixes the issue. I have no idea what else to do in order to resolve the issue as this is very unlike the previous issues where here preemption is explicitly the issue whereas before it was an issue with critical sections.",I assume this is no longer being worked on - the soft timers seem to have stopped failing,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,203,2018-05-30T02:10:44Z,2018-06-02T22:13:18Z,2018-06-02T22:13:21Z,MERGED,True,346,178,9,https://github.com/tituschow,ELEC-441: Add support for incomplete AFE inputs,17,[],https://github.com/uw-midsun/firmware/pull/203,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/203,"Adds the ability to ignore voltage/aux voltage inputs. We've decided to balance the modules between both boxes (18 modules per box), so 2/4 AFEs will only have 6 modules each.
To make using the module easier, the API has not changed. The driver automatically populates the result arrays as if the ignored inputs don't exist. The alternative is to move that behavior into another module/main during processing for faults.
I've also moved more stuff into the config.","Adds the ability to ignore voltage/aux voltage inputs. We've decided to balance the modules between both boxes (18 modules per box), so 2/4 AFEs will only have 6 modules each.
To make using the module easier, the API has not changed. The driver automatically populates the result arrays as if the ignored inputs don't exist. The alternative is to move that behavior into another module/main during processing for faults.
I've also moved more stuff into the config.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,203,2018-05-30T02:10:44Z,2018-06-02T22:13:18Z,2018-06-02T22:13:21Z,MERGED,True,346,178,9,https://github.com/tituschow,ELEC-441: Add support for incomplete AFE inputs,17,[],https://github.com/uw-midsun/firmware/pull/203,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/203#issuecomment-393789807,"Adds the ability to ignore voltage/aux voltage inputs. We've decided to balance the modules between both boxes (18 modules per box), so 2/4 AFEs will only have 6 modules each.
To make using the module easier, the API has not changed. The driver automatically populates the result arrays as if the ignored inputs don't exist. The alternative is to move that behavior into another module/main during processing for faults.
I've also moved more stuff into the config.","Based on the thermistor wiring being easier to keep as one harness, I'll move this logic into another module. The offset stuff is probably unnecessary in that case and we can just process data in a loop.
Edit: actually, that makes balancing kinda gross. I'll just add another bitset for temperature data.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,203,2018-05-30T02:10:44Z,2018-06-02T22:13:18Z,2018-06-02T22:13:21Z,MERGED,True,346,178,9,https://github.com/tituschow,ELEC-441: Add support for incomplete AFE inputs,17,[],https://github.com/uw-midsun/firmware/pull/203,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/203#issuecomment-394066588,"Adds the ability to ignore voltage/aux voltage inputs. We've decided to balance the modules between both boxes (18 modules per box), so 2/4 AFEs will only have 6 modules each.
To make using the module easier, the API has not changed. The driver automatically populates the result arrays as if the ignored inputs don't exist. The alternative is to move that behavior into another module/main during processing for faults.
I've also moved more stuff into the config.","@ckitagawa I realized that I can just make an index lookup, so hopefully that's easier to understand. I've also added a separate aux bitset so we can use a single harness for temperature inputs.
I'll merge it tomorrow after testing if there aren't any issues.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,204,2018-06-01T01:52:02Z,2018-06-02T01:04:26Z,2018-06-02T01:04:32Z,MERGED,True,290,36,10,https://github.com/ckitagawa,ELEC-105: Refactor Relays,6,[],https://github.com/uw-midsun/firmware/pull/204,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/204,"Refactor relays:

Create a separate retry service
Make relays to be aware of if the device they are on is powered and behave accordingly (ERROR on close, success on open)

Once this is merged I will

Refactor the sequencer (tomorrow hopefully)
Add state handling (as soon as sequencer is refactored)
Configure pins and add a main

Goal is to finish this by Saturday. Priority will be on Charger tomorrow in order to be able to charge the battery.","Refactor relays:

Create a separate retry service
Make relays to be aware of if the device they are on is powered and behave accordingly (ERROR on close, success on open)

Once this is merged I will

Refactor the sequencer (tomorrow hopefully)
Add state handling (as soon as sequencer is refactored)
Configure pins and add a main

Goal is to finish this by Saturday. Priority will be on Charger tomorrow in order to be able to charge the battery.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,205,2018-06-02T00:20:42Z,2018-06-02T00:52:33Z,2018-06-02T00:52:38Z,MERGED,True,69,35,6,https://github.com/ckitagawa,ELEC-442: Roll Codegen,2,[],https://github.com/uw-midsun/firmware/pull/205,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/205,,,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,206,2018-06-02T01:58:45Z,2018-06-02T17:36:31Z,2018-06-02T17:36:36Z,MERGED,True,475,123,7,https://github.com/ckitagawa,ELEC-105: Refactor Sequencer,9,[],https://github.com/uw-midsun/firmware/pull/206,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/206,"Putting this up for review. It still needs tests but in case the logic needs to change I want to hold off until after a first pass.
Main changes

Add reset logic
Relay retry service updates
Add filtering to ignore stuff during the emergency state
Update events
Allow any transition. Emergency to Idle is still constrained for safety
Reorder sequences to kill relays early and sync FSMs
Configure the FSM to flush if the previous transition hasn't finished

If awaiting a response we are waiting on CAN so we fail fast, and wait for the message to return to avoid the ack arriving after we transition and forcing a sequence reset.
If not awaiting we do the transition but await a special guard event before actually enqueueing anything to flush.","Putting this up for review. It still needs tests but in case the logic needs to change I want to hold off until after a first pass.
Main changes

Add reset logic
Relay retry service updates
Add filtering to ignore stuff during the emergency state
Update events
Allow any transition. Emergency to Idle is still constrained for safety
Reorder sequences to kill relays early and sync FSMs
Configure the FSM to flush if the previous transition hasn't finished

If awaiting a response we are waiting on CAN so we fail fast, and wait for the message to return to avoid the ack arriving after we transition and forcing a sequence reset.
If not awaiting we do the transition but await a special guard event before actually enqueueing anything to flush.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,206,2018-06-02T01:58:45Z,2018-06-02T17:36:31Z,2018-06-02T17:36:36Z,MERGED,True,475,123,7,https://github.com/ckitagawa,ELEC-105: Refactor Sequencer,9,[],https://github.com/uw-midsun/firmware/pull/206,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/206#issuecomment-394103385,"Putting this up for review. It still needs tests but in case the logic needs to change I want to hold off until after a first pass.
Main changes

Add reset logic
Relay retry service updates
Add filtering to ignore stuff during the emergency state
Update events
Allow any transition. Emergency to Idle is still constrained for safety
Reorder sequences to kill relays early and sync FSMs
Configure the FSM to flush if the previous transition hasn't finished

If awaiting a response we are waiting on CAN so we fail fast, and wait for the message to return to avoid the ack arriving after we transition and forcing a sequence reset.
If not awaiting we do the transition but await a special guard event before actually enqueueing anything to flush.",Thanks! The tests say it works but we will have to wait for integration to see for sure...,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,207,2018-06-02T02:02:39Z,2018-06-02T05:01:55Z,2018-06-02T05:02:01Z,MERGED,True,122,35,7,https://github.com/ArshanKhanifar,ELEC-375: Lights Sync,6,[],https://github.com/uw-midsun/firmware/pull/207,https://github.com/ArshanKhanifar,1,https://github.com/uw-midsun/firmware/pull/207,Adding syncing functionality to lights_signal and lights_blinker.,Adding syncing functionality to lights_signal and lights_blinker.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,208,2018-06-02T02:06:36Z,2018-06-02T15:03:35Z,2018-09-13T03:30:30Z,MERGED,True,195,0,3,https://github.com/ckitagawa,ELEC-105: Emergency State,3,[],https://github.com/uw-midsun/firmware/pull/208,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/208,"Still need unit tests. Just wanted initial comments.
If we enter the emergency state this will periodically raise a notification until driver controls acks it.
If we leave the emergency state we stop sending this message as we should in theory be synced.","Still need unit tests. Just wanted initial comments.
If we enter the emergency state this will periodically raise a notification until driver controls acks it.
If we leave the emergency state we stop sending this message as we should in theory be synced.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,209,2018-06-02T02:25:22Z,2018-06-02T15:19:40Z,2018-06-02T15:19:43Z,MERGED,True,168,0,4,https://github.com/ckitagawa,ELEC-105: State Handler Chaos Side,3,[],https://github.com/uw-midsun/firmware/pull/209,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/209,Adds the state handler for Chaos handling messages from driver controls. I still need to finish the driver controls side in a separate PR.,Adds the state handler for Chaos handling messages from driver controls. I still need to finish the driver controls side in a separate PR.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,210,2018-06-02T02:28:08Z,2018-06-02T20:13:22Z,2018-06-02T20:13:36Z,MERGED,True,186,35,3,https://github.com/ckitagawa,ELEC-105: Chaos Config,19,[],https://github.com/uw-midsun/firmware/pull/210,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/210,This PR adds the configuration for Chaos. The main is only partially complete and was used to tune the voltage and current from the shunts. I will finish the main in another PR this is just to merge the config mostly.,This PR adds the configuration for Chaos. The main is only partially complete and was used to tune the voltage and current from the shunts. I will finish the main in another PR this is just to merge the config mostly.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,211,2018-06-02T17:03:34Z,2018-06-02T20:04:28Z,2018-06-02T20:04:33Z,MERGED,True,198,39,4,https://github.com/ckitagawa,ELEC-105: Refactor GPIO FSM,11,[],https://github.com/uw-midsun/firmware/pull/211,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/211,Refactors the GPIO FSM based on the new assumption any transition is valid to sync with driver controls. Also updated which pins are controlled.,Refactors the GPIO FSM based on the new assumption any transition is valid to sync with driver controls. Also updated which pins are controlled.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,212,2018-06-02T17:15:43Z,2018-06-02T17:56:34Z,2018-06-02T17:56:38Z,MERGED,True,19,19,4,https://github.com/ckitagawa,ELEC-105: Power Path Adjustments,4,[],https://github.com/uw-midsun/firmware/pull/212,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/212,"Simple PR:

adc_read_raw -> adc_read_converted
Use milliseconds instead of microseconds.","Simple PR:

adc_read_raw -> adc_read_converted
Use milliseconds instead of microseconds.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,213,2018-06-02T18:52:31Z,2018-06-02T19:51:11Z,2018-06-02T19:51:14Z,MERGED,True,206,10,6,https://github.com/ckitagawa,ELEC-105: Add Driver Controls Power State,3,[],https://github.com/uw-midsun/firmware/pull/213,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/213,Adds a simple power state output with retry to driver controls.,Adds a simple power state output with retry to driver controls.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,213,2018-06-02T18:52:31Z,2018-06-02T19:51:11Z,2018-06-02T19:51:14Z,MERGED,True,206,10,6,https://github.com/ckitagawa,ELEC-105: Add Driver Controls Power State,3,[],https://github.com/uw-midsun/firmware/pull/213,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/213#issuecomment-394111930,Adds a simple power state output with retry to driver controls.,I don't really like it either but this was fast and avoids having to pipe storage all the way through the power FSM.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,214,2018-06-02T19:44:04Z,2018-06-02T21:14:48Z,2018-06-02T21:14:52Z,MERGED,True,81,0,1,https://github.com/ckitagawa,ELEC-105: Chaos README,6,[],https://github.com/uw-midsun/firmware/pull/214,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/214,,,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,215,2018-06-02T20:36:35Z,2018-07-11T00:07:53Z,2018-07-11T00:07:58Z,MERGED,True,175,84,16,https://github.com/ArshanKhanifar,ELEC-445: Lights Main,21,[],https://github.com/uw-midsun/firmware/pull/215,https://github.com/ArshanKhanifar,1,https://github.com/uw-midsun/firmware/pull/215,main for finishing this 🅱️itch,main for finishing this 🅱️itch,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,215,2018-06-02T20:36:35Z,2018-07-11T00:07:53Z,2018-07-11T00:07:58Z,MERGED,True,175,84,16,https://github.com/ArshanKhanifar,ELEC-445: Lights Main,21,[],https://github.com/uw-midsun/firmware/pull/215,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/215#issuecomment-398251548,main for finishing this 🅱️itch,Ping @ArshanKhanifar we should try to test lights this weekend. Can you have this done for Saturday?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,215,2018-06-02T20:36:35Z,2018-07-11T00:07:53Z,2018-07-11T00:07:58Z,MERGED,True,175,84,16,https://github.com/ArshanKhanifar,ELEC-445: Lights Main,21,[],https://github.com/uw-midsun/firmware/pull/215,https://github.com/ArshanKhanifar,3,https://github.com/uw-midsun/firmware/pull/215#issuecomment-399719596,main for finishing this 🅱️itch,"@ckitagawa It's pretty much done, ready for the last cleanups. I've tested this with hardware too 👍",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,215,2018-06-02T20:36:35Z,2018-07-11T00:07:53Z,2018-07-11T00:07:58Z,MERGED,True,175,84,16,https://github.com/ArshanKhanifar,ELEC-445: Lights Main,21,[],https://github.com/uw-midsun/firmware/pull/215,https://github.com/tituschow,4,https://github.com/uw-midsun/firmware/pull/215#issuecomment-400154585,main for finishing this 🅱️itch,Can you figure out why it seemed like only one headlight was turning on?,True,{'THUMBS_UP': ['https://github.com/ArshanKhanifar']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,215,2018-06-02T20:36:35Z,2018-07-11T00:07:53Z,2018-07-11T00:07:58Z,MERGED,True,175,84,16,https://github.com/ArshanKhanifar,ELEC-445: Lights Main,21,[],https://github.com/uw-midsun/firmware/pull/215,https://github.com/ArshanKhanifar,5,https://github.com/uw-midsun/firmware/pull/215#issuecomment-400169522,main for finishing this 🅱️itch,"About the headlights, yeah that seems weird... I'll do more testing on the board itself and see if it happens with the LED's on the lights board. If not then it could be a hardware issue.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,216,2018-06-02T20:57:48Z,2018-06-02T21:25:53Z,2018-06-02T21:25:57Z,MERGED,True,75,65,2,https://github.com/ckitagawa,ELEC-105: Chaos Main,4,[],https://github.com/uw-midsun/firmware/pull/216,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/216,"Finally after many PRs Chaos is in what I consider to be a ""working"" state. (At least all the modules independently are). Many tests are still required to validate its integration.
This provides the main for Chaos which is pretty simple.
NOTE: Thermistor controls and fan speed code is not present as this is being worked on presently and shared between multiple boards. In the interim I can just make the fans run full speed via PWM if we want.","Finally after many PRs Chaos is in what I consider to be a ""working"" state. (At least all the modules independently are). Many tests are still required to validate its integration.
This provides the main for Chaos which is pretty simple.
NOTE: Thermistor controls and fan speed code is not present as this is being worked on presently and shared between multiple boards. In the interim I can just make the fans run full speed via PWM if we want.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,216,2018-06-02T20:57:48Z,2018-06-02T21:25:53Z,2018-06-02T21:25:57Z,MERGED,True,75,65,2,https://github.com/ckitagawa,ELEC-105: Chaos Main,4,[],https://github.com/uw-midsun/firmware/pull/216,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/216#issuecomment-394118225,"Finally after many PRs Chaos is in what I consider to be a ""working"" state. (At least all the modules independently are). Many tests are still required to validate its integration.
This provides the main for Chaos which is pretty simple.
NOTE: Thermistor controls and fan speed code is not present as this is being worked on presently and shared between multiple boards. In the interim I can just make the fans run full speed via PWM if we want.",Tested on x86 and stm32f0xx it reaches the main event loop successfully. Further testing requires integration with other devices. No emergency is reached thanks to deferring watchdogs until after the first response.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,217,2018-06-02T21:32:43Z,2018-06-24T07:04:07Z,2018-06-24T07:07:03Z,MERGED,True,351,1,5,https://github.com/thomaskidd,ELEC-403: Thermistor Conversion,33,[],https://github.com/uw-midsun/firmware/pull/217,https://github.com/thomaskidd,1,https://github.com/uw-midsun/firmware/pull/217,The thermsitor_converter files provide an interface for using temperature sensitive resistors to measure temperature. It has been implemented to work with the NXRT15XH103FA1B___ resistor. More information can be found here: https://www.murata.com/en-global/products/productdetail.aspx?cate=luNTCforTempeSenso&partno=NXRT15XH103FA1B___,The thermsitor_converter files provide an interface for using temperature sensitive resistors to measure temperature. It has been implemented to work with the NXRT15XH103FA1B___ resistor. More information can be found here: https://www.murata.com/en-global/products/productdetail.aspx?cate=luNTCforTempeSenso&partno=NXRT15XH103FA1B___,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,217,2018-06-02T21:32:43Z,2018-06-24T07:04:07Z,2018-06-24T07:07:03Z,MERGED,True,351,1,5,https://github.com/thomaskidd,ELEC-403: Thermistor Conversion,33,[],https://github.com/uw-midsun/firmware/pull/217,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/217#issuecomment-394119628,The thermsitor_converter files provide an interface for using temperature sensitive resistors to measure temperature. It has been implemented to work with the NXRT15XH103FA1B___ resistor. More information can be found here: https://www.murata.com/en-global/products/productdetail.aspx?cate=luNTCforTempeSenso&partno=NXRT15XH103FA1B___,You're missing some files. Please make sure your PR is complete and add a description.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,217,2018-06-02T21:32:43Z,2018-06-24T07:04:07Z,2018-06-24T07:07:03Z,MERGED,True,351,1,5,https://github.com/thomaskidd,ELEC-403: Thermistor Conversion,33,[],https://github.com/uw-midsun/firmware/pull/217,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/217#issuecomment-399718973,The thermsitor_converter files provide an interface for using temperature sensitive resistors to measure temperature. It has been implemented to work with the NXRT15XH103FA1B___ resistor. More information can be found here: https://www.murata.com/en-global/products/productdetail.aspx?cate=luNTCforTempeSenso&partno=NXRT15XH103FA1B___,You have a merge conflict.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,218,2018-06-06T01:08:15Z,2019-02-05T01:59:59Z,2019-02-13T23:18:38Z,CLOSED,False,284,5,5,https://github.com/mishazharov,ELEC-71: GPS driver,180,[],https://github.com/uw-midsun/firmware/pull/218,https://github.com/mishazharov,1,https://github.com/uw-midsun/firmware/pull/218,Reworked the GPS driver so that it no longer parses NMEA messages,Reworked the GPS driver so that it no longer parses NMEA messages,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,218,2018-06-06T01:08:15Z,2019-02-05T01:59:59Z,2019-02-13T23:18:38Z,CLOSED,False,284,5,5,https://github.com/mishazharov,ELEC-71: GPS driver,180,[],https://github.com/uw-midsun/firmware/pull/218,https://github.com/mishazharov,2,https://github.com/uw-midsun/firmware/pull/218#issuecomment-420125024,Reworked the GPS driver so that it no longer parses NMEA messages,@ckitagawa @tituschow is there anything else I should change / rework?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,218,2018-06-06T01:08:15Z,2019-02-05T01:59:59Z,2019-02-13T23:18:38Z,CLOSED,False,284,5,5,https://github.com/mishazharov,ELEC-71: GPS driver,180,[],https://github.com/uw-midsun/firmware/pull/218,https://github.com/karlding,3,https://github.com/uw-midsun/firmware/pull/218#issuecomment-420136976,Reworked the GPS driver so that it no longer parses NMEA messages,"So I'm going to go out and say that the scope of this PR is a little ridiculous. For the sake of both the reviewers and yourself, can you split this such that GPS goes in first as part of one PR (maybe this one), and then the rest? It'll make getting things merged a lot easier!
I'll just treat this for now as the GPS driver only.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,218,2018-06-06T01:08:15Z,2019-02-05T01:59:59Z,2019-02-13T23:18:38Z,CLOSED,False,284,5,5,https://github.com/mishazharov,ELEC-71: GPS driver,180,[],https://github.com/uw-midsun/firmware/pull/218,https://github.com/mishazharov,4,https://github.com/uw-midsun/firmware/pull/218#issuecomment-435632833,Reworked the GPS driver so that it no longer parses NMEA messages,"@myh999 It's probably a better idea to reopen PR 191 and merge it in, instead of adding the files as a part of this pull request. Ideally, each pull request will contain the smallest unit of new working code",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,218,2018-06-06T01:08:15Z,2019-02-05T01:59:59Z,2019-02-13T23:18:38Z,CLOSED,False,284,5,5,https://github.com/mishazharov,ELEC-71: GPS driver,180,[],https://github.com/uw-midsun/firmware/pull/218,https://github.com/myh999,5,https://github.com/uw-midsun/firmware/pull/218#issuecomment-435634602,Reworked the GPS driver so that it no longer parses NMEA messages,"Noted, reverting.",True,{'THUMBS_UP': ['https://github.com/mishazharov']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,218,2018-06-06T01:08:15Z,2019-02-05T01:59:59Z,2019-02-13T23:18:38Z,CLOSED,False,284,5,5,https://github.com/mishazharov,ELEC-71: GPS driver,180,[],https://github.com/uw-midsun/firmware/pull/218,https://github.com/mishazharov,6,https://github.com/uw-midsun/firmware/pull/218#issuecomment-457032591,Reworked the GPS driver so that it no longer parses NMEA messages,"Hey man, good stuff so far! Did you get a chance to test it on hardware yet?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,218,2018-06-06T01:08:15Z,2019-02-05T01:59:59Z,2019-02-13T23:18:38Z,CLOSED,False,284,5,5,https://github.com/mishazharov,ELEC-71: GPS driver,180,[],https://github.com/uw-midsun/firmware/pull/218,https://github.com/myh999,7,https://github.com/uw-midsun/firmware/pull/218#issuecomment-457214023,Reworked the GPS driver so that it no longer parses NMEA messages,"Yep, it worked when I tested it early December. I'm also briefing a couple of new people who will also be working on this project.",True,{'THUMBS_UP': ['https://github.com/mishazharov']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,218,2018-06-06T01:08:15Z,2019-02-05T01:59:59Z,2019-02-13T23:18:38Z,CLOSED,False,284,5,5,https://github.com/mishazharov,ELEC-71: GPS driver,180,[],https://github.com/uw-midsun/firmware/pull/218,https://github.com/mishazharov,8,https://github.com/uw-midsun/firmware/pull/218#issuecomment-457712199,Reworked the GPS driver so that it no longer parses NMEA messages,"That's great! Let's get this up to date with master, passing the tests and merged. It'll also add feedback this weekend",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,218,2018-06-06T01:08:15Z,2019-02-05T01:59:59Z,2019-02-13T23:18:38Z,CLOSED,False,284,5,5,https://github.com/mishazharov,ELEC-71: GPS driver,180,[],https://github.com/uw-midsun/firmware/pull/218,https://github.com/mishazharov,9,https://github.com/uw-midsun/firmware/pull/218#issuecomment-457855165,Reworked the GPS driver so that it no longer parses NMEA messages,"I left some minor nits, but other than that it looks good",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,218,2018-06-06T01:08:15Z,2019-02-05T01:59:59Z,2019-02-13T23:18:38Z,CLOSED,False,284,5,5,https://github.com/mishazharov,ELEC-71: GPS driver,180,[],https://github.com/uw-midsun/firmware/pull/218,https://github.com/myh999,10,https://github.com/uw-midsun/firmware/pull/218#issuecomment-460486521,Reworked the GPS driver so that it no longer parses NMEA messages,Closing in favour of #320,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,219,2018-06-07T01:06:45Z,2018-06-07T01:20:36Z,2018-06-07T01:20:39Z,MERGED,True,34,28,5,https://github.com/ckitagawa,ELEC-451: Fix bugs in charger found during integration attempt,3,[],https://github.com/uw-midsun/firmware/pull/219,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/219,"I found a few minor issues with the charger code in attempting to get it working. This PR fixes those. In particular there were a few oversights with uninitialized memory, or missing inits. Additionally adds configuration for pins. Also the DLC for the CAN message was wrong although it doesn't explain why the charger wasn't responding.","I found a few minor issues with the charger code in attempting to get it working. This PR fixes those. In particular there were a few oversights with uninitialized memory, or missing inits. Additionally adds configuration for pins. Also the DLC for the CAN message was wrong although it doesn't explain why the charger wasn't responding.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,219,2018-06-07T01:06:45Z,2018-06-07T01:20:36Z,2018-06-07T01:20:39Z,MERGED,True,34,28,5,https://github.com/ckitagawa,ELEC-451: Fix bugs in charger found during integration attempt,3,[],https://github.com/uw-midsun/firmware/pull/219,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/219#issuecomment-395261112,"I found a few minor issues with the charger code in attempting to get it working. This PR fixes those. In particular there were a few oversights with uninitialized memory, or missing inits. Additionally adds configuration for pins. Also the DLC for the CAN message was wrong although it doesn't explain why the charger wasn't responding.","I've been trying to debug CAN and it turns out we can't communicate with any CAN devices other than our own :)
I built a harness for the LAWICEL CAN-USB adapter and I can see CAN activity from the charger using it, but not through a controller board.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,219,2018-06-07T01:06:45Z,2018-06-07T01:20:36Z,2018-06-07T01:20:39Z,MERGED,True,34,28,5,https://github.com/ckitagawa,ELEC-451: Fix bugs in charger found during integration attempt,3,[],https://github.com/uw-midsun/firmware/pull/219,https://github.com/ckitagawa,3,https://github.com/uw-midsun/firmware/pull/219#issuecomment-395261860,"I found a few minor issues with the charger code in attempting to get it working. This PR fixes those. In particular there were a few oversights with uninitialized memory, or missing inits. Additionally adds configuration for pins. Also the DLC for the CAN message was wrong although it doesn't explain why the charger wasn't responding.",Weird. I wonder if our CAN driver has some weird timing configuration or something? It might explain why we can only communicate with our own devices and not external ones. But that is very puzzling.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,220,2018-06-07T01:27:58Z,2018-06-11T06:36:16Z,2018-06-11T06:36:19Z,MERGED,True,522,288,27,https://github.com/tituschow,ELEC-439: Plutus MVP,37,[],https://github.com/uw-midsun/firmware/pull/220,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/220,"I apologize for the massive PR. This is theoretically working FW for MVP. If it helps I can split this into smaller PRs - just wanted to put it up for general thoughts
Specific things of note:

Config
Fault monitoring

New PR:

Enabled CAN automatic bus-off recovery - #221
1-indexed CAN devices (TODO: need to update codegen-tooling) - ELEC-450
Generalized motor relay to sequenced relay - #222
BPS Heartbeat - #223
Killswitch - #223
Cleaned up LTC AFE/ADC to match storage/settings paradigm + naming - #224","I apologize for the massive PR. This is theoretically working FW for MVP. If it helps I can split this into smaller PRs - just wanted to put it up for general thoughts
Specific things of note:

Config
Fault monitoring

New PR:

Enabled CAN automatic bus-off recovery - #221
1-indexed CAN devices (TODO: need to update codegen-tooling) - ELEC-450
Generalized motor relay to sequenced relay - #222
BPS Heartbeat - #223
Killswitch - #223
Cleaned up LTC AFE/ADC to match storage/settings paradigm + naming - #224",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,220,2018-06-07T01:27:58Z,2018-06-11T06:36:16Z,2018-06-11T06:36:19Z,MERGED,True,522,288,27,https://github.com/tituschow,ELEC-439: Plutus MVP,37,[],https://github.com/uw-midsun/firmware/pull/220,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/220#issuecomment-395270999,"I apologize for the massive PR. This is theoretically working FW for MVP. If it helps I can split this into smaller PRs - just wanted to put it up for general thoughts
Specific things of note:

Config
Fault monitoring

New PR:

Enabled CAN automatic bus-off recovery - #221
1-indexed CAN devices (TODO: need to update codegen-tooling) - ELEC-450
Generalized motor relay to sequenced relay - #222
BPS Heartbeat - #223
Killswitch - #223
Cleaned up LTC AFE/ADC to match storage/settings paradigm + naming - #224","Yep, no problem. I'll split this PR up when I'm tired of working on CAN. :P
CAN changes are logged in ELEC-450 (1-indexed CAN devices and adding BPS slave ID).
Plutus does not currently calculate SoC. IMO it's a low-priority task. It'll probably be easier to do it on the telemetry server.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,220,2018-06-07T01:27:58Z,2018-06-11T06:36:16Z,2018-06-11T06:36:19Z,MERGED,True,522,288,27,https://github.com/tituschow,ELEC-439: Plutus MVP,37,[],https://github.com/uw-midsun/firmware/pull/220,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/220#issuecomment-395309625,"I apologize for the massive PR. This is theoretically working FW for MVP. If it helps I can split this into smaller PRs - just wanted to put it up for general thoughts
Specific things of note:

Config
Fault monitoring

New PR:

Enabled CAN automatic bus-off recovery - #221
1-indexed CAN devices (TODO: need to update codegen-tooling) - ELEC-450
Generalized motor relay to sequenced relay - #222
BPS Heartbeat - #223
Killswitch - #223
Cleaned up LTC AFE/ADC to match storage/settings paradigm + naming - #224","I'll leave this PR open for context and to integrate all the split-up PRs to make sure I didn't forget anything. The config, system configuration, and fault monitoring will be integrated through this PR.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,220,2018-06-07T01:27:58Z,2018-06-11T06:36:16Z,2018-06-11T06:36:19Z,MERGED,True,522,288,27,https://github.com/tituschow,ELEC-439: Plutus MVP,37,[],https://github.com/uw-midsun/firmware/pull/220,https://github.com/tituschow,4,https://github.com/uw-midsun/firmware/pull/220#issuecomment-395950137,"I apologize for the massive PR. This is theoretically working FW for MVP. If it helps I can split this into smaller PRs - just wanted to put it up for general thoughts
Specific things of note:

Config
Fault monitoring

New PR:

Enabled CAN automatic bus-off recovery - #221
1-indexed CAN devices (TODO: need to update codegen-tooling) - ELEC-450
Generalized motor relay to sequenced relay - #222
BPS Heartbeat - #223
Killswitch - #223
Cleaned up LTC AFE/ADC to match storage/settings paradigm + naming - #224","@ckitagawa @taipingli
Most recent commit as of this comment (c5fd0bc) has voltage monitoring disabled while I try to figure out how to handle the huge delays required. I might have to split the AFE driver up a bit.
It should have BPS heartbeat (although it might only be listening for BPS slave - undefine standalone mode if that's true) and relay/killswitch handling working. BPS slave doesn't react to BPS faults yet.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,221,2018-06-07T05:57:34Z,2018-06-08T03:40:24Z,2018-06-08T03:40:28Z,MERGED,True,97,48,28,https://github.com/tituschow,ELEC-453: CAN Cleanup,11,[],https://github.com/uw-midsun/firmware/pull/221,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/221,"Swapped CAN storage/settings to match our paradigm. Also enabled automatic bus-off recovery.
Not sure if adding an ACK callback helper would be that useful since you seem to check for different things in each test.","Swapped CAN storage/settings to match our paradigm. Also enabled automatic bus-off recovery.
Not sure if adding an ACK callback helper would be that useful since you seem to check for different things in each test.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,222,2018-06-07T06:05:50Z,2018-06-08T02:35:23Z,2018-06-08T02:35:27Z,MERGED,True,195,151,6,https://github.com/tituschow,ELEC-439: Made motor relay generic,6,[],https://github.com/uw-midsun/firmware/pull/222,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/222,"Mostly a rename. Both BPS boards, motor controller interface, and solar all need to deal with two HV relays.","Mostly a rename. Both BPS boards, motor controller interface, and solar all need to deal with two HV relays.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,223,2018-06-07T06:20:34Z,2018-06-08T04:05:09Z,2018-06-08T04:05:12Z,MERGED,True,299,12,10,https://github.com/tituschow,ELEC-439: Plutus BPS Heartbeat + Killswitch,6,[],https://github.com/uw-midsun/firmware/pull/223,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/223,"This won't build until #222 is in.
Adds BPS Heartbeat TX and killswitch support.","This won't build until #222 is in.
Adds BPS Heartbeat TX and killswitch support.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,224,2018-06-07T06:34:51Z,2018-06-08T02:24:45Z,2018-06-08T02:24:49Z,MERGED,True,96,76,9,https://github.com/tituschow,ELEC-439: Cleaned up LTC AFE/ADC,1,[],https://github.com/uw-midsun/firmware/pull/224,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/224,"Fixes naming and storage/settings paradigm.
Also fixes the delays for the AFE.","Fixes naming and storage/settings paradigm.
Also fixes the delays for the AFE.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,225,2018-06-08T01:50:46Z,2018-06-08T05:56:37Z,2018-06-08T05:56:40Z,MERGED,True,106,7,3,https://github.com/tituschow,ELEC-407: Add neutral state,2,[],https://github.com/uw-midsun/firmware/pull/225,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/225,Adds neutral state and properly resets cruise/direction on fault/power off. I don't think there are any other FSMs that need to be reset?,Adds neutral state and properly resets cruise/direction on fault/power off. I don't think there are any other FSMs that need to be reset?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,226,2018-06-08T02:34:30Z,2018-06-08T03:01:16Z,2018-06-08T03:01:20Z,MERGED,True,46,29,5,https://github.com/ckitagawa,ELEC-450: Roll Codegen Battery Update,3,[],https://github.com/uw-midsun/firmware/pull/226,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/226,,,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,227,2018-06-08T05:57:58Z,2018-06-09T16:18:28Z,2018-06-09T16:18:32Z,MERGED,True,190,103,10,https://github.com/tituschow,ELEC-438: Center Console Inputs,10,[],https://github.com/uw-midsun/firmware/pull/227,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/227,Adds event generator for center console inputs. We'll need to add outputs for fault/button LED/charging indicator eventually. I'd suggest an LED driver.,Adds event generator for center console inputs. We'll need to add outputs for fault/button LED/charging indicator eventually. I'd suggest an LED driver.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,227,2018-06-08T05:57:58Z,2018-06-09T16:18:28Z,2018-06-09T16:18:32Z,MERGED,True,190,103,10,https://github.com/tituschow,ELEC-438: Center Console Inputs,10,[],https://github.com/uw-midsun/firmware/pull/227,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/227#issuecomment-395932693,Adds event generator for center console inputs. We'll need to add outputs for fault/button LED/charging indicator eventually. I'd suggest an LED driver.,Has this been tested at all?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,227,2018-06-08T05:57:58Z,2018-06-09T16:18:28Z,2018-06-09T16:18:32Z,MERGED,True,190,103,10,https://github.com/tituschow,ELEC-438: Center Console Inputs,10,[],https://github.com/uw-midsun/firmware/pull/227,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/227#issuecomment-395933355,Adds event generator for center console inputs. We'll need to add outputs for fault/button LED/charging indicator eventually. I'd suggest an LED driver.,Tested and working :),True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,228,2018-06-08T07:53:03Z,2018-06-22T00:12:28Z,2018-06-22T00:12:30Z,MERGED,True,743,214,27,https://github.com/tituschow,ELEC-455: Signal Output,13,[],https://github.com/uw-midsun/firmware/pull/228,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/228,"Begins integration work of signal outputs.
Currently implemented:

Strobe
Turn signals
Hazards
Horn

Still TODO:

Brakes
Headlights
Dash indicator","Begins integration work of signal outputs.
Currently implemented:

Strobe
Turn signals
Hazards
Horn

Still TODO:

Brakes
Headlights
Dash indicator",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,228,2018-06-08T07:53:03Z,2018-06-22T00:12:28Z,2018-06-22T00:12:30Z,MERGED,True,743,214,27,https://github.com/tituschow,ELEC-455: Signal Output,13,[],https://github.com/uw-midsun/firmware/pull/228,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/228#issuecomment-395932712,"Begins integration work of signal outputs.
Currently implemented:

Strobe
Turn signals
Hazards
Horn

Still TODO:

Brakes
Headlights
Dash indicator",Tests?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,229,2018-06-09T01:29:40Z,2018-06-16T06:30:44Z,2018-06-16T06:30:44Z,CLOSED,False,261,38,5,https://github.com/ashraf2047,ELEC-234: Magnetic Brake Event Generator,26,[],https://github.com/uw-midsun/firmware/pull/229,https://github.com/ashraf2047,1,https://github.com/uw-midsun/firmware/pull/229,The magnetic event brake generator module calibrates the output from the magnetic sensor and converts it to a percentage.,The magnetic event brake generator module calibrates the output from the magnetic sensor and converts it to a percentage.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,230,2018-06-09T19:44:59Z,2018-06-09T20:42:24Z,2018-06-09T20:42:27Z,MERGED,True,570,362,9,https://github.com/tituschow,ELEC-439: LTC AFE FSM,4,[],https://github.com/uw-midsun/firmware/pull/230,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/230,"Switches the LTC6804 module from blocking to event-driven. This is necessary because the required delays block CAN processing, resulting in ACK timeouts.
The implementation layer splits conversion triggering from data readback for the FSM layer to delay and sequence appropriately. The intended usage is to register callbacks for the cell/aux conversion results.","Switches the LTC6804 module from blocking to event-driven. This is necessary because the required delays block CAN processing, resulting in ACK timeouts.
The implementation layer splits conversion triggering from data readback for the FSM layer to delay and sequence appropriately. The intended usage is to register callbacks for the cell/aux conversion results.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,231,2018-06-09T20:36:43Z,2018-06-09T21:05:08Z,2018-06-09T21:05:12Z,MERGED,True,5,1,2,https://github.com/ckitagawa,ELEC-457: Fix CAN Ack Race,2,[],https://github.com/uw-midsun/firmware/pull/231,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/231,Fixes a bug where a timeout of an ACK can interrupt the RX handler.,Fixes a bug where a timeout of an ACK can interrupt the RX handler.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,232,2018-06-09T20:48:02Z,2018-06-09T21:54:07Z,2018-06-09T21:54:11Z,MERGED,True,17,15,7,https://github.com/ckitagawa,ELEC-458: Fix Chaos Configs,6,[],https://github.com/uw-midsun/firmware/pull/232,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/232,Fixes a number of configs in Chaos.,Fixes a number of configs in Chaos.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,233,2018-06-09T21:06:01Z,2018-06-09T22:19:34Z,2018-06-09T22:19:34Z,CLOSED,False,92,3,7,https://github.com/ckitagawa,ELEC-459: Delay Service,5,[],https://github.com/uw-midsun/firmware/pull/233,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/233,Add a delay service to Chaos so it can await the DCDCs starting and GPIO pins transitioning.,Add a delay service to Chaos so it can await the DCDCs starting and GPIO pins transitioning.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,234,2018-06-09T21:56:47Z,2018-06-09T23:32:35Z,2018-06-09T23:32:39Z,MERGED,True,48,1,4,https://github.com/ckitagawa,ELEC-460: Power Path Send Data,4,[],https://github.com/uw-midsun/firmware/pull/234,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/234,Add the ability for power path to periodically send data to telemetry and driver display.,Add the ability for power path to periodically send data to telemetry and driver display.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,235,2018-06-09T23:00:12Z,2018-06-10T07:06:10Z,2018-06-10T07:06:12Z,MERGED,True,201,27,12,https://github.com/tituschow,ELEC-456: Calibration Persist/MVP,9,[],https://github.com/uw-midsun/firmware/pull/235,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/235,Adds calibration persistence and small fixes to make everything work. Adds a mostly complete main loop to test everything.,Adds calibration persistence and small fixes to make everything work. Adds a mostly complete main loop to test everything.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,235,2018-06-09T23:00:12Z,2018-06-10T07:06:10Z,2018-06-10T07:06:12Z,MERGED,True,201,27,12,https://github.com/tituschow,ELEC-456: Calibration Persist/MVP,9,[],https://github.com/uw-midsun/firmware/pull/235,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/235#issuecomment-396025558,Adds calibration persistence and small fixes to make everything work. Adds a mostly complete main loop to test everything.,@ckitagawa I'm going to merge this in before it gets any larger. I've created a new ticket to address the I2C instability.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,236,2018-06-10T06:57:43Z,2018-06-10T22:03:06Z,2018-06-10T22:03:08Z,MERGED,True,10,5,2,https://github.com/tituschow,ELEC-448: Add MC powertrain heartbeat,3,[],https://github.com/uw-midsun/firmware/pull/236,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/236,Adds powertrain heartbeat to motor controller interface. Also fixes the config.,Adds powertrain heartbeat to motor controller interface. Also fixes the config.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,237,2018-06-10T21:34:18Z,2018-06-10T22:26:51Z,2018-06-10T22:26:54Z,MERGED,True,120,49,14,https://github.com/ckitagawa,ELEC-459: Delay Service,11,[],https://github.com/uw-midsun/firmware/pull/237,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/237,Turns out we need this as otherwise motor interface with precharge won't turn on in transition to drive events. Also fixes a couple bugs with period of reading information from power_path.,Turns out we need this as otherwise motor interface with precharge won't turn on in transition to drive events. Also fixes a couple bugs with period of reading information from power_path.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,238,2018-06-10T22:27:18Z,2018-06-29T01:31:15Z,2018-10-19T02:04:11Z,CLOSED,False,46,34,7,https://github.com/ckitagawa,ELEC-465: Integration Variant of Power Distribution.,12,[],https://github.com/uw-midsun/firmware/pull/238,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/238,"In an effort to aid @tituschow in integration this branch exists as a temporary debugging aid. The PR is to record if specific issues or bugs are found in testing.
This branch is special in that it:

Bootstraps the car immediately into the Drive State (see main.c). This can be commented out if testing transitions between states starting in Idle is desirable.
Ignores the solar array relays

Other modifications that may be desirable:

Comment out emergency_fault_process_event(...) in main.c (risks de-sync with driver controls on fault but might be necessary if there are no handlers for it)
Comment out powertrain_heartbeat_process_event(...) in main.c if the powertrain heartbeat handling is being wonky/isn't merged.

Known Issues/Quirks:

@tituschow commented that driver controls isn't getting powered. This doesn't appear to be possible firmware wise. The only modification to that pin occurs in gpio_fsm_init() which is only called once when the board is first powered. I suggest checking the electrical connections and re-flashing with the code exactly on this branch.
There appears to be some flakiness in responding to BPS heartbeats mid-transition. This was reasonably stable as of last night but may arise again.
As the overall state is not re-entrant ie. idle -> idle does nothing. A debug message about failing a transition may be raised over UART. This is usually fine.","In an effort to aid @tituschow in integration this branch exists as a temporary debugging aid. The PR is to record if specific issues or bugs are found in testing.
This branch is special in that it:

Bootstraps the car immediately into the Drive State (see main.c). This can be commented out if testing transitions between states starting in Idle is desirable.
Ignores the solar array relays

Other modifications that may be desirable:

Comment out emergency_fault_process_event(...) in main.c (risks de-sync with driver controls on fault but might be necessary if there are no handlers for it)
Comment out powertrain_heartbeat_process_event(...) in main.c if the powertrain heartbeat handling is being wonky/isn't merged.

Known Issues/Quirks:

@tituschow commented that driver controls isn't getting powered. This doesn't appear to be possible firmware wise. The only modification to that pin occurs in gpio_fsm_init() which is only called once when the board is first powered. I suggest checking the electrical connections and re-flashing with the code exactly on this branch.
There appears to be some flakiness in responding to BPS heartbeats mid-transition. This was reasonably stable as of last night but may arise again.
As the overall state is not re-entrant ie. idle -> idle does nothing. A debug message about failing a transition may be raised over UART. This is usually fine.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,239,2018-06-11T06:47:30Z,2018-06-23T19:51:58Z,2018-06-23T19:52:00Z,MERGED,True,703,9,13,https://github.com/tituschow, ELEC-462: MCP2515,21,[],https://github.com/uw-midsun/firmware/pull/239,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/239,"Adds a driver for the MCP2515 SPI CAN controller and a generic CAN port. Motor controller interface has been modified to use the MCP2515 generic CAN instance.
Also adds a debug script that pulls data from the CANUSB adapter through SocketCAN and parses it.","Adds a driver for the MCP2515 SPI CAN controller and a generic CAN port. Motor controller interface has been modified to use the MCP2515 generic CAN instance.
Also adds a debug script that pulls data from the CANUSB adapter through SocketCAN and parses it.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,239,2018-06-11T06:47:30Z,2018-06-23T19:51:58Z,2018-06-23T19:52:00Z,MERGED,True,703,9,13,https://github.com/tituschow, ELEC-462: MCP2515,21,[],https://github.com/uw-midsun/firmware/pull/239,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/239#issuecomment-396809533,"Adds a driver for the MCP2515 SPI CAN controller and a generic CAN port. Motor controller interface has been modified to use the MCP2515 generic CAN instance.
Also adds a debug script that pulls data from the CANUSB adapter through SocketCAN and parses it.",Too tired to review ATM. Will look at it tomorrow or more likely Thursday. Apologies for the delay. I hope this doesn't block too much bench testing.,True,{'THUMBS_UP': ['https://github.com/tituschow']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,239,2018-06-11T06:47:30Z,2018-06-23T19:51:58Z,2018-06-23T19:52:00Z,MERGED,True,703,9,13,https://github.com/tituschow, ELEC-462: MCP2515,21,[],https://github.com/uw-midsun/firmware/pull/239,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/239#issuecomment-397509441,"Adds a driver for the MCP2515 SPI CAN controller and a generic CAN port. Motor controller interface has been modified to use the MCP2515 generic CAN instance.
Also adds a debug script that pulls data from the CANUSB adapter through SocketCAN and parses it.",I've reverted the change to mc_interface. We'll keep it as CAN UART until the new boards come in.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,239,2018-06-11T06:47:30Z,2018-06-23T19:51:58Z,2018-06-23T19:52:00Z,MERGED,True,703,9,13,https://github.com/tituschow, ELEC-462: MCP2515,21,[],https://github.com/uw-midsun/firmware/pull/239,https://github.com/tituschow,4,https://github.com/uw-midsun/firmware/pull/239#issuecomment-399580983,"Adds a driver for the MCP2515 SPI CAN controller and a generic CAN port. Motor controller interface has been modified to use the MCP2515 generic CAN instance.
Also adds a debug script that pulls data from the CANUSB adapter through SocketCAN and parses it.",ping @ckitagawa,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,240,2018-06-11T06:52:13Z,2018-06-13T08:26:41Z,2018-06-13T08:26:44Z,MERGED,True,156,0,4,https://github.com/tituschow,ELEC-464: Handle BPS fault,6,[],https://github.com/uw-midsun/firmware/pull/240,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/240,"Adds BPS fault handling to hopefully stay in sync with power distribution.
@ckitagawa I've been seeing some weirdness where driver controls faults because it fails to receive a power state transition ACK, causing us to enter the fault state while power distribution stays idle. I need to completely restart the car to get out of that state.","Adds BPS fault handling to hopefully stay in sync with power distribution.
@ckitagawa I've been seeing some weirdness where driver controls faults because it fails to receive a power state transition ACK, causing us to enter the fault state while power distribution stays idle. I need to completely restart the car to get out of that state.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,241,2018-06-11T07:15:07Z,2018-06-13T07:30:43Z,2018-06-13T07:30:47Z,MERGED,True,69,2,3,https://github.com/tituschow,ELEC-432: Add debug LED wrapper,3,[],https://github.com/uw-midsun/firmware/pull/241,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/241,"Adds a wrapper for the controller board's debug LEDs.
Also adds an example use-case for Plutus. The red LED will turn on when faulting, and the yellow LED represents good ACKs.","Adds a wrapper for the controller board's debug LEDs.
Also adds an example use-case for Plutus. The red LED will turn on when faulting, and the yellow LED represents good ACKs.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,242,2018-06-11T22:53:45Z,2018-06-23T20:02:23Z,2018-09-16T18:17:38Z,CLOSED,False,92,44,16,https://github.com/ckitagawa,ELEC-465: Make Driver Controls Tolerant to Missed Acks,7,[],https://github.com/uw-midsun/firmware/pull/242,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/242,This increases the driver controls tolerance to missed Power State acks.,This increases the driver controls tolerance to missed Power State acks.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,242,2018-06-11T22:53:45Z,2018-06-23T20:02:23Z,2018-09-16T18:17:38Z,CLOSED,False,92,44,16,https://github.com/ckitagawa,ELEC-465: Make Driver Controls Tolerant to Missed Acks,7,[],https://github.com/uw-midsun/firmware/pull/242,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/242#issuecomment-399284221,This increases the driver controls tolerance to missed Power State acks.,Outdated? Should this be closed?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,243,2018-06-11T23:27:34Z,2018-06-16T23:04:27Z,2018-06-16T23:04:31Z,MERGED,True,23,17,2,https://github.com/andyjiin,ELEC-443: PWM to support microseconds ,11,[],https://github.com/uw-midsun/firmware/pull/243,https://github.com/andyjiin,1,https://github.com/uw-midsun/firmware/pull/243,Refactored PWM to support microseconds,Refactored PWM to support microseconds,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,244,2018-06-12T08:16:56Z,2018-06-20T03:34:11Z,2018-06-20T03:34:11Z,CLOSED,False,158,62,17,https://github.com/tituschow,ELEC-461: Fix throttle,26,[],https://github.com/uw-midsun/firmware/pull/244,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/244,"This PR has the code required to handle the throttle. I'll probably split the PRs up properly and fix the tests later. There's still a bunch of cleanup required.
Key changes:

Add I2C timeout recovery
Add system CAN dump script through SocketCAN (ideally I'd like to add an interface for telemetry as well)
Add watchdog to ADS1015 - force-triggers interrupt if timed out
Add ""watchdog"" to MCP23008 - force-triggers interrupt periodically to ensure we didn't miss an interrupt
Limit the amount the throttle can change in drive output
Add logging to FSMs","This PR has the code required to handle the throttle. I'll probably split the PRs up properly and fix the tests later. There's still a bunch of cleanup required.
Key changes:

Add I2C timeout recovery
Add system CAN dump script through SocketCAN (ideally I'd like to add an interface for telemetry as well)
Add watchdog to ADS1015 - force-triggers interrupt if timed out
Add ""watchdog"" to MCP23008 - force-triggers interrupt periodically to ensure we didn't miss an interrupt
Limit the amount the throttle can change in drive output
Add logging to FSMs",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,244,2018-06-12T08:16:56Z,2018-06-20T03:34:11Z,2018-06-20T03:34:11Z,CLOSED,False,158,62,17,https://github.com/tituschow,ELEC-461: Fix throttle,26,[],https://github.com/uw-midsun/firmware/pull/244,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/244#issuecomment-397854976,"This PR has the code required to handle the throttle. I'll probably split the PRs up properly and fix the tests later. There's still a bunch of cleanup required.
Key changes:

Add I2C timeout recovery
Add system CAN dump script through SocketCAN (ideally I'd like to add an interface for telemetry as well)
Add watchdog to ADS1015 - force-triggers interrupt if timed out
Add ""watchdog"" to MCP23008 - force-triggers interrupt periodically to ensure we didn't miss an interrupt
Limit the amount the throttle can change in drive output
Add logging to FSMs","@ckitagawa - Once #261, #260, #259, and #258 are in, there should only be small changes left in this branch and it should be good for final review.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,245,2018-06-12T23:07:14Z,2018-06-13T07:40:49Z,2018-06-13T07:40:52Z,MERGED,True,145,113,14,https://github.com/tituschow,ELEC-466: Fix BPS slave,10,[],https://github.com/uw-midsun/firmware/pull/245,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/245,"Fixes the hardfault - we were trying to process events in an FSM that wasn't initialized.
Also changes CAN so it no longer ACKs critical messages unless the user has registered a callback for it and changed the BPS heartbeat to a bitset.
There is also a python script for dumping system CAN.","Fixes the hardfault - we were trying to process events in an FSM that wasn't initialized.
Also changes CAN so it no longer ACKs critical messages unless the user has registered a callback for it and changed the BPS heartbeat to a bitset.
There is also a python script for dumping system CAN.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,245,2018-06-12T23:07:14Z,2018-06-13T07:40:49Z,2018-06-13T07:40:52Z,MERGED,True,145,113,14,https://github.com/tituschow,ELEC-466: Fix BPS slave,10,[],https://github.com/uw-midsun/firmware/pull/245,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/245#issuecomment-396808587,"Fixes the hardfault - we were trying to process events in an FSM that wasn't initialized.
Also changes CAN so it no longer ACKs critical messages unless the user has registered a callback for it and changed the BPS heartbeat to a bitset.
There is also a python script for dumping system CAN.","@ckitagawa Travis is being super glitchy right now but all the tests pass locally. It seems to be failing on can.
Edit: nevermind I'm dumb",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,246,2018-06-13T03:34:34Z,2018-06-15T01:05:23Z,2018-06-15T01:05:26Z,MERGED,True,56,14,8,https://github.com/ckitagawa,ELEC-465: Annotate Emergencies and Backoff on Relay Retry,4,[],https://github.com/uw-midsun/firmware/pull/246,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/246,Annotates the emergency event raises in Chaos and backs off on retrying a relay to avoid spamming the bus.,Annotates the emergency event raises in Chaos and backs off on retrying a relay to avoid spamming the bus.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,247,2018-06-13T03:37:19Z,2018-06-13T04:02:16Z,2018-06-13T04:02:19Z,MERGED,True,4,0,1,https://github.com/ckitagawa,ELEC-465: Fix hardfault bug in ADC,1,[],https://github.com/uw-midsun/firmware/pull/247,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/247,Fixes a bug that causes a hardfault in the ADC driver by dividing by 0 when converting.,Fixes a bug that causes a hardfault in the ADC driver by dividing by 0 when converting.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,248,2018-06-13T03:46:32Z,2018-06-13T04:20:25Z,2018-06-13T04:20:29Z,MERGED,True,25,0,4,https://github.com/ckitagawa,ELEC-465: Allow Delay Service to cancel,4,[],https://github.com/uw-midsun/firmware/pull/248,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/248,Allows the delay service to cancel which avoids up to a 2600 ms delay when interrupted in transitioning between states.,Allows the delay service to cancel which avoids up to a 2600 ms delay when interrupted in transitioning between states.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,249,2018-06-13T04:13:25Z,2018-06-13T04:16:43Z,2018-09-13T07:13:41Z,CLOSED,False,27,31,5,https://github.com/ckitagawa,ELEC-465: Make BPS Heartbeat a bitset,1,[],https://github.com/uw-midsun/firmware/pull/249,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/249,Turns the state field in BPS_HEARTBEAT into a bitset. I'll need to update codegen before merging this as the bitfield is only 8 bits which we can in theory overflow.,Turns the state field in BPS_HEARTBEAT into a bitset. I'll need to update codegen before merging this as the bitfield is only 8 bits which we can in theory overflow.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,249,2018-06-13T04:13:25Z,2018-06-13T04:16:43Z,2018-09-13T07:13:41Z,CLOSED,False,27,31,5,https://github.com/ckitagawa,ELEC-465: Make BPS Heartbeat a bitset,1,[],https://github.com/uw-midsun/firmware/pull/249,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/249#issuecomment-396808025,Turns the state field in BPS_HEARTBEAT into a bitset. I'll need to update codegen before merging this as the bitfield is only 8 bits which we can in theory overflow.,I have a PR open (#245) that makes BPS heartbeat a bitset,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,250,2018-06-13T06:20:12Z,2018-06-16T01:46:38Z,2018-06-16T01:46:40Z,MERGED,True,69,8,6,https://github.com/tituschow,ELEC-446: Select programmer,6,[],https://github.com/uw-midsun/firmware/pull/250,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/250,Adds a script for selecting the debug probe if more than one is attached. Set SERIAL to select a probe through make. Also splits the pylint target from the C lint target.,Adds a script for selecting the debug probe if more than one is attached. Set SERIAL to select a probe through make. Also splits the pylint target from the C lint target.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,251,2018-06-13T06:37:46Z,2018-06-15T20:45:02Z,2018-09-16T09:49:05Z,MERGED,True,20,9,5,https://github.com/tituschow,ELEC-470: Use thread barriers,4,[],https://github.com/uw-midsun/firmware/pull/251,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/251,Adds pthread barriers to block init returns until threads have actually started.,Adds pthread barriers to block init returns until threads have actually started.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,251,2018-06-13T06:37:46Z,2018-06-15T20:45:02Z,2018-09-16T09:49:05Z,MERGED,True,20,9,5,https://github.com/tituschow,ELEC-470: Use thread barriers,4,[],https://github.com/uw-midsun/firmware/pull/251,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/251#issuecomment-397509524,Adds pthread barriers to block init returns until threads have actually started.,Travis seems to consistently hang on the CAN HW tests. Not sure what's causing that.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,251,2018-06-13T06:37:46Z,2018-06-15T20:45:02Z,2018-09-16T09:49:05Z,MERGED,True,20,9,5,https://github.com/tituschow,ELEC-470: Use thread barriers,4,[],https://github.com/uw-midsun/firmware/pull/251,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/251#issuecomment-397511928,Adds pthread barriers to block init returns until threads have actually started.,Ah it seems like TSAN complains about the CAN HW test a lot due to critical sections.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,252,2018-06-16T06:04:05Z,2018-06-16T06:37:00Z,2018-06-16T06:37:00Z,MERGED,True,4697,1095,154,https://github.com/ashraf2047,ELEC-234: Mechanical Brake Calibration,31,[],https://github.com/uw-midsun/firmware/pull/252,https://github.com/ashraf2047,1,https://github.com/uw-midsun/firmware/pull/252,"The mech_brake is a module that calibrates the inputs from the magnetic sensor, then converts subsequent inputs to percentages","The mech_brake is a module that calibrates the inputs from the magnetic sensor, then converts subsequent inputs to percentages",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,252,2018-06-16T06:04:05Z,2018-06-16T06:37:00Z,2018-06-16T06:37:00Z,MERGED,True,4697,1095,154,https://github.com/ashraf2047,ELEC-234: Mechanical Brake Calibration,31,[],https://github.com/uw-midsun/firmware/pull/252,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/252#issuecomment-397791134,"The mech_brake is a module that calibrates the inputs from the magnetic sensor, then converts subsequent inputs to percentages",@ashraf2047 Please merge with master - your commit history is broken,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,253,2018-06-16T06:39:53Z,2018-06-24T02:35:49Z,2018-06-24T02:35:49Z,CLOSED,False,502,3,11,https://github.com/tituschow,ELEC-234: Mechanical Brake Calibration,62,[],https://github.com/uw-midsun/firmware/pull/253,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/253,"Had to create a new PR since your branch was messed up.

The mech_brake is a module that calibrates the inputs from the magnetic sensor, then converts subsequent inputs to percentages","Had to create a new PR since your branch was messed up.

The mech_brake is a module that calibrates the inputs from the magnetic sensor, then converts subsequent inputs to percentages",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,253,2018-06-16T06:39:53Z,2018-06-24T02:35:49Z,2018-06-24T02:35:49Z,CLOSED,False,502,3,11,https://github.com/tituschow,ELEC-234: Mechanical Brake Calibration,62,[],https://github.com/uw-midsun/firmware/pull/253,https://github.com/ad-march,2,https://github.com/uw-midsun/firmware/pull/253#issuecomment-399556262,"Had to create a new PR since your branch was messed up.

The mech_brake is a module that calibrates the inputs from the magnetic sensor, then converts subsequent inputs to percentages",lgtm,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,254,2018-06-16T08:11:36Z,2018-06-17T00:10:29Z,2018-06-17T00:10:32Z,MERGED,True,138,192,36,https://github.com/tituschow,ELEC-469: Update CAN/UART Storage,8,[],https://github.com/uw-midsun/firmware/pull/254,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/254,"Increases UART/CAN FIFO sizes and hardcodes RX handler storage.
I'm considering making FIFO sizes configurable since we have 16k of RAM. 1024 is probably an excessive buffer length.","Increases UART/CAN FIFO sizes and hardcodes RX handler storage.
I'm considering making FIFO sizes configurable since we have 16k of RAM. 1024 is probably an excessive buffer length.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,255,2018-06-16T18:17:25Z,2018-06-16T18:29:53Z,2018-06-16T18:29:56Z,MERGED,True,83,42,10,https://github.com/ckitagawa,ELEC-465: Bug fixes for Power Distribution,9,[],https://github.com/uw-midsun/firmware/pull/255,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/255,A number of bug fixes for power distribution found during integration.,A number of bug fixes for power distribution found during integration.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,256,2018-06-16T21:01:26Z,2018-06-17T00:37:19Z,2018-06-17T00:37:22Z,MERGED,True,67,20,1,https://github.com/tituschow,ELEC-467: Add system dump script,4,[],https://github.com/uw-midsun/firmware/pull/256,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/256,"Updates script for dumping system CAN to handle all currently used messages. Currently uses SocketCAN, but it should be easy to add telemetry (UART) support.","Updates script for dumping system CAN to handle all currently used messages. Currently uses SocketCAN, but it should be easy to add telemetry (UART) support.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,257,2018-06-16T22:55:04Z,2018-06-16T23:18:00Z,2018-06-16T23:18:02Z,MERGED,True,85,5,2,https://github.com/tituschow,ELEC-53: Hardfault Handler,4,[],https://github.com/uw-midsun/firmware/pull/257,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/257,Adds a hardfault handler and replaces the soft timer delay with a busy loop. Soft timers are unstable at very short timeouts.,Adds a hardfault handler and replaces the soft timer delay with a busy loop. Soft timers are unstable at very short timeouts.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,258,2018-06-17T01:56:33Z,2018-06-19T02:40:56Z,2018-06-19T02:40:59Z,MERGED,True,51,20,2,https://github.com/tituschow,ELEC-461: Add I2C recovery function,4,[],https://github.com/uw-midsun/firmware/pull/258,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/258,Attempts to recover from I2C timeouts by manually clocking SCL. This approach seems to work.,Attempts to recover from I2C timeouts by manually clocking SCL. This approach seems to work.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,259,2018-06-17T02:34:45Z,2018-06-19T02:31:48Z,2018-06-19T02:31:50Z,MERGED,True,4,4,3,https://github.com/tituschow,ELEC-475: Fix mocking in STM32,1,[],https://github.com/uw-midsun/firmware/pull/259,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/259,Fixes mock extraction on STM32. Also fixes selecting serial devices on macOS.,Fixes mock extraction on STM32. Also fixes selecting serial devices on macOS.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,259,2018-06-17T02:34:45Z,2018-06-19T02:31:48Z,2018-06-19T02:31:50Z,MERGED,True,4,4,3,https://github.com/tituschow,ELEC-475: Fix mocking in STM32,1,[],https://github.com/uw-midsun/firmware/pull/259,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/259#issuecomment-397850610,Fixes mock extraction on STM32. Also fixes selecting serial devices on macOS.,"Hmm, it seems like mocking doesn't always work because of LTO.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,260,2018-06-17T02:58:31Z,2018-06-19T03:13:57Z,2018-06-19T03:14:03Z,MERGED,True,197,142,10,https://github.com/tituschow,ELEC-416: ADS1015/MCP23008 Watchdog,7,[],https://github.com/uw-midsun/firmware/pull/260,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/260,"Moves the watchdog from the throttle module into the ADS1015 module. Also adds a watchdog/poll to the GPIO expander.
Removes desync tolerance from throttle as we were reading invalid data due to the glitching","Moves the watchdog from the throttle module into the ADS1015 module. Also adds a watchdog/poll to the GPIO expander.
Removes desync tolerance from throttle as we were reading invalid data due to the glitching",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,260,2018-06-17T02:58:31Z,2018-06-19T03:13:57Z,2018-06-19T03:14:03Z,MERGED,True,197,142,10,https://github.com/tituschow,ELEC-416: ADS1015/MCP23008 Watchdog,7,[],https://github.com/uw-midsun/firmware/pull/260,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/260#issuecomment-398252341,"Moves the watchdog from the throttle module into the ADS1015 module. Also adds a watchdog/poll to the GPIO expander.
Removes desync tolerance from throttle as we were reading invalid data due to the glitching","The ADS1015 is a pretty traditional watchdog. I'd say the MCP23008 isn't actually a watchdog, it's more of a polled ""just in case"" thing.",True,{'THUMBS_UP': ['https://github.com/ckitagawa']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,261,2018-06-17T04:09:02Z,2018-06-19T03:40:12Z,2018-06-19T03:40:18Z,MERGED,True,90,18,7,https://github.com/tituschow,ELEC-476: Handle AFE faults,5,[],https://github.com/uw-midsun/firmware/pull/261,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/261,Adds checks for AFE status codes and retry logic to attempt to recover from an error after conversion.,Adds checks for AFE status codes and retry logic to attempt to recover from an error after conversion.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,262,2018-06-17T18:11:39Z,2018-09-21T12:54:50Z,2018-09-21T12:54:50Z,CLOSED,False,422,1,11,https://github.com/andyjiin,ELEC 434: Display brightness adjust,31,[],https://github.com/uw-midsun/firmware/pull/262,https://github.com/andyjiin,1,https://github.com/uw-midsun/firmware/pull/262,"nothing to activate calibration mode yet
currently sampling brightness every 5s","nothing to activate calibration mode yet
currently sampling brightness every 5s",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,262,2018-06-17T18:11:39Z,2018-09-21T12:54:50Z,2018-09-21T12:54:50Z,CLOSED,False,422,1,11,https://github.com/andyjiin,ELEC 434: Display brightness adjust,31,[],https://github.com/uw-midsun/firmware/pull/262,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/262#issuecomment-397903372,"nothing to activate calibration mode yet
currently sampling brightness every 5s",Please use more descriptive commit messages.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,263,2018-06-19T01:59:30Z,2018-06-19T02:08:18Z,2018-06-19T02:08:18Z,CLOSED,False,394,274,48,https://github.com/ashraf2047,ELEC-234: Mechanical Brake Calibration ,5,[],https://github.com/uw-midsun/firmware/pull/263,https://github.com/ashraf2047,1,https://github.com/uw-midsun/firmware/pull/263,"This is the module for the mechanical brake. It reads brake inputs as LSBs from ADS1015, then converts those readings into percentage data.At the same time, it raises events, INPUT_EVENT_MECHANICAL_BRAKE_PRESSED, and INPUT_EVENT_MECHANICAL_BRAKE_PRESSED.","This is the module for the mechanical brake. It reads brake inputs as LSBs from ADS1015, then converts those readings into percentage data.At the same time, it raises events, INPUT_EVENT_MECHANICAL_BRAKE_PRESSED, and INPUT_EVENT_MECHANICAL_BRAKE_PRESSED.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,263,2018-06-19T01:59:30Z,2018-06-19T02:08:18Z,2018-06-19T02:08:18Z,CLOSED,False,394,274,48,https://github.com/ashraf2047,ELEC-234: Mechanical Brake Calibration ,5,[],https://github.com/uw-midsun/firmware/pull/263,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/263#issuecomment-398251485,"This is the module for the mechanical brake. It reads brake inputs as LSBs from ADS1015, then converts those readings into percentage data.At the same time, it raises events, INPUT_EVENT_MECHANICAL_BRAKE_PRESSED, and INPUT_EVENT_MECHANICAL_BRAKE_PRESSED.",Your branch is completely broken. Please stop creating new PRs - use #253.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,264,2018-06-19T02:35:26Z,2018-06-22T02:04:14Z,2018-06-22T02:04:18Z,MERGED,True,46,34,8,https://github.com/ckitagawa,ELEC-465: Fix ADCs + Power Distribution Quirks,19,[],https://github.com/uw-midsun/firmware/pull/264,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/264,Fixes the issues with ADCs not triggering properly and dying. Also reduces some UART/CAN spamming from some scenarios.,Fixes the issues with ADCs not triggering properly and dying. Also reduces some UART/CAN spamming from some scenarios.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,264,2018-06-19T02:35:26Z,2018-06-22T02:04:14Z,2018-06-22T02:04:18Z,MERGED,True,46,34,8,https://github.com/ckitagawa,ELEC-465: Fix ADCs + Power Distribution Quirks,19,[],https://github.com/uw-midsun/firmware/pull/264,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/264#issuecomment-398256122,Fixes the issues with ADCs not triggering properly and dying. Also reduces some UART/CAN spamming from some scenarios.,I couldn't repro the test cases failing on the controller board I was working with... They were just the ones in LIBRARY=ms-common not some ADC test project right?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,264,2018-06-19T02:35:26Z,2018-06-22T02:04:14Z,2018-06-22T02:04:18Z,MERGED,True,46,34,8,https://github.com/ckitagawa,ELEC-465: Fix ADCs + Power Distribution Quirks,19,[],https://github.com/uw-midsun/firmware/pull/264,https://github.com/tituschow,3,https://github.com/uw-midsun/firmware/pull/264#issuecomment-398256205,Fixes the issues with ADCs not triggering properly and dying. Also reduces some UART/CAN spamming from some scenarios.,"Yeah, just test_adc. Maybe it was because it was plugged into a carrier.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,264,2018-06-19T02:35:26Z,2018-06-22T02:04:14Z,2018-06-22T02:04:18Z,MERGED,True,46,34,8,https://github.com/ckitagawa,ELEC-465: Fix ADCs + Power Distribution Quirks,19,[],https://github.com/uw-midsun/firmware/pull/264,https://github.com/tituschow,4,https://github.com/uw-midsun/firmware/pull/264#issuecomment-398256315,Fixes the issues with ADCs not triggering properly and dying. Also reduces some UART/CAN spamming from some scenarios.,"Oh, could you fix the naming and lack of void in test_adc.c?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,265,2018-06-20T03:49:30Z,2018-06-21T20:11:58Z,2018-06-21T20:12:01Z,MERGED,True,164,69,21,https://github.com/tituschow,ELEC-461: Fix Throttle,30,[],https://github.com/uw-midsun/firmware/pull/265,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/265,"Increases the drive output watchdog to provide leeway for timeouts
Fixes hardfault handlers being linked farther away than the branch instruction could support
Adds powertrain fault handling
Add throttle drive output change rate-limiting
Actually check for throttle status codes
Split BPS heartbeat event raise from actually updating the indicators
Temporary fix for motor controller interface by slowing down the rate we send messages (This might be fixed by the UART change)

There's some debug stuff I need to clean up but this is pretty much good to review.","Increases the drive output watchdog to provide leeway for timeouts
Fixes hardfault handlers being linked farther away than the branch instruction could support
Adds powertrain fault handling
Add throttle drive output change rate-limiting
Actually check for throttle status codes
Split BPS heartbeat event raise from actually updating the indicators
Temporary fix for motor controller interface by slowing down the rate we send messages (This might be fixed by the UART change)

There's some debug stuff I need to clean up but this is pretty much good to review.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,266,2018-06-22T01:36:05Z,2018-06-23T21:22:32Z,2018-06-23T21:22:35Z,MERGED,True,45,10,7,https://github.com/ckitagawa,ELEC-482: Fix soft timer race in stm32f0xx,14,[],https://github.com/uw-midsun/firmware/pull/266,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/266,"Wrap start/cancel in critical sections
Require minimum time to start
Don't call prv_update in the start timer
Require minimum period between interrupts","Wrap start/cancel in critical sections
Require minimum time to start
Don't call prv_update in the start timer
Require minimum period between interrupts",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,267,2018-06-23T02:10:25Z,2018-06-23T18:45:24Z,2018-06-23T18:45:34Z,MERGED,True,237,22,8,https://github.com/tituschow,ELEC-471: Packet Framing,8,[],https://github.com/uw-midsun/firmware/pull/267,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/267,"Adds COBS encoding/decoding and packet framing. I haven't tested the CAN UART modifications yet (will do so Saturday), but the COBS part seems to be working. I rewrote the algorithms so I actually understand how they work now :P","Adds COBS encoding/decoding and packet framing. I haven't tested the CAN UART modifications yet (will do so Saturday), but the COBS part seems to be working. I rewrote the algorithms so I actually understand how they work now :P",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,267,2018-06-23T02:10:25Z,2018-06-23T18:45:24Z,2018-06-23T18:45:34Z,MERGED,True,237,22,8,https://github.com/tituschow,ELEC-471: Packet Framing,8,[],https://github.com/uw-midsun/firmware/pull/267,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/267#issuecomment-399692622,"Adds COBS encoding/decoding and packet framing. I haven't tested the CAN UART modifications yet (will do so Saturday), but the COBS part seems to be working. I rewrote the algorithms so I actually understand how they work now :P",Not '0' but 0x00.,True,{'THUMBS_UP': ['https://github.com/ckitagawa']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,268,2018-06-23T18:43:59Z,2018-06-23T20:35:28Z,2018-06-23T20:35:32Z,MERGED,True,33,28,8,https://github.com/ckitagawa,ELEC-479: Update codegen,5,[],https://github.com/uw-midsun/firmware/pull/268,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/268,Had to pseudo-manually do this since the University somehow exceeded the GitHub Rate ACLs for the IP block.,Had to pseudo-manually do this since the University somehow exceeded the GitHub Rate ACLs for the IP block.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,269,2018-06-24T02:36:26Z,2018-06-25T00:42:09Z,2018-06-25T00:43:21Z,MERGED,True,501,4,11,https://github.com/ashraf2047,ELEC-234: Mechanical Brake Calibration,75,[],https://github.com/uw-midsun/firmware/pull/269,https://github.com/ashraf2047,1,https://github.com/uw-midsun/firmware/pull/269,,,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,270,2018-06-26T02:33:07Z,2018-06-28T01:38:31Z,2018-06-28T01:38:34Z,MERGED,True,266,125,26,https://github.com/tituschow,ELEC-487: Plutus Integration,12,[],https://github.com/uw-midsun/firmware/pull/270,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/270,"Adds current calibration + fault monitoring. (Also adds mech brake calibration - untested)
Fixes bug in the LTC AFE FSM where cell read retries weren't being processed.
Still waiting on @ericslchiang for temp faulting.","Adds current calibration + fault monitoring. (Also adds mech brake calibration - untested)
Fixes bug in the LTC AFE FSM where cell read retries weren't being processed.
Still waiting on @ericslchiang for temp faulting.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,271,2018-06-26T03:21:10Z,2018-06-28T01:04:53Z,2018-06-28T01:04:58Z,MERGED,True,30,36,6,https://github.com/tituschow,ELEC-455: Use signal outputs,7,[],https://github.com/uw-midsun/firmware/pull/271,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/271,Driver controls should now handle signals properly.,Driver controls should now handle signals properly.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,272,2018-06-26T06:06:04Z,2018-06-29T02:28:37Z,2018-06-29T02:28:39Z,MERGED,True,128,56,17,https://github.com/tituschow,ELEC-488: Motor Power updates,15,[],https://github.com/uw-midsun/firmware/pull/272,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/272,"Adds bus measurement reporting to motor interface.
@ckitagawa - I had to increase the number of generic CAN handlers and I had some issues with clearing the RX storage.","Adds bus measurement reporting to motor interface.
@ckitagawa - I had to increase the number of generic CAN handlers and I had some issues with clearing the RX storage.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,273,2018-06-28T00:44:34Z,2018-06-28T04:09:59Z,2018-06-28T04:10:02Z,MERGED,True,65,6,12,https://github.com/ckitagawa,ELEC-490: Increase Chaos Watchdog timeouts and Add Fan Control Message.,10,[],https://github.com/uw-midsun/firmware/pull/273,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/273,Approximately doubles the watchdog timeouts. This should really reduce chance of early failure.,Approximately doubles the watchdog timeouts. This should really reduce chance of early failure.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,274,2018-06-28T17:23:41Z,2018-06-29T02:02:24Z,2018-06-29T02:02:27Z,MERGED,True,4,2,2,https://github.com/tituschow,ELEC-456: Actually commit mech brake calibration,2,[],https://github.com/uw-midsun/firmware/pull/274,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/274,"I forgot to actually commit mech brake calibration data. With that, mech brake works well @ashraf2047 :)","I forgot to actually commit mech brake calibration data. With that, mech brake works well @ashraf2047 :)",True,{'THUMBS_UP': ['https://github.com/ashraf2047']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,275,2018-06-28T23:20:57Z,2018-06-30T17:39:10Z,2018-09-16T18:21:24Z,MERGED,True,57,18,12,https://github.com/ckitagawa,ELEC-495: Chaos Fault Reason and Codegen Roll,4,[],https://github.com/uw-midsun/firmware/pull/275,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/275,Adds fault reasons to Chaos and rolls codegen tooling.,Adds fault reasons to Chaos and rolls codegen tooling.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,276,2018-06-28T23:43:53Z,2018-07-03T23:29:52Z,2018-07-03T23:29:52Z,CLOSED,False,7854,193,14,https://github.com/mishazharov,ELEC-63: SD Card Driver,3,[],https://github.com/uw-midsun/firmware/pull/276,https://github.com/mishazharov,1,https://github.com/uw-midsun/firmware/pull/276,Hey guys. I was able to port a SD card driver provided by STM and also added FatFs for telemetry. Currently untested but will do that soon,Hey guys. I was able to port a SD card driver provided by STM and also added FatFs for telemetry. Currently untested but will do that soon,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,276,2018-06-28T23:43:53Z,2018-07-03T23:29:52Z,2018-07-03T23:29:52Z,CLOSED,False,7854,193,14,https://github.com/mishazharov,ELEC-63: SD Card Driver,3,[],https://github.com/uw-midsun/firmware/pull/276,https://github.com/mishazharov,2,https://github.com/uw-midsun/firmware/pull/276#issuecomment-402320079,Hey guys. I was able to port a SD card driver provided by STM and also added FatFs for telemetry. Currently untested but will do that soon,Just going to close this PR until I finish it and test it,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,277,2018-06-28T23:53:59Z,2018-06-30T16:29:53Z,2018-06-30T16:29:56Z,MERGED,True,1,1,1,https://github.com/ckitagawa,ELEC-496: Chaos fix charger logic bug,2,[],https://github.com/uw-midsun/firmware/pull/277,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/277,Whoops...,Whoops...,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,277,2018-06-28T23:53:59Z,2018-06-30T16:29:53Z,2018-06-30T16:29:56Z,MERGED,True,1,1,1,https://github.com/ckitagawa,ELEC-496: Chaos fix charger logic bug,2,[],https://github.com/uw-midsun/firmware/pull/277,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/277#issuecomment-401550698,Whoops...,As per discussion; Chaos automatically responds with OPEN by default if the charger is notifying that a power source is connected. Otherwise it responds with CLOSE if the car is actually in Charging. This bug was preventing Chaos from ever entering the CLOSE state when charging.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,278,2018-06-29T00:30:57Z,,2019-01-17T02:56:07Z,OPEN,False,110,87,13,https://github.com/ckitagawa,ELEC-497: Charger MCP2515,14,[],https://github.com/uw-midsun/firmware/pull/278,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/278,Adds MCP2515 and pilot select pin support for the charger.,Adds MCP2515 and pilot select pin support for the charger.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,278,2018-06-29T00:30:57Z,,2019-01-17T02:56:07Z,OPEN,False,110,87,13,https://github.com/ckitagawa,ELEC-497: Charger MCP2515,14,[],https://github.com/uw-midsun/firmware/pull/278,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/278#issuecomment-402000442,Adds MCP2515 and pilot select pin support for the charger.,Will test on HW tomorrow % any major issues I need to help with fixing.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,279,2018-06-29T01:04:52Z,,2019-04-11T00:15:18Z,OPEN,False,82,48,4,https://github.com/ckitagawa,ELEC-105: Update Pins to Rev3 Chaos,4,[],https://github.com/uw-midsun/firmware/pull/279,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/279,I modified main.c for Taiping to verify his bringup that will be reverted before merging.,I modified main.c for Taiping to verify his bringup that will be reverted before merging.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,279,2018-06-29T01:04:52Z,,2019-04-11T00:15:18Z,OPEN,False,82,48,4,https://github.com/ckitagawa,ELEC-105: Update Pins to Rev3 Chaos,4,[],https://github.com/uw-midsun/firmware/pull/279,https://github.com/mishazharov,2,https://github.com/uw-midsun/firmware/pull/279#issuecomment-476017269,I modified main.c for Taiping to verify his bringup that will be reverted before merging.,What is the status of this PR? Can it be merged / handed off or should we just close it?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,279,2018-06-29T01:04:52Z,,2019-04-11T00:15:18Z,OPEN,False,82,48,4,https://github.com/ckitagawa,ELEC-105: Update Pins to Rev3 Chaos,4,[],https://github.com/uw-midsun/firmware/pull/279,https://github.com/ckitagawa,3,https://github.com/uw-midsun/firmware/pull/279#issuecomment-481088002,I modified main.c for Taiping to verify his bringup that will be reverted before merging.,"Sorry, I haven't been around. The code in this PR should be tested on Chaos Rev 3 (if the pinout hasn't already been updated in the master) and the debug code removed once tested (revert main.c to master).
@mishazharov or @ashraf2047 can one of you take that over?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,279,2018-06-29T01:04:52Z,,2019-04-11T00:15:18Z,OPEN,False,82,48,4,https://github.com/ckitagawa,ELEC-105: Update Pins to Rev3 Chaos,4,[],https://github.com/uw-midsun/firmware/pull/279,https://github.com/mishazharov,4,https://github.com/uw-midsun/firmware/pull/279#issuecomment-481918032,I modified main.c for Taiping to verify his bringup that will be reverted before merging.,"Yes, I can take a look at this next term. How should this be tested, just run the tests which are already written?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,280,2018-06-29T01:31:01Z,2018-07-04T01:54:53Z,2018-10-19T02:03:04Z,CLOSED,False,33,36,4,https://github.com/ckitagawa,ELEC-105: Integration variant for testing in the vehicle,3,[],https://github.com/uw-midsun/firmware/pull/280,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/280,,,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,280,2018-06-29T01:31:01Z,2018-07-04T01:54:53Z,2018-10-19T02:03:04Z,CLOSED,False,33,36,4,https://github.com/ckitagawa,ELEC-105: Integration variant for testing in the vehicle,3,[],https://github.com/uw-midsun/firmware/pull/280,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/280#issuecomment-401238472,,We should just make this a compile-time flag.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,281,2018-06-29T02:27:27Z,2018-07-02T17:53:59Z,2018-07-02T17:54:03Z,MERGED,True,58,29,10,https://github.com/tituschow,ELEC-498: Require explicit overwrite for persist,6,[],https://github.com/uw-midsun/firmware/pull/281,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/281,"Adds a flag to prevent overwriting mismatched blobs unless explicitly requested.
This should prevent calibrated values from being cleared unless a calibration program is run.","Adds a flag to prevent overwriting mismatched blobs unless explicitly requested.
This should prevent calibrated values from being cleared unless a calibration program is run.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,281,2018-06-29T02:27:27Z,2018-07-02T17:53:59Z,2018-07-02T17:54:03Z,MERGED,True,58,29,10,https://github.com/tituschow,ELEC-498: Require explicit overwrite for persist,6,[],https://github.com/uw-midsun/firmware/pull/281,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/281#issuecomment-401582808,"Adds a flag to prevent overwriting mismatched blobs unless explicitly requested.
This should prevent calibrated values from being cleared unless a calibration program is run.",ping @ckitagawa,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,282,2018-06-29T03:48:24Z,,2019-03-25T00:17:49Z,OPEN,False,166,15,10,https://github.com/tituschow,ELEC-489: Minimize fan on aux,11,[],https://github.com/uw-midsun/firmware/pull/282,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/282,"Adds a hook for sequenced relays.
The idea is that we hook the relay state and keep the fans on only while the relays are closed or we've faulted. This means that turning off the car properly should turn the fans off.
We expect Chaos to turn the fans off after clearing a fault.","Adds a hook for sequenced relays.
The idea is that we hook the relay state and keep the fans on only while the relays are closed or we've faulted. This means that turning off the car properly should turn the fans off.
We expect Chaos to turn the fans off after clearing a fault.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,282,2018-06-29T03:48:24Z,,2019-03-25T00:17:49Z,OPEN,False,166,15,10,https://github.com/tituschow,ELEC-489: Minimize fan on aux,11,[],https://github.com/uw-midsun/firmware/pull/282,https://github.com/mishazharov,2,https://github.com/uw-midsun/firmware/pull/282#issuecomment-476016856,"Adds a hook for sequenced relays.
The idea is that we hook the relay state and keep the fans on only while the relays are closed or we've faulted. This means that turning off the car properly should turn the fans off.
We expect Chaos to turn the fans off after clearing a fault.",What is the status of this PR? Can it be merged / handed off or should we just close it?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,283,2018-06-29T03:51:02Z,2018-10-06T04:33:29Z,2018-10-06T04:33:29Z,CLOSED,False,203,59,11,https://github.com/tituschow,ELEC-481: Add center console LEDs,9,[],https://github.com/uw-midsun/firmware/pull/283,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/283,"This hopefully adds LED outputs to new center console board.
I'll be sure to test this before it's merged.","This hopefully adds LED outputs to new center console board.
I'll be sure to test this before it's merged.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,284,2018-06-29T04:11:56Z,2018-07-02T06:23:03Z,2018-07-02T06:40:05Z,MERGED,True,94,8,2,https://github.com/tituschow,ELEC-492: Update dump script to COBS,12,[],https://github.com/uw-midsun/firmware/pull/284,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/284,Adds support for parsing data directly from telemetry to the system dump script.,Adds support for parsing data directly from telemetry to the system dump script.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,285,2018-06-29T08:00:46Z,2019-03-25T01:28:23Z,2019-03-25T01:28:59Z,CLOSED,False,416,0,7,https://github.com/rhaffar99,ELEC-404: Steering Angle Sensor,24,[],https://github.com/uw-midsun/firmware/pull/285,https://github.com/rhaffar99,1,https://github.com/uw-midsun/firmware/pull/285,Modules responsible for calibrating and reading the wheel's angle (under percentage representation) using a rotary sensor.,Modules responsible for calibrating and reading the wheel's angle (under percentage representation) using a rotary sensor.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,285,2018-06-29T08:00:46Z,2019-03-25T01:28:23Z,2019-03-25T01:28:59Z,CLOSED,False,416,0,7,https://github.com/rhaffar99,ELEC-404: Steering Angle Sensor,24,[],https://github.com/uw-midsun/firmware/pull/285,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/285#issuecomment-401385727,Modules responsible for calibrating and reading the wheel's angle (under percentage representation) using a rotary sensor.,Please fix your title and add a description.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,285,2018-06-29T08:00:46Z,2019-03-25T01:28:23Z,2019-03-25T01:28:59Z,CLOSED,False,416,0,7,https://github.com/rhaffar99,ELEC-404: Steering Angle Sensor,24,[],https://github.com/uw-midsun/firmware/pull/285,https://github.com/mishazharov,3,https://github.com/uw-midsun/firmware/pull/285#issuecomment-476017390,Modules responsible for calibrating and reading the wheel's angle (under percentage representation) using a rotary sensor.,What is the status of this PR? Can it be merged / handed off or should we just close it?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,285,2018-06-29T08:00:46Z,2019-03-25T01:28:23Z,2019-03-25T01:28:59Z,CLOSED,False,416,0,7,https://github.com/rhaffar99,ELEC-404: Steering Angle Sensor,24,[],https://github.com/uw-midsun/firmware/pull/285,https://github.com/rhaffar99,4,https://github.com/uw-midsun/firmware/pull/285#issuecomment-476024335,Modules responsible for calibrating and reading the wheel's angle (under percentage representation) using a rotary sensor.,"As I recall, the recommended changes were made and tested alright, but testing was only done on the discovery board. Needs to be tested on pedal board (also needs to update pin configs for the use on the pedal board), and another run through on the code for good measure would be good. I'll circle back to it once charger is good to go.",True,{'THUMBS_UP': ['https://github.com/mishazharov']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,285,2018-06-29T08:00:46Z,2019-03-25T01:28:23Z,2019-03-25T01:28:59Z,CLOSED,False,416,0,7,https://github.com/rhaffar99,ELEC-404: Steering Angle Sensor,24,[],https://github.com/uw-midsun/firmware/pull/285,https://github.com/mishazharov,5,https://github.com/uw-midsun/firmware/pull/285#issuecomment-476024728,Modules responsible for calibrating and reading the wheel's angle (under percentage representation) using a rotary sensor.,"Alright, that sounds good. Let's close this PR for now, and you can reopen it when it's ready for review again",True,{'THUMBS_UP': ['https://github.com/rhaffar99']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,286,2018-06-30T17:57:03Z,2018-09-16T04:22:36Z,2018-10-19T02:04:28Z,CLOSED,False,32,0,4,https://github.com/Derpalooza,ELEC-501: Precharge controller init check,4,[],https://github.com/uw-midsun/firmware/pull/286,https://github.com/Derpalooza,1,https://github.com/uw-midsun/firmware/pull/286,"Since the precharge controller does not always start when initialized, a timer has been added to check the status of the controller, call the init routine if it is still off, and repeat until it is confirmed to be on.","Since the precharge controller does not always start when initialized, a timer has been added to check the status of the controller, call the init routine if it is still off, and repeat until it is confirmed to be on.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,286,2018-06-30T17:57:03Z,2018-09-16T04:22:36Z,2018-10-19T02:04:28Z,CLOSED,False,32,0,4,https://github.com/Derpalooza,ELEC-501: Precharge controller init check,4,[],https://github.com/uw-midsun/firmware/pull/286,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/286#issuecomment-402019877,"Since the precharge controller does not always start when initialized, a timer has been added to check the status of the controller, call the init routine if it is still off, and repeat until it is confirmed to be on.","Turns out the interface is actually restarting. I don't think this is really the correct solution.
It would be better to delay precharge relays from being closed if the bus voltage is high. I'm not entirely sure why this is only a problem when the caps are charged. @taipingli ?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,286,2018-06-30T17:57:03Z,2018-09-16T04:22:36Z,2018-10-19T02:04:28Z,CLOSED,False,32,0,4,https://github.com/Derpalooza,ELEC-501: Precharge controller init check,4,[],https://github.com/uw-midsun/firmware/pull/286,https://github.com/karlding,3,https://github.com/uw-midsun/firmware/pull/286#issuecomment-421690375,"Since the precharge controller does not always start when initialized, a timer has been added to check the status of the controller, call the init routine if it is still off, and repeat until it is confirmed to be on.",Marking as WNF in FW as per previous comment. Closing.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,287,2018-07-02T20:47:19Z,2018-07-04T01:53:00Z,2018-10-19T02:02:08Z,CLOSED,False,74,26,7,https://github.com/ckitagawa,ELEC-504: Increase HB Reliability,5,[],https://github.com/uw-midsun/firmware/pull/287,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/287,"Nate suggested we use multiple sends of a Heartbeat sequentially on each to form a packet on each send. By having 5-10 of the same message in a row this decreases the chance that noise or a dropped packet will clobber the heartbeat and result in a fault. To do so we send the message multiple times without registering an ACK for any of the sends other than the last. This works because the ACK gets registered for a message but all the sends and receives map to an ACK by its ID only. As a result, if a device responds to at least one or more of the messages it is counted. This should be much more reliable.","Nate suggested we use multiple sends of a Heartbeat sequentially on each to form a packet on each send. By having 5-10 of the same message in a row this decreases the chance that noise or a dropped packet will clobber the heartbeat and result in a fault. To do so we send the message multiple times without registering an ACK for any of the sends other than the last. This works because the ACK gets registered for a message but all the sends and receives map to an ACK by its ID only. As a result, if a device responds to at least one or more of the messages it is counted. This should be much more reliable.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,287,2018-07-02T20:47:19Z,2018-07-04T01:53:00Z,2018-10-19T02:02:08Z,CLOSED,False,74,26,7,https://github.com/ckitagawa,ELEC-504: Increase HB Reliability,5,[],https://github.com/uw-midsun/firmware/pull/287,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/287#issuecomment-402062555,"Nate suggested we use multiple sends of a Heartbeat sequentially on each to form a packet on each send. By having 5-10 of the same message in a row this decreases the chance that noise or a dropped packet will clobber the heartbeat and result in a fault. To do so we send the message multiple times without registering an ACK for any of the sends other than the last. This works because the ACK gets registered for a message but all the sends and receives map to an ACK by its ID only. As a result, if a device responds to at least one or more of the messages it is counted. This should be much more reliable.","I tested this in the car and I was seeing a lot of ACK timeouts until I increased the timeout to 50ms. We probably need to profile the roundtrip time of a critical message.
I also have a 4 * 300us delay (1.2ms) that blocks for every single command we send to the AFEs, so that might be related as well.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,288,2018-07-03T02:49:27Z,2018-07-04T01:57:21Z,2018-07-04T01:57:25Z,MERGED,True,87,22,4,https://github.com/ckitagawa,ELEC-506: Mech Brake Windowing,4,[],https://github.com/uw-midsun/firmware/pull/288,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/288,Add an overlapping window to the mechanical brake such that a higher threshold is required to start braking and a lower threshold is required to stop. This way around the 50 percent region there is less fluttering.,Add an overlapping window to the mechanical brake such that a higher threshold is required to start braking and a lower threshold is required to stop. This way around the 50 percent region there is less fluttering.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,289,2018-07-03T02:58:15Z,2018-07-06T19:20:50Z,2018-07-06T19:20:53Z,MERGED,True,22,2,4,https://github.com/ckitagawa,ELEC-507: Chaos Compile Flags,5,[],https://github.com/uw-midsun/firmware/pull/289,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/289,"Add compile flags for

Powertrain heartbeat
Solar relays

I can add flags for other stuff as well if there are other requests.","Add compile flags for

Powertrain heartbeat
Solar relays

I can add flags for other stuff as well if there are other requests.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,290,2018-07-03T08:59:06Z,2018-07-04T01:14:38Z,2018-07-04T01:14:41Z,MERGED,True,16,7,5,https://github.com/tituschow,ELEC-500: LTC AFE FSM Faults,3,[],https://github.com/uw-midsun/firmware/pull/290,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/290,"Implements wakeup method 2 as specified in the datasheet. This makes wakeup much more reliable and actually allows us to reduce our delay between triggering and reading to much more reasonable values.
I plan on trying to bring the delay as low as possible, and if it seems to be stable on the order of a few milliseconds, we can probably switch back to a main loop polled method.","Implements wakeup method 2 as specified in the datasheet. This makes wakeup much more reliable and actually allows us to reduce our delay between triggering and reading to much more reasonable values.
I plan on trying to bring the delay as low as possible, and if it seems to be stable on the order of a few milliseconds, we can probably switch back to a main loop polled method.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,291,2018-07-04T01:50:50Z,2018-07-04T02:28:53Z,2018-07-04T02:28:58Z,MERGED,True,46,16,5,https://github.com/ckitagawa,ELEC-508: Roll codegen,3,[],https://github.com/uw-midsun/firmware/pull/291,https://github.com/ckitagawa,1,https://github.com/uw-midsun/firmware/pull/291,,,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,292,2018-07-05T03:14:02Z,2018-09-08T19:35:20Z,2018-10-19T02:02:29Z,CLOSED,False,103,11,5,https://github.com/ericslchiang,ELEC-499: Thermistor Resistance,17,[],https://github.com/uw-midsun/firmware/pull/292,https://github.com/ericslchiang,1,https://github.com/uw-midsun/firmware/pull/292,First part of the code to the temperature fault. Calculates resistance based on a input temperature.,First part of the code to the temperature fault. Calculates resistance based on a input temperature.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,293,2018-07-05T03:25:48Z,2018-09-20T04:21:07Z,2018-09-20T04:21:07Z,CLOSED,False,497,184,35,https://github.com/tituschow,WIP: Working drive w/ control stalks,15,[],https://github.com/uw-midsun/firmware/pull/293,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/293,"Please ignore this PR. I'm just using it to look at the changes I made.
This PR contains the code that was used for unveiling and resulted in relatively stable drive.","Please ignore this PR. I'm just using it to look at the changes I made.
This PR contains the code that was used for unveiling and resulted in relatively stable drive.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,294,2018-07-06T19:20:32Z,2018-09-11T05:22:13Z,2018-09-13T03:29:42Z,MERGED,True,104,40,3,https://github.com/tituschow,ELEC-510: Improve system dump script,9,[],https://github.com/uw-midsun/firmware/pull/294,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/294,Adds file logging and separates display from content,Adds file logging and separates display from content,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,295,2018-07-06T22:08:00Z,2018-10-06T04:34:12Z,2018-10-06T04:34:12Z,CLOSED,False,49,1,5,https://github.com/tituschow,ELEC-516: Add CAN discharge read/set,1,[],https://github.com/uw-midsun/firmware/pull/295,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/295,"Dumps discharge bitset periodically and adds support for the set discharge bitset command. Note that both messages operate on the raw AFE bitsets, so they must be corrected for the missing inputs.","Dumps discharge bitset periodically and adds support for the set discharge bitset command. Note that both messages operate on the raw AFE bitsets, so they must be corrected for the missing inputs.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,296,2018-07-06T22:33:09Z,2018-07-08T21:01:33Z,2018-07-08T21:01:45Z,MERGED,True,4,4,2,https://github.com/tituschow,ELEC-507: Fix compile flags,1,[],https://github.com/uw-midsun/firmware/pull/296,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/296,Fixes issues with the Chaos compile flags.,Fixes issues with the Chaos compile flags.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,297,2018-07-07T11:37:18Z,2018-09-21T04:54:25Z,2018-09-21T04:54:25Z,CLOSED,False,1488,335,75,https://github.com/tituschow,WIP: July 7 Integration,29,[],https://github.com/uw-midsun/firmware/pull/297,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/297,"This is a WIP branch that merges a bunch of in-progress branches and fixes things.
Namely:

New telemetry script
Updated AFE config
Fixed hazards, brake lights
Working center console (still some desync)
Fixed lights sync

I don't actually expect a review - I plan on splitting this up, but @ArshanKhanifar please port the changes over to #215. Essentially, the issue is that you're using the same event for both sync messages and then processing them in lights_can_process_events in both front/back configurations causes both boards to TX sync events.","This is a WIP branch that merges a bunch of in-progress branches and fixes things.
Namely:

New telemetry script
Updated AFE config
Fixed hazards, brake lights
Working center console (still some desync)
Fixed lights sync

I don't actually expect a review - I plan on splitting this up, but @ArshanKhanifar please port the changes over to #215. Essentially, the issue is that you're using the same event for both sync messages and then processing them in lights_can_process_events in both front/back configurations causes both boards to TX sync events.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,298,2018-07-11T04:20:21Z,2019-01-25T20:07:11Z,2019-01-25T20:07:11Z,MERGED,True,930,0,20,https://github.com/ArshanKhanifar,ELEC-502: Solar Master,25,[],https://github.com/uw-midsun/firmware/pull/298,https://github.com/ArshanKhanifar,1,https://github.com/uw-midsun/firmware/pull/298,I need to rename this project from solar sense to solar master. But basically right now we have relay control support. I've also written tests and stuff... Also the MCP3427 driver is complete but not used. I used FSM's to keep it non-blocking.,I need to rename this project from solar sense to solar master. But basically right now we have relay control support. I've also written tests and stuff... Also the MCP3427 driver is complete but not used. I used FSM's to keep it non-blocking.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,298,2018-07-11T04:20:21Z,2019-01-25T20:07:11Z,2019-01-25T20:07:11Z,MERGED,True,930,0,20,https://github.com/ArshanKhanifar,ELEC-502: Solar Master,25,[],https://github.com/uw-midsun/firmware/pull/298,https://github.com/ckitagawa,2,https://github.com/uw-midsun/firmware/pull/298#issuecomment-423751220,I need to rename this project from solar sense to solar master. But basically right now we have relay control support. I've also written tests and stuff... Also the MCP3427 driver is complete but not used. I used FSM's to keep it non-blocking.,@ArshanKhanifar What is the status of this PR. Do you want to merge it still?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,298,2018-07-11T04:20:21Z,2019-01-25T20:07:11Z,2019-01-25T20:07:11Z,MERGED,True,930,0,20,https://github.com/ArshanKhanifar,ELEC-502: Solar Master,25,[],https://github.com/uw-midsun/firmware/pull/298,https://github.com/anikser,3,https://github.com/uw-midsun/firmware/pull/298#issuecomment-436823521,I need to rename this project from solar sense to solar master. But basically right now we have relay control support. I've also written tests and stuff... Also the MCP3427 driver is complete but not used. I used FSM's to keep it non-blocking.,Depends on #314,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,298,2018-07-11T04:20:21Z,2019-01-25T20:07:11Z,2019-01-25T20:07:11Z,MERGED,True,930,0,20,https://github.com/ArshanKhanifar,ELEC-502: Solar Master,25,[],https://github.com/uw-midsun/firmware/pull/298,https://github.com/anikser,4,https://github.com/uw-midsun/firmware/pull/298#issuecomment-436837054,I need to rename this project from solar sense to solar master. But basically right now we have relay control support. I've also written tests and stuff... Also the MCP3427 driver is complete but not used. I used FSM's to keep it non-blocking.,"Basic functionality is here, but I still need to get multiple ADC on one bus working, and fix a whole host of formatting issues (i.e. moving around constants).
Would appreciate some comments on what I have so far.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,298,2018-07-11T04:20:21Z,2019-01-25T20:07:11Z,2019-01-25T20:07:11Z,MERGED,True,930,0,20,https://github.com/ArshanKhanifar,ELEC-502: Solar Master,25,[],https://github.com/uw-midsun/firmware/pull/298,https://github.com/anikser,5,https://github.com/uw-midsun/firmware/pull/298#issuecomment-439919146,I need to rename this project from solar sense to solar master. But basically right now we have relay control support. I've also written tests and stuff... Also the MCP3427 driver is complete but not used. I used FSM's to keep it non-blocking.,"Still need to write unit tests, but everything seems to be fully working. Haven't checked the CAN messages yet though. Looking for an opportunity to test in the car.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,298,2018-07-11T04:20:21Z,2019-01-25T20:07:11Z,2019-01-25T20:07:11Z,MERGED,True,930,0,20,https://github.com/ArshanKhanifar,ELEC-502: Solar Master,25,[],https://github.com/uw-midsun/firmware/pull/298,https://github.com/ashraf2047,6,https://github.com/uw-midsun/firmware/pull/298#issuecomment-456980636,I need to rename this project from solar sense to solar master. But basically right now we have relay control support. I've also written tests and stuff... Also the MCP3427 driver is complete but not used. I used FSM's to keep it non-blocking.,"@andyjiin This should be merged, could you approve your requested changes?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,299,2018-07-14T08:09:17Z,2018-09-18T03:56:13Z,2018-10-19T02:07:09Z,CLOSED,False,35,1,3,https://github.com/karlding,ELEC-524: Add motor controller reset handlers,1,[],https://github.com/uw-midsun/firmware/pull/299,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/299,"This adds reset handlers on the system CAN bus to allow for resetting
the motor controllers.
This is waiting on codegen changes to be merged so this build doesn't
fail, as it depends on a new enum message id.","This adds reset handlers on the system CAN bus to allow for resetting
the motor controllers.
This is waiting on codegen changes to be merged so this build doesn't
fail, as it depends on a new enum message id.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,299,2018-07-14T08:09:17Z,2018-09-18T03:56:13Z,2018-10-19T02:07:09Z,CLOSED,False,35,1,3,https://github.com/karlding,ELEC-524: Add motor controller reset handlers,1,[],https://github.com/uw-midsun/firmware/pull/299,https://github.com/karlding,2,https://github.com/uw-midsun/firmware/pull/299#issuecomment-422247030,"This adds reset handlers on the system CAN bus to allow for resetting
the motor controllers.
This is waiting on codegen changes to be merged so this build doesn't
fail, as it depends on a new enum message id.",Closing for now. TBD if we still want this.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,300,2018-07-14T16:23:04Z,2018-08-01T08:08:08Z,2018-08-01T08:08:13Z,MERGED,True,17,2,5,https://github.com/karlding,ELEC-524: Roll codegen,1,[],https://github.com/uw-midsun/firmware/pull/300,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/300,Add support for reset motor controller messages,Add support for reset motor controller messages,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,301,2018-07-17T04:46:57Z,2018-09-14T06:12:07Z,2018-10-19T02:07:14Z,CLOSED,False,3187,0,43,https://github.com/karlding,[tmp] Add cell balancing code,2,[],https://github.com/uw-midsun/firmware/pull/301,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/301,"Theoretically works I guess
Code is in main","Theoretically works I guess
Code is in main",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,301,2018-07-17T04:46:57Z,2018-09-14T06:12:07Z,2018-10-19T02:07:14Z,CLOSED,False,3187,0,43,https://github.com/karlding,[tmp] Add cell balancing code,2,[],https://github.com/uw-midsun/firmware/pull/301,https://github.com/karlding,2,https://github.com/uw-midsun/firmware/pull/301#issuecomment-421242168,"Theoretically works I guess
Code is in main","We never ended up bringing up this board at the race, so I'm gonna close this
for now. These changes will probably make their way into the project, instead
of this hack.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,302,2018-08-01T05:21:56Z,2018-08-05T21:52:29Z,2018-08-05T21:52:32Z,MERGED,True,8,1,2,https://github.com/karlding,ELEC-532: Add can_dump project requirements.txt,3,[],https://github.com/uw-midsun/firmware/pull/302,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/302,Add requirements.txt to can_dump project for posterity,Add requirements.txt to can_dump project for posterity,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,303,2018-08-02T07:45:23Z,2018-09-13T03:27:36Z,2018-09-13T03:45:19Z,MERGED,True,184,97,4,https://github.com/karlding,ELEC-534: Add CAN dump parser script,8,[],https://github.com/uw-midsun/firmware/pull/303,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/303,"I'm waiting for the improvements to the CAN script to go in before I rebase
these changes on top of that. However, I'll put this up for review for now,
and then I'll rebase once those changes get in.
This adds a parse_data.py script that parses the logged data.
In addition, I've refactored out the CAN parsing logic out of the main
dump_system.py script, and creates a can_message.py file that
contains all that logic. This allows the parse_data.py script to share
the code.","I'm waiting for the improvements to the CAN script to go in before I rebase
these changes on top of that. However, I'll put this up for review for now,
and then I'll rebase once those changes get in.
This adds a parse_data.py script that parses the logged data.
In addition, I've refactored out the CAN parsing logic out of the main
dump_system.py script, and creates a can_message.py file that
contains all that logic. This allows the parse_data.py script to share
the code.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,303,2018-08-02T07:45:23Z,2018-09-13T03:27:36Z,2018-09-13T03:45:19Z,MERGED,True,184,97,4,https://github.com/karlding,ELEC-534: Add CAN dump parser script,8,[],https://github.com/uw-midsun/firmware/pull/303,https://github.com/karlding,2,https://github.com/uw-midsun/firmware/pull/303#issuecomment-420164304,"I'm waiting for the improvements to the CAN script to go in before I rebase
these changes on top of that. However, I'll put this up for review for now,
and then I'll rebase once those changes get in.
This adds a parse_data.py script that parses the logged data.
In addition, I've refactored out the CAN parsing logic out of the main
dump_system.py script, and creates a can_message.py file that
contains all that logic. This allows the parse_data.py script to share
the code.","Hopefully I haven't broken the dump_system script with all this refactoring..
I've also added a README for the scripts.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,304,2018-08-16T05:13:19Z,2018-09-18T14:41:46Z,2018-09-19T05:22:28Z,MERGED,True,9,0,1,https://github.com/karlding,ELEC-435: Disable gdb signal interrupts,6,[],https://github.com/uw-midsun/firmware/pull/304,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/304,"I was combing through our backlog of tasks, and noticed that this was
still kicking around.
GDB supports a .gdbinit file which is loaded when GDB is started.
As of GDB 7.5, there's a new security feature that prevents GDB from
loading .gdbinit files from non-trusted directories.
In order to get around this, you can add the following to the
~/.gdbinit file in order to trust every single .gdbinit file:
set auto-load safe-path /

Or whitelist them as needed
set auto-load safe-path /home/vagrant/shared/firmware

We could deploy a new box with these changes, or we add them to
the setup instructions (like git hooks). The .gdbinit file can
also be loaded on demand by running source .gdbinit from the
project directory.","I was combing through our backlog of tasks, and noticed that this was
still kicking around.
GDB supports a .gdbinit file which is loaded when GDB is started.
As of GDB 7.5, there's a new security feature that prevents GDB from
loading .gdbinit files from non-trusted directories.
In order to get around this, you can add the following to the
~/.gdbinit file in order to trust every single .gdbinit file:
set auto-load safe-path /

Or whitelist them as needed
set auto-load safe-path /home/vagrant/shared/firmware

We could deploy a new box with these changes, or we add them to
the setup instructions (like git hooks). The .gdbinit file can
also be loaded on demand by running source .gdbinit from the
project directory.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,304,2018-08-16T05:13:19Z,2018-09-18T14:41:46Z,2018-09-19T05:22:28Z,MERGED,True,9,0,1,https://github.com/karlding,ELEC-435: Disable gdb signal interrupts,6,[],https://github.com/uw-midsun/firmware/pull/304,https://github.com/mishazharov,2,https://github.com/uw-midsun/firmware/pull/304#issuecomment-422192393,"I was combing through our backlog of tasks, and noticed that this was
still kicking around.
GDB supports a .gdbinit file which is loaded when GDB is started.
As of GDB 7.5, there's a new security feature that prevents GDB from
loading .gdbinit files from non-trusted directories.
In order to get around this, you can add the following to the
~/.gdbinit file in order to trust every single .gdbinit file:
set auto-load safe-path /

Or whitelist them as needed
set auto-load safe-path /home/vagrant/shared/firmware

We could deploy a new box with these changes, or we add them to
the setup instructions (like git hooks). The .gdbinit file can
also be loaded on demand by running source .gdbinit from the
project directory.","I think it's okay to run source .gdbinit from the project directory for now (we can add a blurb on the Software 101), but next time we deploy a new box we can add the whitelist change as well",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,305,2018-09-14T05:58:52Z,2018-09-17T15:38:15Z,2018-09-18T03:55:40Z,MERGED,True,133,10,8,https://github.com/karlding,ELEC-499: Add AUX inputs to fault monitor,1,[],https://github.com/uw-midsun/firmware/pull/305,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/305,"Slowly porting over the changes that were made over ASC.. This add the AUX
inputs to the fault monitor, so that we actually fault on overtemperature.
This also separates the faults so that we have a notion of the origin of
a fault—this can either be an AFE_CELL (implying a voltage condition)
or an AFE_TEMP (implying a temperature condition).","Slowly porting over the changes that were made over ASC.. This add the AUX
inputs to the fault monitor, so that we actually fault on overtemperature.
This also separates the faults so that we have a notion of the origin of
a fault—this can either be an AFE_CELL (implying a voltage condition)
or an AFE_TEMP (implying a temperature condition).",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,306,2018-09-15T07:03:50Z,2018-09-16T07:10:20Z,2018-09-16T17:49:43Z,MERGED,True,1209,1194,236,https://github.com/karlding,ELEC-334: Use consistent naming,62,[],https://github.com/uw-midsun/firmware/pull/306,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/306,"I'm taking advantage of the lull in activity to make a couple of code
quality changes, in order to minimze the amount of potential merge
conflicts this will undoubtly cause. Regardless, this should probably
go in ASAP before more people branch off master.
I'm waiting on codegen changes to go in first, before I can rebase and
then make the rest of the CAN changes (without breaking the build).
I've tried to keep each replacement in a separate commit, so it's
easier to review. Otherwise, since tests are all passing, and the
build hasn't broken (hopefully), so we should be safe. Also, for some
reason running on Vagrant seems to give really flakey test results for
CAN and Timers, but running native seems to be fine. Same thing for
the x86 command runners. I was getting like 1/50 success rates under
VirtualBox.
Also, do let me know if I missed something that needs to be changed,
and I'll toss that in here.
Waiting on:

 CANMessage","I'm taking advantage of the lull in activity to make a couple of code
quality changes, in order to minimze the amount of potential merge
conflicts this will undoubtly cause. Regardless, this should probably
go in ASAP before more people branch off master.
I'm waiting on codegen changes to go in first, before I can rebase and
then make the rest of the CAN changes (without breaking the build).
I've tried to keep each replacement in a separate commit, so it's
easier to review. Otherwise, since tests are all passing, and the
build hasn't broken (hopefully), so we should be safe. Also, for some
reason running on Vagrant seems to give really flakey test results for
CAN and Timers, but running native seems to be fine. Same thing for
the x86 command runners. I was getting like 1/50 success rates under
VirtualBox.
Also, do let me know if I missed something that needs to be changed,
and I'll toss that in here.
Waiting on:

 CANMessage",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,306,2018-09-15T07:03:50Z,2018-09-16T07:10:20Z,2018-09-16T17:49:43Z,MERGED,True,1209,1194,236,https://github.com/karlding,ELEC-334: Use consistent naming,62,[],https://github.com/uw-midsun/firmware/pull/306,https://github.com/karlding,2,https://github.com/uw-midsun/firmware/pull/306#issuecomment-421613583,"I'm taking advantage of the lull in activity to make a couple of code
quality changes, in order to minimze the amount of potential merge
conflicts this will undoubtly cause. Regardless, this should probably
go in ASAP before more people branch off master.
I'm waiting on codegen changes to go in first, before I can rebase and
then make the rest of the CAN changes (without breaking the build).
I've tried to keep each replacement in a separate commit, so it's
easier to review. Otherwise, since tests are all passing, and the
build hasn't broken (hopefully), so we should be safe. Also, for some
reason running on Vagrant seems to give really flakey test results for
CAN and Timers, but running native seems to be fine. Same thing for
the x86 command runners. I was getting like 1/50 success rates under
VirtualBox.
Also, do let me know if I missed something that needs to be changed,
and I'll toss that in here.
Waiting on:

 CANMessage","Probably? Or at least, related to the init/reinit processes when we call a new subtest.
At the very least, the soft timer test seems to fail because of the non-deterministic behaviour of the short/medium timers, since sometimes I'll see that the medium timer fires when we expect that it doesn't.
Not sure what's happening with CAN HW/ACK and the x86 command runners though.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,307,2018-09-20T07:11:54Z,2018-10-27T17:08:22Z,2018-10-28T08:18:43Z,MERGED,True,249,11,3,https://github.com/karlding,ELEC-548: Add remaining WaveSculptor 20 CAN messages,9,[],https://github.com/uw-midsun/firmware/pull/307,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/307,"This adds the remaining WaveSculptor CAN messages to the wavesculptor.h
header file, which should unblock the work required as part of ELEC-530.
Some new CAN messages may probably need to be allocated in codegen as well
as part of that effort.
Do let me know if you have any naming concerns.
(Also, please do check the datasheet and check that I didn't accidentally
swap the order of data fields, which is quite possible.)","This adds the remaining WaveSculptor CAN messages to the wavesculptor.h
header file, which should unblock the work required as part of ELEC-530.
Some new CAN messages may probably need to be allocated in codegen as well
as part of that effort.
Do let me know if you have any naming concerns.
(Also, please do check the datasheet and check that I didn't accidentally
swap the order of data fields, which is quite possible.)",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,307,2018-09-20T07:11:54Z,2018-10-27T17:08:22Z,2018-10-28T08:18:43Z,MERGED,True,249,11,3,https://github.com/karlding,ELEC-548: Add remaining WaveSculptor 20 CAN messages,9,[],https://github.com/uw-midsun/firmware/pull/307,https://github.com/karlding,2,https://github.com/uw-midsun/firmware/pull/307#issuecomment-432102142,"This adds the remaining WaveSculptor CAN messages to the wavesculptor.h
header file, which should unblock the work required as part of ELEC-530.
Some new CAN messages may probably need to be allocated in codegen as well
as part of that effort.
Do let me know if you have any naming concerns.
(Also, please do check the datasheet and check that I didn't accidentally
swap the order of data fields, which is quite possible.)",ping: @mikzharov @ashraf2047 @andyjiin,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,307,2018-09-20T07:11:54Z,2018-10-27T17:08:22Z,2018-10-28T08:18:43Z,MERGED,True,249,11,3,https://github.com/karlding,ELEC-548: Add remaining WaveSculptor 20 CAN messages,9,[],https://github.com/uw-midsun/firmware/pull/307,https://github.com/mishazharov,3,https://github.com/uw-midsun/firmware/pull/307#issuecomment-432885684,"This adds the remaining WaveSculptor CAN messages to the wavesculptor.h
header file, which should unblock the work required as part of ELEC-530.
Some new CAN messages may probably need to be allocated in codegen as well
as part of that effort.
Do let me know if you have any naming concerns.
(Also, please do check the datasheet and check that I didn't accidentally
swap the order of data fields, which is quite possible.)","(Also, please do check the datasheet and check that I didn't accidentally
swap the order of data fields, which is quite possible.)

I haven't had the chance to check all the values yet. I skimmed a few and they seemed to be correct, but I didn't get an in depth look at all of them.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,308,2018-09-22T22:57:48Z,2018-11-27T08:34:10Z,2019-01-11T21:44:08Z,MERGED,True,27278,5,48,https://github.com/karlding,ELEC-538: Add FreeRTOS libraries and example project,23,[],https://github.com/uw-midsun/firmware/pull/308,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/308,"I'm throwing up an initial pass at integrating FreeRTOS into our
codebase. This also ports the example application to FreeRTOS, so we
have some frame of reference as to how code will look.
I've split the commits up to make this easier to review. The first
commit dumps the relevant FreeRTOS files as a library. No changes
were made to the code after downloading from their website. The next
set of commits get FreeRTOS compiling as a static library, and then a
demo project is implemented.
There's a couple things here that would be worth considering in the
FreeRTOSConfig.h file:

configUSE_IDLE_HOOK: Do we want to perform some logic when we
enter the idle task (potentially low power mode)?
Do we want to enable dynamic allocation? I'm of the opinion that
static allocation is the way to go, since it'll be much easier to
manage, especially on an embedded system.
Are there any API functions that you think are needed/are not
needed?
Do we want a per-project FreeRTOSConfig.h file instead? It would
make it somewhat weird to have FreeRTOS as a library that way

These are fairly trivial to change, and we don't have to decide now,
but just something to keep in mind.
This currently only implements the stm32f0xx port, and I haven't
looked into the x86 layer. Theoretically we can use the Linux
simulator, although it's licensed under GPLv2, which would mean that
we would need to re-license code under GPLv2... That's probably why
the build will fail right now.
There's also the matter of getting debugging working, or else working
with FreeRTOS is going to be a pain. I took a quick look at OpenOCD's
User Guide, and apparently there is an option to make it RTOS aware.
I've tested this on a Controller Board, and it seems to work. Anything
else you guys would like me to validate?","I'm throwing up an initial pass at integrating FreeRTOS into our
codebase. This also ports the example application to FreeRTOS, so we
have some frame of reference as to how code will look.
I've split the commits up to make this easier to review. The first
commit dumps the relevant FreeRTOS files as a library. No changes
were made to the code after downloading from their website. The next
set of commits get FreeRTOS compiling as a static library, and then a
demo project is implemented.
There's a couple things here that would be worth considering in the
FreeRTOSConfig.h file:

configUSE_IDLE_HOOK: Do we want to perform some logic when we
enter the idle task (potentially low power mode)?
Do we want to enable dynamic allocation? I'm of the opinion that
static allocation is the way to go, since it'll be much easier to
manage, especially on an embedded system.
Are there any API functions that you think are needed/are not
needed?
Do we want a per-project FreeRTOSConfig.h file instead? It would
make it somewhat weird to have FreeRTOS as a library that way

These are fairly trivial to change, and we don't have to decide now,
but just something to keep in mind.
This currently only implements the stm32f0xx port, and I haven't
looked into the x86 layer. Theoretically we can use the Linux
simulator, although it's licensed under GPLv2, which would mean that
we would need to re-license code under GPLv2... That's probably why
the build will fail right now.
There's also the matter of getting debugging working, or else working
with FreeRTOS is going to be a pain. I took a quick look at OpenOCD's
User Guide, and apparently there is an option to make it RTOS aware.
I've tested this on a Controller Board, and it seems to work. Anything
else you guys would like me to validate?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,308,2018-09-22T22:57:48Z,2018-11-27T08:34:10Z,2019-01-11T21:44:08Z,MERGED,True,27278,5,48,https://github.com/karlding,ELEC-538: Add FreeRTOS libraries and example project,23,[],https://github.com/uw-midsun/firmware/pull/308,https://github.com/karlding,2,https://github.com/uw-midsun/firmware/pull/308#issuecomment-423780541,"I'm throwing up an initial pass at integrating FreeRTOS into our
codebase. This also ports the example application to FreeRTOS, so we
have some frame of reference as to how code will look.
I've split the commits up to make this easier to review. The first
commit dumps the relevant FreeRTOS files as a library. No changes
were made to the code after downloading from their website. The next
set of commits get FreeRTOS compiling as a static library, and then a
demo project is implemented.
There's a couple things here that would be worth considering in the
FreeRTOSConfig.h file:

configUSE_IDLE_HOOK: Do we want to perform some logic when we
enter the idle task (potentially low power mode)?
Do we want to enable dynamic allocation? I'm of the opinion that
static allocation is the way to go, since it'll be much easier to
manage, especially on an embedded system.
Are there any API functions that you think are needed/are not
needed?
Do we want a per-project FreeRTOSConfig.h file instead? It would
make it somewhat weird to have FreeRTOS as a library that way

These are fairly trivial to change, and we don't have to decide now,
but just something to keep in mind.
This currently only implements the stm32f0xx port, and I haven't
looked into the x86 layer. Theoretically we can use the Linux
simulator, although it's licensed under GPLv2, which would mean that
we would need to re-license code under GPLv2... That's probably why
the build will fail right now.
There's also the matter of getting debugging working, or else working
with FreeRTOS is going to be a pain. I took a quick look at OpenOCD's
User Guide, and apparently there is an option to make it RTOS aware.
I've tested this on a Controller Board, and it seems to work. Anything
else you guys would like me to validate?","Yep, so build is failing due to missing x86 port (as expected for now).",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,308,2018-09-22T22:57:48Z,2018-11-27T08:34:10Z,2019-01-11T21:44:08Z,MERGED,True,27278,5,48,https://github.com/karlding,ELEC-538: Add FreeRTOS libraries and example project,23,[],https://github.com/uw-midsun/firmware/pull/308,https://github.com/karlding,3,https://github.com/uw-midsun/firmware/pull/308#issuecomment-424607093,"I'm throwing up an initial pass at integrating FreeRTOS into our
codebase. This also ports the example application to FreeRTOS, so we
have some frame of reference as to how code will look.
I've split the commits up to make this easier to review. The first
commit dumps the relevant FreeRTOS files as a library. No changes
were made to the code after downloading from their website. The next
set of commits get FreeRTOS compiling as a static library, and then a
demo project is implemented.
There's a couple things here that would be worth considering in the
FreeRTOSConfig.h file:

configUSE_IDLE_HOOK: Do we want to perform some logic when we
enter the idle task (potentially low power mode)?
Do we want to enable dynamic allocation? I'm of the opinion that
static allocation is the way to go, since it'll be much easier to
manage, especially on an embedded system.
Are there any API functions that you think are needed/are not
needed?
Do we want a per-project FreeRTOSConfig.h file instead? It would
make it somewhat weird to have FreeRTOS as a library that way

These are fairly trivial to change, and we don't have to decide now,
but just something to keep in mind.
This currently only implements the stm32f0xx port, and I haven't
looked into the x86 layer. Theoretically we can use the Linux
simulator, although it's licensed under GPLv2, which would mean that
we would need to re-license code under GPLv2... That's probably why
the build will fail right now.
There's also the matter of getting debugging working, or else working
with FreeRTOS is going to be a pain. I took a quick look at OpenOCD's
User Guide, and apparently there is an option to make it RTOS aware.
I've tested this on a Controller Board, and it seems to work. Anything
else you guys would like me to validate?","I was able to validate that OpenOCD + GDB still works after making some changes to platform/stm32f0xx/scripts/gdb_flash. Not sure why the temporary breakpoints were causing a GDB assertion to fail, but yeah.
vagrant@midsunbox:~/shared/firmware$ make gdb PROJECT=freertos_demo
Processing LIB CMSIS
Processing LIB libcore
Processing LIB STM32F0xx_StdPeriph_Driver
Processing LIB stm32f0xx
Processing LIB FreeRTOS
Processing LIB ms-common
Processing PROJ freertos_demo
GNU gdb (GNU Tools for Arm Embedded Processors 7-2018-q2-update) 8.1.0.20180315-git
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type ""show copying""
and ""show warranty"" for details.
This GDB was configured as ""--host=x86_64-linux-gnu --target=arm-none-eabi"".
Type ""show configuration"" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type ""help"".
Type ""apropos word"" to search for commands related to ""word""...
Reading symbols from build/bin/stm32f0xx/freertos_demo.elf...done.
0x0800076c in prvCheckTasksWaitingTermination () at libraries/FreeRTOS/tasks.c:3533
3533                    while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
adapter speed: 1000 kHz
target halted due to debug-request, current mode: Thread
xPSR: 0xc1000000 pc: 0x08001cf8 msp: 0x20002000
Loading section .isr_vector, size 0xc4 lma 0x8000000
Loading section .text, size 0x41c8 lma 0x80000d0
Loading section .data, size 0xa0 lma 0x8004298
Loading section .init_array, size 0x4 lma 0x8004338
Loading section .fini_array, size 0x4 lma 0x800433c
Loading section .jcr, size 0x4 lma 0x8004340
Loading section .eh_frame, size 0x4 lma 0x8004b04
Loading section .ARM.exidx, size 0x8 lma 0x8004b08
Start address 0x8001cf8, load size 17220
Transfer rate: 6 KB/sec, 1913 bytes/write.
(gdb) info thread
[New Thread 536871232]
[New Thread 536871456]
  Id   Target Id         Frame
  2    Thread 536871232 (Name: Blink LED 2) Reset_Handler () at libraries/stm32f0xx/src/startup_stm32f072.s:71
  3    Thread 536871456 (Name: Blin`) Reset_Handler () at libraries/stm32f0xx/src/startup_stm32f072.s:71

The current thread <Thread ID 1> has terminated.  See `help thread'.
(gdb) thread 2
[Switching to thread 2 (Thread 536871232)]
#0  Reset_Handler () at libraries/stm32f0xx/src/startup_stm32f072.s:71
71        ldr   r0, =_estack
(gdb) info thread
[New Thread 536872688]
  Id   Target Id         Frame
* 2    Thread 536871232 (Name: Blink LED 2) Reset_Handler () at libraries/stm32f0xx/src/startup_stm32f072.s:71
  3    Thread 536871456 (Name: Blin`) Reset_Handler () at libraries/stm32f0xx/src/startup_stm32f072.s:71
  4    Thread 536872688 (Name: IDLE, State: Running) Reset_Handler () at libraries/stm32f0xx/src/startup_stm32f072.s:71
(gdb) c
Continuing.
^Cwarning: while parsing threads: not well-formed (invalid token)

Thread 4 received signal SIGINT, Interrupt.
[Switching to Thread 536872688]
0x0800076c in prvCheckTasksWaitingTermination () at libraries/FreeRTOS/tasks.c:3533
3533                    while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
(gdb)

I'll work towards cleaning this up and figuring out how we want to do the x86 layer, if nobody has any questions/comments.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,308,2018-09-22T22:57:48Z,2018-11-27T08:34:10Z,2019-01-11T21:44:08Z,MERGED,True,27278,5,48,https://github.com/karlding,ELEC-538: Add FreeRTOS libraries and example project,23,[],https://github.com/uw-midsun/firmware/pull/308,https://github.com/mishazharov,4,https://github.com/uw-midsun/firmware/pull/308#issuecomment-431683735,"I'm throwing up an initial pass at integrating FreeRTOS into our
codebase. This also ports the example application to FreeRTOS, so we
have some frame of reference as to how code will look.
I've split the commits up to make this easier to review. The first
commit dumps the relevant FreeRTOS files as a library. No changes
were made to the code after downloading from their website. The next
set of commits get FreeRTOS compiling as a static library, and then a
demo project is implemented.
There's a couple things here that would be worth considering in the
FreeRTOSConfig.h file:

configUSE_IDLE_HOOK: Do we want to perform some logic when we
enter the idle task (potentially low power mode)?
Do we want to enable dynamic allocation? I'm of the opinion that
static allocation is the way to go, since it'll be much easier to
manage, especially on an embedded system.
Are there any API functions that you think are needed/are not
needed?
Do we want a per-project FreeRTOSConfig.h file instead? It would
make it somewhat weird to have FreeRTOS as a library that way

These are fairly trivial to change, and we don't have to decide now,
but just something to keep in mind.
This currently only implements the stm32f0xx port, and I haven't
looked into the x86 layer. Theoretically we can use the Linux
simulator, although it's licensed under GPLv2, which would mean that
we would need to re-license code under GPLv2... That's probably why
the build will fail right now.
There's also the matter of getting debugging working, or else working
with FreeRTOS is going to be a pain. I took a quick look at OpenOCD's
User Guide, and apparently there is an option to make it RTOS aware.
I've tested this on a Controller Board, and it seems to work. Anything
else you guys would like me to validate?","I looked over the new files and everything looks good too me.
You mentioned that we can use configUSE_IDLE_HOOK to enter low power mode, that seems like a reasonable thing to do. Maybe we can get that in another pull request though?
I also agree with you that we shouldn't enable dynamic allocation.
A per-project FreeRTOSConfig.h seems like a good idea? But I'm not sure if different projects will need different configurations. Might be a nice option to have anyway, or have some way to override the default configuration options on a per project basis.
Otherwise I think this is good to merge. Does anyone have any other comments or thoughts?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,308,2018-09-22T22:57:48Z,2018-11-27T08:34:10Z,2019-01-11T21:44:08Z,MERGED,True,27278,5,48,https://github.com/karlding,ELEC-538: Add FreeRTOS libraries and example project,23,[],https://github.com/uw-midsun/firmware/pull/308,https://github.com/karlding,5,https://github.com/uw-midsun/firmware/pull/308#issuecomment-433123915,"I'm throwing up an initial pass at integrating FreeRTOS into our
codebase. This also ports the example application to FreeRTOS, so we
have some frame of reference as to how code will look.
I've split the commits up to make this easier to review. The first
commit dumps the relevant FreeRTOS files as a library. No changes
were made to the code after downloading from their website. The next
set of commits get FreeRTOS compiling as a static library, and then a
demo project is implemented.
There's a couple things here that would be worth considering in the
FreeRTOSConfig.h file:

configUSE_IDLE_HOOK: Do we want to perform some logic when we
enter the idle task (potentially low power mode)?
Do we want to enable dynamic allocation? I'm of the opinion that
static allocation is the way to go, since it'll be much easier to
manage, especially on an embedded system.
Are there any API functions that you think are needed/are not
needed?
Do we want a per-project FreeRTOSConfig.h file instead? It would
make it somewhat weird to have FreeRTOS as a library that way

These are fairly trivial to change, and we don't have to decide now,
but just something to keep in mind.
This currently only implements the stm32f0xx port, and I haven't
looked into the x86 layer. Theoretically we can use the Linux
simulator, although it's licensed under GPLv2, which would mean that
we would need to re-license code under GPLv2... That's probably why
the build will fail right now.
There's also the matter of getting debugging working, or else working
with FreeRTOS is going to be a pain. I took a quick look at OpenOCD's
User Guide, and apparently there is an option to make it RTOS aware.
I've tested this on a Controller Board, and it seems to work. Anything
else you guys would like me to validate?",That and driver bringup on FreeRTOS. You'd need to make sure your drivers are RTOS aware...,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,309,2018-09-23T18:21:30Z,2018-09-24T14:47:42Z,2018-09-24T14:48:06Z,MERGED,True,2,1,1,https://github.com/karlding,ELEC-546: Fix dump system log filenames,3,[],https://github.com/uw-midsun/firmware/pull/309,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/309,"This fixes the filename format string so that running on Windows doesn't
create files with invalid filenames.
Pretty trivial change...","This fixes the filename format string so that running on Windows doesn't
create files with invalid filenames.
Pretty trivial change...",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,310,2018-10-17T08:25:29Z,2018-10-25T16:36:21Z,2018-10-25T16:36:28Z,MERGED,True,1,1,1,https://github.com/karlding,ELEC-535: Quote dump_system log timestamps,1,[],https://github.com/uw-midsun/firmware/pull/310,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/310,"The timestamp has a space, so we should quote this in order to generate CSVs
that can properly be parsed.","The timestamp has a space, so we should quote this in order to generate CSVs
that can properly be parsed.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,311,2018-10-22T07:08:44Z,2018-10-28T07:55:11Z,2018-10-28T08:18:34Z,MERGED,True,466,342,8,https://github.com/karlding,ELEC-563: Add version string,10,[],https://github.com/uw-midsun/firmware/pull/311,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/311,"This adds a version string so in the future, people can just checkout
the specific branch or commit hash and know if there were any changes
applied on top, instead of me having to create a spreadsheet. The
idea is that boards dump this as a diagnostic message at boot, which
can then be read.
Currently the version string takes the format of a git hash + an
dirty status flag.
7ad414f8-dirty
  ^       ^
  |       |
  |       +-- dirty status flag
  +---------- git hash

It doesn't really matter what branch contains the commit, since you'd
be working with a detached HEAD anyways. But if you wanted to find
the branch for some reason, you can easily find the branch that
contains the commit using something like:
git branch --contains <commit>","This adds a version string so in the future, people can just checkout
the specific branch or commit hash and know if there were any changes
applied on top, instead of me having to create a spreadsheet. The
idea is that boards dump this as a diagnostic message at boot, which
can then be read.
Currently the version string takes the format of a git hash + an
dirty status flag.
7ad414f8-dirty
  ^       ^
  |       |
  |       +-- dirty status flag
  +---------- git hash

It doesn't really matter what branch contains the commit, since you'd
be working with a detached HEAD anyways. But if you wanted to find
the branch for some reason, you can easily find the branch that
contains the commit using something like:
git branch --contains <commit>",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,311,2018-10-22T07:08:44Z,2018-10-28T07:55:11Z,2018-10-28T08:18:34Z,MERGED,True,466,342,8,https://github.com/karlding,ELEC-563: Add version string,10,[],https://github.com/uw-midsun/firmware/pull/311,https://github.com/mishazharov,2,https://github.com/uw-midsun/firmware/pull/311#issuecomment-431980877,"This adds a version string so in the future, people can just checkout
the specific branch or commit hash and know if there were any changes
applied on top, instead of me having to create a spreadsheet. The
idea is that boards dump this as a diagnostic message at boot, which
can then be read.
Currently the version string takes the format of a git hash + an
dirty status flag.
7ad414f8-dirty
  ^       ^
  |       |
  |       +-- dirty status flag
  +---------- git hash

It doesn't really matter what branch contains the commit, since you'd
be working with a detached HEAD anyways. But if you wanted to find
the branch for some reason, you can easily find the branch that
contains the commit using something like:
git branch --contains <commit>","This looks like it's really useful.
A potential issue might be if a person flashes something onto a board without committing their changes, but it doesn't seem like we can do anything about that. Might be useful to just keep in mind.
Also, what does the dirty status flag mean / when is it toggled?
Edit: Never mind, the dirty flag is set when the working directory is not clean (which solves the issue I was thinking of)",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,311,2018-10-22T07:08:44Z,2018-10-28T07:55:11Z,2018-10-28T08:18:34Z,MERGED,True,466,342,8,https://github.com/karlding,ELEC-563: Add version string,10,[],https://github.com/uw-midsun/firmware/pull/311,https://github.com/karlding,3,https://github.com/uw-midsun/firmware/pull/311#issuecomment-432101610,"This adds a version string so in the future, people can just checkout
the specific branch or commit hash and know if there were any changes
applied on top, instead of me having to create a spreadsheet. The
idea is that boards dump this as a diagnostic message at boot, which
can then be read.
Currently the version string takes the format of a git hash + an
dirty status flag.
7ad414f8-dirty
  ^       ^
  |       |
  |       +-- dirty status flag
  +---------- git hash

It doesn't really matter what branch contains the commit, since you'd
be working with a detached HEAD anyways. But if you wanted to find
the branch for some reason, you can easily find the branch that
contains the commit using something like:
git branch --contains <commit>","Yes, that is correct.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,311,2018-10-22T07:08:44Z,2018-10-28T07:55:11Z,2018-10-28T08:18:34Z,MERGED,True,466,342,8,https://github.com/karlding,ELEC-563: Add version string,10,[],https://github.com/uw-midsun/firmware/pull/311,https://github.com/mishazharov,4,https://github.com/uw-midsun/firmware/pull/311#issuecomment-432392728,"This adds a version string so in the future, people can just checkout
the specific branch or commit hash and know if there were any changes
applied on top, instead of me having to create a spreadsheet. The
idea is that boards dump this as a diagnostic message at boot, which
can then be read.
Currently the version string takes the format of a git hash + an
dirty status flag.
7ad414f8-dirty
  ^       ^
  |       |
  |       +-- dirty status flag
  +---------- git hash

It doesn't really matter what branch contains the commit, since you'd
be working with a detached HEAD anyways. But if you wanted to find
the branch for some reason, you can easily find the branch that
contains the commit using something like:
git branch --contains <commit>","Correct me if I'm wrong, but it looks like all projects still needs to call git_version_init for the hash to be printed on startup. Is it possible / desirable to automatically call it so that all existing projects and new projects will do this without intervention? Or do we want to be explicit when printing the hash?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,311,2018-10-22T07:08:44Z,2018-10-28T07:55:11Z,2018-10-28T08:18:34Z,MERGED,True,466,342,8,https://github.com/karlding,ELEC-563: Add version string,10,[],https://github.com/uw-midsun/firmware/pull/311,https://github.com/karlding,5,https://github.com/uw-midsun/firmware/pull/311#issuecomment-432531502,"This adds a version string so in the future, people can just checkout
the specific branch or commit hash and know if there were any changes
applied on top, instead of me having to create a spreadsheet. The
idea is that boards dump this as a diagnostic message at boot, which
can then be read.
Currently the version string takes the format of a git hash + an
dirty status flag.
7ad414f8-dirty
  ^       ^
  |       |
  |       +-- dirty status flag
  +---------- git hash

It doesn't really matter what branch contains the commit, since you'd
be working with a detached HEAD anyways. But if you wanted to find
the branch for some reason, you can easily find the branch that
contains the commit using something like:
git branch --contains <commit>","It's definitely possible to do that at init on stm32f0xx. We're already using the startup script in order to perform the retargeting (see libraries/stm32f0xx/src/startup_stm32f072.s) before performing a Branch and Link into main. Adding an additional bl to dump the version string would be trivial.
I initially thought about doing that, but I decided against it because:

It's opaque. There's already a struggle with understanding how the car works, not to mention the ""magic"" that goes into retargeting and setting up the vector table. I'd like to keep the startup scripts as simple as possible.
It doesn't work on x86. I guess you could provide a custom crt0 or something, otherwise we'd be depending on compiler specific behaviour. On the other hand, I'm not sure if this is useful on x86, so maybe this is a moot point.
It would make using the board as a CAN-UART interface difficult if you happened to be using USART1 as your UART output, since you'd have the version string dumped as your first message. This would only affect the case that you guys are using right now in order to log 2 buses, so it's not a super big deal.

However, the more I think about it, the more I like having it transparent and automatic...",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,311,2018-10-22T07:08:44Z,2018-10-28T07:55:11Z,2018-10-28T08:18:34Z,MERGED,True,466,342,8,https://github.com/karlding,ELEC-563: Add version string,10,[],https://github.com/uw-midsun/firmware/pull/311,https://github.com/mishazharov,6,https://github.com/uw-midsun/firmware/pull/311#issuecomment-432837724,"This adds a version string so in the future, people can just checkout
the specific branch or commit hash and know if there were any changes
applied on top, instead of me having to create a spreadsheet. The
idea is that boards dump this as a diagnostic message at boot, which
can then be read.
Currently the version string takes the format of a git hash + an
dirty status flag.
7ad414f8-dirty
  ^       ^
  |       |
  |       +-- dirty status flag
  +---------- git hash

It doesn't really matter what branch contains the commit, since you'd
be working with a detached HEAD anyways. But if you wanted to find
the branch for some reason, you can easily find the branch that
contains the commit using something like:
git branch --contains <commit>","Since the version is now printed automatically, maybe we want to have a build flag which would disable it from printing (for things like CAN dump)?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,311,2018-10-22T07:08:44Z,2018-10-28T07:55:11Z,2018-10-28T08:18:34Z,MERGED,True,466,342,8,https://github.com/karlding,ELEC-563: Add version string,10,[],https://github.com/uw-midsun/firmware/pull/311,https://github.com/karlding,7,https://github.com/uw-midsun/firmware/pull/311#issuecomment-433123372,"This adds a version string so in the future, people can just checkout
the specific branch or commit hash and know if there were any changes
applied on top, instead of me having to create a spreadsheet. The
idea is that boards dump this as a diagnostic message at boot, which
can then be read.
Currently the version string takes the format of a git hash + an
dirty status flag.
7ad414f8-dirty
  ^       ^
  |       |
  |       +-- dirty status flag
  +---------- git hash

It doesn't really matter what branch contains the commit, since you'd
be working with a detached HEAD anyways. But if you wanted to find
the branch for some reason, you can easily find the branch that
contains the commit using something like:
git branch --contains <commit>","Well, since this is a shared library, you generally want to minimize wasting time rebuilding. If you left that as a per-project configuration, then there'd be no point in having this as a library, as that defeats the purpose.
If you wanted to do that, you'd want to add a codegen option on a per-project basis, instead of a shared library. This would be built as part of each project instead of a dependency.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,311,2018-10-22T07:08:44Z,2018-10-28T07:55:11Z,2018-10-28T08:18:34Z,MERGED,True,466,342,8,https://github.com/karlding,ELEC-563: Add version string,10,[],https://github.com/uw-midsun/firmware/pull/311,https://github.com/mishazharov,8,https://github.com/uw-midsun/firmware/pull/311#issuecomment-433660294,"This adds a version string so in the future, people can just checkout
the specific branch or commit hash and know if there were any changes
applied on top, instead of me having to create a spreadsheet. The
idea is that boards dump this as a diagnostic message at boot, which
can then be read.
Currently the version string takes the format of a git hash + an
dirty status flag.
7ad414f8-dirty
  ^       ^
  |       |
  |       +-- dirty status flag
  +---------- git hash

It doesn't really matter what branch contains the commit, since you'd
be working with a detached HEAD anyways. But if you wanted to find
the branch for some reason, you can easily find the branch that
contains the commit using something like:
git branch --contains <commit>","Ok, let's leave it as is then and make sure that other scripts will be able to handle the additional output or make sure that we listen after the message was sent.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,312,2018-10-27T20:57:47Z,2019-03-25T00:27:55Z,2019-03-25T00:27:55Z,CLOSED,False,104,111,18,https://github.com/andyjiin,ELEC-549: Clean Driver Controls,8,[],https://github.com/uw-midsun/firmware/pull/312,https://github.com/andyjiin,1,https://github.com/uw-midsun/firmware/pull/312,Clean and merge race changes,Clean and merge race changes,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,312,2018-10-27T20:57:47Z,2019-03-25T00:27:55Z,2019-03-25T00:27:55Z,CLOSED,False,104,111,18,https://github.com/andyjiin,ELEC-549: Clean Driver Controls,8,[],https://github.com/uw-midsun/firmware/pull/312,https://github.com/andyjiin,2,https://github.com/uw-midsun/firmware/pull/312#issuecomment-433654841,Clean and merge race changes,Can someone (preferably someone who went to the race) verify that these are all the changes done. I don't want to flash this in case I missed something 😅,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,312,2018-10-27T20:57:47Z,2019-03-25T00:27:55Z,2019-03-25T00:27:55Z,CLOSED,False,104,111,18,https://github.com/andyjiin,ELEC-549: Clean Driver Controls,8,[],https://github.com/uw-midsun/firmware/pull/312,https://github.com/karlding,3,https://github.com/uw-midsun/firmware/pull/312#issuecomment-433667868,Clean and merge race changes,"I'm not home right now, but can you revert any changes to files that aren't related to Driver Controls? Not sure why you need to modify those files as part of this diff?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,312,2018-10-27T20:57:47Z,2019-03-25T00:27:55Z,2019-03-25T00:27:55Z,CLOSED,False,104,111,18,https://github.com/andyjiin,ELEC-549: Clean Driver Controls,8,[],https://github.com/uw-midsun/firmware/pull/312,https://github.com/andyjiin,4,https://github.com/uw-midsun/firmware/pull/312#issuecomment-433668387,Clean and merge race changes,@karlding should I still include changes done to motor controller and mcp2515 or keep that separate,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,312,2018-10-27T20:57:47Z,2019-03-25T00:27:55Z,2019-03-25T00:27:55Z,CLOSED,False,104,111,18,https://github.com/andyjiin,ELEC-549: Clean Driver Controls,8,[],https://github.com/uw-midsun/firmware/pull/312,https://github.com/karlding,5,https://github.com/uw-midsun/firmware/pull/312#issuecomment-433676620,Clean and merge race changes,Only if you need those changes?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,312,2018-10-27T20:57:47Z,2019-03-25T00:27:55Z,2019-03-25T00:27:55Z,CLOSED,False,104,111,18,https://github.com/andyjiin,ELEC-549: Clean Driver Controls,8,[],https://github.com/uw-midsun/firmware/pull/312,https://github.com/mishazharov,6,https://github.com/uw-midsun/firmware/pull/312#issuecomment-476017779,Clean and merge race changes,"ELEC-580 will hopefully be finished, so we won't need to merge this in. Feel free to reopen this PR if we need it though",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,313,2018-11-04T02:57:09Z,2018-11-04T03:58:52Z,2018-11-04T03:58:52Z,CLOSED,False,564,0,3,https://github.com/myh999,ELEC-71: Restore NMEA parsing components,1,[],https://github.com/uw-midsun/firmware/pull/313,https://github.com/myh999,1,https://github.com/uw-midsun/firmware/pull/313,"Restore NMEA parsing components to allow for parsing on the board.
Relevant discussion","Restore NMEA parsing components to allow for parsing on the board.
Relevant discussion",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,313,2018-11-04T02:57:09Z,2018-11-04T03:58:52Z,2018-11-04T03:58:52Z,CLOSED,False,564,0,3,https://github.com/myh999,ELEC-71: Restore NMEA parsing components,1,[],https://github.com/uw-midsun/firmware/pull/313,https://github.com/myh999,2,https://github.com/uw-midsun/firmware/pull/313#issuecomment-435640123,"Restore NMEA parsing components to allow for parsing on the board.
Relevant discussion",Closing this PR and re-opening PR 191,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,314,2018-11-08T00:03:13Z,2018-11-08T15:07:14Z,2018-11-08T15:07:18Z,MERGED,True,0,0,5,https://github.com/andyjiin,ELEC-570: Move ADS1015 driver to ms-helper,1,[],https://github.com/uw-midsun/firmware/pull/314,https://github.com/andyjiin,1,https://github.com/uw-midsun/firmware/pull/314,,,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,315,2018-11-10T18:47:43Z,2019-05-30T17:53:49Z,2019-05-30T17:53:49Z,CLOSED,False,626,1,14,https://github.com/andyjiin,ELEC-434: Driver Display module,46,[],https://github.com/uw-midsun/firmware/pull/315,https://github.com/andyjiin,1,https://github.com/uw-midsun/firmware/pull/315,"Basic functionality is implemented with the exception of test cases which @stevenli1141 is working on
I will be testing this later today and will update this with the results","Basic functionality is implemented with the exception of test cases which @stevenli1141 is working on
I will be testing this later today and will update this with the results",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,315,2018-11-10T18:47:43Z,2019-05-30T17:53:49Z,2019-05-30T17:53:49Z,CLOSED,False,626,1,14,https://github.com/andyjiin,ELEC-434: Driver Display module,46,[],https://github.com/uw-midsun/firmware/pull/315,https://github.com/mishazharov,2,https://github.com/uw-midsun/firmware/pull/315#issuecomment-476018345,"Basic functionality is implemented with the exception of test cases which @stevenli1141 is working on
I will be testing this later today and will update this with the results",What is the status of this PR? Can it be merged / handed off or should we just close it?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,315,2018-11-10T18:47:43Z,2019-05-30T17:53:49Z,2019-05-30T17:53:49Z,CLOSED,False,626,1,14,https://github.com/andyjiin,ELEC-434: Driver Display module,46,[],https://github.com/uw-midsun/firmware/pull/315,https://github.com/andyjiin,3,https://github.com/uw-midsun/firmware/pull/315#issuecomment-476219981,"Basic functionality is implemented with the exception of test cases which @stevenli1141 is working on
I will be testing this later today and will update this with the results",@mikzharov Last I heard it was waiting for hardware,True,{'THUMBS_UP': ['https://github.com/mishazharov']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,315,2018-11-10T18:47:43Z,2019-05-30T17:53:49Z,2019-05-30T17:53:49Z,CLOSED,False,626,1,14,https://github.com/andyjiin,ELEC-434: Driver Display module,46,[],https://github.com/uw-midsun/firmware/pull/315,https://github.com/anikser,4,https://github.com/uw-midsun/firmware/pull/315#issuecomment-497421891,"Basic functionality is implemented with the exception of test cases which @stevenli1141 is working on
I will be testing this later today and will update this with the results",The driver display board in this form has been deprecated.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,316,2018-11-10T19:10:19Z,,2018-11-11T16:20:24Z,OPEN,False,325,0,3,https://github.com/NicholasThrom,ELEC-540: Math for State of Charge,5,[],https://github.com/uw-midsun/firmware/pull/316,https://github.com/NicholasThrom,1,https://github.com/uw-midsun/firmware/pull/316,"This PR contains all the math for state of charge. Specifically, it contains a way to calculate the charge of some cell, based on the previous charge, as well as the current, voltage, and amount of time passed.
It doesn't contain anything to actually hook it up to the car (e.g. persistence, actually sending the messages to where ever it needs to go, calibration), since it sounds like we don't have the data we need to calibrate it right now.","This PR contains all the math for state of charge. Specifically, it contains a way to calculate the charge of some cell, based on the previous charge, as well as the current, voltage, and amount of time passed.
It doesn't contain anything to actually hook it up to the car (e.g. persistence, actually sending the messages to where ever it needs to go, calibration), since it sounds like we don't have the data we need to calibrate it right now.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,317,2018-11-27T02:43:45Z,2019-04-01T23:49:13Z,2019-04-01T23:49:13Z,CLOSED,False,349,79,17,https://github.com/mishazharov,ELEC-528: Resolving MCI issue,66,[],https://github.com/uw-midsun/firmware/pull/317,https://github.com/mishazharov,1,https://github.com/uw-midsun/firmware/pull/317,"It looks like we've narrowed down the MCI issue to a timing conflict between the Mcp2515 polling and periodic_tx interrupt.
This issue seems to have been resolved by adding some critical sections, but I will test it again just to make sure that this is the case, and that the refactoring in this commit did not break anything. However, feel free to add initial comments while I get a chance to test the fix again.","It looks like we've narrowed down the MCI issue to a timing conflict between the Mcp2515 polling and periodic_tx interrupt.
This issue seems to have been resolved by adding some critical sections, but I will test it again just to make sure that this is the case, and that the refactoring in this commit did not break anything. However, feel free to add initial comments while I get a chance to test the fix again.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,317,2018-11-27T02:43:45Z,2019-04-01T23:49:13Z,2019-04-01T23:49:13Z,CLOSED,False,349,79,17,https://github.com/mishazharov,ELEC-528: Resolving MCI issue,66,[],https://github.com/uw-midsun/firmware/pull/317,https://github.com/karlding,2,https://github.com/uw-midsun/firmware/pull/317#issuecomment-441981571,"It looks like we've narrowed down the MCI issue to a timing conflict between the Mcp2515 polling and periodic_tx interrupt.
This issue seems to have been resolved by adding some critical sections, but I will test it again just to make sure that this is the case, and that the refactoring in this commit did not break anything. However, feel free to add initial comments while I get a chance to test the fix again.","Cool!
If I understand correctly, you're claiming that there's a race between the polling and periodic_tx interrupt, like so:

We poll in main loop via mcp2515_poll
mcp2515_poll calls prv_handle_int
A SPI transaction starts
The motor controller prv_periodic_tx timer runs, preempting the SPI transaction and causing a context switch
We send a new message to Motor Controllers, starting a new SPI transaction which basically invalidates the SPI command in 3 (is this the race that you're talking about?) from the new context
The timer completes, and we context switch back to the mcp2515_poll
The MCP2515 driver doesn't process any messages, since the register read was interrupted (presumably returning garbage values).

Is that correct?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,317,2018-11-27T02:43:45Z,2019-04-01T23:49:13Z,2019-04-01T23:49:13Z,CLOSED,False,349,79,17,https://github.com/mishazharov,ELEC-528: Resolving MCI issue,66,[],https://github.com/uw-midsun/firmware/pull/317,https://github.com/mishazharov,3,https://github.com/uw-midsun/firmware/pull/317#issuecomment-442052357,"It looks like we've narrowed down the MCI issue to a timing conflict between the Mcp2515 polling and periodic_tx interrupt.
This issue seems to have been resolved by adding some critical sections, but I will test it again just to make sure that this is the case, and that the refactoring in this commit did not break anything. However, feel free to add initial comments while I get a chance to test the fix again.","Yes, that's the current suspect. The way we found it was to increase the motor CAN bitrate to 500kbps which made the issue easy to reproduce (took minutes to fail). Disabling the timer seemed to fix the issue, so I added critical sections which seemed to fix it.
I only have 2 concerns left.


We only tested this fix using a power supply to the MCI, so I want to make sure it also works when the car is actually on and driving.


I'm not too sure why step 7 would cause it to not process any other messenges. The issue we see is that the interrupt pin is no longer triggered so it seems like the MCP goes into a bad state, instead of rejecting the command.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,317,2018-11-27T02:43:45Z,2019-04-01T23:49:13Z,2019-04-01T23:49:13Z,CLOSED,False,349,79,17,https://github.com/mishazharov,ELEC-528: Resolving MCI issue,66,[],https://github.com/uw-midsun/firmware/pull/317,https://github.com/mishazharov,4,https://github.com/uw-midsun/firmware/pull/317#issuecomment-442219793,"It looks like we've narrowed down the MCI issue to a timing conflict between the Mcp2515 polling and periodic_tx interrupt.
This issue seems to have been resolved by adding some critical sections, but I will test it again just to make sure that this is the case, and that the refactoring in this commit did not break anything. However, feel free to add initial comments while I get a chance to test the fix again.","I just tested this code on the car, and it doesn't work. No messages are received or sent by the mci. However, the code in tmp_race_branch works so I think that the pull from master went wrong. I'm not sure exactly what the issue is yet, but am working on it. If anyone has any insight into what the issue could be, I would really appreciate it.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,317,2018-11-27T02:43:45Z,2019-04-01T23:49:13Z,2019-04-01T23:49:13Z,CLOSED,False,349,79,17,https://github.com/mishazharov,ELEC-528: Resolving MCI issue,66,[],https://github.com/uw-midsun/firmware/pull/317,https://github.com/ashraf2047,5,https://github.com/uw-midsun/firmware/pull/317#issuecomment-442223922,"It looks like we've narrowed down the MCI issue to a timing conflict between the Mcp2515 polling and periodic_tx interrupt.
This issue seems to have been resolved by adding some critical sections, but I will test it again just to make sure that this is the case, and that the refactoring in this commit did not break anything. However, feel free to add initial comments while I get a chance to test the fix again.",Did you have any issues/conflicts when you pulled from master?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,317,2018-11-27T02:43:45Z,2019-04-01T23:49:13Z,2019-04-01T23:49:13Z,CLOSED,False,349,79,17,https://github.com/mishazharov,ELEC-528: Resolving MCI issue,66,[],https://github.com/uw-midsun/firmware/pull/317,https://github.com/mishazharov,6,https://github.com/uw-midsun/firmware/pull/317#issuecomment-442226161,"It looks like we've narrowed down the MCI issue to a timing conflict between the Mcp2515 polling and periodic_tx interrupt.
This issue seems to have been resolved by adding some critical sections, but I will test it again just to make sure that this is the case, and that the refactoring in this commit did not break anything. However, feel free to add initial comments while I get a chance to test the fix again.","Yup, but as you can see from the build, I resolved them.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,317,2018-11-27T02:43:45Z,2019-04-01T23:49:13Z,2019-04-01T23:49:13Z,CLOSED,False,349,79,17,https://github.com/mishazharov,ELEC-528: Resolving MCI issue,66,[],https://github.com/uw-midsun/firmware/pull/317,https://github.com/mishazharov,7,https://github.com/uw-midsun/firmware/pull/317#issuecomment-442630267,"It looks like we've narrowed down the MCI issue to a timing conflict between the Mcp2515 polling and periodic_tx interrupt.
This issue seems to have been resolved by adding some critical sections, but I will test it again just to make sure that this is the case, and that the refactoring in this commit did not break anything. However, feel free to add initial comments while I get a chance to test the fix again.","This commit seems to fix the issue. I disabled the version logging on startup. As a result, the code for the mci in b005a53 was able to receive and transmit for 1 hour and 50 minutes. Hopefully there will be no other issues as I clean up the code",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,317,2018-11-27T02:43:45Z,2019-04-01T23:49:13Z,2019-04-01T23:49:13Z,CLOSED,False,349,79,17,https://github.com/mishazharov,ELEC-528: Resolving MCI issue,66,[],https://github.com/uw-midsun/firmware/pull/317,https://github.com/ashraf2047,8,https://github.com/uw-midsun/firmware/pull/317#issuecomment-443463136,"It looks like we've narrowed down the MCI issue to a timing conflict between the Mcp2515 polling and periodic_tx interrupt.
This issue seems to have been resolved by adding some critical sections, but I will test it again just to make sure that this is the case, and that the refactoring in this commit did not break anything. However, feel free to add initial comments while I get a chance to test the fix again.","after a 3 hour test, the MCI issue has been resolved (with this PR).",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,317,2018-11-27T02:43:45Z,2019-04-01T23:49:13Z,2019-04-01T23:49:13Z,CLOSED,False,349,79,17,https://github.com/mishazharov,ELEC-528: Resolving MCI issue,66,[],https://github.com/uw-midsun/firmware/pull/317,https://github.com/mishazharov,9,https://github.com/uw-midsun/firmware/pull/317#issuecomment-453782421,"It looks like we've narrowed down the MCI issue to a timing conflict between the Mcp2515 polling and periodic_tx interrupt.
This issue seems to have been resolved by adding some critical sections, but I will test it again just to make sure that this is the case, and that the refactoring in this commit did not break anything. However, feel free to add initial comments while I get a chance to test the fix again.","@karlding @ashraf2047 @taipingli Can someone please review these changes?
Also last time I checked, version logging caused issues for the MCI. Can someone please check if that's still the case, and investigate if it is?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,317,2018-11-27T02:43:45Z,2019-04-01T23:49:13Z,2019-04-01T23:49:13Z,CLOSED,False,349,79,17,https://github.com/mishazharov,ELEC-528: Resolving MCI issue,66,[],https://github.com/uw-midsun/firmware/pull/317,https://github.com/mishazharov,10,https://github.com/uw-midsun/firmware/pull/317#issuecomment-478788559,"It looks like we've narrowed down the MCI issue to a timing conflict between the Mcp2515 polling and periodic_tx interrupt.
This issue seems to have been resolved by adding some critical sections, but I will test it again just to make sure that this is the case, and that the refactoring in this commit did not break anything. However, feel free to add initial comments while I get a chance to test the fix again.",Closing for further investigation,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,318,2019-01-23T13:02:33Z,2019-02-02T08:25:01Z,2019-02-02T08:25:04Z,MERGED,True,34,4,3,https://github.com/karlding,ELEC-583: Fix AFE discharge indices,4,[],https://github.com/uw-midsun/firmware/pull/318,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/318,"I was looking through the AFE driver and noticed that the device and cell values used for the reverse discharge mapping lookup is reversed. As such, you potentially get reads past the buffer, which will probably result in setting the wrong index.
This fixes this problem, and clarifies how the mapping works.","I was looking through the AFE driver and noticed that the device and cell values used for the reverse discharge mapping lookup is reversed. As such, you potentially get reads past the buffer, which will probably result in setting the wrong index.
This fixes this problem, and clarifies how the mapping works.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,318,2019-01-23T13:02:33Z,2019-02-02T08:25:01Z,2019-02-02T08:25:04Z,MERGED,True,34,4,3,https://github.com/karlding,ELEC-583: Fix AFE discharge indices,4,[],https://github.com/uw-midsun/firmware/pull/318,https://github.com/tituschow,2,https://github.com/uw-midsun/firmware/pull/318#issuecomment-457021961,"I was looking through the AFE driver and noticed that the device and cell values used for the reverse discharge mapping lookup is reversed. As such, you potentially get reads past the buffer, which will probably result in setting the wrong index.
This fixes this problem, and clarifies how the mapping works.",Would recommend adding a test for logical -> physical mappings so we can catch this if we change the mapping code.,True,{'THUMBS_UP': ['https://github.com/mishazharov']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,319,2019-01-24T00:40:46Z,2019-01-26T20:32:17Z,2019-01-26T20:32:20Z,MERGED,True,2,3,1,https://github.com/tituschow,ELEC-584: Strip unused sections,2,[],https://github.com/uw-midsun/firmware/pull/319,https://github.com/tituschow,1,https://github.com/uw-midsun/firmware/pull/319,"Before:
Building driver_controls.elf for stm32f0xx
   text    data     bss     dec     hex filename
  53512     576    4300   58388    e414 build/bin/stm32f0xx/driver_controls.elf

After:
Building driver_controls.elf for stm32f0xx
   text    data     bss     dec     hex filename
  40616     540    4260   45416    b168 build/bin/stm32f0xx/driver_controls.elf","Before:
Building driver_controls.elf for stm32f0xx
   text    data     bss     dec     hex filename
  53512     576    4300   58388    e414 build/bin/stm32f0xx/driver_controls.elf

After:
Building driver_controls.elf for stm32f0xx
   text    data     bss     dec     hex filename
  40616     540    4260   45416    b168 build/bin/stm32f0xx/driver_controls.elf",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,320,2019-02-05T02:01:01Z,2019-02-13T23:18:27Z,2019-02-13T23:18:37Z,MERGED,True,284,5,5,https://github.com/myh999,ELEC-71: GPS Driver,180,[],https://github.com/uw-midsun/firmware/pull/320,https://github.com/myh999,1,https://github.com/uw-midsun/firmware/pull/320,"Driver to retrieve and categorize GPS messages
Extension of #218 to allow Misha as a reviewer","Driver to retrieve and categorize GPS messages
Extension of #218 to allow Misha as a reviewer",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,321,2019-02-13T19:44:47Z,2019-02-14T02:22:10Z,2019-02-14T02:22:13Z,MERGED,True,29,23,3,https://github.com/karlding,ELEC-588: Remove reallyclean target,2,[],https://github.com/uw-midsun/firmware/pull/321,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/321,"Remove the distinction between the clean and reallyclean targets.
This creates a lot of confusion, and there are very few cases where the
intended behaviour is to only clean a specific project. Moreover, in the
interests of keeping things consistent with typical conventions, this
renames the reallyclean target to clean.","Remove the distinction between the clean and reallyclean targets.
This creates a lot of confusion, and there are very few cases where the
intended behaviour is to only clean a specific project. Moreover, in the
interests of keeping things consistent with typical conventions, this
renames the reallyclean target to clean.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,322,2019-03-03T23:37:36Z,2019-03-05T18:56:43Z,2019-03-05T18:56:43Z,MERGED,True,48,10,2,https://github.com/mishazharov,ELEC-63: Exposing more functionality to user in the SPI driver,6,[],https://github.com/uw-midsun/firmware/pull/322,https://github.com/mishazharov,1,https://github.com/uw-midsun/firmware/pull/322,"In order to write the SD card driver, the user must have manual control of the CS line. This PR allows users of the SPI driver to manually control the CS line and the receive / transmit flow","In order to write the SD card driver, the user must have manual control of the CS line. This PR allows users of the SPI driver to manually control the CS line and the receive / transmit flow",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,323,2019-03-05T02:28:21Z,2019-03-10T20:54:13Z,2019-03-10T20:54:18Z,MERGED,True,16,4,2,https://github.com/mishazharov,ELEC-533: Changed init to retry and assert success,7,[],https://github.com/uw-midsun/firmware/pull/323,https://github.com/mishazharov,1,https://github.com/uw-midsun/firmware/pull/323,"I was messing around with this and I think I fixed it.
I think the issue was that on slow machines the connect() happens before the socket is fully initialized (judging by the log output and the solution).
As a fix, when the connect() fails, we retry a couple of times. As well, we assert that the x86_socket_write actually succeeds. So if the first fix does not work, at least the test will not hang.","I was messing around with this and I think I fixed it.
I think the issue was that on slow machines the connect() happens before the socket is fully initialized (judging by the log output and the solution).
As a fix, when the connect() fails, we retry a couple of times. As well, we assert that the x86_socket_write actually succeeds. So if the first fix does not work, at least the test will not hang.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,323,2019-03-05T02:28:21Z,2019-03-10T20:54:13Z,2019-03-10T20:54:18Z,MERGED,True,16,4,2,https://github.com/mishazharov,ELEC-533: Changed init to retry and assert success,7,[],https://github.com/uw-midsun/firmware/pull/323,https://github.com/karlding,2,https://github.com/uw-midsun/firmware/pull/323#issuecomment-469779986,"I was messing around with this and I think I fixed it.
I think the issue was that on slow machines the connect() happens before the socket is fully initialized (judging by the log output and the solution).
As a fix, when the connect() fails, we retry a couple of times. As well, we assert that the x86_socket_write actually succeeds. So if the first fix does not work, at least the test will not hang.","I think the issue was that on slow machines the connect() happens before the socket is fully initialized (judging by the log output and the solution).

Are you talking about the socket connection the client is setting up? It is not clear what the issue is (or the sequence of events that leads to the issue) that you are claiming.
In general, when claiming that there's a bug like this, it usually is a good idea to outline the control flow that happens so people understand what the problem is that you're trying to fix.
For example:

Server starts and creates socket
Client creates socket via socket()
Client calls connect()
Client/Server does x, which fails because y",True,{'THUMBS_UP': ['https://github.com/mishazharov']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,323,2019-03-05T02:28:21Z,2019-03-10T20:54:13Z,2019-03-10T20:54:18Z,MERGED,True,16,4,2,https://github.com/mishazharov,ELEC-533: Changed init to retry and assert success,7,[],https://github.com/uw-midsun/firmware/pull/323,https://github.com/mishazharov,3,https://github.com/uw-midsun/firmware/pull/323#issuecomment-469916357,"I was messing around with this and I think I fixed it.
I think the issue was that on slow machines the connect() happens before the socket is fully initialized (judging by the log output and the solution).
As a fix, when the connect() fails, we retry a couple of times. As well, we assert that the x86_socket_write actually succeeds. So if the first fix does not work, at least the test will not hang.","Thanks for letting me know. I'll try to be more clear.
Here's what I think is happening:
In test_x86_cmd_client, the test_x86_socket_client_init call is returning a socket that is not connected to anything.
This is because the prv_server_thread starts after test_x86_socket_client_init trys to connect a socket to the server. That's probably happening because of setup time / slow VM's or something like that. So my solution was to a) allow test_x86_socket_client_init to retry up to 5 times before returning and b) make sure that when x86_socket_write is called in test_x86_cmd_client, it actually returns an ok status, so that we don't get stuck in the while loop forever.
Essentially:

Client creates socket via socket()
Client calls connect()
Server starts and creates socket
The client has already failed to connect, and does not try again",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,323,2019-03-05T02:28:21Z,2019-03-10T20:54:13Z,2019-03-10T20:54:18Z,MERGED,True,16,4,2,https://github.com/mishazharov,ELEC-533: Changed init to retry and assert success,7,[],https://github.com/uw-midsun/firmware/pull/323,https://github.com/mishazharov,4,https://github.com/uw-midsun/firmware/pull/323#issuecomment-469917861,"I was messing around with this and I think I fixed it.
I think the issue was that on slow machines the connect() happens before the socket is fully initialized (judging by the log output and the solution).
As a fix, when the connect() fails, we retry a couple of times. As well, we assert that the x86_socket_write actually succeeds. So if the first fix does not work, at least the test will not hang.","With the new code we have something like this:
[2] libraries/x86/src/x86_socket.c:182: Failed to connect to socket: Connection refused
[0] libraries/x86/src/x86_socket.c:56: Started RX server for cmd (PID 6090)
[0] libraries/x86/test/test_x86_cmd.c:40: Sending command: ""test a b c d""
[0] libraries/x86/src/x86_socket.c:81: New client 5 connected to cmd!
[0] libraries/x86/src/x86_cmd.c:25: Received command test a b c d

Notice how on line 1, the connection fails. However, after a retry, it succeeds",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,323,2019-03-05T02:28:21Z,2019-03-10T20:54:13Z,2019-03-10T20:54:18Z,MERGED,True,16,4,2,https://github.com/mishazharov,ELEC-533: Changed init to retry and assert success,7,[],https://github.com/uw-midsun/firmware/pull/323,https://github.com/karlding,5,https://github.com/uw-midsun/firmware/pull/323#issuecomment-469936147,"I was messing around with this and I think I fixed it.
I think the issue was that on slow machines the connect() happens before the socket is fully initialized (judging by the log output and the solution).
As a fix, when the connect() fails, we retry a couple of times. As well, we assert that the x86_socket_write actually succeeds. So if the first fix does not work, at least the test will not hang.","I'm still not exactly sure when you're saying the Server starts and when the Server binds the socket.
From what I understand, it seems like you're saying that the first connection is happening before the Server thread is able to bind() the socket. You're saying that this behaviour races, however it should protected by the barrier—yet we currently synchronize at the barrier before the socket is bound on the server.
Maybe I'm missing something, but can't you just simply move the barrier after the bind()?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,323,2019-03-05T02:28:21Z,2019-03-10T20:54:13Z,2019-03-10T20:54:18Z,MERGED,True,16,4,2,https://github.com/mishazharov,ELEC-533: Changed init to retry and assert success,7,[],https://github.com/uw-midsun/firmware/pull/323,https://github.com/mishazharov,6,https://github.com/uw-midsun/firmware/pull/323#issuecomment-469939595,"I was messing around with this and I think I fixed it.
I think the issue was that on slow machines the connect() happens before the socket is fully initialized (judging by the log output and the solution).
As a fix, when the connect() fails, we retry a couple of times. As well, we assert that the x86_socket_write actually succeeds. So if the first fix does not work, at least the test will not hang.","Yup, that's what I meant. The client connected before the server binded to the socket. I agree that moving the barrier is a cleaner solution.
Tested that this fixed the problem I was describing by sleeping for 15s before the bind. The client successfully waited for the server to start",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,323,2019-03-05T02:28:21Z,2019-03-10T20:54:13Z,2019-03-10T20:54:18Z,MERGED,True,16,4,2,https://github.com/mishazharov,ELEC-533: Changed init to retry and assert success,7,[],https://github.com/uw-midsun/firmware/pull/323,https://github.com/karlding,7,https://github.com/uw-midsun/firmware/pull/323#issuecomment-469941536,"I was messing around with this and I think I fixed it.
I think the issue was that on slow machines the connect() happens before the socket is fully initialized (judging by the log output and the solution).
As a fix, when the connect() fails, we retry a couple of times. As well, we assert that the x86_socket_write actually succeeds. So if the first fix does not work, at least the test will not hang.","tbh I would write a script or something and check the repro rate with and without the change to the barrier instead of adding another variable into the mix (assuming the script can also cause the issue). Something like:
#!/bin/bash

COUNTER=1
while [ ${COUNTER} -le 1000 ]
do
  echo ""Iteration ${COUNTER}""
  make test LIBRARY=x86 TEST=x86_cmd PLATFORM=x86
  ((COUNTER++))
done",True,{'THUMBS_UP': ['https://github.com/mishazharov']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,323,2019-03-05T02:28:21Z,2019-03-10T20:54:13Z,2019-03-10T20:54:18Z,MERGED,True,16,4,2,https://github.com/mishazharov,ELEC-533: Changed init to retry and assert success,7,[],https://github.com/uw-midsun/firmware/pull/323,https://github.com/mishazharov,8,https://github.com/uw-midsun/firmware/pull/323#issuecomment-469942396,"I was messing around with this and I think I fixed it.
I think the issue was that on slow machines the connect() happens before the socket is fully initialized (judging by the log output and the solution).
As a fix, when the connect() fails, we retry a couple of times. As well, we assert that the x86_socket_write actually succeeds. So if the first fix does not work, at least the test will not hang.","Good idea, I'll work on this tomorrow and update this review",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,323,2019-03-05T02:28:21Z,2019-03-10T20:54:13Z,2019-03-10T20:54:18Z,MERGED,True,16,4,2,https://github.com/mishazharov,ELEC-533: Changed init to retry and assert success,7,[],https://github.com/uw-midsun/firmware/pull/323,https://github.com/mishazharov,9,https://github.com/uw-midsun/firmware/pull/323#issuecomment-470337849,"I was messing around with this and I think I fixed it.
I think the issue was that on slow machines the connect() happens before the socket is fully initialized (judging by the log output and the solution).
As a fix, when the connect() fails, we retry a couple of times. As well, we assert that the x86_socket_write actually succeeds. So if the first fix does not work, at least the test will not hang.","So I edited your script to run both copies of the test. The one without the fix failed every time on my machine (the VM must be extra slow I guess). The fixed version did not fail. Granted, I only ran both 50 times, but seeing as without the fix it fails so often, I figure that's enough.
Script used to test: https://gist.github.com/mikzharov/66c6b71e0b4bc9226345d9bdb0a9afa9",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,323,2019-03-05T02:28:21Z,2019-03-10T20:54:13Z,2019-03-10T20:54:18Z,MERGED,True,16,4,2,https://github.com/mishazharov,ELEC-533: Changed init to retry and assert success,7,[],https://github.com/uw-midsun/firmware/pull/323,https://github.com/karlding,10,https://github.com/uw-midsun/firmware/pull/323#issuecomment-470651433,"I was messing around with this and I think I fixed it.
I think the issue was that on slow machines the connect() happens before the socket is fully initialized (judging by the log output and the solution).
As a fix, when the connect() fails, we retry a couple of times. As well, we assert that the x86_socket_write actually succeeds. So if the first fix does not work, at least the test will not hang.","Just as a note—it's not a matter of whether it is ""slow"" or not. The issue happens due to the order that the context switches occur, as determined by the scheduler (this is typically true in general for any problem dealing with concurrency). It is possible for a ""slow"" machine to finish execution of its thread before getting context switched out, depending on how the scheduler schedules the individual threads.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,323,2019-03-05T02:28:21Z,2019-03-10T20:54:13Z,2019-03-10T20:54:18Z,MERGED,True,16,4,2,https://github.com/mishazharov,ELEC-533: Changed init to retry and assert success,7,[],https://github.com/uw-midsun/firmware/pull/323,https://github.com/mishazharov,11,https://github.com/uw-midsun/firmware/pull/323#issuecomment-470756247,"I was messing around with this and I think I fixed it.
I think the issue was that on slow machines the connect() happens before the socket is fully initialized (judging by the log output and the solution).
As a fix, when the connect() fails, we retry a couple of times. As well, we assert that the x86_socket_write actually succeeds. So if the first fix does not work, at least the test will not hang.","Thanks for explaining that, I'll keep that in mind for next time before blaming slow machines :)
But if there's no other feedback, let's merge this",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,323,2019-03-05T02:28:21Z,2019-03-10T20:54:13Z,2019-03-10T20:54:18Z,MERGED,True,16,4,2,https://github.com/mishazharov,ELEC-533: Changed init to retry and assert success,7,[],https://github.com/uw-midsun/firmware/pull/323,https://github.com/karlding,12,https://github.com/uw-midsun/firmware/pull/323#issuecomment-471096369,"I was messing around with this and I think I fixed it.
I think the issue was that on slow machines the connect() happens before the socket is fully initialized (judging by the log output and the solution).
As a fix, when the connect() fails, we retry a couple of times. As well, we assert that the x86_socket_write actually succeeds. So if the first fix does not work, at least the test will not hang.","Anyways, someone else should probably actually do the review/approval, I just had some concerns about the approach that you were taking with respect to the retries, since it was just hiding the symptoms instead of actually fixing the problem, and it was a good teachable moment 🙂",True,{'THUMBS_UP': ['https://github.com/mishazharov']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,323,2019-03-05T02:28:21Z,2019-03-10T20:54:13Z,2019-03-10T20:54:18Z,MERGED,True,16,4,2,https://github.com/mishazharov,ELEC-533: Changed init to retry and assert success,7,[],https://github.com/uw-midsun/firmware/pull/323,https://github.com/mishazharov,13,https://github.com/uw-midsun/firmware/pull/323#issuecomment-471211010,"I was messing around with this and I think I fixed it.
I think the issue was that on slow machines the connect() happens before the socket is fully initialized (judging by the log output and the solution).
As a fix, when the connect() fails, we retry a couple of times. As well, we assert that the x86_socket_write actually succeeds. So if the first fix does not work, at least the test will not hang.","Great, thanks for the feedback. I really appreciate it!",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,323,2019-03-05T02:28:21Z,2019-03-10T20:54:13Z,2019-03-10T20:54:18Z,MERGED,True,16,4,2,https://github.com/mishazharov,ELEC-533: Changed init to retry and assert success,7,[],https://github.com/uw-midsun/firmware/pull/323,https://github.com/mishazharov,14,https://github.com/uw-midsun/firmware/pull/323#issuecomment-471324013,"I was messing around with this and I think I fixed it.
I think the issue was that on slow machines the connect() happens before the socket is fully initialized (judging by the log output and the solution).
As a fix, when the connect() fails, we retry a couple of times. As well, we assert that the x86_socket_write actually succeeds. So if the first fix does not work, at least the test will not hang.",@andyjiin @anikser @ashraf2047 Can someone please review this? Thanks!,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,323,2019-03-05T02:28:21Z,2019-03-10T20:54:13Z,2019-03-10T20:54:18Z,MERGED,True,16,4,2,https://github.com/mishazharov,ELEC-533: Changed init to retry and assert success,7,[],https://github.com/uw-midsun/firmware/pull/323,https://github.com/ashraf2047,15,https://github.com/uw-midsun/firmware/pull/323#issuecomment-471342721,"I was messing around with this and I think I fixed it.
I think the issue was that on slow machines the connect() happens before the socket is fully initialized (judging by the log output and the solution).
As a fix, when the connect() fails, we retry a couple of times. As well, we assert that the x86_socket_write actually succeeds. So if the first fix does not work, at least the test will not hang.",LGTM,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,324,2019-03-13T22:59:01Z,2019-03-31T00:23:32Z,2019-03-31T00:23:37Z,MERGED,True,18,14,7,https://github.com/mishazharov,ELEC-593: Fixing clang build + adding clang to travis,4,[],https://github.com/uw-midsun/firmware/pull/324,https://github.com/mishazharov,1,https://github.com/uw-midsun/firmware/pull/324,"Was debugging some race condition when I noticed that the build was not working on clang. I fixed the build issues in ways that seemed reasonable to me, please take a look to make sure I did the right thing. I also added the clang build to Travis so that we would have the build working on both compilers","Was debugging some race condition when I noticed that the build was not working on clang. I fixed the build issues in ways that seemed reasonable to me, please take a look to make sure I did the right thing. I also added the clang build to Travis so that we would have the build working on both compilers",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,325,2019-03-25T00:12:03Z,2019-03-27T23:27:15Z,2019-03-27T23:29:37Z,MERGED,True,521,0,3,https://github.com/mishazharov,ELEC-63: SD card raw read / write,23,[],https://github.com/uw-midsun/firmware/pull/325,https://github.com/mishazharov,1,https://github.com/uw-midsun/firmware/pull/325,"This PR implements reading and writing from an SD card without a file system. Please check elec_63_fatfs for writing and reading with a file system.
For some context on how to read / write to SD cards: http://elm-chan.org/docs/mmc/mmc_e.html","This PR implements reading and writing from an SD card without a file system. Please check elec_63_fatfs for writing and reading with a file system.
For some context on how to read / write to SD cards: http://elm-chan.org/docs/mmc/mmc_e.html",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,326,2019-03-27T23:32:17Z,2019-03-30T18:04:57Z,2019-03-30T18:05:01Z,MERGED,True,23338,1,11,https://github.com/mishazharov,ELEC-63: FatFs layer,21,[],https://github.com/uw-midsun/firmware/pull/326,https://github.com/mishazharov,1,https://github.com/uw-midsun/firmware/pull/326,This PR adds a FAT32 filesystem layer on top of the SD card's binary reading / writing code. Most of the FatFs code was not modified except for some casts to make the compiler happy. The config was also updated. This change was tested on HW with the new sd_demo project.,This PR adds a FAT32 filesystem layer on top of the SD card's binary reading / writing code. Most of the FatFs code was not modified except for some casts to make the compiler happy. The config was also updated. This change was tested on HW with the new sd_demo project.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,326,2019-03-27T23:32:17Z,2019-03-30T18:04:57Z,2019-03-30T18:05:01Z,MERGED,True,23338,1,11,https://github.com/mishazharov,ELEC-63: FatFs layer,21,[],https://github.com/uw-midsun/firmware/pull/326,https://github.com/mishazharov,2,https://github.com/uw-midsun/firmware/pull/326#issuecomment-478100223,This PR adds a FAT32 filesystem layer on top of the SD card's binary reading / writing code. Most of the FatFs code was not modified except for some casts to make the compiler happy. The config was also updated. This change was tested on HW with the new sd_demo project.,"Sure, I changed some things in ff.c, basically our compiler complained because of a few cast issues. Here's a diff of the original and the new one:
1171c1171
< 			wc |= fs->win[bc % SS(fs)] << 8;	/* Merge 2nd byte of the entry */
---
> 			wc |= (UINT) fs->win[bc % SS(fs)] << 8;	/* Merge 2nd byte of the entry */
1753c1753
< 			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {	/* Cluster changed? */
---
> 			if ((ofs / SS(fs) & (UINT)(fs->csize - 1)) == 0) {	/* Cluster changed? */
3760c3760
< 			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
---
> 			csect = (UINT)(fp->fptr / SS(fs) & (UINT)(fs->csize - 1));	/* Sector offset in the cluster */
3862c3862
< 			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
---
> 			csect = (UINT)(fp->fptr / SS(fs)) & (UINT)(fs->csize - 1);	/* Sector offset in the cluster */
6554d6553
<
To make it easier to review next time, I'll add unchanged library code as the first commit before making other changes so that reviewers can see what changed.
As well, I had to change diskio.c in order to make sure FatFs was actually using our SD card interface (so that file should be checked)
ffconf.h was changed, but those changes are safe and easy to review (just read over what various options are set to, and ask any questions you have).
No other files were changed",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,326,2019-03-27T23:32:17Z,2019-03-30T18:04:57Z,2019-03-30T18:05:01Z,MERGED,True,23338,1,11,https://github.com/mishazharov,ELEC-63: FatFs layer,21,[],https://github.com/uw-midsun/firmware/pull/326,https://github.com/andyjiin,3,https://github.com/uw-midsun/firmware/pull/326#issuecomment-478120468,This PR adds a FAT32 filesystem layer on top of the SD card's binary reading / writing code. Most of the FatFs code was not modified except for some casts to make the compiler happy. The config was also updated. This change was tested on HW with the new sd_demo project.,"Ehh well if the compiler was complaining with the unchanged library code, it's best to not merge anything ""broken"" into master. But anyways, thanks for pointing the changes out I will take a look soon. Also what is the plan with this file system, where are we going to be using it?",True,{'THUMBS_UP': ['https://github.com/mishazharov']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,326,2019-03-27T23:32:17Z,2019-03-30T18:04:57Z,2019-03-30T18:05:01Z,MERGED,True,23338,1,11,https://github.com/mishazharov,ELEC-63: FatFs layer,21,[],https://github.com/uw-midsun/firmware/pull/326,https://github.com/mishazharov,4,https://github.com/uw-midsun/firmware/pull/326#issuecomment-478123561,This PR adds a FAT32 filesystem layer on top of the SD card's binary reading / writing code. Most of the FatFs code was not modified except for some casts to make the compiler happy. The config was also updated. This change was tested on HW with the new sd_demo project.,"Ehh well if the compiler was complaining with the unchanged library code, it's best to not merge anything ""broken"" into master

Ah I should have been more clear. Next time I will make a commit with the original files, and then make a subsequent commit with the fixes before opening the PR (to make it easier for people to see what I changed in the 3rd party files).

Also what is the plan with this file system, where are we going to be using it?

This is for telemetry, so that if we lose connection with the chase car, we can store the data for later on an SD card. Then you can just pop the SD card into a laptop and read the data.
The first part of the feature is already in (the binary driver), this just adds a filesystem on top of that. The benefits of having the file system are that we can organize data into files, and that we won't need to read raw binary data off the SD card when we want to use it.",True,{'HOORAY': ['https://github.com/andyjiin']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,327,2019-03-30T19:26:49Z,2019-05-11T18:18:15Z,2019-05-11T18:19:17Z,CLOSED,False,15,78,4,https://github.com/myh999,ELEC-71: Turn on GPS module via message,3,[],https://github.com/uw-midsun/firmware/pull/327,https://github.com/myh999,1,https://github.com/uw-midsun/firmware/pull/327,"Right now, the GPS board is designed so that a constant voltage is applied to the VCC and the ON/OFF pin. The original driver pulses the ON/OFF pin to turn it on. Thus, the GPS driver must be changed to comply with this design.
Main Changes

Removed anything responsible for controlling the VCC or ON/OFF pins
Driver now sends an NMEA message to turn on the GPS module instead of pulsing the ON/OFF pin","Right now, the GPS board is designed so that a constant voltage is applied to the VCC and the ON/OFF pin. The original driver pulses the ON/OFF pin to turn it on. Thus, the GPS driver must be changed to comply with this design.
Main Changes

Removed anything responsible for controlling the VCC or ON/OFF pins
Driver now sends an NMEA message to turn on the GPS module instead of pulsing the ON/OFF pin",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,327,2019-03-30T19:26:49Z,2019-05-11T18:18:15Z,2019-05-11T18:19:17Z,CLOSED,False,15,78,4,https://github.com/myh999,ELEC-71: Turn on GPS module via message,3,[],https://github.com/uw-midsun/firmware/pull/327,https://github.com/mishazharov,2,https://github.com/uw-midsun/firmware/pull/327#issuecomment-479688797,"Right now, the GPS board is designed so that a constant voltage is applied to the VCC and the ON/OFF pin. The original driver pulses the ON/OFF pin to turn it on. Thus, the GPS driver must be changed to comply with this design.
Main Changes

Removed anything responsible for controlling the VCC or ON/OFF pins
Driver now sends an NMEA message to turn on the GPS module instead of pulsing the ON/OFF pin",Has this been tested on hardware?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,327,2019-03-30T19:26:49Z,2019-05-11T18:18:15Z,2019-05-11T18:19:17Z,CLOSED,False,15,78,4,https://github.com/myh999,ELEC-71: Turn on GPS module via message,3,[],https://github.com/uw-midsun/firmware/pull/327,https://github.com/myh999,3,https://github.com/uw-midsun/firmware/pull/327#issuecomment-479694050,"Right now, the GPS board is designed so that a constant voltage is applied to the VCC and the ON/OFF pin. The original driver pulses the ON/OFF pin to turn it on. Thus, the GPS driver must be changed to comply with this design.
Main Changes

Removed anything responsible for controlling the VCC or ON/OFF pins
Driver now sends an NMEA message to turn on the GPS module instead of pulsing the ON/OFF pin",@mishazharov This code hasn't been tested yet. I plan to do that by tomorrow.,True,{'THUMBS_UP': ['https://github.com/mishazharov']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,327,2019-03-30T19:26:49Z,2019-05-11T18:18:15Z,2019-05-11T18:19:17Z,CLOSED,False,15,78,4,https://github.com/myh999,ELEC-71: Turn on GPS module via message,3,[],https://github.com/uw-midsun/firmware/pull/327,https://github.com/mishazharov,4,https://github.com/uw-midsun/firmware/pull/327#issuecomment-479694311,"Right now, the GPS board is designed so that a constant voltage is applied to the VCC and the ON/OFF pin. The original driver pulses the ON/OFF pin to turn it on. Thus, the GPS driver must be changed to comply with this design.
Main Changes

Removed anything responsible for controlling the VCC or ON/OFF pins
Driver now sends an NMEA message to turn on the GPS module instead of pulsing the ON/OFF pin","@myh999 Ok, cool! Please lmk when you do and I'll take another look",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,327,2019-03-30T19:26:49Z,2019-05-11T18:18:15Z,2019-05-11T18:19:17Z,CLOSED,False,15,78,4,https://github.com/myh999,ELEC-71: Turn on GPS module via message,3,[],https://github.com/uw-midsun/firmware/pull/327,https://github.com/myh999,5,https://github.com/uw-midsun/firmware/pull/327#issuecomment-480108135,"Right now, the GPS board is designed so that a constant voltage is applied to the VCC and the ON/OFF pin. The original driver pulses the ON/OFF pin to turn it on. Thus, the GPS driver must be changed to comply with this design.
Main Changes

Removed anything responsible for controlling the VCC or ON/OFF pins
Driver now sends an NMEA message to turn on the GPS module instead of pulsing the ON/OFF pin","The driver is able to send a ""turn on"" message, but it seems that it's not turning the module on. I'll try to figure out other workarounds to try to make this work.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,327,2019-03-30T19:26:49Z,2019-05-11T18:18:15Z,2019-05-11T18:19:17Z,CLOSED,False,15,78,4,https://github.com/myh999,ELEC-71: Turn on GPS module via message,3,[],https://github.com/uw-midsun/firmware/pull/327,https://github.com/mishazharov,6,https://github.com/uw-midsun/firmware/pull/327#issuecomment-480284685,"Right now, the GPS board is designed so that a constant voltage is applied to the VCC and the ON/OFF pin. The original driver pulses the ON/OFF pin to turn it on. Thus, the GPS driver must be changed to comply with this design.
Main Changes

Removed anything responsible for controlling the VCC or ON/OFF pins
Driver now sends an NMEA message to turn on the GPS module instead of pulsing the ON/OFF pin","Wait a second, is it even possible to turn the GPS on with a UART message? Quickly looking over the datasheet (https://www.linxtechnologies.com/wp/wp-content/uploads/rxm-gps-f4.pdf) it looks like the only way to power up this is to use the ON_OFF line (page 10). The other command that you are sending (PLSC,200,1*0F\r\n) is a power management command. I think it is meant to be sent after the module was turned on with the ON_OFF line, to set the power mode. The reasoning for this is that you can set it to hibernate, and then send it another message to bring it into the full power mode again (check page 8 for exact details).
Please consult with the hardware team and the datasheet to make sure that what you are doing is possible. Hopefully I'm wrong :)",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,327,2019-03-30T19:26:49Z,2019-05-11T18:18:15Z,2019-05-11T18:19:17Z,CLOSED,False,15,78,4,https://github.com/myh999,ELEC-71: Turn on GPS module via message,3,[],https://github.com/uw-midsun/firmware/pull/327,https://github.com/myh999,7,https://github.com/uw-midsun/firmware/pull/327#issuecomment-491533194,"Right now, the GPS board is designed so that a constant voltage is applied to the VCC and the ON/OFF pin. The original driver pulses the ON/OFF pin to turn it on. Thus, the GPS driver must be changed to comply with this design.
Main Changes

Removed anything responsible for controlling the VCC or ON/OFF pins
Driver now sends an NMEA message to turn on the GPS module instead of pulsing the ON/OFF pin",The GPS board has been modified such that we can now turn the GPS via pulse. Closing.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,328,2019-04-06T21:35:53Z,2019-05-17T01:18:52Z,2019-05-17T01:18:52Z,CLOSED,False,1318,3330,98,https://github.com/ashraf2047,Elec 603 driver controls pedal,9,[],https://github.com/uw-midsun/firmware/pull/328,https://github.com/ashraf2047,1,https://github.com/uw-midsun/firmware/pull/328,"This is the first of 3 PR's for the changes made to driver controls. It only includes the new pedal board project.
Some background : Driver controls has been broken into 3 new boards (pedal, steering and center console). This means that the old driver controls project has to be removed and we created 3 new firmware projects for each board. This PR contains the CAN configs and defined CAN messages for the 3 boards but only includes the pedal board project, subsequent PR's will be made, one for the steering board and another for the center console board.","This is the first of 3 PR's for the changes made to driver controls. It only includes the new pedal board project.
Some background : Driver controls has been broken into 3 new boards (pedal, steering and center console). This means that the old driver controls project has to be removed and we created 3 new firmware projects for each board. This PR contains the CAN configs and defined CAN messages for the 3 boards but only includes the pedal board project, subsequent PR's will be made, one for the steering board and another for the center console board.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,328,2019-04-06T21:35:53Z,2019-05-17T01:18:52Z,2019-05-17T01:18:52Z,CLOSED,False,1318,3330,98,https://github.com/ashraf2047,Elec 603 driver controls pedal,9,[],https://github.com/uw-midsun/firmware/pull/328,https://github.com/karlding,2,https://github.com/uw-midsun/firmware/pull/328#issuecomment-480618940,"This is the first of 3 PR's for the changes made to driver controls. It only includes the new pedal board project.
Some background : Driver controls has been broken into 3 new boards (pedal, steering and center console). This means that the old driver controls project has to be removed and we created 3 new firmware projects for each board. This PR contains the CAN configs and defined CAN messages for the 3 boards but only includes the pedal board project, subsequent PR's will be made, one for the steering board and another for the center console board.","Also to reduce noise on this diff (and people in the future bisecting history), I recommend you do the removal of the current driver controls code as a separate change. So a series of commits like:

Add new pedal project
Add new steering project
Add new center console project
Remove old driver controls project

Ultimately it's your choice, but imo cleaner history is always useful.",True,"{'THUMBS_UP': ['https://github.com/mishazharov', 'https://github.com/taipingli']}"
uw-midsun/firmware,https://github.com/uw-midsun/firmware,328,2019-04-06T21:35:53Z,2019-05-17T01:18:52Z,2019-05-17T01:18:52Z,CLOSED,False,1318,3330,98,https://github.com/ashraf2047,Elec 603 driver controls pedal,9,[],https://github.com/uw-midsun/firmware/pull/328,https://github.com/karlding,3,https://github.com/uw-midsun/firmware/pull/328#issuecomment-481079485,"This is the first of 3 PR's for the changes made to driver controls. It only includes the new pedal board project.
Some background : Driver controls has been broken into 3 new boards (pedal, steering and center console). This means that the old driver controls project has to be removed and we created 3 new firmware projects for each board. This PR contains the CAN configs and defined CAN messages for the 3 boards but only includes the pedal board project, subsequent PR's will be made, one for the steering board and another for the center console board.","Can you explain how this fits into the original proposed architecture for the Driver Controls split? Maybe I just don't understand how your code works, but it seems like you're introducing a lot of complexity that makes it difficult to debug and reason about program flow. Can you elaborate how the control flow for this works, and its interaction with the Steering and Center Console boards?
I was under the impression that 2 of the boards would be dumb and purely provide input (via a periodic timer sending state over CAN), and all the logic would be in 1 of the boards, which you designate as a ""master"". This way you don't have to worry about synchronizing 3 sets of FSMs across 3 different boards, which appears to be what this is doing. Why was the decision made to implement part of the FSM logic here, instead of consolidating it on a single board? Or is the original plan no longer the case? Is there an architectural issue with the original plan that necessitated this change?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,328,2019-04-06T21:35:53Z,2019-05-17T01:18:52Z,2019-05-17T01:18:52Z,CLOSED,False,1318,3330,98,https://github.com/ashraf2047,Elec 603 driver controls pedal,9,[],https://github.com/uw-midsun/firmware/pull/328,https://github.com/ashraf2047,4,https://github.com/uw-midsun/firmware/pull/328#issuecomment-481327801,"This is the first of 3 PR's for the changes made to driver controls. It only includes the new pedal board project.
Some background : Driver controls has been broken into 3 new boards (pedal, steering and center console). This means that the old driver controls project has to be removed and we created 3 new firmware projects for each board. This PR contains the CAN configs and defined CAN messages for the 3 boards but only includes the pedal board project, subsequent PR's will be made, one for the steering board and another for the center console board.","@karlding  The idea of this is that the master board (center console) packs the drive output message into a CAN message based on the inputs it receives from the other 2 boards.  We currently synchronize the FSM's across the three boards and although this works, it does make the code more complex to understand. I will work on making 2 of the boards purely provide input and just have the master board handle all the logic.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,328,2019-04-06T21:35:53Z,2019-05-17T01:18:52Z,2019-05-17T01:18:52Z,CLOSED,False,1318,3330,98,https://github.com/ashraf2047,Elec 603 driver controls pedal,9,[],https://github.com/uw-midsun/firmware/pull/328,https://github.com/taipingli,5,https://github.com/uw-midsun/firmware/pull/328#issuecomment-481328862,"This is the first of 3 PR's for the changes made to driver controls. It only includes the new pedal board project.
Some background : Driver controls has been broken into 3 new boards (pedal, steering and center console). This means that the old driver controls project has to be removed and we created 3 new firmware projects for each board. This PR contains the CAN configs and defined CAN messages for the 3 boards but only includes the pedal board project, subsequent PR's will be made, one for the steering board and another for the center console board.","@karlding The idea of this is that the master board (center console) packs the drive output message into a CAN message based on the inputs it receives from the other 2 boards. We currently synchronize the FSM's across the three boards and although this works, it does make the code more complex to understand. I will work on making 2 of the boards purely provide input and just have the master board handle all the logic.

Could you explain why the center console is designated as the master? I'm just thinking in terms of things to do, it seems to do the most already compared to pedal or steering which just have ADC/GPIOs. Also have you guys tested the UART connection going to the Pi yet?",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,328,2019-04-06T21:35:53Z,2019-05-17T01:18:52Z,2019-05-17T01:18:52Z,CLOSED,False,1318,3330,98,https://github.com/ashraf2047,Elec 603 driver controls pedal,9,[],https://github.com/uw-midsun/firmware/pull/328,https://github.com/ashraf2047,6,https://github.com/uw-midsun/firmware/pull/328#issuecomment-481333923,"This is the first of 3 PR's for the changes made to driver controls. It only includes the new pedal board project.
Some background : Driver controls has been broken into 3 new boards (pedal, steering and center console). This means that the old driver controls project has to be removed and we created 3 new firmware projects for each board. This PR contains the CAN configs and defined CAN messages for the 3 boards but only includes the pedal board project, subsequent PR's will be made, one for the steering board and another for the center console board.","The decision of the master board is somewhat arbitrary because they all have the ability to communicate over CAN. If we want to keep 2 of the boards ""dumb"" and center console is already doing work, then it might be better to keep it as the master.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,328,2019-04-06T21:35:53Z,2019-05-17T01:18:52Z,2019-05-17T01:18:52Z,CLOSED,False,1318,3330,98,https://github.com/ashraf2047,Elec 603 driver controls pedal,9,[],https://github.com/uw-midsun/firmware/pull/328,https://github.com/taipingli,7,https://github.com/uw-midsun/firmware/pull/328#issuecomment-481335438,"This is the first of 3 PR's for the changes made to driver controls. It only includes the new pedal board project.
Some background : Driver controls has been broken into 3 new boards (pedal, steering and center console). This means that the old driver controls project has to be removed and we created 3 new firmware projects for each board. This PR contains the CAN configs and defined CAN messages for the 3 boards but only includes the pedal board project, subsequent PR's will be made, one for the steering board and another for the center console board.","Sure, my main concern is that center console is already processing CAN for driver display/potentially telemetry, dealing with all the buttons etc, while the other boards aren't really doing much.
It should be fine as long as you guys tried to make sure that even with a decent CAN bus load, we don't run into any issues with the center console processing incoming messages for the Pi + acting as the master for driver controls + dealing with button inputs.
It might be hard to quantify bus load based on our current architecture of most messages only being sent when an event occurs instead of periodically, but using whatever we have now + a margin for new messages from telemetry/sensors with a good safety factor should be fine?",True,{'EYES': ['https://github.com/choeuna']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,328,2019-04-06T21:35:53Z,2019-05-17T01:18:52Z,2019-05-17T01:18:52Z,CLOSED,False,1318,3330,98,https://github.com/ashraf2047,Elec 603 driver controls pedal,9,[],https://github.com/uw-midsun/firmware/pull/328,https://github.com/ashraf2047,8,https://github.com/uw-midsun/firmware/pull/328#issuecomment-481367200,"This is the first of 3 PR's for the changes made to driver controls. It only includes the new pedal board project.
Some background : Driver controls has been broken into 3 new boards (pedal, steering and center console). This means that the old driver controls project has to be removed and we created 3 new firmware projects for each board. This PR contains the CAN configs and defined CAN messages for the 3 boards but only includes the pedal board project, subsequent PR's will be made, one for the steering board and another for the center console board.","okay I see, if we observe that there are going to be any issues with the bus load, we will assign either steering or pedal to be the master board.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,329,2019-04-09T02:05:16Z,2019-05-26T17:32:48Z,2019-06-03T14:13:59Z,MERGED,True,378,2,9,https://github.com/mishazharov,ELEC-314: PWM input driver,53,[],https://github.com/uw-midsun/firmware/pull/329,https://github.com/mishazharov,1,https://github.com/uw-midsun/firmware/pull/329,"Hey guys, I finished up the PMW driver. Tested on a couple of timers and channels using the discovery board. Will need to be tested more in the bay with the DMM / signal generator for additional accuracy.
Known issues: The callback does not fire if the Duty Cycle value is 0, this is because when the DC value is 0, there is no rising edge to trigger the interrupt. This is documented so users are expected to work around it by calling the DC getter.
For reference to make the reviewing easier:
https://en.wikipedia.org/wiki/Duty_cycle","Hey guys, I finished up the PMW driver. Tested on a couple of timers and channels using the discovery board. Will need to be tested more in the bay with the DMM / signal generator for additional accuracy.
Known issues: The callback does not fire if the Duty Cycle value is 0, this is because when the DC value is 0, there is no rising edge to trigger the interrupt. This is documented so users are expected to work around it by calling the DC getter.
For reference to make the reviewing easier:
https://en.wikipedia.org/wiki/Duty_cycle",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,329,2019-04-09T02:05:16Z,2019-05-26T17:32:48Z,2019-06-03T14:13:59Z,MERGED,True,378,2,9,https://github.com/mishazharov,ELEC-314: PWM input driver,53,[],https://github.com/uw-midsun/firmware/pull/329,https://github.com/andyjiin,2,https://github.com/uw-midsun/firmware/pull/329#issuecomment-493685910,"Hey guys, I finished up the PMW driver. Tested on a couple of timers and channels using the discovery board. Will need to be tested more in the bay with the DMM / signal generator for additional accuracy.
Known issues: The callback does not fire if the Duty Cycle value is 0, this is because when the DC value is 0, there is no rising edge to trigger the interrupt. This is documented so users are expected to work around it by calling the DC getter.
For reference to make the reviewing easier:
https://en.wikipedia.org/wiki/Duty_cycle","There appears to be a general lack of comments in the source files, I'd appreciate it if we add some 😃",True,{'THUMBS_UP': ['https://github.com/mishazharov']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,329,2019-04-09T02:05:16Z,2019-05-26T17:32:48Z,2019-06-03T14:13:59Z,MERGED,True,378,2,9,https://github.com/mishazharov,ELEC-314: PWM input driver,53,[],https://github.com/uw-midsun/firmware/pull/329,https://github.com/mishazharov,3,https://github.com/uw-midsun/firmware/pull/329#issuecomment-493780926,"Hey guys, I finished up the PMW driver. Tested on a couple of timers and channels using the discovery board. Will need to be tested more in the bay with the DMM / signal generator for additional accuracy.
Known issues: The callback does not fire if the Duty Cycle value is 0, this is because when the DC value is 0, there is no rising edge to trigger the interrupt. This is documented so users are expected to work around it by calling the DC getter.
For reference to make the reviewing easier:
https://en.wikipedia.org/wiki/Duty_cycle",I tested this with a signal generator and added comments,True,{'HOORAY': ['https://github.com/andyjiin']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,329,2019-04-09T02:05:16Z,2019-05-26T17:32:48Z,2019-06-03T14:13:59Z,MERGED,True,378,2,9,https://github.com/mishazharov,ELEC-314: PWM input driver,53,[],https://github.com/uw-midsun/firmware/pull/329,https://github.com/taipingli,4,https://github.com/uw-midsun/firmware/pull/329#issuecomment-495271909,"Hey guys, I finished up the PMW driver. Tested on a couple of timers and channels using the discovery board. Will need to be tested more in the bay with the DMM / signal generator for additional accuracy.
Known issues: The callback does not fire if the Duty Cycle value is 0, this is because when the DC value is 0, there is no rising edge to trigger the interrupt. This is documented so users are expected to work around it by calling the DC getter.
For reference to make the reviewing easier:
https://en.wikipedia.org/wiki/Duty_cycle","Please test this on hardware and characterize the PWM input.
It would be helpful if you also update the alternate pins document on Confluence to include what pins can be used as PWM in and PWM out.",True,{'THUMBS_UP': ['https://github.com/mishazharov']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,329,2019-04-09T02:05:16Z,2019-05-26T17:32:48Z,2019-06-03T14:13:59Z,MERGED,True,378,2,9,https://github.com/mishazharov,ELEC-314: PWM input driver,53,[],https://github.com/uw-midsun/firmware/pull/329,https://github.com/mishazharov,5,https://github.com/uw-midsun/firmware/pull/329#issuecomment-495939011,"Hey guys, I finished up the PMW driver. Tested on a couple of timers and channels using the discovery board. Will need to be tested more in the bay with the DMM / signal generator for additional accuracy.
Known issues: The callback does not fire if the Duty Cycle value is 0, this is because when the DC value is 0, there is no rising edge to trigger the interrupt. This is documented so users are expected to work around it by calling the DC getter.
For reference to make the reviewing easier:
https://en.wikipedia.org/wiki/Duty_cycle","@taipingli Ok, I've just tested this on hardware and documented my findings here: https://uwmidsun.atlassian.net/wiki/spaces/ELEC/pages/805568556/PWM+Input+driver+test",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,330,2019-04-13T22:17:54Z,2019-05-11T19:18:13Z,2019-05-11T19:18:19Z,MERGED,True,3,0,1,https://github.com/choeuna,ELEC-547: Fix race in total battery pack telemetry reporting,2,[],https://github.com/uw-midsun/firmware/pull/330,https://github.com/choeuna,1,https://github.com/uw-midsun/firmware/pull/330,"Periodic timer would interrupt summation of voltages leading to incorrect reports.
When interrupted during memory copy, old voltages would be reported. Added critical
section to prevent this.","Periodic timer would interrupt summation of voltages leading to incorrect reports.
When interrupted during memory copy, old voltages would be reported. Added critical
section to prevent this.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,330,2019-04-13T22:17:54Z,2019-05-11T19:18:13Z,2019-05-11T19:18:19Z,MERGED,True,3,0,1,https://github.com/choeuna,ELEC-547: Fix race in total battery pack telemetry reporting,2,[],https://github.com/uw-midsun/firmware/pull/330,https://github.com/mishazharov,2,https://github.com/uw-midsun/firmware/pull/330#issuecomment-483043303,"Periodic timer would interrupt summation of voltages leading to incorrect reports.
When interrupted during memory copy, old voltages would be reported. Added critical
section to prevent this.",Was this tested to make sure the issue went away?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,331,2019-04-25T01:04:53Z,2019-04-25T19:58:35Z,2019-04-25T19:58:36Z,MERGED,True,25,25,6,https://github.com/mishazharov,ELEC-618: Fixing spi behaviour,4,[],https://github.com/uw-midsun/firmware/pull/331,https://github.com/mishazharov,1,https://github.com/uw-midsun/firmware/pull/331,"Unfortunately #322 broke existing SPI behaviour. The spi_tx method was not calling SPI_ReceiveData8, but in order to maintain existing functionality, it should have. This results in the next rx call returning ""stale"" data from the previous spi_tx call*.
This PR also fixed code in the SD card driver which relied on the broken functionality.
This PR moved the sd_demo project to its own test as well
Edit: * or the overrun flag was set","Unfortunately #322 broke existing SPI behaviour. The spi_tx method was not calling SPI_ReceiveData8, but in order to maintain existing functionality, it should have. This results in the next rx call returning ""stale"" data from the previous spi_tx call*.
This PR also fixed code in the SD card driver which relied on the broken functionality.
This PR moved the sd_demo project to its own test as well
Edit: * or the overrun flag was set",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,331,2019-04-25T01:04:53Z,2019-04-25T19:58:35Z,2019-04-25T19:58:36Z,MERGED,True,25,25,6,https://github.com/mishazharov,ELEC-618: Fixing spi behaviour,4,[],https://github.com/uw-midsun/firmware/pull/331,https://github.com/andyjiin,2,https://github.com/uw-midsun/firmware/pull/331#issuecomment-486692538,"Unfortunately #322 broke existing SPI behaviour. The spi_tx method was not calling SPI_ReceiveData8, but in order to maintain existing functionality, it should have. This results in the next rx call returning ""stale"" data from the previous spi_tx call*.
This PR also fixed code in the SD card driver which relied on the broken functionality.
This PR moved the sd_demo project to its own test as well
Edit: * or the overrun flag was set",I'm kinda confused on the changes in the SD card driver. How was it even working before?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,331,2019-04-25T01:04:53Z,2019-04-25T19:58:35Z,2019-04-25T19:58:36Z,MERGED,True,25,25,6,https://github.com/mishazharov,ELEC-618: Fixing spi behaviour,4,[],https://github.com/uw-midsun/firmware/pull/331,https://github.com/mishazharov,3,https://github.com/uw-midsun/firmware/pull/331#issuecomment-486723549,"Unfortunately #322 broke existing SPI behaviour. The spi_tx method was not calling SPI_ReceiveData8, but in order to maintain existing functionality, it should have. This results in the next rx call returning ""stale"" data from the previous spi_tx call*.
This PR also fixed code in the SD card driver which relied on the broken functionality.
This PR moved the sd_demo project to its own test as well
Edit: * or the overrun flag was set","@andyjiin Basically, when spi_tx sent data in the SD driver, spi_rx would be called immediately after to consume the necessary bytes, and clear the appropriate flags. This functionality was not broken, and was accounted for.
What broke was the spi_exchange function, which the SD card driver did not use.
In order to fix the spi_exchange function, modifications needed to be made to the spi_tx function (I needed to add a SPI_ReceiveData8 call in order to consume the rx bytes). The SD card driver did not expect this to happen, so I changed it to accommodate the spi_tx fix by removing calls to spi_rx after the relevant spi_tx calls.

Interestingly, not every spi_tx call would be followed by spi_rx, this is a bug, but probably did not cause issues because another spi_rx call would clear any overrun flags",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,331,2019-04-25T01:04:53Z,2019-04-25T19:58:35Z,2019-04-25T19:58:36Z,MERGED,True,25,25,6,https://github.com/mishazharov,ELEC-618: Fixing spi behaviour,4,[],https://github.com/uw-midsun/firmware/pull/331,https://github.com/andyjiin,4,https://github.com/uw-midsun/firmware/pull/331#issuecomment-486731775,"Unfortunately #322 broke existing SPI behaviour. The spi_tx method was not calling SPI_ReceiveData8, but in order to maintain existing functionality, it should have. This results in the next rx call returning ""stale"" data from the previous spi_tx call*.
This PR also fixed code in the SD card driver which relied on the broken functionality.
This PR moved the sd_demo project to its own test as well
Edit: * or the overrun flag was set","@mishazharov Okay I see, honestly looking back at our SPI driver, the spi_rx is a little confusing. The fact that we can change the placeholder makes it more than just a rx call. And the fact that spi_tx just discards what's read back but spi_rx allows us to change what's being written is not very consistent imo 🤔",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,331,2019-04-25T01:04:53Z,2019-04-25T19:58:35Z,2019-04-25T19:58:36Z,MERGED,True,25,25,6,https://github.com/mishazharov,ELEC-618: Fixing spi behaviour,4,[],https://github.com/uw-midsun/firmware/pull/331,https://github.com/mishazharov,5,https://github.com/uw-midsun/firmware/pull/331#issuecomment-486765392,"Unfortunately #322 broke existing SPI behaviour. The spi_tx method was not calling SPI_ReceiveData8, but in order to maintain existing functionality, it should have. This results in the next rx call returning ""stale"" data from the previous spi_tx call*.
This PR also fixed code in the SD card driver which relied on the broken functionality.
This PR moved the sd_demo project to its own test as well
Edit: * or the overrun flag was set","@andyjiin That's true, but I don't really see a way around that. In order to get a byte from the slave device, we must first send a byte. And the user should be able to configure what is sent because different application will want different placeholders. Maybe I can rename the method?
But fundamentally:
spi_rx is intended to be used to receive data, so it has a buffer that it will store the rx'd result in. The fact that you can send a placeholder byte is just a side effect (which is actually useful if you want to send and receive one byte). But you cannot specify a buffer that will be sent. It must be a constant value.
On the other hand, spi_tx is meant to transmit data, therefore there is a tx buffer that it will use as the source of data to transmit. When using this method, the user shouldn't care what the rx'd data is. It's assumed that it's just placeholder data.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,331,2019-04-25T01:04:53Z,2019-04-25T19:58:35Z,2019-04-25T19:58:36Z,MERGED,True,25,25,6,https://github.com/mishazharov,ELEC-618: Fixing spi behaviour,4,[],https://github.com/uw-midsun/firmware/pull/331,https://github.com/mishazharov,6,https://github.com/uw-midsun/firmware/pull/331#issuecomment-486814816,"Unfortunately #322 broke existing SPI behaviour. The spi_tx method was not calling SPI_ReceiveData8, but in order to maintain existing functionality, it should have. This results in the next rx call returning ""stale"" data from the previous spi_tx call*.
This PR also fixed code in the SD card driver which relied on the broken functionality.
This PR moved the sd_demo project to its own test as well
Edit: * or the overrun flag was set","Damn, looks like pushing more commits automatically dismisses approvals. I guess that makes sense though",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,332,2019-05-11T18:45:36Z,2019-06-28T01:32:27Z,2019-06-28T01:47:19Z,MERGED,True,71,65,4,https://github.com/myh999,ELEC-71: Remove Redundant Code from GPS Driver,16,[],https://github.com/uw-midsun/firmware/pull/332,https://github.com/myh999,1,https://github.com/uw-midsun/firmware/pull/332,"The GPS driver uses a pin to control the power input of the GPS module. Since the board provides the module with a constant voltage supply, there is no need to control the power input.","The GPS driver uses a pin to control the power input of the GPS module. Since the board provides the module with a constant voltage supply, there is no need to control the power input.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,332,2019-05-11T18:45:36Z,2019-06-28T01:32:27Z,2019-06-28T01:47:19Z,MERGED,True,71,65,4,https://github.com/myh999,ELEC-71: Remove Redundant Code from GPS Driver,16,[],https://github.com/uw-midsun/firmware/pull/332,https://github.com/mishazharov,2,https://github.com/uw-midsun/firmware/pull/332#issuecomment-494585239,"The GPS driver uses a pin to control the power input of the GPS module. Since the board provides the module with a constant voltage supply, there is no need to control the power input.",Has this been tested already?,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,332,2019-05-11T18:45:36Z,2019-06-28T01:32:27Z,2019-06-28T01:47:19Z,MERGED,True,71,65,4,https://github.com/myh999,ELEC-71: Remove Redundant Code from GPS Driver,16,[],https://github.com/uw-midsun/firmware/pull/332,https://github.com/myh999,3,https://github.com/uw-midsun/firmware/pull/332#issuecomment-494625807,"The GPS driver uses a pin to control the power input of the GPS module. Since the board provides the module with a constant voltage supply, there is no need to control the power input.","The module sent out the message “$PLSR,OkToSend*12” periodically when it was flashed for the first time. Not too sure what it means other than it being a power-related issue.  It stopped sending out anything after subsequent flashes. I will continue to investigate Wednesday evening.",True,{'THUMBS_UP': ['https://github.com/mishazharov']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,332,2019-05-11T18:45:36Z,2019-06-28T01:32:27Z,2019-06-28T01:47:19Z,MERGED,True,71,65,4,https://github.com/myh999,ELEC-71: Remove Redundant Code from GPS Driver,16,[],https://github.com/uw-midsun/firmware/pull/332,https://github.com/myh999,4,https://github.com/uw-midsun/firmware/pull/332#issuecomment-502390447,"The GPS driver uses a pin to control the power input of the GPS module. Since the board provides the module with a constant voltage supply, there is no need to control the power input.","After replacing the power supply resistor on the board (from 100 ohms to 10 ohms), the driver is now working properly. I've also added an additional change that checks if the module is already turned on, as another pulse to the module in peak mode would send it to hibernate mode.",True,{'THUMBS_UP': ['https://github.com/mishazharov']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,332,2019-05-11T18:45:36Z,2019-06-28T01:32:27Z,2019-06-28T01:47:19Z,MERGED,True,71,65,4,https://github.com/myh999,ELEC-71: Remove Redundant Code from GPS Driver,16,[],https://github.com/uw-midsun/firmware/pull/332,https://github.com/mishazharov,5,https://github.com/uw-midsun/firmware/pull/332#issuecomment-502391618,"The GPS driver uses a pin to control the power input of the GPS module. Since the board provides the module with a constant voltage supply, there is no need to control the power input.","LGTM, just catch up to master and I'll approve",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,332,2019-05-11T18:45:36Z,2019-06-28T01:32:27Z,2019-06-28T01:47:19Z,MERGED,True,71,65,4,https://github.com/myh999,ELEC-71: Remove Redundant Code from GPS Driver,16,[],https://github.com/uw-midsun/firmware/pull/332,https://github.com/menalabib,6,https://github.com/uw-midsun/firmware/pull/332#issuecomment-504232325,"The GPS driver uses a pin to control the power input of the GPS module. Since the board provides the module with a constant voltage supply, there is no need to control the power input.",This is unacceptable... come see me,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,332,2019-05-11T18:45:36Z,2019-06-28T01:32:27Z,2019-06-28T01:47:19Z,MERGED,True,71,65,4,https://github.com/myh999,ELEC-71: Remove Redundant Code from GPS Driver,16,[],https://github.com/uw-midsun/firmware/pull/332,https://github.com/GarlandZhang,7,https://github.com/uw-midsun/firmware/pull/332#issuecomment-504252059,"The GPS driver uses a pin to control the power input of the GPS module. Since the board provides the module with a constant voltage supply, there is no need to control the power input.","I know this PR is already closed but I recommend that if you plan on removing some redundant code, then make sure your PR is focused on just that. I notice a lot of changes to the code (seems more like a refactoring) that is not just removing unused code. Consider breaking it up into separate PRs and run some tests to ensure there are no behavioral changes.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,332,2019-05-11T18:45:36Z,2019-06-28T01:32:27Z,2019-06-28T01:47:19Z,MERGED,True,71,65,4,https://github.com/myh999,ELEC-71: Remove Redundant Code from GPS Driver,16,[],https://github.com/uw-midsun/firmware/pull/332,https://github.com/GarlandZhang,8,https://github.com/uw-midsun/firmware/pull/332#issuecomment-506569608,"The GPS driver uses a pin to control the power input of the GPS module. Since the board provides the module with a constant voltage supply, there is no need to control the power input.","hey I'm assuming this PR was good to be merged in. For a future reminder, it would be helpful to anyone else watching this PR to see what you and Mena discussed IRL/Slack so everyone is in the loop.
Also consider squashing your commits into one so it doesn't clutter the git logs.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,333,2019-05-15T03:32:26Z,2019-05-18T15:24:37Z,2019-05-18T15:26:08Z,MERGED,True,299,0,12,https://github.com/andyjiin,ELEC-622: Firmware Tutorial On-board Module 1,9,[],https://github.com/uw-midsun/firmware/pull/333,https://github.com/andyjiin,1,https://github.com/uw-midsun/firmware/pull/333,"Module 1 of 2 for the Firmware On-boarding Tutorial (written for the HW Tutorial Board)
Includes:

Push buttons to control LEDs (example code and exercises)
ADC to log analog data from potentiometer (not implemented due to hardware issue)
Unit test and mock function examples","Module 1 of 2 for the Firmware On-boarding Tutorial (written for the HW Tutorial Board)
Includes:

Push buttons to control LEDs (example code and exercises)
ADC to log analog data from potentiometer (not implemented due to hardware issue)
Unit test and mock function examples",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,334,2019-05-15T19:10:29Z,,2019-06-08T22:08:27Z,OPEN,False,365,177,12,https://github.com/anikser,WIP: ELEC-604: Final solar sense firmware,6,[],https://github.com/uw-midsun/firmware/pull/334,https://github.com/anikser,1,https://github.com/uw-midsun/firmware/pull/334,"Gracefully handle failed init, stale data, calculate temp","Gracefully handle failed init, stale data, calculate temp",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,335,2019-05-17T01:56:00Z,2019-07-10T19:58:05Z,2019-07-10T19:58:05Z,CLOSED,False,7269,195,120,https://github.com/ashraf2047,WIP: Elec 580 new driver controls,141,[],https://github.com/uw-midsun/firmware/pull/335,https://github.com/ashraf2047,1,https://github.com/uw-midsun/firmware/pull/335,"@thomaskidd and I made a lot of structural changes to driver controls and as a result, I closed the old PR. I decided to include all 3 new driver controls projects into this PR to provide more context as to how each board communicates with each other and hopefully make it easier to review. Most of the changes in this PR include moving files from the old project into the 3 new folders, which is why there are a lot of lines added.
I also kept the old driver controls project and will remove it when all the comments/concerns are resolved (some changes had to be made in order to get it to build).
Also note that I copied over the codegen output files from https://github.com/uw-midsun/codegen-tooling/pull/35/files temporarily until it is merged in.
This is an overview of the new Driver Controls logic   .

There are three new separate boards (steering, centre console and pedal)
The pedal board has one functionality ; it sends out data about the throttle and mech brake
The steering board sends out an event when a digital/analog input was pressed
The Center console board acts as the master. It packs the messages it receives from the pedal and steering boards along with  its own data (direction) and sends it over CAN","@thomaskidd and I made a lot of structural changes to driver controls and as a result, I closed the old PR. I decided to include all 3 new driver controls projects into this PR to provide more context as to how each board communicates with each other and hopefully make it easier to review. Most of the changes in this PR include moving files from the old project into the 3 new folders, which is why there are a lot of lines added.
I also kept the old driver controls project and will remove it when all the comments/concerns are resolved (some changes had to be made in order to get it to build).
Also note that I copied over the codegen output files from https://github.com/uw-midsun/codegen-tooling/pull/35/files temporarily until it is merged in.
This is an overview of the new Driver Controls logic   .

There are three new separate boards (steering, centre console and pedal)
The pedal board has one functionality ; it sends out data about the throttle and mech brake
The steering board sends out an event when a digital/analog input was pressed
The Center console board acts as the master. It packs the messages it receives from the pedal and steering boards along with  its own data (direction) and sends it over CAN",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,335,2019-05-17T01:56:00Z,2019-07-10T19:58:05Z,2019-07-10T19:58:05Z,CLOSED,False,7269,195,120,https://github.com/ashraf2047,WIP: Elec 580 new driver controls,141,[],https://github.com/uw-midsun/firmware/pull/335,https://github.com/karlding,2,https://github.com/uw-midsun/firmware/pull/335#issuecomment-493350396,"@thomaskidd and I made a lot of structural changes to driver controls and as a result, I closed the old PR. I decided to include all 3 new driver controls projects into this PR to provide more context as to how each board communicates with each other and hopefully make it easier to review. Most of the changes in this PR include moving files from the old project into the 3 new folders, which is why there are a lot of lines added.
I also kept the old driver controls project and will remove it when all the comments/concerns are resolved (some changes had to be made in order to get it to build).
Also note that I copied over the codegen output files from https://github.com/uw-midsun/codegen-tooling/pull/35/files temporarily until it is merged in.
This is an overview of the new Driver Controls logic   .

There are three new separate boards (steering, centre console and pedal)
The pedal board has one functionality ; it sends out data about the throttle and mech brake
The steering board sends out an event when a digital/analog input was pressed
The Center console board acts as the master. It packs the messages it receives from the pedal and steering boards along with  its own data (direction) and sends it over CAN","I am fine having this for reference, but when you plan on actually getting this reviewed please at least split into 3—one for each project. That way people in the future looking at your review will also have an easier time understanding why choices were made.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,336,2019-05-31T18:57:51Z,,2019-06-01T21:54:37Z,OPEN,False,204,90,9,https://github.com/andyjiin,WIP: ELEC 625: Chaos Power Distribution Rev 3,14,[],https://github.com/uw-midsun/firmware/pull/336,https://github.com/andyjiin,1,https://github.com/uw-midsun/firmware/pull/336,"Rev 3 testing of Power Distribution

TODO:

Remove debug statements
Test on car","Rev 3 testing of Power Distribution

TODO:

Remove debug statements
Test on car",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,337,2019-05-31T19:42:28Z,2019-05-31T20:21:23Z,2019-05-31T20:21:27Z,MERGED,True,1,4,1,https://github.com/andyjiin,ELEC 634: Fix ADC not completing conversions,2,[],https://github.com/uw-midsun/firmware/pull/337,https://github.com/andyjiin,1,https://github.com/uw-midsun/firmware/pull/337,"ADC is not properly registering its completion of conversions since the introduction of the conv_complete boolean.

Bench tested on Power Distribution Rev 3
@g-jessmuir tested on Hardware Tutorial Board","ADC is not properly registering its completion of conversions since the introduction of the conv_complete boolean.

Bench tested on Power Distribution Rev 3
@g-jessmuir tested on Hardware Tutorial Board",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,338,2019-06-02T21:06:29Z,2019-06-04T00:03:06Z,2019-06-04T02:03:28Z,MERGED,True,94,69,14,https://github.com/karlding,ELEC-620: Roll codegen forward,2,[],https://github.com/uw-midsun/firmware/pull/338,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/338,Pull latest codegen changes for Driver Controls.,Pull latest codegen changes for Driver Controls.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,339,2019-06-04T06:45:25Z,2019-06-05T20:22:08Z,2019-06-05T20:22:11Z,MERGED,True,460,0,8,https://github.com/karlding,ELEC-580: Add Center Console IO expander and pin config,1,[],https://github.com/uw-midsun/firmware/pull/339,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/339,"Add the GPIO Expander driver and the pin mapping configuration for the
Center Console board.
Also adds a skeleton layout for the Center Console.","Add the GPIO Expander driver and the pin mapping configuration for the
Center Console board.
Also adds a skeleton layout for the Center Console.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,340,2019-06-05T22:50:20Z,2019-06-11T20:30:08Z,2019-06-11T20:30:15Z,MERGED,True,842,3,14,https://github.com/karlding,ELEC-580: Add Center Console button LED and FSMs,4,[],https://github.com/uw-midsun/firmware/pull/340,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/340,"Adds logic to drive the Center Console button LEDs and the associated
FSMs. This introduces the concept of a regular Button, which simply
has an on/off state, as well as a Radio Button group, in which only
one from the group can be active at a time.","Adds logic to drive the Center Console button LEDs and the associated
FSMs. This introduces the concept of a regular Button, which simply
has an on/off state, as well as a Radio Button group, in which only
one from the group can be active at a time.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,341,2019-06-07T21:22:19Z,2019-07-08T03:59:01Z,2019-07-08T03:59:09Z,MERGED,True,623,0,8,https://github.com/karlding,ELEC-580: Add Steering control stalk code,5,[],https://github.com/uw-midsun/firmware/pull/341,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/341,"To speed up the merge process, I'm going to be pipelining PRs instead of only having 1 active PR at a time. I'll take care of any conflicts as they arise.
Add support for interfacing with the Audi A6 control stalk, in addition
to the necessary CAN events.","To speed up the merge process, I'm going to be pipelining PRs instead of only having 1 active PR at a time. I'll take care of any conflicts as they arise.
Add support for interfacing with the Audi A6 control stalk, in addition
to the necessary CAN events.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,341,2019-06-07T21:22:19Z,2019-07-08T03:59:01Z,2019-07-08T03:59:09Z,MERGED,True,623,0,8,https://github.com/karlding,ELEC-580: Add Steering control stalk code,5,[],https://github.com/uw-midsun/firmware/pull/341,https://github.com/karlding,2,https://github.com/uw-midsun/firmware/pull/341#issuecomment-500066638,"To speed up the merge process, I'm going to be pipelining PRs instead of only having 1 active PR at a time. I'll take care of any conflicts as they arise.
Add support for interfacing with the Audi A6 control stalk, in addition
to the necessary CAN events.","smh I'm surprised that this conflict between our clang format and lint rules only came up now..
The solution is probably to disable the lint rule, since it should be handled automatically by the format target",True,{'HOORAY': ['https://github.com/andyjiin']}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,342,2019-06-07T21:53:04Z,2019-06-10T01:24:23Z,2019-06-10T01:24:26Z,MERGED,True,562,0,13,https://github.com/karlding,ELEC-580: Add Pedal FSMs and project skeleton,4,[],https://github.com/uw-midsun/firmware/pull/342,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/342,"Add the Pedal FSMs that do not provide Drive Output. These FSMs
are only dependent on input from Driver Controls: Center Console and
Driver Controls: Steering.
An Event Arbiter is introduced in order to block FSMs from accepting
input in certain states. Technically, this could be flattend into a
giant FSM by computing the Transitive Closure, but it probably makes it
a little easier to reason about and modify this way. This implementation
is pretty much taken from the old Driver Controls code.","Add the Pedal FSMs that do not provide Drive Output. These FSMs
are only dependent on input from Driver Controls: Center Console and
Driver Controls: Steering.
An Event Arbiter is introduced in order to block FSMs from accepting
input in certain states. Technically, this could be flattend into a
giant FSM by computing the Transitive Closure, but it probably makes it
a little easier to reason about and modify this way. This implementation
is pretty much taken from the old Driver Controls code.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,343,2019-06-08T07:11:46Z,2019-06-09T18:26:16Z,2019-06-09T18:26:26Z,MERGED,True,0,18,1,https://github.com/karlding,ELEC-636: Remove redundant linter case,1,[],https://github.com/uw-midsun/firmware/pull/343,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/343,"The whitespace/braces case is pretty much handled implicitly by our
clang-format rules. In certain cases, this clashes with the formatting
that clang-format provides, resulting in no way to pass CI.
As a fix, we remove this check from our cpplint.py fork, as we check
that clang-format has been applied on each PR anyways.","The whitespace/braces case is pretty much handled implicitly by our
clang-format rules. In certain cases, this clashes with the formatting
that clang-format provides, resulting in no way to pass CI.
As a fix, we remove this check from our cpplint.py fork, as we check
that clang-format has been applied on each PR anyways.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,344,2019-06-08T22:42:30Z,2020-10-30T01:05:46Z,2020-10-30T01:05:46Z,CLOSED,False,227,0,6,https://github.com/jessm,ELEC 631: Added initial code for IMU driver,4,[],https://github.com/uw-midsun/firmware/pull/344,https://github.com/jessm,1,https://github.com/uw-midsun/firmware/pull/344,Initial code. Untested due to a lack of hardware. No CAN functionality yet.,Initial code. Untested due to a lack of hardware. No CAN functionality yet.,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,344,2019-06-08T22:42:30Z,2020-10-30T01:05:46Z,2020-10-30T01:05:46Z,CLOSED,False,227,0,6,https://github.com/jessm,ELEC 631: Added initial code for IMU driver,4,[],https://github.com/uw-midsun/firmware/pull/344,https://github.com/andyjiin,2,https://github.com/uw-midsun/firmware/pull/344#issuecomment-500232509,Initial code. Untested due to a lack of hardware. No CAN functionality yet.,"Also you want to rename your PR, to follow our standards. So we usually start it off with the JIRA ticket (e.g ELEC-XXX: Your Info Here)",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,345,2019-06-11T00:32:12Z,2019-07-08T04:59:30Z,2019-07-08T04:59:34Z,MERGED,True,1120,3,14,https://github.com/karlding,ELEC-580: Add brake/throttle and calibration routines,4,[],https://github.com/uw-midsun/firmware/pull/345,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/345,"Add code for obtaining the readings and providing events for FSMs to
process from:
* Mechanical Brake
* Throttle

In addition, the old calibration routines from the old Driver Controls
implementation was ported over.","Add code for obtaining the readings and providing events for FSMs to
process from:
* Mechanical Brake
* Throttle

In addition, the old calibration routines from the old Driver Controls
implementation was ported over.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,346,2019-06-11T23:14:04Z,2019-07-08T05:06:06Z,2019-07-08T05:06:09Z,MERGED,True,469,2,5,https://github.com/karlding,ELEC-580: Add Center Console button handling,3,[],https://github.com/uw-midsun/firmware/pull/346,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/346,"Add logic to handle GPIO inputs for the Center Console buttons and raise
the appropriate events over CAN.
Due to a HW bug (see HW-200), we can't handle all the inputs via a GPIO
interrupt. As such, we poll for the input that shares an EXTI line in
the main loop.","Add logic to handle GPIO inputs for the Center Console buttons and raise
the appropriate events over CAN.
Due to a HW bug (see HW-200), we can't handle all the inputs via a GPIO
interrupt. As such, we poll for the input that shares an EXTI line in
the main loop.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,347,2019-07-08T07:00:21Z,2019-07-08T23:25:18Z,2019-07-08T23:25:21Z,MERGED,True,147,0,4,https://github.com/karlding,ELEC-580: Add Center Console BPS Fault Indicator,2,[],https://github.com/uw-midsun/firmware/pull/347,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/347,"Add code to drive the BPS Fault Dash Indicator LED by piggybacking the
CAN message used to notify Lights to activate the Strobe. This is
because there's currently some inherent coupling between the Lights
board, which is told when to turn on the Strobe, and the required BPS
Fault Dash Indicator is to reflect that state.
If we wish to process the message slightly faster instead of waiting for
the Driver Controls master board to notify everyone, we could also
listen to the BMS Heartbeat.","Add code to drive the BPS Fault Dash Indicator LED by piggybacking the
CAN message used to notify Lights to activate the Strobe. This is
because there's currently some inherent coupling between the Lights
board, which is told when to turn on the Strobe, and the required BPS
Fault Dash Indicator is to reflect that state.
If we wish to process the message slightly faster instead of waiting for
the Driver Controls master board to notify everyone, we could also
listen to the BMS Heartbeat.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,348,2019-07-09T19:30:50Z,2019-07-09T19:43:41Z,2019-07-09T19:43:52Z,MERGED,True,1783,3,27,https://github.com/karlding,ELEC-580: Add Pedal dependencies for drive output,1,[],https://github.com/uw-midsun/firmware/pull/348,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/348,"Add the FSMs and logic that controls the Drive Output message.
This includes a basic way of toggling whether regenerative braking is
enabled via a compile-time constant. This should be further extended in
the future (either at the Motor Controller Interface or in the Driver
Controls Master) to either allow the driver to configure whether regen
is enabled, or dynamically do so depending on battery SoC.
Currently it also naively assumes that the ADS1015 is always going to
successfully sample. It is probably worth adding logic to the FSMs to
deal with the failure case where the ADC stops sampling, resulting in
stale data being sent to the Motor Controller Interface. Currently we
just zero the data for the pedal/brake positions and hope for the best.
In addition, modified the Exported Enums to add the bitmasks for BMS
Heartbeat status, since it seems like the enum indices were updated, but
this was missed in the process.","Add the FSMs and logic that controls the Drive Output message.
This includes a basic way of toggling whether regenerative braking is
enabled via a compile-time constant. This should be further extended in
the future (either at the Motor Controller Interface or in the Driver
Controls Master) to either allow the driver to configure whether regen
is enabled, or dynamically do so depending on battery SoC.
Currently it also naively assumes that the ADS1015 is always going to
successfully sample. It is probably worth adding logic to the FSMs to
deal with the failure case where the ADC stops sampling, resulting in
stale data being sent to the Motor Controller Interface. Currently we
just zero the data for the pedal/brake positions and hope for the best.
In addition, modified the Exported Enums to add the bitmasks for BMS
Heartbeat status, since it seems like the enum indices were updated, but
this was missed in the process.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,349,2019-07-09T19:37:50Z,2019-07-09T19:52:19Z,2019-07-09T19:52:23Z,MERGED,True,0,5454,70,https://github.com/karlding,ELEC-580: Remove old Driver Controls code,2,[],https://github.com/uw-midsun/firmware/pull/349,https://github.com/karlding,1,https://github.com/uw-midsun/firmware/pull/349,"This project is no longer used in MS XII.
The firmware was originally used in MS XII prior to FSGP/ASC 2018, but
due to various issues around EMC, the hardware was heavily modified for
competition. It was later superseded by the distributed Driver Controls
hardware, consisting of the Pedal, Steering, and Center Console boards,
which were used at FSGP 2019.","This project is no longer used in MS XII.
The firmware was originally used in MS XII prior to FSGP/ASC 2018, but
due to various issues around EMC, the hardware was heavily modified for
competition. It was later superseded by the distributed Driver Controls
hardware, consisting of the Pedal, Steering, and Center Console boards,
which were used at FSGP 2019.",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,350,2021-01-31T17:32:27Z,2021-05-05T15:47:03Z,2021-05-05T15:47:05Z,CLOSED,False,94,0,6,https://github.com/PurpleRhythms,Daniel Zeng's Firmware 102 HW,1,[],https://github.com/uw-midsun/firmware/pull/350,https://github.com/PurpleRhythms,1,https://github.com/uw-midsun/firmware/pull/350,,,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,351,2021-05-14T03:20:49Z,2021-05-15T02:06:46Z,2021-05-15T02:06:46Z,CLOSED,False,48,0,2,https://github.com/ShiCheng-Lu,FW102 homework counter project,1,[],https://github.com/uw-midsun/firmware/pull/351,https://github.com/ShiCheng-Lu,1,https://github.com/uw-midsun/firmware/pull/351,"Hello everyone, this is the FW 102 homework, I think it works. :)","Hello everyone, this is the FW 102 homework, I think it works. :)",True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,352,2021-05-16T03:23:51Z,2021-05-16T22:05:19Z,2021-05-16T22:06:06Z,CLOSED,False,48,0,2,https://github.com/ShiCheng-Lu,soft_999_shicheng_lu_fw_102,1,[],https://github.com/uw-midsun/firmware/pull/352,https://github.com/ShiCheng-Lu,1,https://github.com/uw-midsun/firmware/pull/352,completed homework :0,completed homework :0,True,{}
uw-midsun/firmware,https://github.com/uw-midsun/firmware,353,2021-05-16T04:33:44Z,2021-05-16T22:05:31Z,2021-05-16T22:05:41Z,CLOSED,False,122,0,4,https://github.com/ShiCheng-Lu,Soft 999 shicheng lu fw 103,2,[],https://github.com/uw-midsun/firmware/pull/353,https://github.com/ShiCheng-Lu,1,https://github.com/uw-midsun/firmware/pull/353,"completed homework
I don't know if this works as intended, I do not know how to test button presses yet.","completed homework
I don't know if this works as intended, I do not know how to test button presses yet.",True,{}
