tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,423,2016-03-09T12:14:18Z,2016-12-28T21:36:14Z,2017-03-13T11:31:11Z,CLOSED,False,296,105,7,https://github.com/keshonok,Send responses in correct order. Handle non-idempotent requests. (#419),1,[],https://github.com/tempesta-tech/tempesta/pull/423,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/423,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,423,2016-03-09T12:14:18Z,2016-12-28T21:36:14Z,2017-03-13T11:31:11Z,CLOSED,False,296,105,7,https://github.com/keshonok,Send responses in correct order. Handle non-idempotent requests. (#419),1,[],https://github.com/tempesta-tech/tempesta/pull/423,https://github.com/keshonok,2,https://github.com/tempesta-tech/tempesta/pull/423#issuecomment-269544681,,Superceded by #660.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,425,2016-03-10T17:03:44Z,2016-03-15T15:40:10Z,2016-05-27T19:26:59Z,MERGED,True,24,3,1,https://github.com/keshonok,Add client connection hook to handle connection errors. (#424),1,[],https://github.com/tempesta-tech/tempesta/pull/425,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/425,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,427,2016-03-14T15:25:39Z,2016-03-14T15:25:49Z,2016-05-27T19:26:59Z,MERGED,True,15,1,1,https://github.com/keshonok,Cover a missed case for the SKB page allocator. (#426),1,[],https://github.com/tempesta-tech/tempesta/pull/427,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/427,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,429,2016-03-15T17:04:55Z,2016-03-15T17:28:05Z,2016-05-27T19:26:59Z,MERGED,True,21,3,2,https://github.com/keshonok,Allocate per-cpu page cache dynamically for memory pool.,1,[],https://github.com/tempesta-tech/tempesta/pull/429,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/429,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,429,2016-03-15T17:04:55Z,2016-03-15T17:28:05Z,2016-05-27T19:26:59Z,MERGED,True,21,3,2,https://github.com/keshonok,Allocate per-cpu page cache dynamically for memory pool.,1,[],https://github.com/tempesta-tech/tempesta/pull/429,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/429#issuecomment-196935196,,good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,438,2016-03-22T16:05:54Z,2016-05-06T15:22:46Z,2016-05-30T07:31:11Z,CLOSED,False,1971,1363,38,https://github.com/sergsever,fix #65,75,[],https://github.com/tempesta-tech/tempesta/pull/438,https://github.com/sergsever,1,https://github.com/tempesta-tech/tempesta/pull/438,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,438,2016-03-22T16:05:54Z,2016-05-06T15:22:46Z,2016-05-30T07:31:11Z,CLOSED,False,1971,1363,38,https://github.com/sergsever,fix #65,75,[],https://github.com/tempesta-tech/tempesta/pull/438,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/438#issuecomment-217245526,,Good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,440,2016-03-25T10:42:21Z,2016-04-12T14:27:03Z,2016-05-27T19:26:59Z,MERGED,True,548,406,4,https://github.com/keshonok,Process GRO-ed SKBs in a correct way.,11,[],https://github.com/tempesta-tech/tempesta/pull/440,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/440,"This fixes kernel crashes in multiple places as noted in issues
#430, #431, #432, #433, #435, #437.
The core issue was the ss_skb_split() is not supposed to work with
GRO-ed SKBs that has data in skb_shinfo(skb)->frag_list. Splitting
of those SKBs resulted in the appearance of all kinds of invalid
SKBs that caused total havoc in the kernel. It also triggered #436
that will be fixed separately.","This fixes kernel crashes in multiple places as noted in issues
#430, #431, #432, #433, #435, #437.
The core issue was the ss_skb_split() is not supposed to work with
GRO-ed SKBs that has data in skb_shinfo(skb)->frag_list. Splitting
of those SKBs resulted in the appearance of all kinds of invalid
SKBs that caused total havoc in the kernel. It also triggered #436
that will be fixed separately.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,440,2016-03-25T10:42:21Z,2016-04-12T14:27:03Z,2016-05-27T19:26:59Z,MERGED,True,548,406,4,https://github.com/keshonok,Process GRO-ed SKBs in a correct way.,11,[],https://github.com/tempesta-tech/tempesta/pull/440,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/440#issuecomment-208929367,"This fixes kernel crashes in multiple places as noted in issues
#430, #431, #432, #433, #435, #437.
The core issue was the ss_skb_split() is not supposed to work with
GRO-ed SKBs that has data in skb_shinfo(skb)->frag_list. Splitting
of those SKBs resulted in the appearance of all kinds of invalid
SKBs that caused total havoc in the kernel. It also triggered #436
that will be fixed separately.",Good to merge without 607ddc7,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,441,2016-03-25T23:50:27Z,2016-03-28T20:46:34Z,2016-05-27T19:26:59Z,MERGED,True,4,5,1,https://github.com/milabs,Check for the client`s address before doing any allocations,1,[],https://github.com/tempesta-tech/tempesta/pull/441,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/441,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,441,2016-03-25T23:50:27Z,2016-03-28T20:46:34Z,2016-05-27T19:26:59Z,MERGED,True,4,5,1,https://github.com/milabs,Check for the client`s address before doing any allocations,1,[],https://github.com/tempesta-tech/tempesta/pull/441,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/441#issuecomment-201824906,,good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,442,2016-03-27T00:18:17Z,2016-03-28T20:46:52Z,2016-05-27T19:26:59Z,MERGED,True,8,0,1,https://github.com/milabs,sock_clnt: check for duplicate listener addresses,1,[],https://github.com/tempesta-tech/tempesta/pull/442,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/442,This refers #418 and prevents of using multiple equals listen directives.,This refers #418 and prevents of using multiple equals listen directives.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,442,2016-03-27T00:18:17Z,2016-03-28T20:46:52Z,2016-05-27T19:26:59Z,MERGED,True,8,0,1,https://github.com/milabs,sock_clnt: check for duplicate listener addresses,1,[],https://github.com/tempesta-tech/tempesta/pull/442,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/442#issuecomment-201964564,This refers #418 and prevents of using multiple equals listen directives.,good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,443,2016-03-27T10:36:21Z,2016-03-27T11:15:22Z,2016-05-27T19:26:59Z,MERGED,True,3,0,1,https://github.com/keshonok,Make sure the pool pointer is valid.,1,[],https://github.com/tempesta-tech/tempesta/pull/443,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/443,"There's an execution path where the pool pointer can be NULL. That
happens when an HTTP message structure is allocated statically or
on stack (one of TfwHttpMsg{}, TfwHttpReq{}, or TfwHttpResp{}).","There's an execution path where the pool pointer can be NULL. That
happens when an HTTP message structure is allocated statically or
on stack (one of TfwHttpMsg{}, TfwHttpReq{}, or TfwHttpResp{}).",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,443,2016-03-27T10:36:21Z,2016-03-27T11:15:22Z,2016-05-27T19:26:59Z,MERGED,True,3,0,1,https://github.com/keshonok,Make sure the pool pointer is valid.,1,[],https://github.com/tempesta-tech/tempesta/pull/443,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/443#issuecomment-202033602,"There's an execution path where the pool pointer can be NULL. That
happens when an HTTP message structure is allocated statically or
on stack (one of TfwHttpMsg{}, TfwHttpReq{}, or TfwHttpResp{}).",Good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,451,2016-04-14T11:25:44Z,2016-04-17T07:58:48Z,2016-05-27T19:26:59Z,CLOSED,False,344,243,5,https://github.com/milabs,Allow only LF and CRLF in while parsing HTTP,3,[],https://github.com/tempesta-tech/tempesta/pull/451,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/451,"This patch set intended to solve #444 issue by implementing generalized logic of EOL handling while parsing HTTP. Now, LF and CRLF is the only valid EOL markers. Also, this set adds support for tracking amount of EOL characters in TfwStr-strings.","This patch set intended to solve #444 issue by implementing generalized logic of EOL handling while parsing HTTP. Now, LF and CRLF is the only valid EOL markers. Also, this set adds support for tracking amount of EOL characters in TfwStr-strings.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,452,2016-04-14T13:15:34Z,2016-04-17T07:54:27Z,2016-05-27T19:26:59Z,MERGED,True,2,3,1,https://github.com/milabs,frang: check URI length even if string is not completed,1,[],https://github.com/tempesta-tech/tempesta/pull/452,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/452,"Check URI length in Frang after each chunk of data is processed.
This fixes #445.","Check URI length in Frang after each chunk of data is processed.
This fixes #445.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,452,2016-04-14T13:15:34Z,2016-04-17T07:54:27Z,2016-05-27T19:26:59Z,MERGED,True,2,3,1,https://github.com/milabs,frang: check URI length even if string is not completed,1,[],https://github.com/tempesta-tech/tempesta/pull/452,https://github.com/keshonok,2,https://github.com/tempesta-tech/tempesta/pull/452#issuecomment-209965743,"Check URI length in Frang after each chunk of data is processed.
This fixes #445.",Looks good to me.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,452,2016-04-14T13:15:34Z,2016-04-17T07:54:27Z,2016-05-27T19:26:59Z,MERGED,True,2,3,1,https://github.com/milabs,frang: check URI length even if string is not completed,1,[],https://github.com/tempesta-tech/tempesta/pull/452,https://github.com/krizhanovsky,3,https://github.com/tempesta-tech/tempesta/pull/452#issuecomment-210921874,"Check URI length in Frang after each chunk of data is processed.
This fixes #445.",good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,453,2016-04-14T19:15:08Z,2016-04-19T17:10:26Z,2016-05-27T19:26:59Z,CLOSED,False,344,243,5,https://github.com/milabs,Allow only LF and CRLF in while parsing HTTP (v2),3,[],https://github.com/tempesta-tech/tempesta/pull/453,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/453,"This patch set intended to solve #444 issue by implementing generalized logic of EOL handling while parsing HTTP. Now, LF and CRLF is the only valid EOL markers. Also, this set adds support for tracking amount of EOL characters in TfwStr-strings.
This is a second version of the patch set which takes into account comments passed on v1.","This patch set intended to solve #444 issue by implementing generalized logic of EOL handling while parsing HTTP. Now, LF and CRLF is the only valid EOL markers. Also, this set adds support for tracking amount of EOL characters in TfwStr-strings.
This is a second version of the patch set which takes into account comments passed on v1.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,453,2016-04-14T19:15:08Z,2016-04-19T17:10:26Z,2016-05-27T19:26:59Z,CLOSED,False,344,243,5,https://github.com/milabs,Allow only LF and CRLF in while parsing HTTP (v2),3,[],https://github.com/tempesta-tech/tempesta/pull/453,https://github.com/keshonok,2,https://github.com/tempesta-tech/tempesta/pull/453#issuecomment-210236249,"This patch set intended to solve #444 issue by implementing generalized logic of EOL handling while parsing HTTP. Now, LF and CRLF is the only valid EOL markers. Also, this set adds support for tracking amount of EOL characters in TfwStr-strings.
This is a second version of the patch set which takes into account comments passed on v1.",Looks good to me.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,456,2016-04-18T17:40:06Z,2016-04-19T22:42:16Z,2016-05-27T19:26:59Z,MERGED,True,31,14,1,https://github.com/keshonok,Correcty remove the EOL bytes of a header field. (#446),1,[],https://github.com/tempesta-tech/tempesta/pull/456,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/456,"Now the EOL bytes are removed by length and therefore can cross
boundaries of fragments that make up an SKB.","Now the EOL bytes are removed by length and therefore can cross
boundaries of fragments that make up an SKB.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,456,2016-04-18T17:40:06Z,2016-04-19T22:42:16Z,2016-05-27T19:26:59Z,MERGED,True,31,14,1,https://github.com/keshonok,Correcty remove the EOL bytes of a header field. (#446),1,[],https://github.com/tempesta-tech/tempesta/pull/456,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/456#issuecomment-212069673,"Now the EOL bytes are removed by length and therefore can cross
boundaries of fragments that make up an SKB.",good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,457,2016-04-18T22:28:15Z,2016-05-13T19:37:43Z,2016-05-27T19:26:59Z,MERGED,True,66,26,1,https://github.com/milabs,cleanup cache entry size calculation,2,[],https://github.com/tempesta-tech/tempesta/pull/457,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/457,"Please, pull","Please, pull",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,457,2016-04-18T22:28:15Z,2016-05-13T19:37:43Z,2016-05-27T19:26:59Z,MERGED,True,66,26,1,https://github.com/milabs,cleanup cache entry size calculation,2,[],https://github.com/tempesta-tech/tempesta/pull/457,https://github.com/milabs,2,https://github.com/tempesta-tech/tempesta/pull/457#issuecomment-214712284,"Please, pull","@krizhanovsky @keshonok please, review",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,457,2016-04-18T22:28:15Z,2016-05-13T19:37:43Z,2016-05-27T19:26:59Z,MERGED,True,66,26,1,https://github.com/milabs,cleanup cache entry size calculation,2,[],https://github.com/tempesta-tech/tempesta/pull/457,https://github.com/krizhanovsky,3,https://github.com/tempesta-tech/tempesta/pull/457#issuecomment-219135925,"Please, pull",good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,458,2016-04-19T17:07:51Z,2016-05-22T22:12:36Z,2016-05-27T19:26:59Z,MERGED,True,241,200,3,https://github.com/keshonok,Use pskb throughout ss_skb.c to set it->skb and it->ptr in place,8,[],https://github.com/tempesta-tech/tempesta/pull/458,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/458,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,458,2016-04-19T17:07:51Z,2016-05-22T22:12:36Z,2016-05-27T19:26:59Z,MERGED,True,241,200,3,https://github.com/keshonok,Use pskb throughout ss_skb.c to set it->skb and it->ptr in place,8,[],https://github.com/tempesta-tech/tempesta/pull/458,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/458#issuecomment-220851506,,Looks good for me,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,459,2016-04-19T17:39:34Z,2016-04-19T22:52:10Z,2016-05-27T19:26:59Z,CLOSED,False,635,466,5,https://github.com/milabs,Allow only LF and CRLF in while parsing HTTP (v3),4,[],https://github.com/tempesta-tech/tempesta/pull/459,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/459,"This patch set intended to solve #444 issue by implementing generalized logic of EOL handling while parsing HTTP. Now, LF and CRLF is the only valid EOL markers. Also, this set adds support for tracking amount of EOL characters in TfwStr-strings.
Review history:

#451 (v1)
#453 (v2)

Changes since v2:

fulfilling the CodingStyle (braces and fill-column limit)
don't use separate header file for EOL
cache's code reflects that s_line not contains EOL anymore
__hdr_del / __hdr_sub are updated to use EOL
common (raw) headers correctness checking (colon + alphabet)","This patch set intended to solve #444 issue by implementing generalized logic of EOL handling while parsing HTTP. Now, LF and CRLF is the only valid EOL markers. Also, this set adds support for tracking amount of EOL characters in TfwStr-strings.
Review history:

#451 (v1)
#453 (v2)

Changes since v2:

fulfilling the CodingStyle (braces and fill-column limit)
don't use separate header file for EOL
cache's code reflects that s_line not contains EOL anymore
__hdr_del / __hdr_sub are updated to use EOL
common (raw) headers correctness checking (colon + alphabet)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,460,2016-04-19T22:48:32Z,2016-04-20T09:12:27Z,2016-05-27T19:26:59Z,MERGED,True,610,464,5,https://github.com/milabs,Allow only LF and CRLF in while parsing HTTP (v4),4,[],https://github.com/tempesta-tech/tempesta/pull/460,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/460,"This patch set intended to solve #444 issue by implementing generalized logic of EOL handling while parsing HTTP. Now, LF and CRLF is the only valid EOL markers. Also, this set adds support for tracking amount of EOL characters in TfwStr-strings.
Review history:

#451 (v1)
#453 (v2)
#459 (v3)

Changes since v3:

__hdr_sub reimplemented
tfw_cache_copy_str -> tfw_cache_strcpy_eol

Changes since v2:

fulfilling the CodingStyle (braces and fill-column limit)
don't use separate header file for EOL
cache's code reflects that s_line not contains EOL anymore
__hdr_del / __hdr_sub are updated to use EOL
common (raw) headers correctness checking (colon + alphabet)","This patch set intended to solve #444 issue by implementing generalized logic of EOL handling while parsing HTTP. Now, LF and CRLF is the only valid EOL markers. Also, this set adds support for tracking amount of EOL characters in TfwStr-strings.
Review history:

#451 (v1)
#453 (v2)
#459 (v3)

Changes since v3:

__hdr_sub reimplemented
tfw_cache_copy_str -> tfw_cache_strcpy_eol

Changes since v2:

fulfilling the CodingStyle (braces and fill-column limit)
don't use separate header file for EOL
cache's code reflects that s_line not contains EOL anymore
__hdr_del / __hdr_sub are updated to use EOL
common (raw) headers correctness checking (colon + alphabet)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,460,2016-04-19T22:48:32Z,2016-04-20T09:12:27Z,2016-05-27T19:26:59Z,MERGED,True,610,464,5,https://github.com/milabs,Allow only LF and CRLF in while parsing HTTP (v4),4,[],https://github.com/tempesta-tech/tempesta/pull/460,https://github.com/keshonok,2,https://github.com/tempesta-tech/tempesta/pull/460#issuecomment-212339640,"This patch set intended to solve #444 issue by implementing generalized logic of EOL handling while parsing HTTP. Now, LF and CRLF is the only valid EOL markers. Also, this set adds support for tracking amount of EOL characters in TfwStr-strings.
Review history:

#451 (v1)
#453 (v2)
#459 (v3)

Changes since v3:

__hdr_sub reimplemented
tfw_cache_copy_str -> tfw_cache_strcpy_eol

Changes since v2:

fulfilling the CodingStyle (braces and fill-column limit)
don't use separate header file for EOL
cache's code reflects that s_line not contains EOL anymore
__hdr_del / __hdr_sub are updated to use EOL
common (raw) headers correctness checking (colon + alphabet)",Looks good to me.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,462,2016-04-22T13:37:36Z,2016-12-28T15:27:33Z,2017-03-22T15:51:02Z,CLOSED,False,1019,269,20,https://github.com/sergsever,Sl 396,121,[],https://github.com/tempesta-tech/tempesta/pull/462,https://github.com/sergsever,1,https://github.com/tempesta-tech/tempesta/pull/462,Fix #396 and #375.,Fix #396 and #375.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,463,2016-04-24T20:55:21Z,2016-05-07T09:50:03Z,2016-05-27T19:26:59Z,CLOSED,False,2073,1452,36,https://github.com/milabs,Fix erroneous accumulation of processed data in HTTP parser,54,[],https://github.com/tempesta-tech/tempesta/pull/463,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/463,This patch-set fixes #461 issue by synchronizing fix-ups and data movement what was the reason of erroneous accumulation of processed data.,This patch-set fixes #461 issue by synchronizing fix-ups and data movement what was the reason of erroneous accumulation of processed data.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,463,2016-04-24T20:55:21Z,2016-05-07T09:50:03Z,2016-05-27T19:26:59Z,CLOSED,False,2073,1452,36,https://github.com/milabs,Fix erroneous accumulation of processed data in HTTP parser,54,[],https://github.com/tempesta-tech/tempesta/pull/463,https://github.com/milabs,2,https://github.com/tempesta-tech/tempesta/pull/463#issuecomment-215696917,This patch-set fixes #461 issue by synchronizing fix-ups and data movement what was the reason of erroneous accumulation of processed data.,"Sorry, but the patch-set is currently unstable. I'm working on it's completion.
Fixed.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,464,2016-04-26T02:08:15Z,2016-05-03T19:21:02Z,2016-05-27T19:26:59Z,MERGED,True,3,2,1,https://github.com/milabs,"Fix ""BUG: using smp_processor_id() in preemptible"" message",1,[],https://github.com/tempesta-tech/tempesta/pull/464,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/464,"This patch fixes ""BUG: using smp_processor_id() in preemptible"" bug while running with CONFIG_DEBUG_PREEMPT enabled:
  Call Trace:
    [<ffffffff8161b6a1>] dump_stack+0x65/0x83
    [<ffffffff81374716>] check_preemption_disabled+0xe6/0xf0
    [<ffffffff81374737>] debug_smp_processor_id+0x17/0x20
    [<ffffffff81549e4e>] __pg_skb_alloc+0x2e/0x450
    [<ffffffff8154a2be>] __alloc_skb+0x4e/0x250
    [<ffffffff81374753>] ? __this_cpu_preempt_check+0x13/0x20
    [<ffffffff81545cf8>] sock_wmalloc+0x38/0xb0
    [<ffffffff815ecb84>] unix_stream_connect+0xb4/0x4a0
    [<ffffffff815439e3>] SyS_connect+0xe3/0x110
    [<ffffffff81620dee>] system_call_fastpath+0x12/0x71
  BUG: using smp_processor_id() in preemptible [00000000] code: sh/112
  caller is debug_smp_processor_id+0x17/0x20","This patch fixes ""BUG: using smp_processor_id() in preemptible"" bug while running with CONFIG_DEBUG_PREEMPT enabled:
  Call Trace:
    [<ffffffff8161b6a1>] dump_stack+0x65/0x83
    [<ffffffff81374716>] check_preemption_disabled+0xe6/0xf0
    [<ffffffff81374737>] debug_smp_processor_id+0x17/0x20
    [<ffffffff81549e4e>] __pg_skb_alloc+0x2e/0x450
    [<ffffffff8154a2be>] __alloc_skb+0x4e/0x250
    [<ffffffff81374753>] ? __this_cpu_preempt_check+0x13/0x20
    [<ffffffff81545cf8>] sock_wmalloc+0x38/0xb0
    [<ffffffff815ecb84>] unix_stream_connect+0xb4/0x4a0
    [<ffffffff815439e3>] SyS_connect+0xe3/0x110
    [<ffffffff81620dee>] system_call_fastpath+0x12/0x71
  BUG: using smp_processor_id() in preemptible [00000000] code: sh/112
  caller is debug_smp_processor_id+0x17/0x20",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,464,2016-04-26T02:08:15Z,2016-05-03T19:21:02Z,2016-05-27T19:26:59Z,MERGED,True,3,2,1,https://github.com/milabs,"Fix ""BUG: using smp_processor_id() in preemptible"" message",1,[],https://github.com/tempesta-tech/tempesta/pull/464,https://github.com/keshonok,2,https://github.com/tempesta-tech/tempesta/pull/464#issuecomment-214715886,"This patch fixes ""BUG: using smp_processor_id() in preemptible"" bug while running with CONFIG_DEBUG_PREEMPT enabled:
  Call Trace:
    [<ffffffff8161b6a1>] dump_stack+0x65/0x83
    [<ffffffff81374716>] check_preemption_disabled+0xe6/0xf0
    [<ffffffff81374737>] debug_smp_processor_id+0x17/0x20
    [<ffffffff81549e4e>] __pg_skb_alloc+0x2e/0x450
    [<ffffffff8154a2be>] __alloc_skb+0x4e/0x250
    [<ffffffff81374753>] ? __this_cpu_preempt_check+0x13/0x20
    [<ffffffff81545cf8>] sock_wmalloc+0x38/0xb0
    [<ffffffff815ecb84>] unix_stream_connect+0xb4/0x4a0
    [<ffffffff815439e3>] SyS_connect+0xe3/0x110
    [<ffffffff81620dee>] system_call_fastpath+0x12/0x71
  BUG: using smp_processor_id() in preemptible [00000000] code: sh/112
  caller is debug_smp_processor_id+0x17/0x20","Looks good to me. In fact, I have had the same fix in my working version of Tempesta kernel, so this is the case of two minds that think alike.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,464,2016-04-26T02:08:15Z,2016-05-03T19:21:02Z,2016-05-27T19:26:59Z,MERGED,True,3,2,1,https://github.com/milabs,"Fix ""BUG: using smp_processor_id() in preemptible"" message",1,[],https://github.com/tempesta-tech/tempesta/pull/464,https://github.com/krizhanovsky,3,https://github.com/tempesta-tech/tempesta/pull/464#issuecomment-216635887,"This patch fixes ""BUG: using smp_processor_id() in preemptible"" bug while running with CONFIG_DEBUG_PREEMPT enabled:
  Call Trace:
    [<ffffffff8161b6a1>] dump_stack+0x65/0x83
    [<ffffffff81374716>] check_preemption_disabled+0xe6/0xf0
    [<ffffffff81374737>] debug_smp_processor_id+0x17/0x20
    [<ffffffff81549e4e>] __pg_skb_alloc+0x2e/0x450
    [<ffffffff8154a2be>] __alloc_skb+0x4e/0x250
    [<ffffffff81374753>] ? __this_cpu_preempt_check+0x13/0x20
    [<ffffffff81545cf8>] sock_wmalloc+0x38/0xb0
    [<ffffffff815ecb84>] unix_stream_connect+0xb4/0x4a0
    [<ffffffff815439e3>] SyS_connect+0xe3/0x110
    [<ffffffff81620dee>] system_call_fastpath+0x12/0x71
  BUG: using smp_processor_id() in preemptible [00000000] code: sh/112
  caller is debug_smp_processor_id+0x17/0x20","Good to merge.
Please commit the change to https://github.com/tempesta-tech/linux-4.1-tfw as well.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,464,2016-04-26T02:08:15Z,2016-05-03T19:21:02Z,2016-05-27T19:26:59Z,MERGED,True,3,2,1,https://github.com/milabs,"Fix ""BUG: using smp_processor_id() in preemptible"" message",1,[],https://github.com/tempesta-tech/tempesta/pull/464,https://github.com/milabs,4,https://github.com/tempesta-tech/tempesta/pull/464#issuecomment-216639987,"This patch fixes ""BUG: using smp_processor_id() in preemptible"" bug while running with CONFIG_DEBUG_PREEMPT enabled:
  Call Trace:
    [<ffffffff8161b6a1>] dump_stack+0x65/0x83
    [<ffffffff81374716>] check_preemption_disabled+0xe6/0xf0
    [<ffffffff81374737>] debug_smp_processor_id+0x17/0x20
    [<ffffffff81549e4e>] __pg_skb_alloc+0x2e/0x450
    [<ffffffff8154a2be>] __alloc_skb+0x4e/0x250
    [<ffffffff81374753>] ? __this_cpu_preempt_check+0x13/0x20
    [<ffffffff81545cf8>] sock_wmalloc+0x38/0xb0
    [<ffffffff815ecb84>] unix_stream_connect+0xb4/0x4a0
    [<ffffffff815439e3>] SyS_connect+0xe3/0x110
    [<ffffffff81620dee>] system_call_fastpath+0x12/0x71
  BUG: using smp_processor_id() in preemptible [00000000] code: sh/112
  caller is debug_smp_processor_id+0x17/0x20",https://github.com/tempesta-tech/linux-4.1-tfw/commit/9e082b9e40a98964fbd18ab37546e2120f44ac39,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,465,2016-04-27T17:11:55Z,2016-04-27T18:31:27Z,2016-05-27T19:26:59Z,MERGED,True,8,1,2,https://github.com/milabs,Check for NULL as a path name in read_file_via_vfs,2,[],https://github.com/tempesta-tech/tempesta/pull/465,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/465,"Please, pull changes.","Please, pull changes.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,465,2016-04-27T17:11:55Z,2016-04-27T18:31:27Z,2016-05-27T19:26:59Z,MERGED,True,8,1,2,https://github.com/milabs,Check for NULL as a path name in read_file_via_vfs,2,[],https://github.com/tempesta-tech/tempesta/pull/465,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/465#issuecomment-215169831,"Please, pull changes.",good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,466,2016-04-28T21:37:02Z,2016-05-13T19:00:24Z,2016-05-27T19:26:59Z,MERGED,True,10,0,1,https://github.com/milabs,Some leaks in cfg was detected while running kmemleak.,1,[],https://github.com/tempesta-tech/tempesta/pull/466,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/466,"Please, review the patch.","Please, review the patch.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,466,2016-04-28T21:37:02Z,2016-05-13T19:00:24Z,2016-05-27T19:26:59Z,MERGED,True,10,0,1,https://github.com/milabs,Some leaks in cfg was detected while running kmemleak.,1,[],https://github.com/tempesta-tech/tempesta/pull/466,https://github.com/keshonok,2,https://github.com/tempesta-tech/tempesta/pull/466#issuecomment-218490140,"Please, review the patch.",Looks good to me.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,466,2016-04-28T21:37:02Z,2016-05-13T19:00:24Z,2016-05-27T19:26:59Z,MERGED,True,10,0,1,https://github.com/milabs,Some leaks in cfg was detected while running kmemleak.,1,[],https://github.com/tempesta-tech/tempesta/pull/466,https://github.com/krizhanovsky,3,https://github.com/tempesta-tech/tempesta/pull/466#issuecomment-219129015,"Please, review the patch.",good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,468,2016-05-04T16:05:27Z,2016-05-04T18:51:28Z,2016-05-27T19:26:59Z,MERGED,True,5,0,1,https://github.com/milabs,sock_srv: limit conns_n by TFW_SRV_MAX_CONN while parsing,1,[],https://github.com/tempesta-tech/tempesta/pull/468,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/468,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,468,2016-05-04T16:05:27Z,2016-05-04T18:51:28Z,2016-05-27T19:26:59Z,MERGED,True,5,0,1,https://github.com/milabs,sock_srv: limit conns_n by TFW_SRV_MAX_CONN while parsing,1,[],https://github.com/tempesta-tech/tempesta/pull/468,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/468#issuecomment-216956250,,good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,470,2016-05-04T21:32:48Z,2016-05-05T09:24:46Z,2016-05-27T19:26:59Z,MERGED,True,9,7,1,https://github.com/keshonok,Offset must be a signed type in __skb_fragment(),1,[],https://github.com/tempesta-tech/tempesta/pull/470,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/470,"Also, make sure that we don't let through requests for deletion that
skip over the whole length if the string. That also ensures that the
CRLF tail is not deleted alone without the deletion of a part of the
tail part of the string.
Also, simplify several statements by using standard abs() and max()
functions.","Also, make sure that we don't let through requests for deletion that
skip over the whole length if the string. That also ensures that the
CRLF tail is not deleted alone without the deletion of a part of the
tail part of the string.
Also, simplify several statements by using standard abs() and max()
functions.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,470,2016-05-04T21:32:48Z,2016-05-05T09:24:46Z,2016-05-27T19:26:59Z,MERGED,True,9,7,1,https://github.com/keshonok,Offset must be a signed type in __skb_fragment(),1,[],https://github.com/tempesta-tech/tempesta/pull/470,https://github.com/milabs,2,https://github.com/tempesta-tech/tempesta/pull/470#issuecomment-217011021,"Also, make sure that we don't let through requests for deletion that
skip over the whole length if the string. That also ensures that the
CRLF tail is not deleted alone without the deletion of a part of the
tail part of the string.
Also, simplify several statements by using standard abs() and max()
functions.",Looks good to me.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,470,2016-05-04T21:32:48Z,2016-05-05T09:24:46Z,2016-05-27T19:26:59Z,MERGED,True,9,7,1,https://github.com/keshonok,Offset must be a signed type in __skb_fragment(),1,[],https://github.com/tempesta-tech/tempesta/pull/470,https://github.com/krizhanovsky,3,https://github.com/tempesta-tech/tempesta/pull/470#issuecomment-217090785,"Also, make sure that we don't let through requests for deletion that
skip over the whole length if the string. That also ensures that the
CRLF tail is not deleted alone without the deletion of a part of the
tail part of the string.
Also, simplify several statements by using standard abs() and max()
functions.",good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,472,2016-05-06T13:40:26Z,2016-05-06T18:00:03Z,2016-05-27T19:26:59Z,MERGED,True,13,5,1,https://github.com/milabs,http-parser: fix sparse EOL bug,1,[],https://github.com/tempesta-tech/tempesta/pull/472,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/472,"Fix bug introduced in 16795c9 where
sparse EOL's doesn't handled properly. We don't need to fixup anything
in case of moving from RGen__EoL to RGen_EoL.
Fixes #461.","Fix bug introduced in 16795c9 where
sparse EOL's doesn't handled properly. We don't need to fixup anything
in case of moving from RGen__EoL to RGen_EoL.
Fixes #461.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,472,2016-05-06T13:40:26Z,2016-05-06T18:00:03Z,2016-05-27T19:26:59Z,MERGED,True,13,5,1,https://github.com/milabs,http-parser: fix sparse EOL bug,1,[],https://github.com/tempesta-tech/tempesta/pull/472,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/472#issuecomment-217510761,"Fix bug introduced in 16795c9 where
sparse EOL's doesn't handled properly. We don't need to fixup anything
in case of moving from RGen__EoL to RGen_EoL.
Fixes #461.",good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,473,2016-05-07T13:07:06Z,2016-05-07T13:48:47Z,2016-05-27T19:26:59Z,MERGED,True,204,203,1,https://github.com/milabs,Rework data manipulations in HTTP-parser,4,[],https://github.com/tempesta-tech/tempesta/pull/473,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/473,Add some macros. Fix problem with incorrect msg->crlf handling in case of sparse CRLF (the problem existed earlier and was found while working on #461 (comment)),Add some macros. Fix problem with incorrect msg->crlf handling in case of sparse CRLF (the problem existed earlier and was found while working on #461 (comment)),True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,473,2016-05-07T13:07:06Z,2016-05-07T13:48:47Z,2016-05-27T19:26:59Z,MERGED,True,204,203,1,https://github.com/milabs,Rework data manipulations in HTTP-parser,4,[],https://github.com/tempesta-tech/tempesta/pull/473,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/473#issuecomment-217635493,Add some macros. Fix problem with incorrect msg->crlf handling in case of sparse CRLF (the problem existed earlier and was found while working on #461 (comment)),Good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,476,2016-05-08T21:15:28Z,2016-05-13T20:46:00Z,2016-05-27T19:27:00Z,MERGED,True,312,139,4,https://github.com/milabs,Fixes for the #474 and #207 issues,4,[],https://github.com/tempesta-tech/tempesta/pull/476,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/476,"Fixes #474, #207","Fixes #474, #207",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,478,2016-05-10T23:40:27Z,2016-05-13T20:46:25Z,2016-05-27T19:27:00Z,MERGED,True,11,7,2,https://github.com/milabs,t/unit: fix tests running problems,1,[],https://github.com/tempesta-tech/tempesta/pull/478,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/478,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,478,2016-05-10T23:40:27Z,2016-05-13T20:46:25Z,2016-05-27T19:27:00Z,MERGED,True,11,7,2,https://github.com/milabs,t/unit: fix tests running problems,1,[],https://github.com/tempesta-tech/tempesta/pull/478,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/478#issuecomment-219053056,,good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,479,2016-05-11T00:09:52Z,2016-05-13T13:59:20Z,2016-05-27T19:27:00Z,MERGED,True,8,5,1,https://github.com/milabs,Fix unpaired lock/unlock issue,1,[],https://github.com/tempesta-tech/tempesta/pull/479,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/479,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,479,2016-05-11T00:09:52Z,2016-05-13T13:59:20Z,2016-05-27T19:27:00Z,MERGED,True,8,5,1,https://github.com/milabs,Fix unpaired lock/unlock issue,1,[],https://github.com/tempesta-tech/tempesta/pull/479,https://github.com/keshonok,2,https://github.com/tempesta-tech/tempesta/pull/479#issuecomment-218430760,,Looks good to me.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,479,2016-05-11T00:09:52Z,2016-05-13T13:59:20Z,2016-05-27T19:27:00Z,MERGED,True,8,5,1,https://github.com/milabs,Fix unpaired lock/unlock issue,1,[],https://github.com/tempesta-tech/tempesta/pull/479,https://github.com/krizhanovsky,3,https://github.com/tempesta-tech/tempesta/pull/479#issuecomment-219048438,,good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,480,2016-05-16T12:41:54Z,2016-05-16T13:01:23Z,2016-05-27T19:27:00Z,MERGED,True,17,17,3,https://github.com/milabs,Fix two memory leaks,3,[],https://github.com/tempesta-tech/tempesta/pull/480,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/480,"This fixes two leaks, found while digging #411","This fixes two leaks, found while digging #411",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,481,2016-05-16T12:52:57Z,2016-05-16T16:36:09Z,2016-05-27T19:27:00Z,MERGED,True,7,10,1,https://github.com/milabs,filter: rework tfw_filter_check_ip,1,[],https://github.com/tempesta-tech/tempesta/pull/481,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/481,"This patch reworks tfw_filter_check_ip and adds missed tdb_rec_put
call.","This patch reworks tfw_filter_check_ip and adds missed tdb_rec_put
call.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,483,2016-05-17T15:09:29Z,2016-05-17T16:38:44Z,2016-05-27T19:27:00Z,MERGED,True,16,16,6,https://github.com/keshonok,Remove RCU-like access to sk->sk_user_data (#434),1,[],https://github.com/tempesta-tech/tempesta/pull/483,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/483,"Replace it with plain and simple access. Now that Tempesta code
runs completely under socket lock, the use of RCU-like access
is no longer needed.","Replace it with plain and simple access. Now that Tempesta code
runs completely under socket lock, the use of RCU-like access
is no longer needed.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,483,2016-05-17T15:09:29Z,2016-05-17T16:38:44Z,2016-05-27T19:27:00Z,MERGED,True,16,16,6,https://github.com/keshonok,Remove RCU-like access to sk->sk_user_data (#434),1,[],https://github.com/tempesta-tech/tempesta/pull/483,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/483#issuecomment-219771268,"Replace it with plain and simple access. Now that Tempesta code
runs completely under socket lock, the use of RCU-like access
is no longer needed.",Looks good. Could you please update ./t/sync_sockets/kernel/sync_*.c and ./t/bomber.c as well?,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,485,2016-05-17T20:24:46Z,2016-05-17T21:06:37Z,2016-05-27T19:27:00Z,MERGED,True,6,4,1,https://github.com/keshonok,Fix CID 111489,1,[],https://github.com/tempesta-tech/tempesta/pull/485,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/485,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,485,2016-05-17T20:24:46Z,2016-05-17T21:06:37Z,2016-05-27T19:27:00Z,MERGED,True,6,4,1,https://github.com/keshonok,Fix CID 111489,1,[],https://github.com/tempesta-tech/tempesta/pull/485,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/485#issuecomment-219851691,,good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,486,2016-05-18T21:05:06Z,2016-05-18T21:31:36Z,2016-05-27T19:27:00Z,MERGED,True,5,5,1,https://github.com/milabs,Fix crash while working with the cache ,2,[],https://github.com/tempesta-tech/tempesta/pull/486,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/486,Crash happens when duplicate string being read from the cache.,Crash happens when duplicate string being read from the cache.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,486,2016-05-18T21:05:06Z,2016-05-18T21:31:36Z,2016-05-27T19:27:00Z,MERGED,True,5,5,1,https://github.com/milabs,Fix crash while working with the cache ,2,[],https://github.com/tempesta-tech/tempesta/pull/486,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/486#issuecomment-220162411,Crash happens when duplicate string being read from the cache.,good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,492,2016-05-20T17:01:32Z,2016-05-28T13:29:11Z,2016-05-28T13:29:19Z,MERGED,True,177,244,4,https://github.com/milabs,Fix chunked body parsing issue,6,[],https://github.com/tempesta-tech/tempesta/pull/492,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/492,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,492,2016-05-20T17:01:32Z,2016-05-28T13:29:11Z,2016-05-28T13:29:19Z,MERGED,True,177,244,4,https://github.com/milabs,Fix chunked body parsing issue,6,[],https://github.com/tempesta-tech/tempesta/pull/492,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/492#issuecomment-222307645,,good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,504,2016-05-24T13:51:04Z,2016-05-24T21:48:55Z,2016-05-27T19:27:00Z,MERGED,True,96,8,3,https://github.com/keshonok,Add cache_method directive: cache the specified request methods only. (#494),1,[],https://github.com/tempesta-tech/tempesta/pull/504,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/504,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,504,2016-05-24T13:51:04Z,2016-05-24T21:48:55Z,2016-05-27T19:27:00Z,MERGED,True,96,8,3,https://github.com/keshonok,Add cache_method directive: cache the specified request methods only. (#494),1,[],https://github.com/tempesta-tech/tempesta/pull/504,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/504#issuecomment-221302295,,Good to merge after several cleanups,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,505,2016-05-24T13:53:00Z,2016-05-24T21:47:42Z,2016-05-27T19:27:00Z,MERGED,True,1,1,1,https://github.com/keshonok,"Set TCP layer's tcp_gso_segs, instead of skb's gso_segs.",1,[],https://github.com/tempesta-tech/tempesta/pull/505,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/505,"skb's gso_segs, gso_size and gso_type are set by the TCP layer at
a later stage.","skb's gso_segs, gso_size and gso_type are set by the TCP layer at
a later stage.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,505,2016-05-24T13:53:00Z,2016-05-24T21:47:42Z,2016-05-27T19:27:00Z,MERGED,True,1,1,1,https://github.com/keshonok,"Set TCP layer's tcp_gso_segs, instead of skb's gso_segs.",1,[],https://github.com/tempesta-tech/tempesta/pull/505,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/505#issuecomment-221303798,"skb's gso_segs, gso_size and gso_type are set by the TCP layer at
a later stage.",good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,509,2016-05-25T12:29:43Z,2016-05-28T13:52:04Z,2016-05-28T13:52:06Z,MERGED,True,2,1,1,https://github.com/milabs,Fix CID 78555,1,[],https://github.com/tempesta-tech/tempesta/pull/509,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/509,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,509,2016-05-25T12:29:43Z,2016-05-28T13:52:04Z,2016-05-28T13:52:06Z,MERGED,True,2,1,1,https://github.com/milabs,Fix CID 78555,1,[],https://github.com/tempesta-tech/tempesta/pull/509,https://github.com/keshonok,2,https://github.com/tempesta-tech/tempesta/pull/509#issuecomment-221900337,,Looks good to me.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,509,2016-05-25T12:29:43Z,2016-05-28T13:52:04Z,2016-05-28T13:52:06Z,MERGED,True,2,1,1,https://github.com/milabs,Fix CID 78555,1,[],https://github.com/tempesta-tech/tempesta/pull/509,https://github.com/krizhanovsky,3,https://github.com/tempesta-tech/tempesta/pull/509#issuecomment-222309336,,good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,510,2016-05-25T12:41:50Z,2016-05-28T13:37:29Z,2016-05-28T13:39:25Z,MERGED,True,5,2,1,https://github.com/milabs,Fix CID 78566,1,[],https://github.com/tempesta-tech/tempesta/pull/510,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/510,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,510,2016-05-25T12:41:50Z,2016-05-28T13:37:29Z,2016-05-28T13:39:25Z,MERGED,True,5,2,1,https://github.com/milabs,Fix CID 78566,1,[],https://github.com/tempesta-tech/tempesta/pull/510,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/510#issuecomment-222308862,,good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,512,2016-05-25T13:28:34Z,2016-05-30T14:04:20Z,2016-05-30T14:04:21Z,MERGED,True,6,2,1,https://github.com/milabs,Fix CID 111488,1,[],https://github.com/tempesta-tech/tempesta/pull/512,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/512,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,512,2016-05-25T13:28:34Z,2016-05-30T14:04:20Z,2016-05-30T14:04:21Z,MERGED,True,6,2,1,https://github.com/milabs,Fix CID 111488,1,[],https://github.com/tempesta-tech/tempesta/pull/512,https://github.com/keshonok,2,https://github.com/tempesta-tech/tempesta/pull/512#issuecomment-221899559,,Looks good to me.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,512,2016-05-25T13:28:34Z,2016-05-30T14:04:20Z,2016-05-30T14:04:21Z,MERGED,True,6,2,1,https://github.com/milabs,Fix CID 111488,1,[],https://github.com/tempesta-tech/tempesta/pull/512,https://github.com/krizhanovsky,3,https://github.com/tempesta-tech/tempesta/pull/512#issuecomment-222498656,,good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,539,2016-05-28T10:13:05Z,2016-05-29T16:36:27Z,2016-05-29T16:36:30Z,MERGED,True,17,5,1,https://github.com/keshonok,Expect an error when processing a directive within a cfg section. (#538),1,[],https://github.com/tempesta-tech/tempesta/pull/539,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/539,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,540,2016-05-28T11:44:50Z,2016-05-31T13:17:22Z,2016-05-31T13:17:27Z,MERGED,True,285,16,8,https://github.com/keshonok,"Implement ""suffix"" operation for string matching. (#495, #471)",2,[],https://github.com/tempesta-tech/tempesta/pull/540,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/540,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,540,2016-05-28T11:44:50Z,2016-05-31T13:17:22Z,2016-05-31T13:17:27Z,MERGED,True,285,16,8,https://github.com/keshonok,"Implement ""suffix"" operation for string matching. (#495, #471)",2,[],https://github.com/tempesta-tech/tempesta/pull/540,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/540#issuecomment-222683220,,good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,542,2016-05-29T01:43:16Z,2016-05-29T14:39:31Z,2016-05-29T14:39:33Z,MERGED,True,5,0,1,https://github.com/milabs,sock: take header reference correctly (fixes #411),1,[],https://github.com/tempesta-tech/tempesta/pull/542,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/542,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,542,2016-05-29T01:43:16Z,2016-05-29T14:39:31Z,2016-05-29T14:39:33Z,MERGED,True,5,0,1,https://github.com/milabs,sock: take header reference correctly (fixes #411),1,[],https://github.com/tempesta-tech/tempesta/pull/542,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/542#issuecomment-222362778,,Looks good for me,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,543,2016-05-30T13:59:26Z,2016-06-06T12:31:28Z,2016-06-06T12:31:32Z,MERGED,True,940,7,11,https://github.com/keshonok,"cache - location, cache-bypass, cache-fulfill",3,[],https://github.com/tempesta-tech/tempesta/pull/543,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/543,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,543,2016-05-30T13:59:26Z,2016-06-06T12:31:28Z,2016-06-06T12:31:32Z,MERGED,True,940,7,11,https://github.com/keshonok,"cache - location, cache-bypass, cache-fulfill",3,[],https://github.com/tempesta-tech/tempesta/pull/543,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/543#issuecomment-223825464,,"Well done! Good to merge after small cleanups.
Please describe the new finctionality with example, like it's described in the issue, in README.md and make description & default configuration in etc/tempesta_fw.conf",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,545,2016-06-01T12:55:03Z,2016-06-05T11:56:50Z,2016-06-09T09:40:53Z,MERGED,True,282,96,3,https://github.com/keshonok, 	Handle a response that is terminated by closing the connection.,3,[],https://github.com/tempesta-tech/tempesta/pull/545,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/545,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,545,2016-06-01T12:55:03Z,2016-06-05T11:56:50Z,2016-06-09T09:40:53Z,MERGED,True,282,96,3,https://github.com/keshonok, 	Handle a response that is terminated by closing the connection.,3,[],https://github.com/tempesta-tech/tempesta/pull/545,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/545#issuecomment-223806124,,good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,546,2016-06-01T20:55:53Z,2016-06-05T09:00:50Z,2016-06-05T09:00:52Z,MERGED,True,60,27,2,https://github.com/milabs,Fix bugs in implementation of __hdr_append,4,[],https://github.com/tempesta-tech/tempesta/pull/546,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/546,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,547,2016-06-01T22:05:41Z,2016-06-04T20:21:42Z,2016-06-04T20:21:44Z,MERGED,True,1,1,1,https://github.com/milabs,Fix CID 78558,1,[],https://github.com/tempesta-tech/tempesta/pull/547,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/547,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,547,2016-06-01T22:05:41Z,2016-06-04T20:21:42Z,2016-06-04T20:21:44Z,MERGED,True,1,1,1,https://github.com/milabs,Fix CID 78558,1,[],https://github.com/tempesta-tech/tempesta/pull/547,https://github.com/keshonok,2,https://github.com/tempesta-tech/tempesta/pull/547#issuecomment-223208990,,Looks good to me.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,547,2016-06-01T22:05:41Z,2016-06-04T20:21:42Z,2016-06-04T20:21:44Z,MERGED,True,1,1,1,https://github.com/milabs,Fix CID 78558,1,[],https://github.com/tempesta-tech/tempesta/pull/547,https://github.com/krizhanovsky,3,https://github.com/tempesta-tech/tempesta/pull/547#issuecomment-223776104,,good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,548,2016-06-01T22:14:31Z,2016-06-04T21:18:44Z,2016-06-04T21:18:46Z,MERGED,True,7,2,1,https://github.com/milabs,Fix CID 78557,1,[],https://github.com/tempesta-tech/tempesta/pull/548,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/548,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,548,2016-06-01T22:14:31Z,2016-06-04T21:18:44Z,2016-06-04T21:18:46Z,MERGED,True,7,2,1,https://github.com/milabs,Fix CID 78557,1,[],https://github.com/tempesta-tech/tempesta/pull/548,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/548#issuecomment-223778407,,good to merge with the fixe and cleanups,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,549,2016-06-02T14:12:35Z,2016-06-05T14:27:29Z,2016-06-05T14:29:25Z,MERGED,True,74,9,2,https://github.com/keshonok,Process the Pragma header field in requests. (#526),1,[],https://github.com/tempesta-tech/tempesta/pull/549,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/549,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,549,2016-06-02T14:12:35Z,2016-06-05T14:27:29Z,2016-06-05T14:29:25Z,MERGED,True,74,9,2,https://github.com/keshonok,Process the Pragma header field in requests. (#526),1,[],https://github.com/tempesta-tech/tempesta/pull/549,https://github.com/milabs,2,https://github.com/tempesta-tech/tempesta/pull/549#issuecomment-223305424,,Looks good.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,550,2016-06-02T15:39:47Z,2016-09-17T19:00:22Z,2016-10-17T20:22:29Z,CLOSED,False,6276,0,21,https://github.com/dmleontiev9000,SSE parser,56,[],https://github.com/tempesta-tech/tempesta/pull/550,https://github.com/dmleontiev9000,1,https://github.com/tempesta-tech/tempesta/pull/550,"current version of parser is located in files http_parser.h, http_parser.c, http_parser_impl.c
http_parser_impl.c contains body of parser function, which can be tuned by external definitions.
right now FAST_FORWARD option is supported, which enabled parser to quickly ""scroll"" over long headers.
sse_parser.c/h should be considered broken. it will be removed as soon as all algorithms will be ported to new version","current version of parser is located in files http_parser.h, http_parser.c, http_parser_impl.c
http_parser_impl.c contains body of parser function, which can be tuned by external definitions.
right now FAST_FORWARD option is supported, which enabled parser to quickly ""scroll"" over long headers.
sse_parser.c/h should be considered broken. it will be removed as soon as all algorithms will be ported to new version",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,550,2016-06-02T15:39:47Z,2016-09-17T19:00:22Z,2016-10-17T20:22:29Z,CLOSED,False,6276,0,21,https://github.com/dmleontiev9000,SSE parser,56,[],https://github.com/tempesta-tech/tempesta/pull/550,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/550#issuecomment-247797835,"current version of parser is located in files http_parser.h, http_parser.c, http_parser_impl.c
http_parser_impl.c contains body of parser function, which can be tuned by external definitions.
right now FAST_FORWARD option is supported, which enabled parser to quickly ""scroll"" over long headers.
sse_parser.c/h should be considered broken. it will be removed as soon as all algorithms will be ported to new version",Senseless patch,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,553,2016-06-03T13:26:31Z,2016-06-05T14:25:24Z,2016-06-05T14:25:25Z,MERGED,True,71,8,3,https://github.com/milabs,ss-skb: prevent expanding tail of splitted SKB,2,[],https://github.com/tempesta-tech/tempesta/pull/553,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/553,"When modifying SKB's data, Tempesta may map a piece of skb's linear
data to a paged fragment. That leads to the following complications
that may result in data corruption:

Once that kind of data mapping is done, any subsequent skb
modification cannot use the fast path optimization where skb->tail
is moved forward towards skb->end.

This fixes the problem by adding tail locking ability when skb->peeked
is used as a locked/unlocked flag.
Related to #503.","When modifying SKB's data, Tempesta may map a piece of skb's linear
data to a paged fragment. That leads to the following complications
that may result in data corruption:

Once that kind of data mapping is done, any subsequent skb
modification cannot use the fast path optimization where skb->tail
is moved forward towards skb->end.

This fixes the problem by adding tail locking ability when skb->peeked
is used as a locked/unlocked flag.
Related to #503.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,554,2016-06-04T14:35:37Z,2016-06-04T14:50:38Z,2016-06-04T14:50:41Z,MERGED,True,13,0,1,https://github.com/milabs,sock: drop zero-sized SKBs while in ss_do_send,1,[],https://github.com/tempesta-tech/tempesta/pull/554,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/554,Fixes #551.,Fixes #551.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,554,2016-06-04T14:35:37Z,2016-06-04T14:50:38Z,2016-06-04T14:50:41Z,MERGED,True,13,0,1,https://github.com/milabs,sock: drop zero-sized SKBs while in ss_do_send,1,[],https://github.com/tempesta-tech/tempesta/pull/554,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/554#issuecomment-223759428,Fixes #551.,good for me,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,555,2016-06-09T13:51:54Z,2016-06-15T19:02:04Z,2016-06-15T19:02:06Z,MERGED,True,24,21,1,https://github.com/milabs,Update linux-4.1-tfw.patch,1,[],https://github.com/tempesta-tech/tempesta/pull/555,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/555,Related to #411.,Related to #411.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,555,2016-06-09T13:51:54Z,2016-06-15T19:02:04Z,2016-06-15T19:02:06Z,MERGED,True,24,21,1,https://github.com/milabs,Update linux-4.1-tfw.patch,1,[],https://github.com/tempesta-tech/tempesta/pull/555,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/555#issuecomment-226271357,Related to #411.,good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,556,2016-06-10T18:51:56Z,2016-06-20T21:36:02Z,2016-07-12T13:36:23Z,CLOSED,False,80,2,3,https://github.com/avbelov23,Storing Responses to Authenticated Requests (#3),1,[],https://github.com/tempesta-tech/tempesta/pull/556,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/556,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,556,2016-06-10T18:51:56Z,2016-06-20T21:36:02Z,2016-07-12T13:36:23Z,CLOSED,False,80,2,3,https://github.com/avbelov23,Storing Responses to Authenticated Requests (#3),1,[],https://github.com/tempesta-tech/tempesta/pull/556,https://github.com/keshonok,2,https://github.com/tempesta-tech/tempesta/pull/556#issuecomment-227277083,,Major part of this pull request has been merged into #559. Thanks!,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,557,2016-06-11T16:38:47Z,2016-06-16T20:59:24Z,2016-06-16T20:59:26Z,MERGED,True,104,78,3,https://github.com/milabs,rework __lookup_pgfrag_room,2,[],https://github.com/tempesta-tech/tempesta/pull/557,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/557,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,557,2016-06-11T16:38:47Z,2016-06-16T20:59:24Z,2016-06-16T20:59:26Z,MERGED,True,104,78,3,https://github.com/milabs,rework __lookup_pgfrag_room,2,[],https://github.com/tempesta-tech/tempesta/pull/557,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/557#issuecomment-226550376,,Good to merge with small cleanups and improvements,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,558,2016-06-15T13:47:55Z,2016-06-20T21:34:53Z,2016-07-12T13:38:42Z,MERGED,True,437,30,9,https://github.com/keshonok,Implement manual cache purging using HTTP PURGE method. (#501),5,[],https://github.com/tempesta-tech/tempesta/pull/558,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/558,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,558,2016-06-15T13:47:55Z,2016-06-20T21:34:53Z,2016-07-12T13:38:42Z,MERGED,True,437,30,9,https://github.com/keshonok,Implement manual cache purging using HTTP PURGE method. (#501),5,[],https://github.com/tempesta-tech/tempesta/pull/558,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/558#issuecomment-226561773,,"This is new functionality, so please update cache chapter in README.md.
Please also create a test issue for @sergsever which should check PURGE functionality.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,559,2016-06-15T13:49:38Z,2016-06-20T21:32:19Z,2016-07-12T13:34:11Z,MERGED,True,930,418,4,https://github.com/keshonok,Implement various cache-related features,9,[],https://github.com/tempesta-tech/tempesta/pull/559,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/559,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,562,2016-06-17T13:20:48Z,2016-06-19T16:46:28Z,2016-06-19T16:49:16Z,MERGED,True,128,3,5,https://github.com/keshonok,Implement hdr_via directive. Add Via: header to all messages. (#524),2,[],https://github.com/tempesta-tech/tempesta/pull/562,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/562,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,562,2016-06-17T13:20:48Z,2016-06-19T16:46:28Z,2016-06-19T16:49:16Z,MERGED,True,128,3,5,https://github.com/keshonok,Implement hdr_via directive. Add Via: header to all messages. (#524),2,[],https://github.com/tempesta-tech/tempesta/pull/562,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/562#issuecomment-226773967,,good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,566,2016-06-19T20:01:28Z,2016-06-24T17:29:55Z,2016-06-24T17:29:58Z,MERGED,True,117,51,3,https://github.com/milabs,Get rid of skb_unclone in ss_tcp_process_data,2,[],https://github.com/tempesta-tech/tempesta/pull/566,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/566,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,566,2016-06-19T20:01:28Z,2016-06-24T17:29:55Z,2016-06-24T17:29:58Z,MERGED,True,117,51,3,https://github.com/milabs,Get rid of skb_unclone in ss_tcp_process_data,2,[],https://github.com/tempesta-tech/tempesta/pull/566,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/566#issuecomment-228196908,,"Ok, just write TODO comment near from consume_skb() to optimize skb reallocation and merge the fix to master.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,567,2016-06-22T14:00:56Z,2016-06-23T13:06:51Z,2016-06-23T13:06:53Z,MERGED,True,38,24,5,https://github.com/milabs,Use eolen with __hdr_add,3,[],https://github.com/tempesta-tech/tempesta/pull/567,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/567,#561,#561,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,567,2016-06-22T14:00:56Z,2016-06-23T13:06:51Z,2016-06-23T13:06:53Z,MERGED,True,38,24,5,https://github.com/milabs,Use eolen with __hdr_add,3,[],https://github.com/tempesta-tech/tempesta/pull/567,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/567#issuecomment-228040907,#561,Basically looks good for me,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,568,2016-06-22T20:31:44Z,2016-06-22T22:46:59Z,2016-06-22T22:47:01Z,MERGED,True,12,13,4,https://github.com/milabs,wq: add sync flag to __tfw_wq_push,1,[],https://github.com/tempesta-tech/tempesta/pull/568,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/568,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,568,2016-06-22T20:31:44Z,2016-06-22T22:46:59Z,2016-06-22T22:47:01Z,MERGED,True,12,13,4,https://github.com/milabs,wq: add sync flag to __tfw_wq_push,1,[],https://github.com/tempesta-tech/tempesta/pull/568,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/568#issuecomment-227891396,,good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,569,2016-06-23T12:10:13Z,2016-06-23T21:52:22Z,2016-06-23T21:52:25Z,MERGED,True,11,3,1,https://github.com/keshonok,"Correctly process ""Content-Length: 0"" case. (#563)",1,[],https://github.com/tempesta-tech/tempesta/pull/569,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/569,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,569,2016-06-23T12:10:13Z,2016-06-23T21:52:22Z,2016-06-23T21:52:25Z,MERGED,True,11,3,1,https://github.com/keshonok,"Correctly process ""Content-Length: 0"" case. (#563)",1,[],https://github.com/tempesta-tech/tempesta/pull/569,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/569#issuecomment-228192576,,good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,570,2016-06-23T12:10:57Z,2016-06-23T21:54:43Z,2016-06-23T21:54:47Z,MERGED,True,11,1,1,https://github.com/keshonok,Store response's flags and HTTP version in cache entry.,1,[],https://github.com/tempesta-tech/tempesta/pull/570,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/570,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,570,2016-06-23T12:10:57Z,2016-06-23T21:54:43Z,2016-06-23T21:54:47Z,MERGED,True,11,1,1,https://github.com/keshonok,Store response's flags and HTTP version in cache entry.,1,[],https://github.com/tempesta-tech/tempesta/pull/570,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/570#issuecomment-228194563,,Good to merge with small cleanup,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,571,2016-06-23T21:53:05Z,2016-06-23T22:09:21Z,2016-06-23T22:09:23Z,MERGED,True,26,23,1,https://github.com/milabs,Update linux-4.1-tfw.patch,1,[],https://github.com/tempesta-tech/tempesta/pull/571,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/571,Related to #455.,Related to #455.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,572,2016-06-24T11:16:51Z,2016-07-07T19:31:58Z,2016-07-07T19:32:00Z,MERGED,True,44,36,1,https://github.com/milabs,http-msg: replace __hdr_append with __hdr_expand,1,[],https://github.com/tempesta-tech/tempesta/pull/572,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/572,"Instead of complete deletion followed by a complete insertion, it's
possible to overwrite part of the original header with data from the
substitute header, and add a bit more room for the rest of the
substitute header exactly where it is needed.
Related to #552.","Instead of complete deletion followed by a complete insertion, it's
possible to overwrite part of the original header with data from the
substitute header, and add a bit more room for the rest of the
substitute header exactly where it is needed.
Related to #552.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,572,2016-06-24T11:16:51Z,2016-07-07T19:31:58Z,2016-07-07T19:32:00Z,MERGED,True,44,36,1,https://github.com/milabs,http-msg: replace __hdr_append with __hdr_expand,1,[],https://github.com/tempesta-tech/tempesta/pull/572,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/572#issuecomment-228414877,"Instead of complete deletion followed by a complete insertion, it's
possible to overwrite part of the original header with data from the
substitute header, and add a bit more room for the rest of the
substitute header exactly where it is needed.
Related to #552.","looks good for me. @keshonok , please review as well",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,572,2016-06-24T11:16:51Z,2016-07-07T19:31:58Z,2016-07-07T19:32:00Z,MERGED,True,44,36,1,https://github.com/milabs,http-msg: replace __hdr_append with __hdr_expand,1,[],https://github.com/tempesta-tech/tempesta/pull/572,https://github.com/krizhanovsky,3,https://github.com/tempesta-tech/tempesta/pull/572#issuecomment-229072875,"Instead of complete deletion followed by a complete insertion, it's
possible to overwrite part of the original header with data from the
substitute header, and add a bit more room for the rest of the
substitute header exactly where it is needed.
Related to #552.",Looks good for me,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,573,2016-06-24T13:55:32Z,2016-09-17T18:59:54Z,2016-10-17T20:23:12Z,CLOSED,False,14774,9,44,https://github.com/dmleontiev9000,Dl issue 182,71,[],https://github.com/tempesta-tech/tempesta/pull/573,https://github.com/dmleontiev9000,1,https://github.com/tempesta-tech/tempesta/pull/573,"Tempesta parser was cut from main source tree and supporting code was refactored for testing in standalone environment. Tempesta parser was patched with AVX insertions in performance critical places, but otherwise remains intact and can be transferred back to it's original position.","Tempesta parser was cut from main source tree and supporting code was refactored for testing in standalone environment. Tempesta parser was patched with AVX insertions in performance critical places, but otherwise remains intact and can be transferred back to it's original position.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,573,2016-06-24T13:55:32Z,2016-09-17T18:59:54Z,2016-10-17T20:23:12Z,CLOSED,False,14774,9,44,https://github.com/dmleontiev9000,Dl issue 182,71,[],https://github.com/tempesta-tech/tempesta/pull/573,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/573#issuecomment-229653270,"Tempesta parser was cut from main source tree and supporting code was refactored for testing in standalone environment. Tempesta parser was patched with AVX insertions in performance critical places, but otherwise remains intact and can be transferred back to it's original position.","The code doesn't comply our coding style, please adjust the style.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,573,2016-06-24T13:55:32Z,2016-09-17T18:59:54Z,2016-10-17T20:23:12Z,CLOSED,False,14774,9,44,https://github.com/dmleontiev9000,Dl issue 182,71,[],https://github.com/tempesta-tech/tempesta/pull/573,https://github.com/krizhanovsky,3,https://github.com/tempesta-tech/tempesta/pull/573#issuecomment-229657693,"Tempesta parser was cut from main source tree and supporting code was refactored for testing in standalone environment. Tempesta parser was patched with AVX insertions in performance critical places, but otherwise remains intact and can be transferred back to it's original position.","What's going on in tempesta_fw/t/unit/dl-182? It seems there should be test/benchmark for HTTP parser, but why do you copy skb stuff there? Please look at other unit tests.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,573,2016-06-24T13:55:32Z,2016-09-17T18:59:54Z,2016-10-17T20:23:12Z,CLOSED,False,14774,9,44,https://github.com/dmleontiev9000,Dl issue 182,71,[],https://github.com/tempesta-tech/tempesta/pull/573,https://github.com/krizhanovsky,4,https://github.com/tempesta-tech/tempesta/pull/573#issuecomment-247797800,"Tempesta parser was cut from main source tree and supporting code was refactored for testing in standalone environment. Tempesta parser was patched with AVX insertions in performance critical places, but otherwise remains intact and can be transferred back to it's original position.",Poorly done,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,574,2016-06-29T21:20:27Z,2016-07-13T14:15:21Z,2016-07-13T14:15:24Z,MERGED,True,113,110,12,https://github.com/milabs,SS: Proper TCP options,2,[],https://github.com/tempesta-tech/tempesta/pull/574,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/574,This fixes #475,This fixes #475,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,574,2016-06-29T21:20:27Z,2016-07-13T14:15:21Z,2016-07-13T14:15:24Z,MERGED,True,113,110,12,https://github.com/milabs,SS: Proper TCP options,2,[],https://github.com/tempesta-tech/tempesta/pull/574,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/574#issuecomment-230172751,This fixes #475,"""use MSG_MORE to optimize packet size at IP layer"" in the original task #475 was mostly about https://github.com/tempesta-tech/linux-4.1-tfw/blob/master/net/ipv4/tcp.c#L688: don't send partial TCP segements, so it's good to implement the option.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,574,2016-06-29T21:20:27Z,2016-07-13T14:15:21Z,2016-07-13T14:15:24Z,MERGED,True,113,110,12,https://github.com/milabs,SS: Proper TCP options,2,[],https://github.com/tempesta-tech/tempesta/pull/574,https://github.com/krizhanovsky,3,https://github.com/tempesta-tech/tempesta/pull/574#issuecomment-230174494,This fixes #475,"Please, review possible bug in ss_do_close(): the function returns (here and here) after socket reference counter incrementing. So it seems socket descriptor leakage is possible.
IIRC we enter ss_do_close() with zero refcounter of the socket, so we don't need to do sock_put() twice (in inet_csk_destroy_sock() and at below of the function) as standard tcp_close() does it. However, if we return from the function we never reach zero refcounter on following ss_do_close() calls.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,574,2016-06-29T21:20:27Z,2016-07-13T14:15:21Z,2016-07-13T14:15:24Z,MERGED,True,113,110,12,https://github.com/milabs,SS: Proper TCP options,2,[],https://github.com/tempesta-tech/tempesta/pull/574,https://github.com/milabs,4,https://github.com/tempesta-tech/tempesta/pull/574#issuecomment-230759789,This fixes #475,"@krizhanovsky Well, ss_do_close always followed by the sock_put, so I do not see the problem with descriptor leakage you've mentioned. Am I missed something?",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,574,2016-06-29T21:20:27Z,2016-07-13T14:15:21Z,2016-07-13T14:15:24Z,MERGED,True,113,110,12,https://github.com/milabs,SS: Proper TCP options,2,[],https://github.com/tempesta-tech/tempesta/pull/574,https://github.com/krizhanovsky,5,https://github.com/tempesta-tech/tempesta/pull/574#issuecomment-231162182,This fixes #475,"@milabs , ""Well, ss_do_close always followed by the sock_put, so I do not see the problem with descriptor leakage you've mentioned. Am I missed something?""
Oh, I see. Thanks.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,574,2016-06-29T21:20:27Z,2016-07-13T14:15:21Z,2016-07-13T14:15:24Z,MERGED,True,113,110,12,https://github.com/milabs,SS: Proper TCP options,2,[],https://github.com/tempesta-tech/tempesta/pull/574,https://github.com/krizhanovsky,6,https://github.com/tempesta-tech/tempesta/pull/574#issuecomment-232357566,This fixes #475,good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,575,2016-06-30T11:46:43Z,2016-06-30T12:32:52Z,2016-06-30T12:32:59Z,MERGED,True,10,8,3,https://github.com/keshonok,More informative message on work queue overrun.,1,[],https://github.com/tempesta-tech/tempesta/pull/575,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/575,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,575,2016-06-30T11:46:43Z,2016-06-30T12:32:52Z,2016-06-30T12:32:59Z,MERGED,True,10,8,3,https://github.com/keshonok,More informative message on work queue overrun.,1,[],https://github.com/tempesta-tech/tempesta/pull/575,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/575#issuecomment-229639167,,good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,577,2016-07-06T14:01:32Z,2016-07-08T16:59:06Z,2016-07-08T16:59:09Z,MERGED,True,16,8,1,https://github.com/keshonok,Schedule cache work to all available CPUs. (#576),1,[],https://github.com/tempesta-tech/tempesta/pull/577,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/577,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,577,2016-07-06T14:01:32Z,2016-07-08T16:59:06Z,2016-07-08T16:59:09Z,MERGED,True,16,8,1,https://github.com/keshonok,Schedule cache work to all available CPUs. (#576),1,[],https://github.com/tempesta-tech/tempesta/pull/577,https://github.com/milabs,2,https://github.com/tempesta-tech/tempesta/pull/577#issuecomment-230782360,,👍,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,577,2016-07-06T14:01:32Z,2016-07-08T16:59:06Z,2016-07-08T16:59:09Z,MERGED,True,16,8,1,https://github.com/keshonok,Schedule cache work to all available CPUs. (#576),1,[],https://github.com/tempesta-tech/tempesta/pull/577,https://github.com/krizhanovsky,3,https://github.com/tempesta-tech/tempesta/pull/577#issuecomment-231374040,,good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,579,2016-07-08T12:44:34Z,2016-07-09T23:18:43Z,2016-07-09T23:18:46Z,CLOSED,False,14,7,2,https://github.com/milabs,Prevent deadlock on net->ipv4.ip_local_ports.lock,1,[],https://github.com/tempesta-tech/tempesta/pull/579,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/579,Related to #578.,Related to #578.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,579,2016-07-08T12:44:34Z,2016-07-09T23:18:43Z,2016-07-09T23:18:46Z,CLOSED,False,14,7,2,https://github.com/milabs,Prevent deadlock on net->ipv4.ip_local_ports.lock,1,[],https://github.com/tempesta-tech/tempesta/pull/579,https://github.com/milabs,2,https://github.com/tempesta-tech/tempesta/pull/579#issuecomment-231561116,Related to #578.,This issue was fixed in linux kernel by 4ee3bd4a8c7463cdef0b82ebc33fc94a9170a7e0 commit.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,581,2016-07-10T20:40:21Z,2016-07-11T15:37:11Z,2016-07-11T15:37:23Z,MERGED,True,74,40,8,https://github.com/krizhanovsky,#576: fix infinite loop on work queue push(),4,[],https://github.com/tempesta-tech/tempesta/pull/581,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/581,Fix #576 (comment): do not try to push() socket close work synchronously if current context is the work queue consumer,Fix #576 (comment): do not try to push() socket close work synchronously if current context is the work queue consumer,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,582,2016-07-11T10:04:27Z,2016-08-29T08:15:37Z,2017-03-22T15:50:54Z,CLOSED,False,1118,827,21,https://github.com/sergsever,215,205,[],https://github.com/tempesta-tech/tempesta/pull/582,https://github.com/sergsever,1,https://github.com/tempesta-tech/tempesta/pull/582,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,584,2016-07-12T13:30:24Z,2016-07-14T11:27:15Z,2016-07-14T11:30:43Z,MERGED,True,15,12,2,https://github.com/milabs,Fix failover reference accounting (fixes #580),1,[],https://github.com/tempesta-tech/tempesta/pull/584,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/584,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,584,2016-07-12T13:30:24Z,2016-07-14T11:27:15Z,2016-07-14T11:30:43Z,MERGED,True,15,12,2,https://github.com/milabs,Fix failover reference accounting (fixes #580),1,[],https://github.com/tempesta-tech/tempesta/pull/584,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/584#issuecomment-232110783,,Basically good for me,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,584,2016-07-12T13:30:24Z,2016-07-14T11:27:15Z,2016-07-14T11:30:43Z,MERGED,True,15,12,2,https://github.com/milabs,Fix failover reference accounting (fixes #580),1,[],https://github.com/tempesta-tech/tempesta/pull/584,https://github.com/keshonok,3,https://github.com/tempesta-tech/tempesta/pull/584#issuecomment-232504959,,Looks good to me.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,584,2016-07-12T13:30:24Z,2016-07-14T11:27:15Z,2016-07-14T11:30:43Z,MERGED,True,15,12,2,https://github.com/milabs,Fix failover reference accounting (fixes #580),1,[],https://github.com/tempesta-tech/tempesta/pull/584,https://github.com/krizhanovsky,4,https://github.com/tempesta-tech/tempesta/pull/584#issuecomment-232619487,,Good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,585,2016-07-13T14:05:01Z,2016-07-14T11:30:29Z,2018-11-15T06:18:50Z,MERGED,True,23,0,1,https://github.com/milabs,Make a copy of IP-header while unrolling,1,[],https://github.com/tempesta-tech/tempesta/pull/585,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/585,"This fixes problem with ss_skb_fmt_src_addr() which is called from the
tfw_http_add_x_forwarded_for() function. In case of GRO, unrollong
process can take place and orignal SKB metadata will be lost.","This fixes problem with ss_skb_fmt_src_addr() which is called from the
tfw_http_add_x_forwarded_for() function. In case of GRO, unrollong
process can take place and orignal SKB metadata will be lost.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,585,2016-07-13T14:05:01Z,2016-07-14T11:30:29Z,2018-11-15T06:18:50Z,MERGED,True,23,0,1,https://github.com/milabs,Make a copy of IP-header while unrolling,1,[],https://github.com/tempesta-tech/tempesta/pull/585,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/585#issuecomment-232452106,"This fixes problem with ss_skb_fmt_src_addr() which is called from the
tfw_http_add_x_forwarded_for() function. In case of GRO, unrollong
process can take place and orignal SKB metadata will be lost.","Ok, looks good for me. But please write good comment following our discussion which describes why do we copy the header.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,586,2016-07-13T18:40:40Z,2016-07-14T08:44:54Z,2016-07-14T08:44:58Z,MERGED,True,28,4,1,https://github.com/keshonok,Comment the reasons for having ss_skb_unroll().,1,[],https://github.com/tempesta-tech/tempesta/pull/586,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/586,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,586,2016-07-13T18:40:40Z,2016-07-14T08:44:54Z,2016-07-14T08:44:58Z,MERGED,True,28,4,1,https://github.com/keshonok,Comment the reasons for having ss_skb_unroll().,1,[],https://github.com/tempesta-tech/tempesta/pull/586,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/586#issuecomment-232586786,,good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,587,2016-07-18T08:56:38Z,2017-01-16T14:35:40Z,2017-03-22T15:50:36Z,CLOSED,False,897,238,17,https://github.com/sergsever,Sl-490,3,[],https://github.com/tempesta-tech/tempesta/pull/587,https://github.com/sergsever,1,https://github.com/tempesta-tech/tempesta/pull/587,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,589,2016-07-20T11:27:19Z,2016-07-28T12:47:55Z,2016-07-28T12:48:11Z,CLOSED,False,19,5,3,https://github.com/sergsever,fix #1,19,[],https://github.com/tempesta-tech/tempesta/pull/589,https://github.com/sergsever,1,https://github.com/tempesta-tech/tempesta/pull/589,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,591,2016-07-23T20:21:35Z,2016-08-03T09:23:20Z,2016-08-03T09:23:23Z,MERGED,True,4,1,1,https://github.com/milabs,Fix NULL-pointer dereference when response is served from the cached …,1,[],https://github.com/tempesta-tech/tempesta/pull/591,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/591,…(fixes #588),…(fixes #588),True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,591,2016-07-23T20:21:35Z,2016-08-03T09:23:20Z,2016-08-03T09:23:23Z,MERGED,True,4,1,1,https://github.com/milabs,Fix NULL-pointer dereference when response is served from the cached …,1,[],https://github.com/tempesta-tech/tempesta/pull/591,https://github.com/keshonok,2,https://github.com/tempesta-tech/tempesta/pull/591#issuecomment-236138289,…(fixes #588),Looks good to me.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,591,2016-07-23T20:21:35Z,2016-08-03T09:23:20Z,2016-08-03T09:23:23Z,MERGED,True,4,1,1,https://github.com/milabs,Fix NULL-pointer dereference when response is served from the cached …,1,[],https://github.com/tempesta-tech/tempesta/pull/591,https://github.com/krizhanovsky,3,https://github.com/tempesta-tech/tempesta/pull/591#issuecomment-236991758,…(fixes #588),good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,592,2016-07-29T06:22:46Z,2016-08-03T18:25:31Z,2016-08-03T18:26:07Z,CLOSED,False,15,3,3,https://github.com/sergsever,fix #1,8,[],https://github.com/tempesta-tech/tempesta/pull/592,https://github.com/sergsever,1,https://github.com/tempesta-tech/tempesta/pull/592,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,592,2016-07-29T06:22:46Z,2016-08-03T18:25:31Z,2016-08-03T18:26:07Z,CLOSED,False,15,3,3,https://github.com/sergsever,fix #1,8,[],https://github.com/tempesta-tech/tempesta/pull/592,https://github.com/keshonok,2,https://github.com/tempesta-tech/tempesta/pull/592#issuecomment-236138154,,Looks good to me.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,594,2016-08-02T11:52:55Z,2016-09-20T15:17:39Z,2016-10-17T20:22:19Z,CLOSED,False,9,8,1,https://github.com/sergsever,Sl 477,13,[],https://github.com/tempesta-tech/tempesta/pull/594,https://github.com/sergsever,1,https://github.com/tempesta-tech/tempesta/pull/594,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,594,2016-08-02T11:52:55Z,2016-09-20T15:17:39Z,2016-10-17T20:22:19Z,CLOSED,False,9,8,1,https://github.com/sergsever,Sl 477,13,[],https://github.com/tempesta-tech/tempesta/pull/594,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/594#issuecomment-248314000,,"Ok, then good to merge. http_match.c is subject for rework in context of TL development, so we can ignore it for now.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,595,2016-08-03T09:23:44Z,2016-08-23T20:07:32Z,2016-08-23T20:07:35Z,CLOSED,False,3563,1248,161,https://github.com/milabs,tls: add the implementation,2,[],https://github.com/tempesta-tech/tempesta/pull/595,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/595,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,595,2016-08-03T09:23:44Z,2016-08-23T20:07:32Z,2016-08-23T20:07:35Z,CLOSED,False,3563,1248,161,https://github.com/milabs,tls: add the implementation,2,[],https://github.com/tempesta-tech/tempesta/pull/595,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/595#issuecomment-238047490,,It seems tempesta/scripts/tempesta.sh should be updated to load/unload ttls module,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,595,2016-08-03T09:23:44Z,2016-08-23T20:07:32Z,2016-08-23T20:07:35Z,CLOSED,False,3563,1248,161,https://github.com/milabs,tls: add the implementation,2,[],https://github.com/tempesta-tech/tempesta/pull/595,https://github.com/krizhanovsky,3,https://github.com/tempesta-tech/tempesta/pull/595#issuecomment-238048291,,"Since the PR also contains updated and ported to Linux kernel version of mbedTLS, then all comments from #597 are applicable to the PR as well.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,595,2016-08-03T09:23:44Z,2016-08-23T20:07:32Z,2016-08-23T20:07:35Z,CLOSED,False,3563,1248,161,https://github.com/milabs,tls: add the implementation,2,[],https://github.com/tempesta-tech/tempesta/pull/595,https://github.com/milabs,4,https://github.com/tempesta-tech/tempesta/pull/595#issuecomment-241859756,,Improved and merged within #603,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,596,2016-08-03T11:12:23Z,2016-08-06T00:57:59Z,2016-08-23T20:45:36Z,CLOSED,False,2920,21,19,https://github.com/milabs,mbedtls-mini: it works (occasionally),1,[],https://github.com/tempesta-tech/tempesta/pull/596,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/596,Review-only branch.,Review-only branch.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,597,2016-08-06T00:49:49Z,2016-08-08T22:06:41Z,2016-08-08T22:06:44Z,MERGED,True,3410,68188,587,https://github.com/milabs,ttls: update to mbedTLS 2.3.0 (GPL) version,2,[],https://github.com/tempesta-tech/tempesta/pull/597,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/597,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,597,2016-08-06T00:49:49Z,2016-08-08T22:06:41Z,2016-08-08T22:06:44Z,MERGED,True,3410,68188,587,https://github.com/milabs,ttls: update to mbedTLS 2.3.0 (GPL) version,2,[],https://github.com/tempesta-tech/tempesta/pull/597,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/597#issuecomment-238266497,,Please move ttls/ content to tls since there is only README.md and merge to master,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,599,2016-08-11T11:06:31Z,2016-08-11T21:04:32Z,2016-08-11T21:04:34Z,MERGED,True,47,2,3,https://github.com/milabs,ttls: add threading (locking) implementation,1,[],https://github.com/tempesta-tech/tempesta/pull/599,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/599,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,599,2016-08-11T11:06:31Z,2016-08-11T21:04:32Z,2016-08-11T21:04:34Z,MERGED,True,47,2,3,https://github.com/milabs,ttls: add threading (locking) implementation,1,[],https://github.com/tempesta-tech/tempesta/pull/599,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/599#issuecomment-239264916,,Looks good for me,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,600,2016-08-13T21:22:33Z,2016-08-16T18:52:26Z,2016-10-12T14:04:00Z,MERGED,True,1295,904,24,https://github.com/krizhanovsky,Fix #235:,3,[],https://github.com/tempesta-tech/tempesta/pull/600,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/600,"Introduce clients hash table, now new connection just get()'s TfwClient;
Since client can have many HTTP sessions, TfwSession is introduced to
handle different sticky cookies for the same client;
Now received sticky cookie is verified, so timestamp is added to cookie value;
To keep HTTP sessions persistent sticky_secret config option is introduced;
Config option sess_lifetime is also introduced to limit sessions lifetime;
Sticky cookie is just a mechanism for HTTP sessions, so http_sticky is renamed
to http_sess;
tfw_addr_get_sk_saddr() was removed as doubling for ss_getpeername();
TfwHttpMsg was replaced by TfwHttpReq and TfwHttpResp to make the logic explicit
about what the arguements are;
tfw_http_prep_hexstring() is removed since there are standard bin2hex().","Introduce clients hash table, now new connection just get()'s TfwClient;
Since client can have many HTTP sessions, TfwSession is introduced to
handle different sticky cookies for the same client;
Now received sticky cookie is verified, so timestamp is added to cookie value;
To keep HTTP sessions persistent sticky_secret config option is introduced;
Config option sess_lifetime is also introduced to limit sessions lifetime;
Sticky cookie is just a mechanism for HTTP sessions, so http_sticky is renamed
to http_sess;
tfw_addr_get_sk_saddr() was removed as doubling for ss_getpeername();
TfwHttpMsg was replaced by TfwHttpReq and TfwHttpResp to make the logic explicit
about what the arguements are;
tfw_http_prep_hexstring() is removed since there are standard bin2hex().",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,601,2016-08-15T10:14:49Z,2016-09-16T09:15:07Z,2016-09-16T09:15:13Z,MERGED,True,1339,30,14,https://github.com/keshonok,Implement APM stats for server response times. (#564),8,[],https://github.com/tempesta-tech/tempesta/pull/601,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/601,"Response time for each request is accumulated over a predefined time
period for each configured back end server, and used for calculation
of percentiles. Accumulated data for the latest time period is used
in the calculation. That gives a fresh impression on the performance
of a specific server.
Server's APM stats are available now by reading the file in /proc:
/proc/tempesta/servers/:","Response time for each request is accumulated over a predefined time
period for each configured back end server, and used for calculation
of percentiles. Accumulated data for the latest time period is used
in the calculation. That gives a fresh impression on the performance
of a specific server.
Server's APM stats are available now by reading the file in /proc:
/proc/tempesta/servers/:",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,601,2016-08-15T10:14:49Z,2016-09-16T09:15:07Z,2016-09-16T09:15:13Z,MERGED,True,1339,30,14,https://github.com/keshonok,Implement APM stats for server response times. (#564),8,[],https://github.com/tempesta-tech/tempesta/pull/601,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/601#issuecomment-240182042,"Response time for each request is accumulated over a predefined time
period for each configured back end server, and used for calculation
of percentiles. Accumulated data for the latest time period is used
in the calculation. That gives a fresh impression on the performance
of a specific server.
Server's APM stats are available now by reading the file in /proc:
/proc/tempesta/servers/:","Also please update the unit test with ""bad"" cases which the algorithm does poor calculations on.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,601,2016-08-15T10:14:49Z,2016-09-16T09:15:07Z,2016-09-16T09:15:13Z,MERGED,True,1339,30,14,https://github.com/keshonok,Implement APM stats for server response times. (#564),8,[],https://github.com/tempesta-tech/tempesta/pull/601,https://github.com/krizhanovsky,3,https://github.com/tempesta-tech/tempesta/pull/601#issuecomment-247358846,"Response time for each request is accumulated over a predefined time
period for each configured back end server, and used for calculation
of percentiles. Accumulated data for the latest time period is used
in the calculation. That gives a fresh impression on the performance
of a specific server.
Server's APM stats are available now by reading the file in /proc:
/proc/tempesta/servers/:","Ok, looks good for me.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,603,2016-08-18T11:32:15Z,2016-08-23T20:03:54Z,2016-08-23T20:45:38Z,MERGED,True,764,140,19,https://github.com/milabs,tls: add the implementation (v1),11,[],https://github.com/tempesta-tech/tempesta/pull/603,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/603,"This adds stable TLS support based on mbedTLS library.
TODO:

 FSM for TLS","This adds stable TLS support based on mbedTLS library.
TODO:

 FSM for TLS",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,603,2016-08-18T11:32:15Z,2016-08-23T20:03:54Z,2016-08-23T20:45:38Z,MERGED,True,764,140,19,https://github.com/milabs,tls: add the implementation (v1),11,[],https://github.com/tempesta-tech/tempesta/pull/603,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/603#issuecomment-241852897,"This adds stable TLS support based on mbedTLS library.
TODO:

 FSM for TLS",good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,604,2016-08-23T01:29:11Z,2016-08-23T01:29:50Z,2016-08-23T20:45:02Z,CLOSED,False,746,149,20,https://github.com/milabs,Fix #602,11,[],https://github.com/tempesta-tech/tempesta/pull/604,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/604,Based on TLS branch,Based on TLS branch,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,604,2016-08-23T01:29:11Z,2016-08-23T01:29:50Z,2016-08-23T20:45:02Z,CLOSED,False,746,149,20,https://github.com/milabs,Fix #602,11,[],https://github.com/tempesta-tech/tempesta/pull/604,https://github.com/milabs,2,https://github.com/tempesta-tech/tempesta/pull/604#issuecomment-241601162,Based on TLS branch,Erroneous base branch was selected for that PR.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,605,2016-08-23T01:29:26Z,2016-08-23T20:45:00Z,2016-08-23T20:45:02Z,MERGED,True,8,9,3,https://github.com/milabs,Fix #602,1,[],https://github.com/tempesta-tech/tempesta/pull/605,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/605,Based on TLS branch,Based on TLS branch,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,605,2016-08-23T01:29:26Z,2016-08-23T20:45:00Z,2016-08-23T20:45:02Z,MERGED,True,8,9,3,https://github.com/milabs,Fix #602,1,[],https://github.com/tempesta-tech/tempesta/pull/605,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/605#issuecomment-241853391,Based on TLS branch,Good for me. @keshonok could you please have a look as well?,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,605,2016-08-23T01:29:26Z,2016-08-23T20:45:00Z,2016-08-23T20:45:02Z,MERGED,True,8,9,3,https://github.com/milabs,Fix #602,1,[],https://github.com/tempesta-tech/tempesta/pull/605,https://github.com/keshonok,3,https://github.com/tempesta-tech/tempesta/pull/605#issuecomment-241867686,Based on TLS branch,Looks good to me.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,607,2016-08-25T20:15:02Z,2016-08-26T07:35:39Z,2016-08-26T07:35:42Z,MERGED,True,1,3,1,https://github.com/milabs,http-parser: remove erroneous isdigit check when parsing day,1,[],https://github.com/tempesta-tech/tempesta/pull/607,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/607,"It's incorrect to check for digit before calling parse_int_ws() as there
may be delimiter at the start of chunk. Also, check for upper day limit.
Fixes #606.","It's incorrect to check for digit before calling parse_int_ws() as there
may be delimiter at the start of chunk. Also, check for upper day limit.
Fixes #606.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,607,2016-08-25T20:15:02Z,2016-08-26T07:35:39Z,2016-08-26T07:35:42Z,MERGED,True,1,3,1,https://github.com/milabs,http-parser: remove erroneous isdigit check when parsing day,1,[],https://github.com/tempesta-tech/tempesta/pull/607,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/607#issuecomment-242534531,"It's incorrect to check for digit before calling parse_int_ws() as there
may be delimiter at the start of chunk. Also, check for upper day limit.
Fixes #606.",good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,608,2016-08-26T15:28:25Z,2018-05-13T15:01:39Z,2018-05-13T15:02:08Z,CLOSED,False,11732,26,10,https://github.com/milabs,Add FSM for the TLS,3,[],https://github.com/tempesta-tech/tempesta/pull/608,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/608,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,608,2016-08-26T15:28:25Z,2018-05-13T15:01:39Z,2018-05-13T15:02:08Z,CLOSED,False,11732,26,10,https://github.com/milabs,Add FSM for the TLS,3,[],https://github.com/tempesta-tech/tempesta/pull/608,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/608#issuecomment-388633405,,I close the poorly designed PR in favour to the new implementation.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,609,2016-08-26T21:56:34Z,2016-08-30T18:40:46Z,2017-01-02T18:26:09Z,CLOSED,False,10,1,2,https://github.com/milabs,Fix a bug while unloading with no connection to the backend,1,[],https://github.com/tempesta-tech/tempesta/pull/609,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/609,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,610,2016-08-29T08:16:36Z,2017-01-05T15:44:46Z,2017-03-22T15:50:10Z,CLOSED,False,603,689,20,https://github.com/sergsever,fix #215,85,[],https://github.com/tempesta-tech/tempesta/pull/610,https://github.com/sergsever,1,https://github.com/tempesta-tech/tempesta/pull/610,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,612,2016-08-31T12:21:48Z,2016-08-31T14:24:39Z,2016-08-31T14:24:42Z,MERGED,True,24,28,2,https://github.com/milabs,Update TLS configuration manual,2,[],https://github.com/tempesta-tech/tempesta/pull/612,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/612,Add an example of how to generate and use self-signed certificate.,Add an example of how to generate and use self-signed certificate.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,612,2016-08-31T12:21:48Z,2016-08-31T14:24:39Z,2016-08-31T14:24:42Z,MERGED,True,24,28,2,https://github.com/milabs,Update TLS configuration manual,2,[],https://github.com/tempesta-tech/tempesta/pull/612,https://github.com/keshonok,2,https://github.com/tempesta-tech/tempesta/pull/612#issuecomment-243751637,Add an example of how to generate and use self-signed certificate.,Looks perfect to me.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,612,2016-08-31T12:21:48Z,2016-08-31T14:24:39Z,2016-08-31T14:24:42Z,MERGED,True,24,28,2,https://github.com/milabs,Update TLS configuration manual,2,[],https://github.com/tempesta-tech/tempesta/pull/612,https://github.com/krizhanovsky,3,https://github.com/tempesta-tech/tempesta/pull/612#issuecomment-243780211,Add an example of how to generate and use self-signed certificate.,good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,616,2016-09-22T00:42:05Z,2016-09-22T09:46:58Z,2016-09-22T09:47:02Z,MERGED,True,6,3,1,https://github.com/keshonok,"On rbuf entry reset, clear min/max/avg/tot counters as well. (#564)",1,[],https://github.com/tempesta-tech/tempesta/pull/616,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/616,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,616,2016-09-22T00:42:05Z,2016-09-22T09:46:58Z,2016-09-22T09:47:02Z,MERGED,True,6,3,1,https://github.com/keshonok,"On rbuf entry reset, clear min/max/avg/tot counters as well. (#564)",1,[],https://github.com/tempesta-tech/tempesta/pull/616,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/616#issuecomment-248852358,,good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,617,2016-09-29T10:47:26Z,2016-11-16T17:16:47Z,2016-11-16T17:16:57Z,MERGED,True,18,20,1,https://github.com/keshonok,Fix a bug with error handling when calculating sticky cookie value.,1,[],https://github.com/tempesta-tech/tempesta/pull/617,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/617,"If the calculation of the sticky cookie value resulted in an error,
then the 502 error response was sent to the client, and the result
of zero was returned to tfw_http_req_cache_cb(). Then the request
was processed further as if nothing had happened. Potentially, the
request was sent to a server, and then another response to the same
request was sent to the client.
Also, it's important that with this change the sticky cookie module
doesn't send any error responses any more. That's the prerogative of
the code in http.c.
Also, a small refactoring and better comments in a couple of places.","If the calculation of the sticky cookie value resulted in an error,
then the 502 error response was sent to the client, and the result
of zero was returned to tfw_http_req_cache_cb(). Then the request
was processed further as if nothing had happened. Potentially, the
request was sent to a server, and then another response to the same
request was sent to the client.
Also, it's important that with this change the sticky cookie module
doesn't send any error responses any more. That's the prerogative of
the code in http.c.
Also, a small refactoring and better comments in a couple of places.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,618,2016-10-04T15:13:30Z,2016-10-11T15:02:48Z,2016-10-12T16:33:34Z,MERGED,True,333,204,9,https://github.com/ikoveshnikov,Fix unit tests: tfw_str,19,[],https://github.com/tempesta-tech/tempesta/pull/618,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/618,fix few issues in unit tests for tfw_str.,fix few issues in unit tests for tfw_str.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,620,2016-10-10T08:36:32Z,2016-10-17T20:15:10Z,2016-10-17T20:21:43Z,MERGED,True,907,686,12,https://github.com/krizhanovsky,HTTP parser fixes and few unit test additions and cleanups,5,[],https://github.com/tempesta-tech/tempesta/pull/620,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/620,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,621,2016-10-25T15:56:45Z,2016-10-27T07:32:24Z,2016-10-27T07:33:43Z,MERGED,True,1,1,1,https://github.com/ikoveshnikov,HttpMsg: fix raw header removal,1,[],https://github.com/tempesta-tech/tempesta/pull/621,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/621,Fix bug: removing RAW http header from TfwHttpMsg using tfw_http_msg_hdr_xfrm() function call cause memory corruption.,Fix bug: removing RAW http header from TfwHttpMsg using tfw_http_msg_hdr_xfrm() function call cause memory corruption.,True,{'THUMBS_UP': ['https://github.com/krizhanovsky']}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,621,2016-10-25T15:56:45Z,2016-10-27T07:32:24Z,2016-10-27T07:33:43Z,MERGED,True,1,1,1,https://github.com/ikoveshnikov,HttpMsg: fix raw header removal,1,[],https://github.com/tempesta-tech/tempesta/pull/621,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/621#issuecomment-256351931,Fix bug: removing RAW http header from TfwHttpMsg using tfw_http_msg_hdr_xfrm() function call cause memory corruption.,"Good catch! Also good for me, let's merge it.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,623,2016-10-27T13:49:09Z,2016-11-04T13:00:44Z,2016-12-29T05:22:35Z,CLOSED,False,253,51,8,https://github.com/ikoveshnikov,Ik dont cache hbh headers,12,[],https://github.com/tempesta-tech/tempesta/pull/623,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/623,"Fix issue #409
Notes about unit tests:

test_http_parser.c: parses_req_uri Requests like ""GET http://natsys-lab.com/* HTTP/1.1\r\n\r\n"" causes crashes. Same Behaviour on master branch
test_http_parser.c:  fills_hdr_tbl_for_resp gives 137 assertions on tfw_str_eq_cstr() for keep-alive header. Actually the same situation on master, but keep-alive header is not checked on master. Do not know the reason, going to work on in during my next assignment.","Fix issue #409
Notes about unit tests:

test_http_parser.c: parses_req_uri Requests like ""GET http://natsys-lab.com/* HTTP/1.1\r\n\r\n"" causes crashes. Same Behaviour on master branch
test_http_parser.c:  fills_hdr_tbl_for_resp gives 137 assertions on tfw_str_eq_cstr() for keep-alive header. Actually the same situation on master, but keep-alive header is not checked on master. Do not know the reason, going to work on in during my next assignment.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,623,2016-10-27T13:49:09Z,2016-11-04T13:00:44Z,2016-12-29T05:22:35Z,CLOSED,False,253,51,8,https://github.com/ikoveshnikov,Ik dont cache hbh headers,12,[],https://github.com/tempesta-tech/tempesta/pull/623,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/623#issuecomment-256649259,"Fix issue #409
Notes about unit tests:

test_http_parser.c: parses_req_uri Requests like ""GET http://natsys-lab.com/* HTTP/1.1\r\n\r\n"" causes crashes. Same Behaviour on master branch
test_http_parser.c:  fills_hdr_tbl_for_resp gives 137 assertions on tfw_str_eq_cstr() for keep-alive header. Actually the same situation on master, but keep-alive header is not checked on master. Do not know the reason, going to work on in during my next assignment.",Unit tests related issues described in #624,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,623,2016-10-27T13:49:09Z,2016-11-04T13:00:44Z,2016-12-29T05:22:35Z,CLOSED,False,253,51,8,https://github.com/ikoveshnikov,Ik dont cache hbh headers,12,[],https://github.com/tempesta-tech/tempesta/pull/623,https://github.com/ikoveshnikov,3,https://github.com/tempesta-tech/tempesta/pull/623#issuecomment-258424677,"Fix issue #409
Notes about unit tests:

test_http_parser.c: parses_req_uri Requests like ""GET http://natsys-lab.com/* HTTP/1.1\r\n\r\n"" causes crashes. Same Behaviour on master branch
test_http_parser.c:  fills_hdr_tbl_for_resp gives 137 assertions on tfw_str_eq_cstr() for keep-alive header. Actually the same situation on master, but keep-alive header is not checked on master. Do not know the reason, going to work on in during my next assignment.","Obsoleted by #633
This implementation did not pass code review due to architectural issues: low speed, wrong approach",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,625,2016-10-27T22:25:02Z,2016-10-30T20:21:35Z,2016-10-30T20:21:35Z,MERGED,True,2619,666,29,https://github.com/krizhanovsky,AVX2 HTTP strings processing & multiple HTTP parser fixes,7,['crucial'],https://github.com/tempesta-tech/tempesta/pull/625,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/625,"Also see stings benchmark https://github.com/natsys/blog/tree/master/fast_str .
Please note that AVX2 is required to test the feature, so if your host system has at least Haswell CPU, then use -cpu host key for you qemu VM to pass all CPU options to the guest. While the code is written to be compilable w/o AVX2, I found that if I try to run Tempesta FW in guest w/o -cpu host it crashes at first XMM register load.
I tested the code with test_tfw_str and test_http_parser unit tests as well as with manual requests and some simple traffic generators.
Please review this ASAP since we need to do performance testing ASAP.","Also see stings benchmark https://github.com/natsys/blog/tree/master/fast_str .
Please note that AVX2 is required to test the feature, so if your host system has at least Haswell CPU, then use -cpu host key for you qemu VM to pass all CPU options to the guest. While the code is written to be compilable w/o AVX2, I found that if I try to run Tempesta FW in guest w/o -cpu host it crashes at first XMM register load.
I tested the code with test_tfw_str and test_http_parser unit tests as well as with manual requests and some simple traffic generators.
Please review this ASAP since we need to do performance testing ASAP.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,627,2016-10-28T14:47:55Z,2016-10-31T07:38:16Z,2016-10-31T07:38:25Z,MERGED,True,5,5,1,https://github.com/ikoveshnikov,Obtain session information before serving from cache,1,[],https://github.com/tempesta-tech/tempesta/pull/627,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/627,"Req->sess must be set before adjusting response
Fix issue #626","Req->sess must be set before adjusting response
Fix issue #626",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,627,2016-10-28T14:47:55Z,2016-10-31T07:38:16Z,2016-10-31T07:38:25Z,MERGED,True,5,5,1,https://github.com/ikoveshnikov,Obtain session information before serving from cache,1,[],https://github.com/tempesta-tech/tempesta/pull/627,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/627#issuecomment-256954893,"Req->sess must be set before adjusting response
Fix issue #626",Looks good. Please address the comment #626 (comment) as well.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,632,2016-11-03T14:06:08Z,2016-11-04T18:41:12Z,2016-11-04T18:44:02Z,MERGED,True,163,150,2,https://github.com/krizhanovsky,Performance optimization,3,['crucial'],https://github.com/tempesta-tech/tempesta/pull/632,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/632,Do not queue cache work for local CPU: 25% better performance on single connection and now we have almost linear scalability on 2K-32K connections; also remove old debug prints,Do not queue cache work for local CPU: 25% better performance on single connection and now we have almost linear scalability on 2K-32K connections; also remove old debug prints,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,633,2016-11-04T12:57:34Z,2016-11-24T13:09:36Z,2016-12-29T05:20:10Z,CLOSED,False,446,91,11,https://github.com/ikoveshnikov,Don't cache and don't forward hop-by-hop headers,14,[],https://github.com/tempesta-tech/tempesta/pull/633,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/633,"Fix issue #409
Main changes:

Update http parser to save Connection header string as list of header names tagged with flag TFW_STR_VALUE. Most common tokens keep-alive and close and also delimiters are not marked with this flag: first processed as special header as most common one, others don't point to any headers.  TFW_HTTP_CONN_EXTRA flag for whole message is set if Connection contains more than just keep-alive or close
Keep-alive header is set as special. That helps not to slow down performance by multiple string comparisons if Keep-alive is the only header set by Connection. Corresponding unit test was updated.
Remove hop-by-hop headers when forwarding messages from client to server and vice-versa
Don't cache hop-by-hop headers for server responses.","Fix issue #409
Main changes:

Update http parser to save Connection header string as list of header names tagged with flag TFW_STR_VALUE. Most common tokens keep-alive and close and also delimiters are not marked with this flag: first processed as special header as most common one, others don't point to any headers.  TFW_HTTP_CONN_EXTRA flag for whole message is set if Connection contains more than just keep-alive or close
Keep-alive header is set as special. That helps not to slow down performance by multiple string comparisons if Keep-alive is the only header set by Connection. Corresponding unit test was updated.
Remove hop-by-hop headers when forwarding messages from client to server and vice-versa
Don't cache hop-by-hop headers for server responses.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,633,2016-11-04T12:57:34Z,2016-11-24T13:09:36Z,2016-12-29T05:20:10Z,CLOSED,False,446,91,11,https://github.com/ikoveshnikov,Don't cache and don't forward hop-by-hop headers,14,[],https://github.com/tempesta-tech/tempesta/pull/633,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/633#issuecomment-260308157,"Fix issue #409
Main changes:

Update http parser to save Connection header string as list of header names tagged with flag TFW_STR_VALUE. Most common tokens keep-alive and close and also delimiters are not marked with this flag: first processed as special header as most common one, others don't point to any headers.  TFW_HTTP_CONN_EXTRA flag for whole message is set if Connection contains more than just keep-alive or close
Keep-alive header is set as special. That helps not to slow down performance by multiple string comparisons if Keep-alive is the only header set by Connection. Corresponding unit test was updated.
Remove hop-by-hop headers when forwarding messages from client to server and vice-versa
Don't cache hop-by-hop headers for server responses.","Changes:

Rebased to current master
Hop-by-hop headers refactored: get rid of memory allocations and VLAs, simplify code, don't try to find hop-by-hop headers twice for same response (during caching and during adjusting)
removed extra empty lines
update function documentation

TODO:

check unit tests (fail on master branch, not caused by the PR)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,633,2016-11-04T12:57:34Z,2016-11-24T13:09:36Z,2016-12-29T05:20:10Z,CLOSED,False,446,91,11,https://github.com/ikoveshnikov,Don't cache and don't forward hop-by-hop headers,14,[],https://github.com/tempesta-tech/tempesta/pull/633,https://github.com/ikoveshnikov,3,https://github.com/tempesta-tech/tempesta/pull/633#issuecomment-262772884,"Fix issue #409
Main changes:

Update http parser to save Connection header string as list of header names tagged with flag TFW_STR_VALUE. Most common tokens keep-alive and close and also delimiters are not marked with this flag: first processed as special header as most common one, others don't point to any headers.  TFW_HTTP_CONN_EXTRA flag for whole message is set if Connection contains more than just keep-alive or close
Keep-alive header is set as special. That helps not to slow down performance by multiple string comparisons if Keep-alive is the only header set by Connection. Corresponding unit test was updated.
Remove hop-by-hop headers when forwarding messages from client to server and vice-versa
Don't cache hop-by-hop headers for server responses.",redisigned in #650,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,637,2016-11-07T13:41:07Z,2016-11-10T16:45:16Z,2016-11-10T16:48:49Z,MERGED,True,105,102,5,https://github.com/keshonok,Correctly save the body of a message. (#630),3,[],https://github.com/tempesta-tech/tempesta/pull/637,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/637,"Remove the condition that prevented saving parts of the body.
Use BUG_ON() to enforce the correct length of the body.","Remove the condition that prevented saving parts of the body.
Use BUG_ON() to enforce the correct length of the body.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,637,2016-11-07T13:41:07Z,2016-11-10T16:45:16Z,2016-11-10T16:48:49Z,MERGED,True,105,102,5,https://github.com/keshonok,Correctly save the body of a message. (#630),3,[],https://github.com/tempesta-tech/tempesta/pull/637,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/637#issuecomment-259732938,"Remove the condition that prevented saving parts of the body.
Use BUG_ON() to enforce the correct length of the body.",Good fix! Good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,638,2016-11-09T09:53:48Z,2016-11-17T15:46:49Z,2016-11-17T15:46:52Z,MERGED,True,133,2,4,https://github.com/ikoveshnikov,http parser: fix parsing connection termination during response witho…,5,[],https://github.com/tempesta-tech/tempesta/pull/638,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/638,"…ut known lenght
For responses without Content-Length header parser during
TFW_HTTP_INIT_RESP_BODY_PARSING() procedure switches its state to
Resp_BodyUnlimStart state. If response body is present parser will
switch to Resp_BodyUnlimRead state. When server will terminate
connection to indicate that end of response is reached, message will
be forwarded to client.
But if no body is present, parser will never reach Resp_BodyUnlimRead
state and message will not be forwarded to client.
fix issue #629","…ut known lenght
For responses without Content-Length header parser during
TFW_HTTP_INIT_RESP_BODY_PARSING() procedure switches its state to
Resp_BodyUnlimStart state. If response body is present parser will
switch to Resp_BodyUnlimRead state. When server will terminate
connection to indicate that end of response is reached, message will
be forwarded to client.
But if no body is present, parser will never reach Resp_BodyUnlimRead
state and message will not be forwarded to client.
fix issue #629",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,638,2016-11-09T09:53:48Z,2016-11-17T15:46:49Z,2016-11-17T15:46:52Z,MERGED,True,133,2,4,https://github.com/ikoveshnikov,http parser: fix parsing connection termination during response witho…,5,[],https://github.com/tempesta-tech/tempesta/pull/638,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/638#issuecomment-260660196,"…ut known lenght
For responses without Content-Length header parser during
TFW_HTTP_INIT_RESP_BODY_PARSING() procedure switches its state to
Resp_BodyUnlimStart state. If response body is present parser will
switch to Resp_BodyUnlimRead state. When server will terminate
connection to indicate that end of response is reached, message will
be forwarded to client.
But if no body is present, parser will never reach Resp_BodyUnlimRead
state and message will not be forwarded to client.
fix issue #629","Changes since last review:

Rebased to master
fix issue #639 by adding Content-Length to message with unlimited body",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,641,2016-11-15T13:33:23Z,2016-11-30T17:00:12Z,2016-11-30T17:00:35Z,MERGED,True,509,286,7,https://github.com/keshonok,Correctly handle msg->crlf.,7,[],https://github.com/tempesta-tech/tempesta/pull/641,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/641,"Do not add extra chunks to msg->crlf in case of a chunked body
and trailing headers.
In tests, do not send ""Content-Length:"" header together with
""Transfer-Encoding:"" header.
Check that the parsed body length matches the value specified
in ""Content-Length:"" header only for messages with linear body
(not chunked).","Do not add extra chunks to msg->crlf in case of a chunked body
and trailing headers.
In tests, do not send ""Content-Length:"" header together with
""Transfer-Encoding:"" header.
Check that the parsed body length matches the value specified
in ""Content-Length:"" header only for messages with linear body
(not chunked).",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,643,2016-11-17T07:14:46Z,2016-11-17T08:16:08Z,2017-03-22T10:09:21Z,CLOSED,False,2,0,2,https://github.com/sergsever,fix #642,1,[],https://github.com/tempesta-tech/tempesta/pull/643,https://github.com/sergsever,1,https://github.com/tempesta-tech/tempesta/pull/643,Directories for functional tests.,Directories for functional tests.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,643,2016-11-17T07:14:46Z,2016-11-17T08:16:08Z,2017-03-22T10:09:21Z,CLOSED,False,2,0,2,https://github.com/sergsever,fix #642,1,[],https://github.com/tempesta-tech/tempesta/pull/643,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/643#issuecomment-261182756,Directories for functional tests.,The changes are inadequately small.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,644,2016-11-18T14:01:05Z,2016-11-18T16:41:05Z,2016-11-18T16:41:10Z,MERGED,True,2,2,1,https://github.com/keshonok,Move to next token at correct offset in http_parser.c,1,[],https://github.com/tempesta-tech/tempesta/pull/644,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/644,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,647,2016-11-22T13:59:05Z,2016-11-23T16:38:26Z,2016-11-23T17:24:07Z,MERGED,True,2,0,1,https://github.com/krizhanovsky,Fix #645: clear skb->sender_cpu before forwardning,1,['crucial'],https://github.com/tempesta-tech/tempesta/pull/647,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/647,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,648,2016-11-22T18:23:19Z,2016-11-23T18:33:55Z,2016-11-27T18:08:46Z,MERGED,True,21,19,3,https://github.com/krizhanovsky,Fix #646,3,['crucial'],https://github.com/tempesta-tech/tempesta/pull/648,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/648,"Unlink hm->conn before the connection is freed;
don't try to free statically allocated HTTP message.","Unlink hm->conn before the connection is freed;
don't try to free statically allocated HTTP message.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,649,2016-11-22T20:26:08Z,2016-11-22T23:05:35Z,2016-11-22T23:09:27Z,MERGED,True,33,26,3,https://github.com/keshonok,Fix the handling of crlf and related tests,3,[],https://github.com/tempesta-tech/tempesta/pull/649,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/649,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,650,2016-11-24T13:07:41Z,2016-12-29T05:17:37Z,2016-12-29T05:17:41Z,MERGED,True,890,171,9,https://github.com/ikoveshnikov,Don't cache and don't forward hop-by-hop headers,24,[],https://github.com/tempesta-tech/tempesta/pull/650,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/650,"Fix issue #409

Parse Connection header during parsing HTTP message;
Store raw headers listed in Connection header in temporary array allocated in message's pool: every raw header is marked as hop-by-hop if it's name present in that array. When connection header parsed in the first time, parser checks already parsed raw headers and mark them as hop-by-hop headers if needed. If Connection header does not contain any raw headers names no extra allocations or string comparison happen;
Special headers have their own marking procedure which does not involve string comparisons. Some of the special headers are always hop-by-hop (Connection, we also mark Server in responses as hop-by-hop) and using generic comparison like for Raw headers will ruin performance;
Unit tests for responses and requests with hop-by-hop marking checks;
little optimisation of __hdr_lookup(): reduce string comparisons.

TBD:
When response contains Connection: keep-alive, Keep-alive header will be marked as hop-by-hop header and will not be saved in cache (that was the requirement in #409 ). RFC 7230 6.1 also say:
 A proxy or gateway MUST parse a received Connection header field before
   a message is forwarded and, for each connection-option in this field,
   remove any header field(s) from the message with the same name as the
   connection-option, and then remove the Connection header field itself
   (or replace it with the intermediary's own connection options for the
   forwarded message).

Currently we have no realised way to set default Keep-Alive header (not found in issues but here is corresponding TODO: https://github.com/tempesta-tech/tempesta/blob/master/tempesta_fw/http.c#L639 ). So question is: delete Keep-Alive header in forwarded messages or not? But messages served from cache will have no such header. Currently i remove it from both forwarded messages: response and request, disabling that is one-line patch.","Fix issue #409

Parse Connection header during parsing HTTP message;
Store raw headers listed in Connection header in temporary array allocated in message's pool: every raw header is marked as hop-by-hop if it's name present in that array. When connection header parsed in the first time, parser checks already parsed raw headers and mark them as hop-by-hop headers if needed. If Connection header does not contain any raw headers names no extra allocations or string comparison happen;
Special headers have their own marking procedure which does not involve string comparisons. Some of the special headers are always hop-by-hop (Connection, we also mark Server in responses as hop-by-hop) and using generic comparison like for Raw headers will ruin performance;
Unit tests for responses and requests with hop-by-hop marking checks;
little optimisation of __hdr_lookup(): reduce string comparisons.

TBD:
When response contains Connection: keep-alive, Keep-alive header will be marked as hop-by-hop header and will not be saved in cache (that was the requirement in #409 ). RFC 7230 6.1 also say:
 A proxy or gateway MUST parse a received Connection header field before
   a message is forwarded and, for each connection-option in this field,
   remove any header field(s) from the message with the same name as the
   connection-option, and then remove the Connection header field itself
   (or replace it with the intermediary's own connection options for the
   forwarded message).

Currently we have no realised way to set default Keep-Alive header (not found in issues but here is corresponding TODO: https://github.com/tempesta-tech/tempesta/blob/master/tempesta_fw/http.c#L639 ). So question is: delete Keep-Alive header in forwarded messages or not? But messages served from cache will have no such header. Currently i remove it from both forwarded messages: response and request, disabling that is one-line patch.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,650,2016-11-24T13:07:41Z,2016-12-29T05:17:37Z,2016-12-29T05:17:41Z,MERGED,True,890,171,9,https://github.com/ikoveshnikov,Don't cache and don't forward hop-by-hop headers,24,[],https://github.com/tempesta-tech/tempesta/pull/650,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/650#issuecomment-264633446,"Fix issue #409

Parse Connection header during parsing HTTP message;
Store raw headers listed in Connection header in temporary array allocated in message's pool: every raw header is marked as hop-by-hop if it's name present in that array. When connection header parsed in the first time, parser checks already parsed raw headers and mark them as hop-by-hop headers if needed. If Connection header does not contain any raw headers names no extra allocations or string comparison happen;
Special headers have their own marking procedure which does not involve string comparisons. Some of the special headers are always hop-by-hop (Connection, we also mark Server in responses as hop-by-hop) and using generic comparison like for Raw headers will ruin performance;
Unit tests for responses and requests with hop-by-hop marking checks;
little optimisation of __hdr_lookup(): reduce string comparisons.

TBD:
When response contains Connection: keep-alive, Keep-alive header will be marked as hop-by-hop header and will not be saved in cache (that was the requirement in #409 ). RFC 7230 6.1 also say:
 A proxy or gateway MUST parse a received Connection header field before
   a message is forwarded and, for each connection-option in this field,
   remove any header field(s) from the message with the same name as the
   connection-option, and then remove the Connection header field itself
   (or replace it with the intermediary's own connection options for the
   forwarded message).

Currently we have no realised way to set default Keep-Alive header (not found in issues but here is corresponding TODO: https://github.com/tempesta-tech/tempesta/blob/master/tempesta_fw/http.c#L639 ). So question is: delete Keep-Alive header in forwarded messages or not? But messages served from cache will have no such header. Currently i remove it from both forwarded messages: response and request, disabling that is one-line patch.",Please address the comment #409 (comment) or move the requirement to #634,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,650,2016-11-24T13:07:41Z,2016-12-29T05:17:37Z,2016-12-29T05:17:41Z,MERGED,True,890,171,9,https://github.com/ikoveshnikov,Don't cache and don't forward hop-by-hop headers,24,[],https://github.com/tempesta-tech/tempesta/pull/650,https://github.com/ikoveshnikov,3,https://github.com/tempesta-tech/tempesta/pull/650#issuecomment-264703028,"Fix issue #409

Parse Connection header during parsing HTTP message;
Store raw headers listed in Connection header in temporary array allocated in message's pool: every raw header is marked as hop-by-hop if it's name present in that array. When connection header parsed in the first time, parser checks already parsed raw headers and mark them as hop-by-hop headers if needed. If Connection header does not contain any raw headers names no extra allocations or string comparison happen;
Special headers have their own marking procedure which does not involve string comparisons. Some of the special headers are always hop-by-hop (Connection, we also mark Server in responses as hop-by-hop) and using generic comparison like for Raw headers will ruin performance;
Unit tests for responses and requests with hop-by-hop marking checks;
little optimisation of __hdr_lookup(): reduce string comparisons.

TBD:
When response contains Connection: keep-alive, Keep-alive header will be marked as hop-by-hop header and will not be saved in cache (that was the requirement in #409 ). RFC 7230 6.1 also say:
 A proxy or gateway MUST parse a received Connection header field before
   a message is forwarded and, for each connection-option in this field,
   remove any header field(s) from the message with the same name as the
   connection-option, and then remove the Connection header field itself
   (or replace it with the intermediary's own connection options for the
   forwarded message).

Currently we have no realised way to set default Keep-Alive header (not found in issues but here is corresponding TODO: https://github.com/tempesta-tech/tempesta/blob/master/tempesta_fw/http.c#L639 ). So question is: delete Keep-Alive header in forwarded messages or not? But messages served from cache will have no such header. Currently i remove it from both forwarded messages: response and request, disabling that is one-line patch.","Changes since last review:

rebased to current master
fixed error in current master with Transfer-Encoding header: the header now is SPEC header but it missed in __http_msg_hdr_val()
Connection header is limited to have less than 16 connection tokens for raw headers. Otherwise request or response will be filtered
Drop message if some of connection tokens is end-to-end headers used by tempesta and parsed by TFW_HTTP_PARSE_RAWHDR_VAL macro. Comparing of connection tokens with all headers defined in RFC 7230, 7231 as end-to-end will lead to a lot of string comparisons inside of parsing of Connection header
Unit tests updated to have more test cases for hop-by-hop headers marking

The feature have no special requirements for #634 . (Headers listed there are not hop-by-hop)
I tried to compare behaviour with nginx, but it support hop-by-hop headers in terms of obsoleted RFC 2616, not 7230",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,652,2016-11-25T10:58:56Z,2016-11-25T12:40:18Z,2016-12-06T14:15:30Z,CLOSED,False,28,16,1,https://github.com/keshonok,Correctly lock requests from concurrent deletion. (#651),1,[],https://github.com/tempesta-tech/tempesta/pull/652,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/652,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,652,2016-11-25T10:58:56Z,2016-11-25T12:40:18Z,2016-12-06T14:15:30Z,CLOSED,False,28,16,1,https://github.com/keshonok,Correctly lock requests from concurrent deletion. (#651),1,[],https://github.com/tempesta-tech/tempesta/pull/652,https://github.com/keshonok,2,https://github.com/tempesta-tech/tempesta/pull/652#issuecomment-262950029,,"In fact, a server connection is get'ed before a request is forwarded to the server over that connection. That's done in an atomic way, so a server connection cannot be get'ed when it is released. Equally, a server connection cannot be released while forwarding action of that request is in progress. While this patch does prevent the crash, that just a workaround that masks the real problem. The core of the problem is different, and the issue must be resolved in a different way.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,657,2016-11-29T17:31:23Z,2016-11-30T20:15:03Z,2016-12-03T19:23:31Z,MERGED,True,168,87,11,https://github.com/krizhanovsky,Proxy performance tuning; fix #655,6,[],https://github.com/tempesta-tech/tempesta/pull/657,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/657,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,660,2016-12-05T13:40:18Z,2017-03-03T08:16:49Z,2017-03-13T11:32:40Z,MERGED,True,3279,1093,40,https://github.com/keshonok,Enforce the correct order of responses. Handle non-idempotent requests.,67,[],https://github.com/tempesta-tech/tempesta/pull/660,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/660,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,660,2016-12-05T13:40:18Z,2017-03-03T08:16:49Z,2017-03-13T11:32:40Z,MERGED,True,3279,1093,40,https://github.com/keshonok,Enforce the correct order of responses. Handle non-idempotent requests.,67,[],https://github.com/tempesta-tech/tempesta/pull/660,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/660#issuecomment-283798427,,Good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,661,2016-12-07T13:53:14Z,2017-01-17T13:12:15Z,2017-01-17T13:12:37Z,CLOSED,False,1988,559,42,https://github.com/sergsever,Functional tests,7,[],https://github.com/tempesta-tech/tempesta/pull/661,https://github.com/sergsever,1,https://github.com/tempesta-tech/tempesta/pull/661,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,662,2016-12-11T22:12:49Z,2016-12-12T13:37:49Z,2016-12-12T13:37:50Z,MERGED,True,199,130,9,https://github.com/krizhanovsky,Resistance to misbehaving upstream server,2,[],https://github.com/tempesta-tech/tempesta/pull/662,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/662,"Workaround for #651: introduce TFW_HTTP_MSG_SENT flag such that unsent requests aren't paired with inavalid responses; drop connections if unpaired responses
detected.
Fix tfw_connection_unlink_to_sk(): do the actions in reverse order as they are
done in tfw_connection_link_to_sk().
Fix multiple memory leaks in error paths in HTTP request/response processing
(HTTP messages weren't freed).
Partial #658: print warning on parser failures, print reasons for error HTTP
responses.
Optimizations: don't copy request skbs if no caching introduced; don't put
work for known dead socket to work queue (races arepossible, but
we just do the extra work in worst case)
Many cleanups.","Workaround for #651: introduce TFW_HTTP_MSG_SENT flag such that unsent requests aren't paired with inavalid responses; drop connections if unpaired responses
detected.
Fix tfw_connection_unlink_to_sk(): do the actions in reverse order as they are
done in tfw_connection_link_to_sk().
Fix multiple memory leaks in error paths in HTTP request/response processing
(HTTP messages weren't freed).
Partial #658: print warning on parser failures, print reasons for error HTTP
responses.
Optimizations: don't copy request skbs if no caching introduced; don't put
work for known dead socket to work queue (races arepossible, but
we just do the extra work in worst case)
Many cleanups.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,665,2016-12-20T10:35:36Z,2016-12-20T16:13:20Z,2016-12-20T16:13:25Z,MERGED,True,24,22,1,https://github.com/keshonok,Better handling of default values in configuration.,1,[],https://github.com/tempesta-tech/tempesta/pull/665,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/665,"It's been assumed that default values should not give an error
just because the configuration data provided for those values is
carefully prepared in the code. However, the configuration data
may require that multiple internal data structures are created,
and that process may result in an error. It's unacceptable when
Tempesta crashes just because of that. This patch fixes the issue.
Default values is treated the same way as any other configuration
values.","It's been assumed that default values should not give an error
just because the configuration data provided for those values is
carefully prepared in the code. However, the configuration data
may require that multiple internal data structures are created,
and that process may result in an error. It's unacceptable when
Tempesta crashes just because of that. This patch fixes the issue.
Default values is treated the same way as any other configuration
values.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,666,2016-12-20T12:12:27Z,2017-03-22T14:10:57Z,2017-06-03T19:02:32Z,CLOSED,False,1321,196,17,https://github.com/ikoveshnikov,Sticky Sessions implementation,15,[],https://github.com/tempesta-tech/tempesta/pull/666,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/666,"Fix issue #593
Schedule HTTP request to the same servers for session preservation","Fix issue #593
Schedule HTTP request to the same servers for session preservation",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,666,2016-12-20T12:12:27Z,2017-03-22T14:10:57Z,2017-06-03T19:02:32Z,CLOSED,False,1321,196,17,https://github.com/ikoveshnikov,Sticky Sessions implementation,15,[],https://github.com/tempesta-tech/tempesta/pull/666,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/666#issuecomment-288410237,"Fix issue #593
Schedule HTTP request to the same servers for session preservation",Over engineered and does not suit requirements,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,667,2016-12-27T11:40:19Z,2016-12-30T15:51:16Z,2016-12-30T15:51:20Z,MERGED,True,5,2,1,https://github.com/keshonok,Fix out of bounds access in add_rand_string() in fuzzer.c,1,[],https://github.com/tempesta-tech/tempesta/pull/667,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/667,"The calculation uses XOR which may lead to negative values.
That leads to negative indices which cause out of bounds accesses.
The issue was reported by KASan.","The calculation uses XOR which may lead to negative values.
That leads to negative indices which cause out of bounds accesses.
The issue was reported by KASan.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,669,2016-12-27T22:12:01Z,2016-12-28T16:53:00Z,2016-12-28T19:02:10Z,MERGED,True,82,73,25,https://github.com/krizhanovsky,Fix #651,7,['crucial'],https://github.com/tempesta-tech/tempesta/pull/669,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/669,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,670,2016-12-28T13:53:55Z,2017-04-04T13:56:10Z,2017-06-19T20:44:19Z,CLOSED,False,1686,749,29,https://github.com/keshonok,Advanced load balancing - ratio scheduler,18,[],https://github.com/tempesta-tech/tempesta/pull/670,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/670,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,670,2016-12-28T13:53:55Z,2017-04-04T13:56:10Z,2017-06-19T20:44:19Z,CLOSED,False,1686,749,29,https://github.com/keshonok,Advanced load balancing - ratio scheduler,18,[],https://github.com/tempesta-tech/tempesta/pull/670,https://github.com/keshonok,2,https://github.com/tempesta-tech/tempesta/pull/670#issuecomment-291507451,,Replaced by #718.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,671,2016-12-28T15:52:53Z,2017-07-31T13:57:29Z,2017-07-31T13:57:36Z,CLOSED,False,260,0,2,https://github.com/ikoveshnikov,Initial wiki notes for schedulers,1,[],https://github.com/tempesta-tech/tempesta/pull/671,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/671,"Here is just initial description of schedulers for wiki.
In my opinion, wiki should contain only those things that do not changed frequently. Copying code comments is waste of paper: one day documentation will be far away from code and will be useless.
Instead i suggest documenting in wiki the next things:

Tempesta configuration file. User edit it, so good explanation of options is wanted. Some option can affect each other, and that can be quite complicated.
Complicated logic of some subsystems/features. That more for developers. Some subsystems like an iceberg: api is pretty and clear, but the devil is in the detail.

That is not final document: there is a lot of references to other subsystem/modules. Just need a feedback, which sections to add, what to cover. Better to see in rich diff format.
Please don't pay a lot of attention to looks, still working on it (:","Here is just initial description of schedulers for wiki.
In my opinion, wiki should contain only those things that do not changed frequently. Copying code comments is waste of paper: one day documentation will be far away from code and will be useless.
Instead i suggest documenting in wiki the next things:

Tempesta configuration file. User edit it, so good explanation of options is wanted. Some option can affect each other, and that can be quite complicated.
Complicated logic of some subsystems/features. That more for developers. Some subsystems like an iceberg: api is pretty and clear, but the devil is in the detail.

That is not final document: there is a lot of references to other subsystem/modules. Just need a feedback, which sections to add, what to cover. Better to see in rich diff format.
Please don't pay a lot of attention to looks, still working on it (:",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,671,2016-12-28T15:52:53Z,2017-07-31T13:57:29Z,2017-07-31T13:57:36Z,CLOSED,False,260,0,2,https://github.com/ikoveshnikov,Initial wiki notes for schedulers,1,[],https://github.com/tempesta-tech/tempesta/pull/671,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/671#issuecomment-319074646,"Here is just initial description of schedulers for wiki.
In my opinion, wiki should contain only those things that do not changed frequently. Copying code comments is waste of paper: one day documentation will be far away from code and will be useless.
Instead i suggest documenting in wiki the next things:

Tempesta configuration file. User edit it, so good explanation of options is wanted. Some option can affect each other, and that can be quite complicated.
Complicated logic of some subsystems/features. That more for developers. Some subsystems like an iceberg: api is pretty and clear, but the devil is in the detail.

That is not final document: there is a lot of references to other subsystem/modules. Just need a feedback, which sections to add, what to cover. Better to see in rich diff format.
Please don't pay a lot of attention to looks, still working on it (:",Outdated by wiki pages,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,675,2017-01-18T11:48:04Z,2017-02-03T19:16:21Z,2017-02-03T19:16:28Z,MERGED,True,55,1,2,https://github.com/keshonok,Fix BUG_ON() to account for responses to HEAD requests. (#674),2,[],https://github.com/tempesta-tech/tempesta/pull/675,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/675,"Responses to HEAD requests have the full header with real value
in 'Content-Length:' header field, but no actual body.","Responses to HEAD requests have the full header with real value
in 'Content-Length:' header field, but no actual body.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,676,2017-01-29T12:03:55Z,2017-02-02T18:04:42Z,2017-03-22T15:51:19Z,MERGED,True,733,411,25,https://github.com/krizhanovsky,Fix #116 and #254: clean restart,8,['crucial'],https://github.com/tempesta-tech/tempesta/pull/676,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/676,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,677,2017-01-31T16:54:10Z,2017-03-22T15:50:43Z,2017-03-22T15:50:43Z,CLOSED,False,1618,363,25,https://github.com/sergsever,Sl 659,2,[],https://github.com/tempesta-tech/tempesta/pull/677,https://github.com/sergsever,1,https://github.com/tempesta-tech/tempesta/pull/677,Branch sl-659 made from sl-396 and has to be compared with sl-396.,Branch sl-659 made from sl-396 and has to be compared with sl-396.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,679,2017-02-08T16:41:44Z,2017-03-14T10:38:55Z,2017-03-14T10:39:03Z,MERGED,True,4160,207,39,https://github.com/ikoveshnikov,Testing framework,75,[],https://github.com/tempesta-tech/tempesta/pull/679,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/679,"Here is framework for functional, stress and performance testing of TempestaFW. Readme provide more information.","Here is framework for functional, stress and performance testing of TempestaFW. Readme provide more information.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,681,2017-02-12T20:25:29Z,2017-02-13T10:42:38Z,2017-02-13T10:47:45Z,MERGED,True,3,70,1,https://github.com/krizhanovsky,Fix #145: do not use socket accept queue at all,1,[],https://github.com/tempesta-tech/tempesta/pull/681,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/681,Also consider https://github.com/tempesta-tech/linux-4.8.15-tfw/pull/1 for review,Also consider https://github.com/tempesta-tech/linux-4.8.15-tfw/pull/1 for review,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,694,2017-03-06T14:11:54Z,2019-01-26T22:04:27Z,2019-01-26T22:04:27Z,CLOSED,False,31,1,1,https://github.com/sysprg,First version of the HTTP/2 implementation,1571,[],https://github.com/tempesta-tech/tempesta/pull/694,https://github.com/sysprg,1,https://github.com/tempesta-tech/tempesta/pull/694,This is first phase of the HTTP/2 implementation,This is first phase of the HTTP/2 implementation,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,694,2017-03-06T14:11:54Z,2019-01-26T22:04:27Z,2019-01-26T22:04:27Z,CLOSED,False,31,1,1,https://github.com/sysprg,First version of the HTTP/2 implementation,1571,[],https://github.com/tempesta-tech/tempesta/pull/694,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/694#issuecomment-284779394,This is first phase of the HTTP/2 implementation,"There should be some Makefile which at least build the code. Also it seems you generated hftestdata.h using some script, so there is no sense to commit the large auto-generated file to the repository. Instead it's better to commit the generation script and run it on build.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,700,2017-03-14T10:42:41Z,2017-03-14T16:31:40Z,2017-03-14T16:31:45Z,MERGED,True,59,32,5,https://github.com/keshonok,Do not share @req->reason with @req->resp. (#696),2,[],https://github.com/tempesta-tech/tempesta/pull/700,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/700,HTTP responses don't use @msg.seq_list. No need to init it.,HTTP responses don't use @msg.seq_list. No need to init it.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,704,2017-03-14T19:27:03Z,2017-03-15T06:27:35Z,2017-03-15T06:27:39Z,MERGED,True,7,1,2,https://github.com/ikoveshnikov,Fix http_sticky unittest,2,[],https://github.com/tempesta-tech/tempesta/pull/704,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/704,fix issue #703,fix issue #703,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,705,2017-03-14T20:04:27Z,2017-03-14T22:28:00Z,2017-03-14T22:28:04Z,MERGED,True,35,21,3,https://github.com/keshonok,Fix the potential deadlock case in tfw_apm_stats(). (#664),1,[],https://github.com/tempesta-tech/tempesta/pull/705,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/705,"Use _BH locks in user context, and regular locks in kernel context.","Use _BH locks in user context, and regular locks in kernel context.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,707,2017-03-16T15:00:07Z,2017-03-17T16:20:52Z,2017-03-22T10:15:02Z,MERGED,True,254,201,13,https://github.com/ikoveshnikov,Fix errors in configuration,4,[],https://github.com/tempesta-tech/tempesta/pull/707,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/707,"Change log:

fix issue #698 .
display configuration parsing errors without rate limit.
fix issue #65 , display error in the correct way, e.g print message:

[18638.202740] [tempesta] ERROR: invalid number of values; expected: 1, got: 0
[18638.204503] [tempesta] ERROR: Unable to parse 'listen' value: 'No value specified'
[18638.206276] [tempesta] ERROR: configuration parsing error:
                  5: listen; # 80;
                     ^^^^^^^^^^^^^
[18638.208295] [tempesta] ERROR: failed to start modules

for configuration:
cache 0;
listen 80;
server 127.0.0.1:8080;
# some comment here
listen; # 80;
# some comment here
# some comment here
# some comment here
# some comment here
# some comment here","Change log:

fix issue #698 .
display configuration parsing errors without rate limit.
fix issue #65 , display error in the correct way, e.g print message:

[18638.202740] [tempesta] ERROR: invalid number of values; expected: 1, got: 0
[18638.204503] [tempesta] ERROR: Unable to parse 'listen' value: 'No value specified'
[18638.206276] [tempesta] ERROR: configuration parsing error:
                  5: listen; # 80;
                     ^^^^^^^^^^^^^
[18638.208295] [tempesta] ERROR: failed to start modules

for configuration:
cache 0;
listen 80;
server 127.0.0.1:8080;
# some comment here
listen; # 80;
# some comment here
# some comment here
# some comment here
# some comment here
# some comment here",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,711,2017-03-19T23:37:58Z,2017-03-22T09:17:33Z,2017-03-22T09:17:41Z,MERGED,True,45,37,1,https://github.com/keshonok,Correctly re-enable server connections after they are repaired.,2,[],https://github.com/tempesta-tech/tempesta/pull/711,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/711,"This fixes a tricky bug where server connections may have been left
in repair state for a long time or forever.","This fixes a tricky bug where server connections may have been left
in repair state for a long time or forever.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,713,2017-03-22T14:09:50Z,2017-03-27T10:53:16Z,2017-03-27T10:53:24Z,MERGED,True,1726,350,31,https://github.com/ikoveshnikov,Sticky sessions implementation,24,[],https://github.com/tempesta-tech/tempesta/pull/713,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/713,"Change log:

fix #593 implement sticky sessions scheduler
fix setting unlimited sticky cookie life time
improve stability of unit tests

comment #76 (comment) not implemented in the patch, instead i work on it in separate branch since some discussion may be needed.","Change log:

fix #593 implement sticky sessions scheduler
fix setting unlimited sticky cookie life time
improve stability of unit tests

comment #76 (comment) not implemented in the patch, instead i work on it in separate branch since some discussion may be needed.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,714,2017-03-24T05:57:20Z,2017-03-24T10:24:29Z,2019-08-13T09:17:50Z,CLOSED,False,324,81,8,https://github.com/ikoveshnikov,Allow unlimited (mostly) servers and connections,1,[],https://github.com/tempesta-tech/tempesta/pull/714,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/714,"Number of servers in server group is limited to USHRT_MAX
Number of connections for server  is limited to USHRT_MAX

Branch requires changes from ik-sticky-ng, so diff here is for that branch","Number of servers in server group is limited to USHRT_MAX
Number of connections for server  is limited to USHRT_MAX

Branch requires changes from ik-sticky-ng, so diff here is for that branch",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,718,2017-04-03T13:25:36Z,2017-06-03T13:44:10Z,2017-06-10T12:56:59Z,MERGED,True,2953,1383,24,https://github.com/keshonok,Ratio algorithm for dynamic load balancing,39,[],https://github.com/tempesta-tech/tempesta/pull/718,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/718,"Also, includes dynamic memory allocation for server and connection data
so that the maximum number of servers or connections it's not limited by
constants.","Also, includes dynamic memory allocation for server and connection data
so that the maximum number of servers or connections it's not limited by
constants.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,719,2017-04-04T12:25:11Z,2017-04-17T11:44:18Z,2017-06-03T19:00:50Z,MERGED,True,186,2,14,https://github.com/ikoveshnikov,Debian package,4,[],https://github.com/tempesta-tech/tempesta/pull/719,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/719,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,720,2017-04-06T12:26:59Z,2017-04-07T06:03:06Z,2017-04-07T06:03:11Z,MERGED,True,6,2,1,https://github.com/ikoveshnikov,Don't choose restricted connections in hash scheduler,1,[],https://github.com/tempesta-tech/tempesta/pull/720,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/720,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,722,2017-04-07T11:58:19Z,2017-04-07T14:25:17Z,2017-04-07T14:25:21Z,MERGED,True,3,3,1,https://github.com/keshonok,Fix debug statements to use new names of the arguments.,1,[],https://github.com/tempesta-tech/tempesta/pull/722,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/722,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,723,2017-04-10T08:12:46Z,2017-04-17T08:40:22Z,2017-04-17T08:40:36Z,MERGED,True,20,3,2,https://github.com/keshonok,Correctly account for active connections when Tempesta is stopped on configuration error,3,[],https://github.com/tempesta-tech/tempesta/pull/723,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/723,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,725,2017-04-20T13:50:28Z,2017-04-20T14:52:29Z,2017-04-20T14:52:33Z,MERGED,True,174,0,2,https://github.com/ikoveshnikov,Installer script,4,[],https://github.com/tempesta-tech/tempesta/pull/725,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/725,Script for easy installing Tempesta from latest github releases.,Script for easy installing Tempesta from latest github releases.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,727,2017-04-20T20:26:12Z,2017-04-21T07:32:45Z,2017-04-21T07:32:51Z,CLOSED,False,561569,0,1582,https://github.com/ikoveshnikov,Linux packaging,4,[],https://github.com/tempesta-tech/tempesta/pull/727,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/727,"add linux kernel packaging for debian 9: /pkg/linux/debian
move /pkg/debian to /pkg/tempesta/debian
add packaging readme","add linux kernel packaging for debian 9: /pkg/linux/debian
move /pkg/debian to /pkg/tempesta/debian
add packaging readme",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,727,2017-04-20T20:26:12Z,2017-04-21T07:32:45Z,2017-04-21T07:32:51Z,CLOSED,False,561569,0,1582,https://github.com/ikoveshnikov,Linux packaging,4,[],https://github.com/tempesta-tech/tempesta/pull/727,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/727#issuecomment-295902110,"add linux kernel packaging for debian 9: /pkg/linux/debian
move /pkg/debian to /pkg/tempesta/debian
add packaging readme","As discussed, i put debian packaging for linux kernel into /pkg/. That doesn't seems to be a good solution: 1.5K files and 0.5M lines added by this patch. Storing TempestaFW packaging in /pkg/ doesn't
burden the repo and significantly simplify packaging.
Isn't it better to move linux packaging to separate repo, like i have done it originally: https://github.com/ikoveshnikov/linux-tfw-package ?",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,729,2017-05-04T12:09:24Z,2017-05-04T12:09:51Z,2017-06-03T19:00:12Z,MERGED,True,151,35,2,https://github.com/ikoveshnikov,update installer,2,[],https://github.com/tempesta-tech/tempesta/pull/729,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/729,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,734,2017-05-23T14:09:31Z,2017-06-08T09:05:03Z,2017-06-08T09:05:07Z,MERGED,True,212,445,9,https://github.com/ikoveshnikov,Speed up hash scheduler,7,[],https://github.com/tempesta-tech/tempesta/pull/734,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/734,"Note: patch highly rely on changes in ab-alb-2 branch, so pull request is done to that branch. Changes:

functional tests is updated to support ratio scheduler
Hash scheduler uses sorted array of connections, this improves performance (O(lg n)).
It is possible now to get connection as soon as it found. No reruns of scheduling are needed.
Calculation of connection hashes was improved to avoid collisions.

Drawbacks:

Assigning server group to hash scheduler is rather slow: creation of sorted array is implemented in naive and not optimal way.","Note: patch highly rely on changes in ab-alb-2 branch, so pull request is done to that branch. Changes:

functional tests is updated to support ratio scheduler
Hash scheduler uses sorted array of connections, this improves performance (O(lg n)).
It is possible now to get connection as soon as it found. No reruns of scheduling are needed.
Calculation of connection hashes was improved to avoid collisions.

Drawbacks:

Assigning server group to hash scheduler is rather slow: creation of sorted array is implemented in naive and not optimal way.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,740,2017-05-30T14:13:41Z,2017-06-08T09:07:13Z,2017-06-08T09:07:17Z,MERGED,True,681,60,11,https://github.com/ikoveshnikov,Support for new HTTP methods,8,[],https://github.com/tempesta-tech/tempesta/pull/740,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/740,"fix #730
fix parsing split Purge requests (in segments:  <E...>)","fix #730
fix parsing split Purge requests (in segments:  <E...>)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,741,2017-05-30T14:50:57Z,2017-05-31T19:41:55Z,2017-05-31T23:04:16Z,MERGED,True,9,0,1,https://github.com/keshonok,Fix a memory leak in implementation of pool,1,[],https://github.com/tempesta-tech/tempesta/pull/741,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/741,"The implementation keeps a handful number of pages cached.
The cache was not cleared when Tempesta was unloaded.","The implementation keeps a handful number of pages cached.
The cache was not cleared when Tempesta was unloaded.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,741,2017-05-30T14:50:57Z,2017-05-31T19:41:55Z,2017-05-31T23:04:16Z,MERGED,True,9,0,1,https://github.com/keshonok,Fix a memory leak in implementation of pool,1,[],https://github.com/tempesta-tech/tempesta/pull/741,https://github.com/nmmmnu,2,https://github.com/tempesta-tech/tempesta/pull/741#issuecomment-305281781,"The implementation keeps a handful number of pages cached.
The cache was not cleared when Tempesta was unloaded.","Strange but this code looks fishy :) Something is not right

for_each_online_cpu(icpu) {
unsigned int pgn = per_cpu(pg_next, icpu);
while (pgn--) {
unsigned long *pgc = (unsigned long *)
    per_cpu_ptr(pg_cache, icpu);
free_page(pgc[pgn]);
}
}

correct me but:

*unsigned long *pgc = (unsigned long *) per_cpu_ptr(pg_cache, icpu);*

does not depends of while loop.

correct version must be something like this:

for_each_online_cpu(icpu) {
unsigned int pgn = per_cpu(pg_next, icpu);
unsigned long *pgc = (unsigned long *) per_cpu_ptr(pg_cache, icpu);

while (pgn--)
free_page(pgc[pgn]);
}

sure modern optimizer will pull this outside of the loop.
…
On Wed, May 31, 2017 at 9:18 PM, Alexander Krizhanovsky < ***@***.***> wrote:
 ***@***.**** approved this pull request.

 Very good catch!
 ------------------------------

 In tempesta_fw/pool.c
 <#741 (comment)>
 :

 > @@ -254,6 +254,17 @@ tfw_pool_init(void)
  void
  tfw_pool_exit(void)
  {
 +	int icpu;
 +
 +	for_each_online_cpu(icpu) {
 +		unsigned int pgn = per_cpu(pg_next, icpu);
 +		while (pgn--) {
 +			unsigned long *pgc = (unsigned long *)
 +					     per_cpu_ptr(pg_cache, icpu);

 Usually following formatting looks better if there is not enough space:

         unsigned long *pgc;
         pgc = (unsigned long *)per_cpu_ptr(pg_cache, icpu);

 —
 You are receiving this because you are subscribed to this thread.
 Reply to this email directly, view it on GitHub
 <#741 (review)>,
 or mute the thread
 <https://github.com/notifications/unsubscribe-auth/AAqJ1XyLTmn9i9MzNwBOIYF9A3DFrQEQks5r_a7sgaJpZM4NqaGW>
 .",True,{'THUMBS_UP': ['https://github.com/krizhanovsky']}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,741,2017-05-30T14:50:57Z,2017-05-31T19:41:55Z,2017-05-31T23:04:16Z,MERGED,True,9,0,1,https://github.com/keshonok,Fix a memory leak in implementation of pool,1,[],https://github.com/tempesta-tech/tempesta/pull/741,https://github.com/krizhanovsky,3,https://github.com/tempesta-tech/tempesta/pull/741#issuecomment-305342958,"The implementation keeps a handful number of pages cached.
The cache was not cleared when Tempesta was unloaded.",@nmmmnu thank you for good remark!,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,742,2017-06-01T14:26:17Z,2017-06-08T09:15:24Z,2017-06-08T09:15:28Z,MERGED,True,23,24,11,https://github.com/ikoveshnikov,Fix __read_mostly section collision,1,[],https://github.com/tempesta-tech/tempesta/pull/742,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/742,"const __read_mostly is not legal and causes section type conflicts.
That's because the read.mostly section is not read only.
GCC 7 raises build error on this line.","const __read_mostly is not legal and causes section type conflicts.
That's because the read.mostly section is not read only.
GCC 7 raises build error on this line.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,742,2017-06-01T14:26:17Z,2017-06-08T09:15:24Z,2017-06-08T09:15:28Z,MERGED,True,23,24,11,https://github.com/ikoveshnikov,Fix __read_mostly section collision,1,[],https://github.com/tempesta-tech/tempesta/pull/742,https://github.com/nmmmnu,2,https://github.com/tempesta-tech/tempesta/pull/742#issuecomment-305523063,"const __read_mostly is not legal and causes section type conflicts.
That's because the read.mostly section is not read only.
GCC 7 raises build error on this line.","[0 ... _TFW_HTTP_VER_COUNT] = NULL,

this is GNU extension why not do it without this?

some like solution below.

Also string literals, e.g. ""1.0 "" and others are of type ""const char *"".
Are you going to modify them in some way?

Also, at least for C++ (not sure for C), accessing static variable is done
by lock.
You can just pull this static variable s_http_version into .h file or make
it global constant into .c file.
Because it is static, it is global anyway.

also seems like global variables are guaranteed to be zeroing so you can do
just -
note this will be initialized in compile time and will be generally faster
than current solution.

const char *s_http_version[] = { [TFW_HTTP_VER_09] = ""0.9 "" ,
[TFW_HTTP_VER_10] = ""1.0 "" , [TFW_HTTP_VER_11] = ""1.1 "" , [TFW_HTTP_VER_20]
= ""2.0 "" };
https://gist.github.com/nmmmnu/07c3acbb2729dce9d74867fdb7489baa

…
On Thu, Jun 1, 2017 at 5:26 PM, Ivan Koveshnikov ***@***.***> wrote:
 const __read_mostly is not legal and causes section type conflicts.
 That's because the read.mostly section is not read only.

 GCC 7 raises build error on this line.
 ------------------------------
 You can view, comment on, or merge this pull request online at:

   #742
 Commit Summary

    - fix __read_mostly section collision

 File Changes

    - *M* tempesta_fw/http.c
    <https://github.com/tempesta-tech/tempesta/pull/742/files#diff-0> (2)

 Patch Links:

    - https://github.com/tempesta-tech/tempesta/pull/742.patch
    - https://github.com/tempesta-tech/tempesta/pull/742.diff

 —
 You are receiving this because you are subscribed to this thread.
 Reply to this email directly, view it on GitHub
 <#742>, or mute the thread
 <https://github.com/notifications/unsubscribe-auth/AAqJ1UaL_LhqN30ahv6GAPoNoXMWulNMks5r_soJgaJpZM4NtDuU>
 .",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,742,2017-06-01T14:26:17Z,2017-06-08T09:15:24Z,2017-06-08T09:15:28Z,MERGED,True,23,24,11,https://github.com/ikoveshnikov,Fix __read_mostly section collision,1,[],https://github.com/tempesta-tech/tempesta/pull/742,https://github.com/nmmmnu,3,https://github.com/tempesta-tech/tempesta/pull/742#issuecomment-305712132,"const __read_mostly is not legal and causes section type conflicts.
That's because the read.mostly section is not read only.
GCC 7 raises build error on this line.",".ptr = (void *)(""\0   0.9 1.0 1.1 2.0 "" + hm->version * 4),
Man this is just awful code.  :)
But there is one more problem, if new protocol is added in the future, how you will handle it.
but you can do something like:
       char x[4][] = {
               ""\n\n\n\n"",
              ""0.9"",
              ""1.0"",
              //...
       }


at least is more readable",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,744,2017-06-05T13:39:42Z,2017-06-09T08:14:18Z,2017-06-09T08:14:21Z,MERGED,True,108,24,5,https://github.com/ikoveshnikov,Functional test: reboot under high load,4,[],https://github.com/tempesta-tech/tempesta/pull/744,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/744,fix #738,fix #738,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,745,2017-06-08T14:18:38Z,2017-06-08T16:51:21Z,2017-06-08T16:51:25Z,MERGED,True,32,17,4,https://github.com/ikoveshnikov,Fix serving from cache responses with empty bodies,4,[],https://github.com/tempesta-tech/tempesta/pull/745,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/745,"fix #743
fix #690","fix #743
fix #690",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,747,2017-06-09T11:32:58Z,2017-06-14T16:16:55Z,2017-06-14T16:16:59Z,MERGED,True,2,1,1,https://github.com/ikoveshnikov,Fix parsing named server groups,1,[],https://github.com/tempesta-tech/tempesta/pull/747,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/747,fix #746,fix #746,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,749,2017-06-10T16:18:17Z,2017-06-16T15:06:19Z,2017-06-16T15:06:24Z,MERGED,True,1,1,1,https://github.com/keshonok,Handle arguments with const qualifiers in tfw_str_dprint().,1,[],https://github.com/tempesta-tech/tempesta/pull/749,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/749,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,750,2017-06-14T14:44:41Z,2017-06-14T16:17:24Z,2017-06-14T16:17:28Z,MERGED,True,113,44,10,https://github.com/ikoveshnikov,Fix critical bug in hash scheduler and update func tests,7,[],https://github.com/tempesta-tech/tempesta/pull/750,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/750,"Fix critical bug in hash scheduler: possible null pointer dereference under heavy server connections failovering because of copy-paste error
Refactoring of stress tests for sticky sessions: replace buggy Siege with Wrk + lua script to support setting session cookies.
Rename Round-Robin scheduler to Ratio in all corresponding tests","Fix critical bug in hash scheduler: possible null pointer dereference under heavy server connections failovering because of copy-paste error
Refactoring of stress tests for sticky sessions: replace buggy Siege with Wrk + lua script to support setting session cookies.
Rename Round-Robin scheduler to Ratio in all corresponding tests",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,753,2017-06-18T19:20:01Z,2017-06-30T09:45:35Z,2017-06-30T09:47:36Z,MERGED,True,352,400,3,https://github.com/keshonok,Remove atomic ops in APM as updates and calculations are serialized.,9,[],https://github.com/tempesta-tech/tempesta/pull/753,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/753,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,753,2017-06-18T19:20:01Z,2017-06-30T09:45:35Z,2017-06-30T09:47:36Z,MERGED,True,352,400,3,https://github.com/keshonok,Remove atomic ops in APM as updates and calculations are serialized.,9,[],https://github.com/tempesta-tech/tempesta/pull/753,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/753#issuecomment-312202151,,Good to merge,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,756,2017-06-20T14:12:48Z,2017-07-17T22:06:46Z,2017-07-17T22:06:54Z,MERGED,True,587,272,45,https://github.com/ikoveshnikov,fix remaining active socket in state SYN-SENT,18,[],https://github.com/tempesta-tech/tempesta/pull/756,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/756,fix #751,fix #751,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,756,2017-06-20T14:12:48Z,2017-07-17T22:06:46Z,2017-07-17T22:06:54Z,MERGED,True,587,272,45,https://github.com/ikoveshnikov,fix remaining active socket in state SYN-SENT,18,[],https://github.com/tempesta-tech/tempesta/pull/756,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/756#issuecomment-313847011,fix #751,"Changes since last review:

rework of server connection lifetime. All resources attached to server connections will be released once linked socket is closed
add vim modeline to python files to set correct indentation rules.
rebase to latest master",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,757,2017-06-21T14:12:38Z,2017-07-16T09:15:33Z,2017-07-26T15:52:44Z,MERGED,True,2224,187,11,https://github.com/krizhanovsky,Fix #692,32,[],https://github.com/tempesta-tech/tempesta/pull/757,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/757,"This is unfinished work on #692, I still see crashes in tcp_clean_rtx_queue().","This is unfinished work on #692, I still see crashes in tcp_clean_rtx_queue().",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,770,2017-07-19T13:14:12Z,2017-07-19T14:11:51Z,2017-07-19T14:11:57Z,MERGED,True,6,3,2,https://github.com/keshonok,Fix handling of HTTPS connections.,1,[],https://github.com/tempesta-tech/tempesta/pull/770,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/770,"Recently TfwConn{} was split into TfwCliConn{} and TfwSrvConn{}.
TfwConn{} used to be what's now TfwCliConn{}. The change didn't
make it to TfwTlsConn{} which lead to a sure crash when using
HTTPS with Tempesta.","Recently TfwConn{} was split into TfwCliConn{} and TfwSrvConn{}.
TfwConn{} used to be what's now TfwCliConn{}. The change didn't
make it to TfwTlsConn{} which lead to a sure crash when using
HTTPS with Tempesta.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,771,2017-07-19T20:30:47Z,2017-07-26T12:49:03Z,2017-07-26T15:53:06Z,MERGED,True,520,333,11,https://github.com/krizhanovsky,Ak 763,9,[],https://github.com/tempesta-tech/tempesta/pull/771,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/771,Fix #735 and #763. Make SS logging with Tempesta prefixes.,Fix #735 and #763. Make SS logging with Tempesta prefixes.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,773,2017-07-25T18:29:35Z,2017-07-28T08:39:44Z,2017-07-28T10:02:55Z,MERGED,True,21,28,1,https://github.com/milabs,http_parser: bring return code into __FSM_EXIT macro,2,[],https://github.com/tempesta-tech/tempesta/pull/773,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/773,"Please, review.","Please, review.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,777,2017-07-28T09:33:59Z,2017-07-28T17:54:48Z,2017-07-28T17:55:53Z,MERGED,True,14,14,5,https://github.com/milabs,Make it possible to use make with -jN option,1,[],https://github.com/tempesta-tech/tempesta/pull/777,https://github.com/milabs,1,https://github.com/tempesta-tech/tempesta/pull/777,"This speeds up compile time by allowing to use -jN option with the
make. I have the following timings:
$ time make
real 0m54.787s
$ time make -j$(cat /proc/cpuinfo | grep processor | wc -l)
real 0m28.370s","This speeds up compile time by allowing to use -jN option with the
make. I have the following timings:
$ time make
real 0m54.787s
$ time make -j$(cat /proc/cpuinfo | grep processor | wc -l)
real 0m28.370s",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,783,2017-08-01T13:49:30Z,2017-08-09T13:33:45Z,2017-08-09T13:33:51Z,MERGED,True,271,286,16,https://github.com/intelfx,Various fixes to functional tests,20,[],https://github.com/tempesta-tech/tempesta/pull/783,https://github.com/intelfx,1,https://github.com/tempesta-tech/tempesta/pull/783,"(Mostly) fixes #759.
Remaining issues are:

rare sporadic failures (empty replies) in functional tests
rare sporadic failures in stress tests when all three components are ran on the same host","(Mostly) fixes #759.
Remaining issues are:

rare sporadic failures (empty replies) in functional tests
rare sporadic failures in stress tests when all three components are ran on the same host",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,783,2017-08-01T13:49:30Z,2017-08-09T13:33:45Z,2017-08-09T13:33:51Z,MERGED,True,271,286,16,https://github.com/intelfx,Various fixes to functional tests,20,[],https://github.com/tempesta-tech/tempesta/pull/783,https://github.com/intelfx,2,https://github.com/tempesta-tech/tempesta/pull/783#issuecomment-320963677,"(Mostly) fixes #759.
Remaining issues are:

rare sporadic failures (empty replies) in functional tests
rare sporadic failures in stress tests when all three components are ran on the same host",I have shuffled commits a bit (misrebase; two commits got their contents swapped). No real code changes.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,784,2017-08-02T14:57:52Z,2017-08-08T12:45:37Z,2017-08-08T12:45:40Z,MERGED,True,11,3,3,https://github.com/ikoveshnikov,Fix possible but unlikely  TfwSrvConn.qsize overflow,3,[],https://github.com/tempesta-tech/tempesta/pull/784,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/784,"The overflow is very unlikely but still may happen.
server_queue_size 0; in TempestaFW configuration means ""unlimited queue size"" and sets
TfwSrvGroup.max_qsize to UINT_MAX. New requests can be pushed into TfwSrvConn.fwd_queue
until queue size is smaller than max_qsize. Queue size may overflow the maximum allowed size, but
overflowing  UINT_MAX cause unsigned integer overflow, so queue size will have wrong value.
Could happen if server_queue_size is set to 0 and size of fwd_queue has reached UINT_MAX.
The issue is very unlikely, almost impossible.","The overflow is very unlikely but still may happen.
server_queue_size 0; in TempestaFW configuration means ""unlimited queue size"" and sets
TfwSrvGroup.max_qsize to UINT_MAX. New requests can be pushed into TfwSrvConn.fwd_queue
until queue size is smaller than max_qsize. Queue size may overflow the maximum allowed size, but
overflowing  UINT_MAX cause unsigned integer overflow, so queue size will have wrong value.
Could happen if server_queue_size is set to 0 and size of fwd_queue has reached UINT_MAX.
The issue is very unlikely, almost impossible.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,785,2017-08-04T13:09:27Z,2017-08-07T06:26:43Z,2017-08-07T06:26:48Z,MERGED,True,49,24,1,https://github.com/keshonok,Several optimizations of the process of clearing of 'fwd_queue'.,4,[],https://github.com/tempesta-tech/tempesta/pull/785,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/785,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,789,2017-08-07T06:58:12Z,2017-08-08T12:07:01Z,2017-08-08T12:07:07Z,MERGED,True,114,3,5,https://github.com/ikoveshnikov,Fix PURGE requests,3,[],https://github.com/tempesta-tech/tempesta/pull/789,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/789,"Fix invalidating responses with PURGE requests, issue #787. Corresponding functional test is provided.

Dependency to request method in request key generation is removed. This have to positives outcomes:

All cached responses for the same resource is added to TDB with the same key, and stored in the same collision chain. That makes much easier to process PURGE request.
The dependency actually broke hash scheduler: different methods for the same resource may be scheduled to different servers. So this is fixed.


Fix getting the next record in collision chain in htrie","Fix invalidating responses with PURGE requests, issue #787. Corresponding functional test is provided.

Dependency to request method in request key generation is removed. This have to positives outcomes:

All cached responses for the same resource is added to TDB with the same key, and stored in the same collision chain. That makes much easier to process PURGE request.
The dependency actually broke hash scheduler: different methods for the same resource may be scheduled to different servers. So this is fixed.


Fix getting the next record in collision chain in htrie",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,789,2017-08-07T06:58:12Z,2017-08-08T12:07:01Z,2017-08-08T12:07:07Z,MERGED,True,114,3,5,https://github.com/ikoveshnikov,Fix PURGE requests,3,[],https://github.com/tempesta-tech/tempesta/pull/789,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/789#issuecomment-320586506,"Fix invalidating responses with PURGE requests, issue #787. Corresponding functional test is provided.

Dependency to request method in request key generation is removed. This have to positives outcomes:

All cached responses for the same resource is added to TDB with the same key, and stored in the same collision chain. That makes much easier to process PURGE request.
The dependency actually broke hash scheduler: different methods for the same resource may be scheduled to different servers. So this is fixed.


Fix getting the next record in collision chain in htrie","Although corresponding functional test is provided, it fails due to several issues: first it fails when trying to serve from cache request which was previously invalidated - issue #788 , then Tempesta is crushed due to issue #782.
It also can fail due to mismach of Date: header, the situation is discussed with @intelfx during his work on #782 . This happen quite frequent for me. Here is a workaround, but i can't provide it as final solution:
--- a/tempesta_fw/t/functional/helpers/deproxy.py
+++ b/tempesta_fw/t/functional/helpers/deproxy.py
@@ -136,8 +136,8 @@ class HeaderCollection(object):
         return headers
 
     def __eq__(self, other):
-        h_self = set([(hed.lower(), val) for hed, val in self.items()])
-        h_other = set([(hed.lower(), val) for hed, val in other.items()])
+        h_self = set([(hed.lower(), val) for hed, val in self.items() if hed.lower() != 'date'])
+        h_other = set([(hed.lower(), val) for hed, val in other.items() if hed.lower() != 'date'])
         return h_self == h_other
 
     def __ne__(self, other):",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,790,2017-08-07T17:29:51Z,2017-08-07T21:33:23Z,2017-08-07T21:37:12Z,CLOSED,False,191,0,2,https://github.com/keshonok,Introduce SKB dumping functions that are helpful in debugging.,1,[],https://github.com/tempesta-tech/tempesta/pull/790,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/790,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,790,2017-08-07T17:29:51Z,2017-08-07T21:33:23Z,2017-08-07T21:37:12Z,CLOSED,False,191,0,2,https://github.com/keshonok,Introduce SKB dumping functions that are helpful in debugging.,1,[],https://github.com/tempesta-tech/tempesta/pull/790,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/790#issuecomment-320784835,,"This is already done in 54ecbed#diff-6892ca70f781b6c0fb03c6b20fc4cd0eR1145 . I doubt if skb consistency checking is usable by others. Anyway, if it is, then it should be done as an incremental patch to the pointed out patch.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,799,2017-08-15T14:11:01Z,2017-08-30T13:30:22Z,2017-08-30T13:31:47Z,MERGED,True,739,370,26,https://github.com/intelfx,Further fixes to functional tests,19,['test'],https://github.com/tempesta-tech/tempesta/pull/799,https://github.com/intelfx,1,https://github.com/tempesta-tech/tempesta/pull/799,"Fixes #792, #793, #795, #797 and various non-reported problems.","Fixes #792, #793, #795, #797 and various non-reported problems.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,799,2017-08-15T14:11:01Z,2017-08-30T13:30:22Z,2017-08-30T13:31:47Z,MERGED,True,739,370,26,https://github.com/intelfx,Further fixes to functional tests,19,['test'],https://github.com/tempesta-tech/tempesta/pull/799,https://github.com/intelfx,2,https://github.com/tempesta-tech/tempesta/pull/799#issuecomment-325990460,"Fixes #792, #793, #795, #797 and various non-reported problems.",Force-pushed to add missing .gitignore entries as requested.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,800,2017-08-16T05:36:49Z,2017-08-16T12:13:06Z,2017-08-16T12:15:02Z,MERGED,True,2,2,1,https://github.com/aleksostapenko,Bugfix #794: Detach scheduler from server group before servers' destruction.,1,[],https://github.com/tempesta-tech/tempesta/pull/800,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/800,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,800,2017-08-16T05:36:49Z,2017-08-16T12:13:06Z,2017-08-16T12:15:02Z,MERGED,True,2,2,1,https://github.com/aleksostapenko,Bugfix #794: Detach scheduler from server group before servers' destruction.,1,[],https://github.com/tempesta-tech/tempesta/pull/800,https://github.com/aleksostapenko,2,https://github.com/tempesta-tech/tempesta/pull/800#issuecomment-322751040,,Thanks:),True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,801,2017-08-16T12:01:21Z,2017-08-30T14:08:33Z,2017-08-30T14:08:48Z,MERGED,True,2387,817,16,https://github.com/ikoveshnikov,Handle conditional requests,20,[],https://github.com/tempesta-tech/tempesta/pull/801,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/801,"#529 : ETag is added to cache entry to allow handling validation and range requests
#519 : Process Conditional (If-Modified-Since and If-None-Match) requests, respond with 304 or 412 code

More unit and functional tests to come in a couple of days.","#529 : ETag is added to cache entry to allow handling validation and range requests
#519 : Process Conditional (If-Modified-Since and If-None-Match) requests, respond with 304 or 412 code

More unit and functional tests to come in a couple of days.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,807,2017-08-19T08:37:33Z,2017-08-19T17:57:27Z,2017-08-19T17:57:32Z,MERGED,True,1,1,1,https://github.com/ikoveshnikov,Fix match to list of singular headers,1,[],https://github.com/tempesta-tech/tempesta/pull/807,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/807,"fc in __hdr_is_singular() has a garbage value: it equals first byte of TfwStr structure, but not the first character in the string.","fc in __hdr_is_singular() has a garbage value: it equals first byte of TfwStr structure, but not the first character in the string.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,808,2017-08-19T20:16:43Z,2017-08-22T06:11:08Z,2017-08-23T11:56:21Z,MERGED,True,39,2,3,https://github.com/aleksostapenko,Fix #768: Set limit for digits count in 'chunk-size' field of chunked request.,1,[],https://github.com/tempesta-tech/tempesta/pull/808,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/808,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,808,2017-08-19T20:16:43Z,2017-08-22T06:11:08Z,2017-08-23T11:56:21Z,MERGED,True,39,2,3,https://github.com/aleksostapenko,Fix #768: Set limit for digits count in 'chunk-size' field of chunked request.,1,[],https://github.com/tempesta-tech/tempesta/pull/808,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/808#issuecomment-323548062,,"Please, also add unit test to test_http_parser.c.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,814,2017-08-23T09:17:04Z,2017-08-24T15:03:02Z,2017-08-24T15:03:02Z,CLOSED,False,2,0,1,https://github.com/dkirjanov,Fix #782: release server connection resources on server disconnect,1,[],https://github.com/tempesta-tech/tempesta/pull/814,https://github.com/dkirjanov,1,https://github.com/tempesta-tech/tempesta/pull/814,"there is a chance that the server connection resources wont't be released
on server disconnect and tempesta shutdown threafter so we have to explicitly
call the tfw_connection_release()
[17193.213542] ------------[ cut here ]------------
[17193.217477] Kernel BUG at ffffffffc04f06e7 [verbose debug info unavailable]
[17193.217477] invalid opcode: 0000 [#1] SMP
[17193.217477] Modules linked in: tfw_sched_ratio(O) tfw_sched_http(O)
tfw_sched_hash(O) tempesta_fw(O) tempesta_db(O) tempesta_tls(O)
bochs_drm ttm drm_kms_helper drm fb_sys_fops syscopyarea sysfillrect
ppdev input_leds led_class sg serio_raw sysimgblt parport_pc parport
pcspkr button ip_tables x_tables autofs4 ext4 crc16 jbd2 fscrypto
mbcache sr_mod cdrom sd_mod ata_generic crc32c_intel psmouse ata_piix
libata i2c_piix4 e1000 scsi_mod floppy [last unloaded: tempesta_tls]
[17193.217477] CPU: 1 PID: 4288 Comm: sysctl Tainted: G           O    4.9.35 #2
[17193.217477] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),
BIOS rel-1.10.2-0-g5f4c7b1-prebuilt.qemu-project.org 04/01/2014
[17193.217477] task: ffff93939a8f6700 task.stack: ffffa400005f0000
[17193.217477] RIP: 0010:[]  []
tfw_sock_srv_del_conns+0xf7/0x110 [tempesta_fw]
[17193.217477] RSP: 0018:ffffa400005f3ce8  EFLAGS: 00010202
[17193.217477] RAX: 0000000000000001 RBX: ffff93937642b2a0 RCX: ffffffffc0500a50
[17193.217477] RDX: ffff93937642b350 RSI: ffff93939ba9c700 RDI: ffff9393734a6420
[17193.217477] RBP: ffff93937642b2d8 R08: fffffffffffffffc R09: 0000000000000003
[17193.217477] R10: 0010000100023588 R11: 0000000000000000 R12: ffff9393734a63d8
[17193.217477] R13: ffff9393734a6410 R14: ffff9393734a6410 R15: ffffa400005f3f20
[17193.217477] FS:  00007fbc0655c880(0000) GS:ffff9393bfd00000(0000)
knlGS:0000000000000000
[17193.217477] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[17193.217477] CR2: 00007fbc05c55d00 CR3: 0000000036565000 CR4: 00000000000006e0
[17193.217477] Stack:
[17193.217477]  ffff9393734a6410 ffff93939ba9c490 ffffffffc04f05f0
ffff93939ba9c480
[17193.217477]  0000561d95e7e2e0 ffffffffc04eceb8 ece581022d7a1302
ffffffffc0500fd0
[17193.217477]  ffffffffc0500fd0 dead000000000200 dead000000000100
ffffffffc04f0835
[17193.217477] Call Trace:
[17193.217477]  [] ?
tfw_cfg_handle_ratio_predyn_opts+0x150/0x150 [tempesta_fw]
[17193.217477]  [] ? tfw_sg_for_each_srv+0x58/0x90
[tempesta_fw]
[17193.217477]  [] ?
tfw_clean_srv_groups+0x135/0x150 [tempesta_fw]
[17193.217477]  [] ? tfw_cfg_stop+0x6f/0xb0 [tempesta_fw]
[17193.217477]  [] ?
handle_sysctl_state_io+0x19d/0x1d0 [tempesta_fw]
[17193.217477]  [] ?
handle_sysctl_state_io+0x3a/0x1d0 [tempesta_fw]
[17193.217477]  [] ? proc_sys_call_handler+0xde/0x100
[17193.217477]  [] ? __vfs_write+0x2e/0x160
[17193.217477]  [] ? vfs_write+0xab/0x190
[17193.217477]  [] ? SyS_write+0x4d/0xb0
[17193.217477]  [] ? entry_SYSCALL_64_fastpath+0x17/0x98
[17193.217477] Code: 38 48 83 e8 38 4c 39 f5 74 23 4d 8b ac 24 88 00
00 00 4d 85 ed 74 14 49 8b 54 24 38 4c 89 e3 49 89 c4 48 39 d5 0f 85
46 ff ff ff <0f> 0b 5b 31 c0 5d 41 5c 41 5d 41 5e c3 66 90 66 2e 0f 1f
84 00
[17193.217477] RIP  []
tfw_sock_srv_del_conns+0xf7/0x110 [tempesta_fw]
[17193.217477]  RSP 
[17193.473816] ---[ end trace c254541427767bd1 ]---
[17193.485634] [tempesta] Un-registering scheduler: hash
[17193.518667] [tempesta] Un-registering scheduler: http
[17193.550624] [tempesta] Un-registering scheduler: ratio
[17193.585109] [tempesta] exiting...
[17193.588362] kmem_cache_destroy tfw_srv_conn_cache: Slab cache still
has objects
[17193.594033] CPU: 0 PID: 4301 Comm: rmmod Tainted: G      D    O    4.9.35 #2
[17193.598002] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),
BIOS rel-1.10.2-0-g5f4c7b1-prebuilt.qemu-project.org 04/01/2014
[17193.598002]  0000000000000000 ffffffffa569ddf8 ffff93939a0bdb40
0000000000000000
[17193.598002]  ffffffffa553c59e 00ff93939a0bdae0 ffffa400003b7e70
ffffa400003b7e70
[17193.598002]  ffffa400003b7e80 ffffa400003b7e80 4501bb40293c7162
000000000000000a
[17193.598002] Call Trace:
[17193.598002]  [] ? dump_stack+0x46/0x5e
[17193.598002]  [] ? kmem_cache_destroy+0x23e/0x250
[17193.598002]  [] ? tfw_exit+0x2b/0x60 [tempesta_fw]
[17193.598002]  [] ? SyS_delete_module+0x178/0x240
[17193.598002]  [] ? exit_to_usermode_loop+0x64/0x80
[17193.598002]  [] ? entry_SYSCALL_64_fastpath+0x17/0x98
Signed-off-by: Denis Kirjanov dk@tempesta-tech.com","there is a chance that the server connection resources wont't be released
on server disconnect and tempesta shutdown threafter so we have to explicitly
call the tfw_connection_release()
[17193.213542] ------------[ cut here ]------------
[17193.217477] Kernel BUG at ffffffffc04f06e7 [verbose debug info unavailable]
[17193.217477] invalid opcode: 0000 [#1] SMP
[17193.217477] Modules linked in: tfw_sched_ratio(O) tfw_sched_http(O)
tfw_sched_hash(O) tempesta_fw(O) tempesta_db(O) tempesta_tls(O)
bochs_drm ttm drm_kms_helper drm fb_sys_fops syscopyarea sysfillrect
ppdev input_leds led_class sg serio_raw sysimgblt parport_pc parport
pcspkr button ip_tables x_tables autofs4 ext4 crc16 jbd2 fscrypto
mbcache sr_mod cdrom sd_mod ata_generic crc32c_intel psmouse ata_piix
libata i2c_piix4 e1000 scsi_mod floppy [last unloaded: tempesta_tls]
[17193.217477] CPU: 1 PID: 4288 Comm: sysctl Tainted: G           O    4.9.35 #2
[17193.217477] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),
BIOS rel-1.10.2-0-g5f4c7b1-prebuilt.qemu-project.org 04/01/2014
[17193.217477] task: ffff93939a8f6700 task.stack: ffffa400005f0000
[17193.217477] RIP: 0010:[]  []
tfw_sock_srv_del_conns+0xf7/0x110 [tempesta_fw]
[17193.217477] RSP: 0018:ffffa400005f3ce8  EFLAGS: 00010202
[17193.217477] RAX: 0000000000000001 RBX: ffff93937642b2a0 RCX: ffffffffc0500a50
[17193.217477] RDX: ffff93937642b350 RSI: ffff93939ba9c700 RDI: ffff9393734a6420
[17193.217477] RBP: ffff93937642b2d8 R08: fffffffffffffffc R09: 0000000000000003
[17193.217477] R10: 0010000100023588 R11: 0000000000000000 R12: ffff9393734a63d8
[17193.217477] R13: ffff9393734a6410 R14: ffff9393734a6410 R15: ffffa400005f3f20
[17193.217477] FS:  00007fbc0655c880(0000) GS:ffff9393bfd00000(0000)
knlGS:0000000000000000
[17193.217477] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[17193.217477] CR2: 00007fbc05c55d00 CR3: 0000000036565000 CR4: 00000000000006e0
[17193.217477] Stack:
[17193.217477]  ffff9393734a6410 ffff93939ba9c490 ffffffffc04f05f0
ffff93939ba9c480
[17193.217477]  0000561d95e7e2e0 ffffffffc04eceb8 ece581022d7a1302
ffffffffc0500fd0
[17193.217477]  ffffffffc0500fd0 dead000000000200 dead000000000100
ffffffffc04f0835
[17193.217477] Call Trace:
[17193.217477]  [] ?
tfw_cfg_handle_ratio_predyn_opts+0x150/0x150 [tempesta_fw]
[17193.217477]  [] ? tfw_sg_for_each_srv+0x58/0x90
[tempesta_fw]
[17193.217477]  [] ?
tfw_clean_srv_groups+0x135/0x150 [tempesta_fw]
[17193.217477]  [] ? tfw_cfg_stop+0x6f/0xb0 [tempesta_fw]
[17193.217477]  [] ?
handle_sysctl_state_io+0x19d/0x1d0 [tempesta_fw]
[17193.217477]  [] ?
handle_sysctl_state_io+0x3a/0x1d0 [tempesta_fw]
[17193.217477]  [] ? proc_sys_call_handler+0xde/0x100
[17193.217477]  [] ? __vfs_write+0x2e/0x160
[17193.217477]  [] ? vfs_write+0xab/0x190
[17193.217477]  [] ? SyS_write+0x4d/0xb0
[17193.217477]  [] ? entry_SYSCALL_64_fastpath+0x17/0x98
[17193.217477] Code: 38 48 83 e8 38 4c 39 f5 74 23 4d 8b ac 24 88 00
00 00 4d 85 ed 74 14 49 8b 54 24 38 4c 89 e3 49 89 c4 48 39 d5 0f 85
46 ff ff ff <0f> 0b 5b 31 c0 5d 41 5c 41 5d 41 5e c3 66 90 66 2e 0f 1f
84 00
[17193.217477] RIP  []
tfw_sock_srv_del_conns+0xf7/0x110 [tempesta_fw]
[17193.217477]  RSP 
[17193.473816] ---[ end trace c254541427767bd1 ]---
[17193.485634] [tempesta] Un-registering scheduler: hash
[17193.518667] [tempesta] Un-registering scheduler: http
[17193.550624] [tempesta] Un-registering scheduler: ratio
[17193.585109] [tempesta] exiting...
[17193.588362] kmem_cache_destroy tfw_srv_conn_cache: Slab cache still
has objects
[17193.594033] CPU: 0 PID: 4301 Comm: rmmod Tainted: G      D    O    4.9.35 #2
[17193.598002] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),
BIOS rel-1.10.2-0-g5f4c7b1-prebuilt.qemu-project.org 04/01/2014
[17193.598002]  0000000000000000 ffffffffa569ddf8 ffff93939a0bdb40
0000000000000000
[17193.598002]  ffffffffa553c59e 00ff93939a0bdae0 ffffa400003b7e70
ffffa400003b7e70
[17193.598002]  ffffa400003b7e80 ffffa400003b7e80 4501bb40293c7162
000000000000000a
[17193.598002] Call Trace:
[17193.598002]  [] ? dump_stack+0x46/0x5e
[17193.598002]  [] ? kmem_cache_destroy+0x23e/0x250
[17193.598002]  [] ? tfw_exit+0x2b/0x60 [tempesta_fw]
[17193.598002]  [] ? SyS_delete_module+0x178/0x240
[17193.598002]  [] ? exit_to_usermode_loop+0x64/0x80
[17193.598002]  [] ? entry_SYSCALL_64_fastpath+0x17/0x98
Signed-off-by: Denis Kirjanov dk@tempesta-tech.com",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,815,2017-08-23T13:42:22Z,2017-08-25T06:30:20Z,2017-08-25T06:30:31Z,MERGED,True,21,11,3,https://github.com/aleksostapenko,Fix #768:  1. Replace 'int' with 'long' for chunks size. 2. Add check for 'signed long' overflow.,1,[],https://github.com/tempesta-tech/tempesta/pull/815,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/815,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,817,2017-08-24T15:15:11Z,2017-08-24T15:15:37Z,2017-08-24T15:17:31Z,CLOSED,False,2,0,1,https://github.com/dkirjanov,Bug782,3,[],https://github.com/tempesta-tech/tempesta/pull/817,https://github.com/dkirjanov,1,https://github.com/tempesta-tech/tempesta/pull/817,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,818,2017-08-24T15:19:27Z,2017-08-25T10:32:47Z,2017-08-25T10:35:14Z,CLOSED,False,2,0,1,https://github.com/dkirjanov,Fix #782: release a server connection resources on server disconnect,1,[],https://github.com/tempesta-tech/tempesta/pull/818,https://github.com/dkirjanov,1,https://github.com/tempesta-tech/tempesta/pull/818,"there is a chance that the server connection resources wont't be released
on server disconnect and tempesta shutdown threafter so we have to explicitly
call the tfw_connection_release()
On tempesta shutdown a backend server connection state
is set to the TFW_CONN_DEATHCNT value and thus we won't
release the connection resources in tfw_sock_srv_disconnect()
and directly close the socket causing the BUG() in case
tfw_sock_srv_connect_try_later() is still trying to reconnect.
Signed-off-by: Denis Kirjanov dk@tempesta-tech.com","there is a chance that the server connection resources wont't be released
on server disconnect and tempesta shutdown threafter so we have to explicitly
call the tfw_connection_release()
On tempesta shutdown a backend server connection state
is set to the TFW_CONN_DEATHCNT value and thus we won't
release the connection resources in tfw_sock_srv_disconnect()
and directly close the socket causing the BUG() in case
tfw_sock_srv_connect_try_later() is still trying to reconnect.
Signed-off-by: Denis Kirjanov dk@tempesta-tech.com",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,819,2017-08-25T12:48:00Z,2017-08-25T12:51:37Z,2017-08-25T12:52:05Z,CLOSED,False,6,0,1,https://github.com/dkirjanov,Fix #782: release a server connection resources on tempesta,3,[],https://github.com/tempesta-tech/tempesta/pull/819,https://github.com/dkirjanov,1,https://github.com/tempesta-tech/tempesta/pull/819,"shutdown
there is a chance that the server connection resources wont't be released
on server disconnect and tempesta shutdown threafter so we have to explicitly
call the tfw_connection_release()
Signed-off-by: Denis Kirjanov dk@tempesta-tech.com","shutdown
there is a chance that the server connection resources wont't be released
on server disconnect and tempesta shutdown threafter so we have to explicitly
call the tfw_connection_release()
Signed-off-by: Denis Kirjanov dk@tempesta-tech.com",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,820,2017-08-25T13:00:19Z,2017-08-26T19:29:25Z,2017-08-26T19:29:33Z,MERGED,True,33,16,1,https://github.com/dkirjanov,Fix #782: release a server connection resources on shutdown,2,[],https://github.com/tempesta-tech/tempesta/pull/820,https://github.com/dkirjanov,1,https://github.com/tempesta-tech/tempesta/pull/820,"make sure the resources of a connection closed by a backend
right before the shutdown are released.
Signed-off-by: Denis Kirjanov dk@tempesta-tech.com","make sure the resources of a connection closed by a backend
right before the shutdown are released.
Signed-off-by: Denis Kirjanov dk@tempesta-tech.com",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,820,2017-08-25T13:00:19Z,2017-08-26T19:29:25Z,2017-08-26T19:29:33Z,MERGED,True,33,16,1,https://github.com/dkirjanov,Fix #782: release a server connection resources on shutdown,2,[],https://github.com/tempesta-tech/tempesta/pull/820,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/820#issuecomment-324979009,"make sure the resources of a connection closed by a backend
right before the shutdown are released.
Signed-off-by: Denis Kirjanov dk@tempesta-tech.com","@keshonok please add the comment as you've discussed and double check with @ikoveshnikov, who reproduced the issue, that #782 is no longer appear. It's also worth to run full cycle of our functional tests. If the tests passes, then it's good to merge to master.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,820,2017-08-25T13:00:19Z,2017-08-26T19:29:25Z,2017-08-26T19:29:33Z,MERGED,True,33,16,1,https://github.com/dkirjanov,Fix #782: release a server connection resources on shutdown,2,[],https://github.com/tempesta-tech/tempesta/pull/820,https://github.com/ikoveshnikov,3,https://github.com/tempesta-tech/tempesta/pull/820#issuecomment-325006063,"make sure the resources of a connection closed by a backend
right before the shutdown are released.
Signed-off-by: Denis Kirjanov dk@tempesta-tech.com",I can confirm that the issue is not reproduced with the patch applied. I also run the full cycle of the functional tests and everything is still fine. The patch can be merged as soon as the comment is added to the patch.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,824,2017-08-28T09:35:29Z,2017-08-30T09:41:55Z,2017-08-30T09:45:42Z,MERGED,True,8,1,1,https://github.com/aleksostapenko,Fix #798: Avoid crash during processing of erroneous response.,1,[],https://github.com/tempesta-tech/tempesta/pull/824,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/824,"Sending error response to client (with correct removal of paired request).
Sending correct response to client after sibling message creation failure (before server connection closing).","Sending error response to client (with correct removal of paired request).
Sending correct response to client after sibling message creation failure (before server connection closing).",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,827,2017-08-30T13:58:25Z,2017-08-31T17:42:20Z,2017-08-31T17:42:24Z,MERGED,True,68,31,4,https://github.com/keshonok,Inherit unspecified directives from group 'default' (Fix #813),4,[],https://github.com/tempesta-tech/tempesta/pull/827,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/827,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,835,2017-09-03T20:31:53Z,2017-09-05T07:04:17Z,2017-09-05T07:04:20Z,MERGED,True,25,13,3,https://github.com/ikoveshnikov,Fix parsing responses not allowed to have a body,3,[],https://github.com/tempesta-tech/tempesta/pull/835,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/835,"Fix #816

Tag all responses not allowed to have a body with VOID_BODY flag
Block responses with Content-Length header if it is not allowed by RFC 7230 Section 3.3.2","Fix #816

Tag all responses not allowed to have a body with VOID_BODY flag
Block responses with Content-Length header if it is not allowed by RFC 7230 Section 3.3.2",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,835,2017-09-03T20:31:53Z,2017-09-05T07:04:17Z,2017-09-05T07:04:20Z,MERGED,True,25,13,3,https://github.com/ikoveshnikov,Fix parsing responses not allowed to have a body,3,[],https://github.com/tempesta-tech/tempesta/pull/835,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/835#issuecomment-326886660,"Fix #816

Tag all responses not allowed to have a body with VOID_BODY flag
Block responses with Content-Length header if it is not allowed by RFC 7230 Section 3.3.2",@keshonok Thank you for review!,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,836,2017-09-04T11:57:01Z,2017-09-05T12:00:19Z,2017-09-05T13:13:20Z,CLOSED,False,71,49,5,https://github.com/aleksostapenko,Fix #826: Set APM data before setting scheduler for server group.,1,[],https://github.com/tempesta-tech/tempesta/pull/836,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/836,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,837,2017-09-05T12:24:22Z,2017-10-05T17:02:41Z,2017-10-05T17:03:04Z,MERGED,True,290,46,8,https://github.com/bartolootrit,Frang: limit HTTP error codes (password crackers blocking) #717,5,[],https://github.com/tempesta-tech/tempesta/pull/837,https://github.com/bartolootrit,1,https://github.com/tempesta-tech/tempesta/pull/837,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,837,2017-09-05T12:24:22Z,2017-10-05T17:02:41Z,2017-10-05T17:03:04Z,MERGED,True,290,46,8,https://github.com/bartolootrit,Frang: limit HTTP error codes (password crackers blocking) #717,5,[],https://github.com/tempesta-tech/tempesta/pull/837,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/837#issuecomment-334528686,,@bartolootrit thank you very much for you valuable contribution!,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,839,2017-09-08T13:29:30Z,2017-09-25T10:00:48Z,2017-09-25T10:05:24Z,MERGED,True,166,104,5,https://github.com/aleksostapenko,Fix #825: Close client connection if error response is failed.,6,[],https://github.com/tempesta-tech/tempesta/pull/839,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/839,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,839,2017-09-08T13:29:30Z,2017-09-25T10:00:48Z,2017-09-25T10:05:24Z,MERGED,True,166,104,5,https://github.com/aleksostapenko,Fix #825: Close client connection if error response is failed.,6,[],https://github.com/tempesta-tech/tempesta/pull/839,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/839#issuecomment-328143419,,"Seems that it's the best solution possible since the issue can happen on any processing stage.  I think that tfw_http_send_*() in the patch shouldn't return error code on errors. It should have the same behaviour as tfw_http_resp_fwd(): send response or process the error if needed.
I have also noticed, that generated 302 and 304 replies are still affected by the issue.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,840,2017-09-13T14:40:42Z,2017-09-19T14:54:47Z,2017-09-19T14:54:53Z,MERGED,True,18,7,2,https://github.com/ikoveshnikov,Fix error in fuzzer unit test,3,[],https://github.com/tempesta-tech/tempesta/pull/840,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/840,"Mark responses generated by fuzzer as invalid, if Content-Length header present but not allowed by the RFC
Print tests summary on the single line","Mark responses generated by fuzzer as invalid, if Content-Length header present but not allowed by the RFC
Print tests summary on the single line",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,845,2017-09-22T21:29:57Z,2017-09-28T05:18:33Z,2017-09-28T05:19:33Z,MERGED,True,183,4,6,https://github.com/aleksostapenko,Add new stress tests.,4,[],https://github.com/tempesta-tech/tempesta/pull/845,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/845,"Add pipelined requests during stress testing.
Add fault injection via SystemTap.","Add pipelined requests during stress testing.
Add fault injection via SystemTap.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,845,2017-09-22T21:29:57Z,2017-09-28T05:18:33Z,2017-09-28T05:19:33Z,MERGED,True,183,4,6,https://github.com/aleksostapenko,Add new stress tests.,4,[],https://github.com/tempesta-tech/tempesta/pull/845,https://github.com/intelfx,2,https://github.com/tempesta-tech/tempesta/pull/845#issuecomment-332164249,"Add pipelined requests during stress testing.
Add fault injection via SystemTap.",@krizhanovsky We discussed this briefly on Slack — with the conclusion being that @aleksostapenko does the stress test (which does not concern itself with correctness) and I do the functional test once I'm done with CI.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,848,2017-10-09T16:05:17Z,2017-11-02T12:22:30Z,2017-11-02T12:22:30Z,MERGED,True,903,287,14,https://github.com/aleksostapenko,Fix #658: Add possibility to configure error response behaviour.,6,[],https://github.com/tempesta-tech/tempesta/pull/848,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/848,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,849,2017-10-11T23:07:14Z,2017-10-14T00:14:20Z,2017-12-31T11:06:54Z,MERGED,True,166,98,5,https://github.com/krizhanovsky,Fix #691,6,['crucial'],https://github.com/tempesta-tech/tempesta/pull/849,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/849,"Fix #691: free() skbs in ss_tx_action() is a connection is dead;
Fix memory corruption in __copy_ip_header(): don't write IP header after reserved, and only allocated, skb room;
Use native Linux skb_entail();
Add assertions to debug #692;
Don't use virt_to_head_page() if we're unsure that the page is heading.","Fix #691: free() skbs in ss_tx_action() is a connection is dead;
Fix memory corruption in __copy_ip_header(): don't write IP header after reserved, and only allocated, skb room;
Use native Linux skb_entail();
Add assertions to debug #692;
Don't use virt_to_head_page() if we're unsure that the page is heading.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,851,2017-10-28T09:29:53Z,2017-12-29T18:49:13Z,2017-12-29T19:38:46Z,MERGED,True,4177,1721,45,https://github.com/ikoveshnikov,Live reconfiguration,53,[],https://github.com/tempesta-tech/tempesta/pull/851,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/851,"Live reconfiguration, only core features are supported in reconfiguration:

Adding and removing server groups
adding and removing servers in server groups
adding more connections to each server (removing of connection are not supported)
adding and removing http match rules
changing any server group options
changing scheduler assigned to a server group

Known limitations/issues:

can't reduce number of server connections

To start live reconfiguration simply run ./scripts/tempesta.sh --reload or write sysctl variable sysctl -w net.tempesta.state=start while Tempesta FW is running.","Live reconfiguration, only core features are supported in reconfiguration:

Adding and removing server groups
adding and removing servers in server groups
adding more connections to each server (removing of connection are not supported)
adding and removing http match rules
changing any server group options
changing scheduler assigned to a server group

Known limitations/issues:

can't reduce number of server connections

To start live reconfiguration simply run ./scripts/tempesta.sh --reload or write sysctl variable sysctl -w net.tempesta.state=start while Tempesta FW is running.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,855,2017-11-03T19:59:18Z,2017-11-15T14:04:30Z,2017-11-15T14:05:00Z,MERGED,True,28,30,7,https://github.com/aleksostapenko,Remove TFW_STOP/SS_STOP flags (#658).,4,[],https://github.com/tempesta-tech/tempesta/pull/855,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/855,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,859,2017-11-10T13:19:39Z,2017-11-12T20:54:16Z,2017-11-12T20:54:32Z,MERGED,True,21,11,3,https://github.com/aleksostapenko,Corrections for some functional tests.,2,[],https://github.com/tempesta-tech/tempesta/pull/859,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/859,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,863,2017-11-21T07:46:26Z,2017-11-21T14:27:25Z,2017-11-21T15:10:47Z,MERGED,True,0,9,1,https://github.com/keshonok,Remove dead function declarations from http.h,1,[],https://github.com/tempesta-tech/tempesta/pull/863,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/863,These functions had since been renamed and placed in http_msg.[ch].,These functions had since been renamed and placed in http_msg.[ch].,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,864,2017-11-22T16:49:13Z,2017-11-26T23:20:33Z,2017-11-26T23:20:33Z,CLOSED,False,0,25,2,https://github.com/keshonok,Cleanup: Remove dead code: tfw_str_del_chunk(),1,[],https://github.com/tempesta-tech/tempesta/pull/864,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/864,"The function is unused since the commit 08a10df when the original
__field_finish() was removed from http_parser.c, and the parser was
fixed to not create unnecessary empty chunks at the end of a current
chunk of processed data.
There was no need in this function since September 2015, so I believe
it's safe to remove it.","The function is unused since the commit 08a10df when the original
__field_finish() was removed from http_parser.c, and the parser was
fixed to not create unnecessary empty chunks at the end of a current
chunk of processed data.
There was no need in this function since September 2015, so I believe
it's safe to remove it.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,864,2017-11-22T16:49:13Z,2017-11-26T23:20:33Z,2017-11-26T23:20:33Z,CLOSED,False,0,25,2,https://github.com/keshonok,Cleanup: Remove dead code: tfw_str_del_chunk(),1,[],https://github.com/tempesta-tech/tempesta/pull/864,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/864#issuecomment-346416041,"The function is unused since the commit 08a10df when the original
__field_finish() was removed from http_parser.c, and the parser was
fixed to not create unnecessary empty chunks at the end of a current
chunk of processed data.
There was no need in this function since September 2015, so I believe
it's safe to remove it.","str.[ch] is a string library and tfw_str_del_chunk() can be useful in further code. If we just remove the function, then it's likely that we'll just forget about it and reinvent it when we need it. Meantime the bad thing about the function is that it isn't covered by t/unit/test_tfw_str.c - it'd be good to write a unit test for the function.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,864,2017-11-22T16:49:13Z,2017-11-26T23:20:33Z,2017-11-26T23:20:33Z,CLOSED,False,0,25,2,https://github.com/keshonok,Cleanup: Remove dead code: tfw_str_del_chunk(),1,[],https://github.com/tempesta-tech/tempesta/pull/864,https://github.com/keshonok,3,https://github.com/tempesta-tech/tempesta/pull/864#issuecomment-346492943,"The function is unused since the commit 08a10df when the original
__field_finish() was removed from http_parser.c, and the parser was
fixed to not create unnecessary empty chunks at the end of a current
chunk of processed data.
There was no need in this function since September 2015, so I believe
it's safe to remove it.","Uh, that's fine. Just thought that, perhaps, it was worth removing since it wasn't used in two years. But I can understand the point that this should be considered a library function.
My understanding is that the two opposite functions here are tfw_str_del_chunk() and tfw_str_add_compound(). As far as I can see none of these are really covered by unit tests. The second one is just used in str tests.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,864,2017-11-22T16:49:13Z,2017-11-26T23:20:33Z,2017-11-26T23:20:33Z,CLOSED,False,0,25,2,https://github.com/keshonok,Cleanup: Remove dead code: tfw_str_del_chunk(),1,[],https://github.com/tempesta-tech/tempesta/pull/864,https://github.com/krizhanovsky,4,https://github.com/tempesta-tech/tempesta/pull/864#issuecomment-346611055,"The function is unused since the commit 08a10df when the original
__field_finish() was removed from http_parser.c, and the parser was
fixed to not create unnecessary empty chunks at the end of a current
chunk of processed data.
There was no need in this function since September 2015, so I believe
it's safe to remove it.",Created issue #865 for the tests @,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,864,2017-11-22T16:49:13Z,2017-11-26T23:20:33Z,2017-11-26T23:20:33Z,CLOSED,False,0,25,2,https://github.com/keshonok,Cleanup: Remove dead code: tfw_str_del_chunk(),1,[],https://github.com/tempesta-tech/tempesta/pull/864,https://github.com/keshonok,5,https://github.com/tempesta-tech/tempesta/pull/864#issuecomment-347047415,"The function is unused since the commit 08a10df when the original
__field_finish() was removed from http_parser.c, and the parser was
fixed to not create unnecessary empty chunks at the end of a current
chunk of processed data.
There was no need in this function since September 2015, so I believe
it's safe to remove it.","The function in question is a library function, hence it's should not be removed.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,866,2017-11-26T20:18:01Z,2017-11-30T14:25:09Z,2017-11-30T14:25:09Z,MERGED,True,9,3,1,https://github.com/keshonok,Correctly check for an overflow of pc->end value in apm.c,1,[],https://github.com/tempesta-tech/tempesta/pull/866,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/866,"Without this fix, in the impossible case the loop that calculates
the new pc->end value could run nearly indefinitely, and the check
in BUG_ON() would always be false.","Without this fix, in the impossible case the loop that calculates
the new pc->end value could run nearly indefinitely, and the check
in BUG_ON() would always be false.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,867,2017-11-27T12:58:19Z,2017-12-04T10:47:25Z,2017-12-04T10:58:58Z,MERGED,True,238,24,6,https://github.com/aleksostapenko,Fix #860: Add functional tests for TCP connection closing.,5,[],https://github.com/tempesta-tech/tempesta/pull/867,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/867,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,869,2017-12-08T12:44:21Z,2017-12-11T13:33:40Z,2017-12-11T13:33:44Z,MERGED,True,310,0,3,https://github.com/ikoveshnikov,Unit tests for  work queue,1,[],https://github.com/tempesta-tech/tempesta/pull/869,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/869,fix #779,fix #779,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,870,2017-12-08T13:10:34Z,2017-12-28T12:12:34Z,2017-12-28T12:18:56Z,MERGED,True,151,0,4,https://github.com/vladtcvs,Add tests against memory leaks,2,[],https://github.com/tempesta-tech/tempesta/pull/870,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/870,Fix #758,Fix #758,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,872,2017-12-15T13:17:14Z,2018-02-26T00:02:58Z,2018-02-26T00:03:01Z,MERGED,True,765,76,13,https://github.com/ikoveshnikov,Add user-defined headers before forward response to client,12,[],https://github.com/tempesta-tech/tempesta/pull/872,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/872,fix #511,fix #511,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,874,2017-12-19T15:21:16Z,2018-01-18T13:11:53Z,2018-10-23T13:37:47Z,MERGED,True,1107,0,12,https://github.com/vladtcvs, Add wrk mixed requests tests,5,[],https://github.com/tempesta-tech/tempesta/pull/874,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/874,"GET requests
HEAD GET requests
GET POST requests
POST requests with small body
POST requests with big body
fix #765","GET requests
HEAD GET requests
GET POST requests
POST requests with small body
POST requests with big body
fix #765",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,875,2017-12-22T10:39:33Z,2018-02-28T20:47:44Z,2018-03-01T12:45:40Z,MERGED,True,482,228,18,https://github.com/vladtcvs,Exception catching in tearDown,1,[],https://github.com/tempesta-tech/tempesta/pull/875,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/875,"use try except for catching exceptions in stop functions
fix #846","use try except for catching exceptions in stop functions
fix #846",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,875,2017-12-22T10:39:33Z,2018-02-28T20:47:44Z,2018-03-01T12:45:40Z,MERGED,True,482,228,18,https://github.com/vladtcvs,Exception catching in tearDown,1,[],https://github.com/tempesta-tech/tempesta/pull/875,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/875#issuecomment-365223272,"use try except for catching exceptions in stop functions
fix #846","Tried to run tests and got this:
1 ik@ikpc ../tempesta/tempesta_fw/t/functional (git)-[vlts-846-exceptions] 
% ./run_tests.py -v                                                  
Traceback (most recent call last):
  File ""./run_tests.py"", line 10, in <module>
    from helpers import tf_cfg, remote, shell, control
  File ""/mnt/Storage/Projects/tempesta/tempesta/tempesta_fw/t/functional/helpers/control.py"", line 299, in <module>
    class DeproxyTester(object, Stateful):
TypeError: Error when calling the metaclass bases
    Cannot create a consistent method resolution
order (MRO) for bases object, Stateful",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,876,2017-12-28T03:12:37Z,2017-12-29T21:52:11Z,2017-12-31T11:06:59Z,MERGED,True,295,157,6,https://github.com/krizhanovsky,"Fix #692 & #615: skb page refcounting, forwarded skb initialization",1,[],https://github.com/tempesta-tech/tempesta/pull/876,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/876,"Fix #692 in the kernel.


ss_skb_init_for_xmit() initializes forwarded skbs;


Protect tcp_v4_connect() -> tcp_connect() by the socket lock to let it
finish it's operation before getting response (e.g. ACK) from the peer
(crucial for loopback connections sending packets just by function calls);


Add assertions to guarantee that socket lock is aquired by current CPU;


Many replacements of BUG() assertions by WARN_ON_ONCE() for better
reliability.


Define TFW_CLASSIFIER_ACCSZ in dependence on CONFIG_DEBUG_LOCK_ALLOC
and several other minor fixes and cleanups;


I reviewed UDP/datagram code as well and the patch introduces several
fixes applicable to datagrams (e.g. skb_morph()), so I believe #615 can be safely closed.","Fix #692 in the kernel.


ss_skb_init_for_xmit() initializes forwarded skbs;


Protect tcp_v4_connect() -> tcp_connect() by the socket lock to let it
finish it's operation before getting response (e.g. ACK) from the peer
(crucial for loopback connections sending packets just by function calls);


Add assertions to guarantee that socket lock is aquired by current CPU;


Many replacements of BUG() assertions by WARN_ON_ONCE() for better
reliability.


Define TFW_CLASSIFIER_ACCSZ in dependence on CONFIG_DEBUG_LOCK_ALLOC
and several other minor fixes and cleanups;


I reviewed UDP/datagram code as well and the patch introduces several
fixes applicable to datagrams (e.g. skb_morph()), so I believe #615 can be safely closed.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,877,2017-12-28T21:51:09Z,2018-03-04T16:33:06Z,2018-03-04T16:33:59Z,MERGED,True,1888,138,29,https://github.com/aleksostapenko,Fix #672: Add health monitoring for backend servers.,30,[],https://github.com/tempesta-tech/tempesta/pull/877,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/877,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,882,2018-01-12T10:36:08Z,2018-01-12T11:06:19Z,2018-01-12T11:06:23Z,MERGED,True,10,3,1,https://github.com/ikoveshnikov,fix build without CONFIG_DEBUG_SPINLOCK,1,['crucial'],https://github.com/tempesta-tech/tempesta/pull/882,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/882,"Member owner_cpu exists in raw_spinlock only when CONFIG_DEBUG_SPINLOCK is set. It's very likely that the configuration option is disabled (at least it is so for Debian configuration), compilation of current master fails.","Member owner_cpu exists in raw_spinlock only when CONFIG_DEBUG_SPINLOCK is set. It's very likely that the configuration option is disabled (at least it is so for Debian configuration), compilation of current master fails.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,884,2018-01-16T19:11:22Z,2018-03-13T19:49:24Z,2018-03-13T19:49:40Z,MERGED,True,707,355,23,https://github.com/ikoveshnikov,Early bind of response and request,19,[],https://github.com/tempesta-tech/tempesta/pull/884,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/884,"fix #871.
Also done:

Http parser can look now inside request when parses response, that was required for some methods.
remove the hack described in #838, but GFSM revision is still required.","fix #871.
Also done:

Http parser can look now inside request when parses response, that was required for some methods.
remove the hack described in #838, but GFSM revision is still required.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,884,2018-01-16T19:11:22Z,2018-03-13T19:49:24Z,2018-03-13T19:49:40Z,MERGED,True,707,355,23,https://github.com/ikoveshnikov,Early bind of response and request,19,[],https://github.com/tempesta-tech/tempesta/pull/884,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/884#issuecomment-358300529,"fix #871.
Also done:

Http parser can look now inside request when parses response, that was required for some methods.
remove the hack described in #838, but GFSM revision is still required.",@keshonok Thank for your review!,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,885,2018-01-17T14:37:56Z,2018-03-15T11:21:41Z,2018-03-15T11:25:00Z,MERGED,True,774,11,9,https://github.com/vladtcvs,1M backends,4,[],https://github.com/tempesta-tech/tempesta/pull/885,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/885,"fix: #680
1M backends
Separate listener config to class
Use UUID for config name
Support of multiple ports","fix: #680
1M backends
Separate listener config to class
Use UUID for config name
Support of multiple ports",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,885,2018-01-17T14:37:56Z,2018-03-15T11:21:41Z,2018-03-15T11:25:00Z,MERGED,True,774,11,9,https://github.com/vladtcvs,1M backends,4,[],https://github.com/tempesta-tech/tempesta/pull/885,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/885#issuecomment-366444903,"fix: #680
1M backends
Separate listener config to class
Use UUID for config name
Support of multiple ports",Please address comment #680 (comment),True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,885,2018-01-17T14:37:56Z,2018-03-15T11:21:41Z,2018-03-15T11:25:00Z,MERGED,True,774,11,9,https://github.com/vladtcvs,1M backends,4,[],https://github.com/tempesta-tech/tempesta/pull/885,https://github.com/vladtcvs,3,https://github.com/tempesta-tech/tempesta/pull/885#issuecomment-373343684,"fix: #680
1M backends
Separate listener config to class
Use UUID for config name
Support of multiple ports","Due to performance problems, I couldn't test with 1M backend, only with much less.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,889,2018-01-21T14:21:57Z,2018-01-26T18:43:37Z,2018-02-02T15:51:22Z,MERGED,True,10,11,2,https://github.com/krizhanovsky,"We know what we do with sched_data, so disable senseless warnings",1,[],https://github.com/tempesta-tech/tempesta/pull/889,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/889,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,891,2018-01-22T05:35:47Z,2018-02-09T20:56:05Z,2018-02-12T18:26:03Z,MERGED,True,136,2,9,https://github.com/aleksostapenko,Add http scheduler matching for Referer header. ,6,[],https://github.com/tempesta-tech/tempesta/pull/891,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/891,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,892,2018-01-23T12:07:16Z,2018-01-23T15:04:30Z,2018-01-23T15:04:35Z,MERGED,True,16,6,4,https://github.com/ikoveshnikov,Update installer and packaging,1,[],https://github.com/tempesta-tech/tempesta/pull/892,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/892,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,894,2018-01-24T17:59:55Z,2018-02-05T13:31:40Z,2018-02-05T13:31:44Z,MERGED,True,96,31,6,https://github.com/ikoveshnikov,Fix hang on configuration parse error,8,[],https://github.com/tempesta-tech/tempesta/pull/894,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/894,Fix first part of #893,Fix first part of #893,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,896,2018-01-25T09:52:27Z,2018-02-02T14:35:47Z,2018-02-02T15:51:01Z,MERGED,True,314,182,13,https://github.com/krizhanovsky,"Fix #838, fix #842: make GFSM get more data on L4-L7",2,[],https://github.com/tempesta-tech/tempesta/pull/896,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/896,"GFSM #838: use TfwFsmData as L4-L7 data descriptor for GFSM - pass skb and
off as well as request and response, probably NULL, to each call.
GFSM #842: actually hooks are unregisterable for a while;
Frang: use explicit uint type conversion instead of FRANG_RESP_TIME_PERIOD
Frang: no need to keep per-quantum counter in 64-bit integer;
Adjust levels of debug messages on SS layer according to log.h comment;
Small cleanups all around.","GFSM #838: use TfwFsmData as L4-L7 data descriptor for GFSM - pass skb and
off as well as request and response, probably NULL, to each call.
GFSM #842: actually hooks are unregisterable for a while;
Frang: use explicit uint type conversion instead of FRANG_RESP_TIME_PERIOD
Frang: no need to keep per-quantum counter in 64-bit integer;
Adjust levels of debug messages on SS layer according to log.h comment;
Small cleanups all around.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,897,2018-01-26T11:45:43Z,2018-03-16T12:08:45Z,2018-03-16T12:08:49Z,MERGED,True,935,61,18,https://github.com/vladtcvs,Long body in responses and requests,12,[],https://github.com/tempesta-tech/tempesta/pull/897,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/897,fix #619,fix #619,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,897,2018-01-26T11:45:43Z,2018-03-16T12:08:45Z,2018-03-16T12:08:49Z,MERGED,True,935,61,18,https://github.com/vladtcvs,Long body in responses and requests,12,[],https://github.com/tempesta-tech/tempesta/pull/897,https://github.com/vladtcvs,2,https://github.com/tempesta-tech/tempesta/pull/897#issuecomment-366517347,fix #619,problem with breaking other tests fixed,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,898,2018-01-26T20:31:23Z,2018-02-09T14:43:07Z,2018-02-12T18:24:55Z,MERGED,True,43,5,4,https://github.com/aleksostapenko,Fix #802: Add 'Age:' header for stored responses.,2,[],https://github.com/tempesta-tech/tempesta/pull/898,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/898,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,904,2018-02-05T15:04:46Z,2018-02-05T15:55:17Z,2018-02-05T15:55:21Z,MERGED,True,1,0,1,https://github.com/ikoveshnikov,fix unwanded deletion,1,[],https://github.com/tempesta-tech/tempesta/pull/904,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/904,Mistakenly removed in last commit of #894,Mistakenly removed in last commit of #894,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,906,2018-02-07T15:41:23Z,2018-12-07T11:07:36Z,2018-12-07T11:07:47Z,CLOSED,False,210,50,7,https://github.com/vladtcvs,Stress tests 702 error handling,13,[],https://github.com/tempesta-tech/tempesta/pull/906,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/906,fix: #702,fix: #702,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,906,2018-02-07T15:41:23Z,2018-12-07T11:07:36Z,2018-12-07T11:07:47Z,CLOSED,False,210,50,7,https://github.com/vladtcvs,Stress tests 702 error handling,13,[],https://github.com/tempesta-tech/tempesta/pull/906,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/906#issuecomment-425652132,fix: #702,"#702 is a test for #940, scheduled for 1.0.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,906,2018-02-07T15:41:23Z,2018-12-07T11:07:36Z,2018-12-07T11:07:47Z,CLOSED,False,210,50,7,https://github.com/vladtcvs,Stress tests 702 error handling,13,[],https://github.com/tempesta-tech/tempesta/pull/906,https://github.com/ikoveshnikov,3,https://github.com/tempesta-tech/tempesta/pull/906#issuecomment-445199990,fix: #702,"The proposed approach is dead-end. The only way to stabilize the tests - completely disable net rate limits.  But in this case other tests became more, especially if high load is used in the test. The complete and stable solution can be done only after #940 is implemented",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,909,2018-02-13T10:19:13Z,2018-02-18T12:23:03Z,2018-02-18T12:23:06Z,MERGED,True,2,2,1,https://github.com/ikoveshnikov,Update return codes on message parsing errors.,1,[],https://github.com/tempesta-tech/tempesta/pull/909,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/909,"502 status code indicates that gateway or proxy received an
invalid response from an inbound server. See RFC 7231 Section 6.6.3.
400 status code indicates a client error (e.g., malformed request
syntax, invalid request message framing, or deceptive request routing).
See RFC 7231 Section 6.5.1.
Note, that frang module can block responses and requests, but such
blocks shouldn't be confused for parsing errors. If request was
filtered out by frang, the 403 status code must be returned. If
response was filtered out, then the same 502 status code must be
returned.
Although the patch closes issue described in #900, more work (as fixing up content-length header) is required in #900.","502 status code indicates that gateway or proxy received an
invalid response from an inbound server. See RFC 7231 Section 6.6.3.
400 status code indicates a client error (e.g., malformed request
syntax, invalid request message framing, or deceptive request routing).
See RFC 7231 Section 6.5.1.
Note, that frang module can block responses and requests, but such
blocks shouldn't be confused for parsing errors. If request was
filtered out by frang, the 403 status code must be returned. If
response was filtered out, then the same 502 status code must be
returned.
Although the patch closes issue described in #900, more work (as fixing up content-length header) is required in #900.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,913,2018-02-16T23:05:54Z,2018-03-01T13:21:41Z,2018-03-01T13:23:11Z,MERGED,True,122,5,6,https://github.com/aleksostapenko,Fix #844: Avoid frang and sticky processing for whitelist requests.,6,[],https://github.com/tempesta-tech/tempesta/pull/913,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/913,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,916,2018-02-17T14:22:48Z,2018-03-03T08:35:13Z,2018-03-03T08:45:34Z,MERGED,True,727,596,20,https://github.com/krizhanovsky,"Fix #76 #886 #908 #911, many other fixes and optimizations",13,[],https://github.com/tempesta-tech/tempesta/pull/916,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/916,Please read commits descriptions,Please read commits descriptions,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,916,2018-02-17T14:22:48Z,2018-03-03T08:35:13Z,2018-03-03T08:45:34Z,MERGED,True,727,596,20,https://github.com/krizhanovsky,"Fix #76 #886 #908 #911, many other fixes and optimizations",13,[],https://github.com/tempesta-tech/tempesta/pull/916,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/916#issuecomment-368636758,Please read commits descriptions,"Still reviewing: there is some issue in reconfigurations code. Reconfiguration tests fail and crash Tempesta:
   40.543629] [tdb] Start Tempesta DB
[   40.554990] net_ratelimit: 1 callbacks suppressed
[   40.556483] [tempesta] Initializing Tempesta FW kernel module...
[   40.564618] [tempesta] Registering new scheduler: hash
[   40.570745] [tempesta] Registering new scheduler: http
[   40.581123] [tempesta] Registering new scheduler: ratio
[   40.626207] [tempesta] Prepearing for the configuration processing.
[   40.628830] [tempesta] Configuration processing is completed.
[   40.639633] [tdb] Opened table /opt/tempesta/db/filter.tdb: size=16777216 rec_size=20 base=ffff94157c400000
[   40.762709] [tdb] Opened table /opt/tempesta/db/cache.tdb: size=268435456 rec_size=0 base=ffff94156c400000
[   40.765524] [tempesta] Open listen socket on: 0.0.0.0
[   40.780090] [tempesta] modules are started
[   50.519206] [tempesta] Live reconfiguration of Tempesta.
[   50.521350] [tempesta] Prepearing for the configuration processing.
[   50.523342] [tempesta] Configuration processing is completed.
[   50.525629] ------------[ cut here ]------------
[   50.527083] kernel BUG at /home/user/tempesta/tempesta/tempesta_fw/http.c:1330!
[   50.528735] invalid opcode: 0000 [#1] SMP
[   50.528735] Modules linked in: tfw_sched_ratio(O) tfw_sched_http(O) tfw_sched_hash(O) tempesta_fw(O) tempesta_db(O) tempesta_tls(O) crct10dif_pclmul binfmt_misc crc32_pclmul snd_hda_codec_generic iTCO_wdt iTCO_vendor_support ghash_clmulni_intel ppdev snd_hda_intel snd_hda_codec snd_hda_core snd_hwdep snd_pcm evdev snd_timer snd lpc_ich serio_raw pcspkr soundcore mfd_core virtio_balloon sg virtio_console qxl parport_pc parport ttm drm_kms_helper button drm shpchp ip_tables x_tables autofs4 ext4 crc16 jbd2 crc32c_generic fscrypto ecb mbcache sr_mod cdrom virtio_blk virtio_net crc32c_intel ahci libahci aesni_intel i2c_i801 i2c_smbus aes_x86_64 glue_helper lrw gf128mul ablk_helper cryptd psmouse uhci_hcd ehci_pci ehci_hcd libata usbcore usb_common sym53c8xx scsi_transport_spi scsi_mod virtio_pci virtio_ring virtio [last unloaded: tempesta_tls]
[   50.534804] CPU: 0 PID: 1453 Comm: sysctl Tainted: G           O    4.9.0-tempesta-amd64 #1 Debian 4.9.35-tfw4-1
[   50.534804] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.11.0-20171110_100015-anatol 04/01/2014
[   50.534804] task: ffff94155b449d00 task.stack: ffffb0c1816c8000
[   50.534804] RIP: 0010:[<ffffffffc085bd23>]  [<ffffffffc085bd23>] tfw_http_req_destruct+0x53/0x60 [tempesta_fw]
[   50.534804] RSP: 0018:ffff94157fc03c30  EFLAGS: 00010206
[   50.534804] RAX: ffff9415597e63f0 RBX: ffff94155aeba020 RCX: 000000010010000a
[   50.534804] RDX: ffff94155aeba3f0 RSI: ffffd99fc1667c40 RDI: ffff94155aeba020
[   50.534804] RBP: ffff94157fc03c50 R08: ffff9415599f1200 R09: 000000010010000a
[   50.534804] R10: ffff9415599f1400 R11: 2ce33e6c02ce3300 R12: ffff9415599b5678
[   50.534804] R13: ffff94157fc03c50 R14: ffff9415599b572c R15: ffff94157fc03c50
[   50.534804] FS:  00007f4d1a61b880(0000) GS:ffff94157fc00000(0000) knlGS:0000000000000000
[   50.534804] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   50.534804] CR2: 00007f4d19d15d00 CR3: 000000005b8fb000 CR4: 00000000003406f0
[   50.534804] Stack:
[   50.534804]  ffff9415599b5678 ffffffffc085f579 ffff94155aeba020 ffffffffc085be92
[   50.534804]  ffff94157fc03c50 ffff94157fc03c50 0000000059645e70 212fd317b59b8a3f
[   50.534804]  0000000700000024 ffff9415599f0020 ffff94155aeba020 ffff94157fc1a540
[   50.534804] Call Trace:
[   50.534804]  <IRQ> [   50.534804]  [<ffffffffc085f579>] ? tfw_http_msg_free+0x89/0xa0 [tempesta_fw]
[   50.534804]  [<ffffffffc085be92>] ? tfw_http_resp_fwd+0x162/0x2c0 [tempesta_fw]
[   50.534804]  [<ffffffffc085c177>] ? tfw_http_send_resp+0x187/0x1a0 [tempesta_fw]
[   50.534804]  [<ffffffffc085cc2c>] ? tfw_http_conn_shrink_fwdq_resched+0x23c/0x2b0 [tempesta_fw]
[   50.534804]  [<ffffffffc085ceb4>] ? tfw_http_conn_release+0x214/0x240 [tempesta_fw]
[   50.534804]  [<ffffffffc0859334>] ? tfw_connection_release+0x24/0x50 [tempesta_fw]
[   50.534804]  [<ffffffffc087ed7e>] ? tfw_srv_conn_release+0xe/0x80 [tempesta_fw]
[   50.534804]  [<ffffffffc087bbcc>] ? ss_tx_action+0x38c/0x4b0 [tempesta_fw]
[   50.534804]  [<ffffffffb95048db>] ? net_tx_action+0x9b/0x1d0
[   50.534804]  [<ffffffffb9610d1a>] ? __do_softirq+0x10a/0x29a
[   50.534804]  [<ffffffffc087f090>] ? tfw_sock_srv_grace_shutdown_srv+0x110/0x110 [tempesta_fw]
[   50.534804]  [<ffffffffb960f16c>] ? do_softirq_own_stack+0x1c/0x30
[   50.534804]  <EOI> [   50.534804]  [<ffffffffb908056d>] ? do_softirq.part.18+0x3d/0x50
[   50.534804]  [<ffffffffb90805f8>] ? __local_bh_enable_ip+0x78/0x80
[   50.534804]  [<ffffffffc087ee73>] ? tfw_sock_srv_disconnect_srv+0x83/0xb0 [tempesta_fw]
[   50.534804]  [<ffffffffc087f07c>] ? tfw_sock_srv_grace_shutdown_srv+0xfc/0x110 [tempesta_fw]
[   50.534804]  [<ffffffffc087f0f7>] ? __tfw_cfgop_update_sg_srv_list+0x67/0x1a0 [tempesta_fw]
[   50.534804]  [<ffffffffc087f090>] ? tfw_sock_srv_grace_shutdown_srv+0x110/0x110 [tempesta_fw]
[   50.534804]  [<ffffffffc087f090>] ? tfw_sock_srv_grace_shutdown_srv+0x110/0x110 [tempesta_fw]
[   50.534804]  [<ffffffffc0879940>] ? __tfw_sg_for_each_srv+0x70/0xa0 [tempesta_fw]
[   50.534804]  [<ffffffffc087eac5>] ? tfw_sock_srv_start+0xf5/0x330 [tempesta_fw]
[   50.534804]  [<ffffffffc087784d>] ? tfw_ctlfn_state_io+0x36d/0x530 [tempesta_fw]
[   50.534804]  [<ffffffffb960b77e>] ? mutex_lock+0xe/0x30
[   50.534804]  [<ffffffffc0877524>] ? tfw_ctlfn_state_io+0x44/0x530 [tempesta_fw]
[   50.534804]  [<ffffffffb9282b43>] ? proc_sys_call_handler+0xe3/0x100
[   50.534804]  [<ffffffffb9208820>] ? vfs_write+0xb0/0x190
[   50.534804]  [<ffffffffb9209c12>] ? SyS_write+0x52/0xc0
[   50.534804]  [<ffffffffb960e1fb>] ? system_call_fast_compare_end+0xc/0x9b
[   50.534804] Code: 03 00 00 48 8d 97 e0 03 00 00 48 39 c2 75 1e 48 8b bf 58 03 00 00 48 85 ff 74 09 48 83 c4 08 e9 74 b0 01 00 48 83 c4 08 c3 0f 0b <0f> 0b 0f 0b 66 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 41 57 41 
[   50.534804] RIP  [<ffffffffc085bd23>] tfw_http_req_destruct+0x53/0x60 [tempesta_fw]
[   50.534804]  RSP <ffff94157fc03c30>

The crash happened on reconf.test_stress_sched_hash.SchedHashCustomSg.test_hash_del_add_srvs. In the same time i have no issues with reconf tests on current master",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,916,2018-02-17T14:22:48Z,2018-03-03T08:35:13Z,2018-03-03T08:45:34Z,MERGED,True,727,596,20,https://github.com/krizhanovsky,"Fix #76 #886 #908 #911, many other fixes and optimizations",13,[],https://github.com/tempesta-tech/tempesta/pull/916,https://github.com/krizhanovsky,3,https://github.com/tempesta-tech/tempesta/pull/916#issuecomment-369974783,Please read commits descriptions,"The crash #916 (comment) is due to assertion BUG_ON(!list_empty(&req->fwd_list)). The root casue is that tfw_http_conn_shrink_fwdq_resched() calls tfw_http_req_err() with srv_conn == NULL since it passes the whole srv_conn->fwd_queue to schq, so tfw_http_req_delist() isn't called for a request.  This works fine if req is going to be added to the error queue, but we hit the crash if we try to send an error response immediately. The assertion fail is expected and harmless in general, but still must be fixed.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,920,2018-02-20T04:29:01Z,2018-02-21T23:14:42Z,2018-02-21T23:14:47Z,MERGED,True,964,207,18,https://github.com/ikoveshnikov,Add JS challenge,7,[],https://github.com/tempesta-tech/tempesta/pull/920,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/920,"Add JavaScript challenge (fix #536)
start frang on demand (#888)","Add JavaScript challenge (fix #536)
start frang on demand (#888)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,921,2018-02-20T10:42:16Z,2018-02-21T12:14:08Z,2018-02-21T12:14:12Z,CLOSED,False,1,0,1,https://github.com/ikoveshnikov,fix #886: remove saved sessions after tests,1,[],https://github.com/tempesta-tech/tempesta/pull/921,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/921,"I can't reproduce the issue on my side, but the sticky cleanup is certainly missed in sticky tests. Previously tfw_http_sess_exit() was responsible for the cleanup, not it's tfw_cfgop_sticky_cleanup() job.","I can't reproduce the issue on my side, but the sticky cleanup is certainly missed in sticky tests. Previously tfw_http_sess_exit() was responsible for the cleanup, not it's tfw_cfgop_sticky_cleanup() job.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,921,2018-02-20T10:42:16Z,2018-02-21T12:14:08Z,2018-02-21T12:14:12Z,CLOSED,False,1,0,1,https://github.com/ikoveshnikov,fix #886: remove saved sessions after tests,1,[],https://github.com/tempesta-tech/tempesta/pull/921,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/921#issuecomment-367152803,"I can't reproduce the issue on my side, but the sticky cleanup is certainly missed in sticky tests. Previously tfw_http_sess_exit() was responsible for the cleanup, not it's tfw_cfgop_sticky_cleanup() job.","Thank you for the starting point to fix the issue, the full version is 64fe087",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,927,2018-02-26T20:47:51Z,2018-02-28T21:29:38Z,2018-02-28T21:29:46Z,MERGED,True,62,14,6,https://github.com/ikoveshnikov,Better verbosity for tests,7,[],https://github.com/tempesta-tech/tempesta/pull/927,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/927,"Running tests on a new testbed configuration raises question, how effective tests are. I had been running tests for a long time before I realised that the load was extremely low and tests was ineffective.
Changes:

Get requests rate from wrk  output and show it on 2-nd level of debug
Echo full wrk output on debug level 3
Warn on wrk socket errors
Add basic tests for predict and dynamic ratio schedulers

At least now it's easier to look though tests results to check for performance regressions.","Running tests on a new testbed configuration raises question, how effective tests are. I had been running tests for a long time before I realised that the load was extremely low and tests was ineffective.
Changes:

Get requests rate from wrk  output and show it on 2-nd level of debug
Echo full wrk output on debug level 3
Warn on wrk socket errors
Add basic tests for predict and dynamic ratio schedulers

At least now it's easier to look though tests results to check for performance regressions.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,928,2018-03-02T16:12:52Z,2018-03-02T16:25:24Z,2018-03-02T16:25:39Z,MERGED,True,1,1,1,https://github.com/vladtcvs,Fix leaks test,1,[],https://github.com/tempesta-tech/tempesta/pull/928,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/928,Fix using client.results() in leaks test,Fix using client.results() in leaks test,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,933,2018-03-03T22:17:53Z,2018-03-04T17:33:38Z,2018-03-04T17:33:43Z,MERGED,True,43,54,3,https://github.com/ikoveshnikov,Fix --no-resume cmdline option,2,[],https://github.com/tempesta-tech/tempesta/pull/933,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/933,And fix multiple pylint2 warnings.,And fix multiple pylint2 warnings.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,935,2018-03-04T18:26:28Z,2018-03-06T07:18:42Z,2018-03-10T15:20:45Z,MERGED,True,34,22,5,https://github.com/krizhanovsky,Fix #925; improve WQ testing for #922,4,[],https://github.com/tempesta-tech/tempesta/pull/935,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/935,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,937,2018-03-05T20:43:42Z,2018-03-09T16:51:18Z,2018-03-10T15:20:40Z,MERGED,True,28,18,1,https://github.com/krizhanovsky,Fix #922.,2,[],https://github.com/tempesta-tech/tempesta/pull/937,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/937,"The fix sets head_local for a producer before entering to the loop, so a consumer always sees the least heads. See the problem description in #922 (comment)","The fix sets head_local for a producer before entering to the loop, so a consumer always sees the least heads. See the problem description in #922 (comment)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,937,2018-03-05T20:43:42Z,2018-03-09T16:51:18Z,2018-03-10T15:20:40Z,MERGED,True,28,18,1,https://github.com/krizhanovsky,Fix #922.,2,[],https://github.com/tempesta-tech/tempesta/pull/937,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/937#issuecomment-370677935,"The fix sets head_local for a producer before entering to the loop, so a consumer always sees the least heads. See the problem description in #922 (comment)","Tested the branch on server ang got a crush after ~7.5 hours:
[ 1586.533856] [tdb] Start Tempesta DB
[ 1586.543436] [tempesta] Initializing Tempesta FW kernel module...
[ 1586.553060] [tempesta] Registering new scheduler: hash
[ 1586.561156] [tempesta] Registering new scheduler: http
[ 1586.569173] [tempesta] Registering new scheduler: ratio
[ 1586.578837] [tempesta] Prepearing for the configuration processing.
[ 1586.585550] [tempesta] Configuration processing is completed.
[ 1586.595550] [tdb] Opened table /opt/tempesta/db/filter.tdb: size=16777216 rec_size=20 base=ffff8f4a16400000
[ 1586.605957] [tempesta] Open listen socket on: 0.0.0.0
[ 1586.632395] [tempesta] modules are started
[ 2344.585787] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[ 5178.329271] perf: interrupt took too long (2502 > 2500), lowering kernel.perf_event_max_sample_rate to 79750
[ 5610.327222] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[ 5747.424291] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[ 5987.780530] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[ 8198.127809] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[ 8686.900919] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[10864.922185] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[11021.253118] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[11691.150241] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[13729.154001] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[15600.166762] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[20105.734405] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[21610.205865] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[22202.809255] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[23111.284270] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[23428.922355] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[27106.485050] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[28114.367605] ------------[ cut here ]------------
[28114.372685] WARNING: CPU: 1 PID: 0 at /root/ik/tempesta/tempesta_fw/work_queue.c:162 tfw_wq_pop_ticket+0x151/0x3f0 [tempesta_fw]
[28114.384914] Modules linked in: tfw_sched_ratio(O) tfw_sched_http(O) tfw_sched_hash(O) tempesta_fw(O) tempesta_db(O) tempesta_tls(O) bridge mlx5_core(O) 8021q garp mrp mlxfw(O) stp llc mlx4_en(O) intel_rapl x86_pkg_temp_thermal intel_powerclamp coretemp kvm_intel kvm irqbypass crct10dif_pclmul crc32_pclmul ghash_clmulni_intel ast intel_cstate iTCO_wdt ttm iTCO_vendor_support hci_uart drm_kms_helper btbcm btqca i2c_i801 drm btintel igb pcspkr intel_uncore intel_lpss_acpi ie31200_edac mei_me intel_lpss intel_rapl_perf i2c_smbus ipmi_si dca i2c_algo_bit bluetooth mfd_core joydev sg edac_core mei ipmi_msghandler acpi_als video battery rfkill i2c_hid acpi_power_meter kfifo_buf button industrialio mlx4_core(O) mlx_compat(O) devlink ptp pps_core ip_tables x_tables autofs4 ext4 crc16 jbd2 crc32c_generic fscrypto
[28114.459420]  ecb mbcache sd_mod evdev hid_generic usbhid hid mpt3sas crc32c_intel raid_class xhci_pci scsi_transport_sas aesni_intel aes_x86_64 glue_helper xhci_hcd lrw gf128mul ablk_helper scsi_mod cryptd usbcore usb_common shpchp fan thermal [last unloaded: tempesta_tls]
[28114.483989] CPU: 1 PID: 0 Comm: swapper/1 Tainted: G           O    4.9.0-tempesta-amd64 #1 Debian 4.9.35-tfw5-1
[28114.494596] Hardware name: Supermicro Super Server/X11SSL-CF, BIOS 1.0a 01/29/2016
[28114.502584]  0000000000000000 ffffffff8832f194 0000000000000000 0000000000000000
[28114.510490]  ffffffff8807adee ffff8f4a37843ee0 ffff8f4a3785a840 ffffffff88d13ec0
[28114.518392]  000000005f074747 ffff8f4a37843ee8 ffffffffc12a54f8 ffffffffc0e69d61
[28114.526311] Call Trace:
[28114.529206]  <IRQ> 
[28114.531151]  [<ffffffff8832f194>] ? dump_stack+0x5c/0x78
[28114.536916]  [<ffffffff8807adee>] ? __warn+0xbe/0xe0
[28114.542341]  [<ffffffffc0e69d61>] ? tfw_wq_pop_ticket+0x151/0x3f0 [tempesta_fw]
[28114.550110]  [<ffffffffc0e5e990>] ? ss_tx_action+0x250/0x4b0 [tempesta_fw]
[28114.557449]  [<ffffffff880eaacd>] ? hrtimer_get_next_event+0x3d/0x60
[28114.564265]  [<ffffffff885048db>] ? net_tx_action+0x9b/0x1d0
[28114.570397]  [<ffffffff88610d1a>] ? __do_softirq+0x10a/0x29a
[28114.576536]  [<ffffffff88080f4e>] ? irq_exit+0xae/0xb0
[28114.582159]  [<ffffffff886103e2>] ? call_function_single_interrupt+0x82/0x90
[28114.589772]  <EOI> 
[28114.591709]  [<ffffffff8860dd6a>] ? poll_idle+0x2a/0x57
[28114.597438]  [<ffffffff884d282a>] ? cpuidle_enter_state+0xea/0x2b0
[28114.604106]  [<ffffffff880bd884>] ? cpu_startup_entry+0x154/0x240
[28114.610658]  [<ffffffff880480ed>] ? start_secondary+0x14d/0x190
[28114.617033] ---[ end trace f6dc18978cdf8115 ]---
[28114.622119] ------------[ cut here ]------------
[28114.627203] WARNING: CPU: 1 PID: 0 at /root/ik/tempesta/tempesta_fw/work_queue.c:141 tfw_wq_pop_ticket+0xbd/0x3f0 [tempesta_fw]
[28114.639621] Modules linked in: tfw_sched_ratio(O) tfw_sched_http(O) tfw_sched_hash(O) tempesta_fw(O) tempesta_db(O) tempesta_tls(O) bridge mlx5_core(O) 8021q garp mrp mlxfw(O) stp llc mlx4_en(O) intel_rapl x86_pkg_temp_thermal intel_powerclamp coretemp kvm_intel kvm irqbypass crct10dif_pclmul crc32_pclmul ghash_clmulni_intel ast intel_cstate iTCO_wdt ttm iTCO_vendor_support hci_uart drm_kms_helper btbcm btqca i2c_i801 drm btintel igb pcspkr intel_uncore intel_lpss_acpi ie31200_edac mei_me intel_lpss intel_rapl_perf i2c_smbus ipmi_si dca i2c_algo_bit bluetooth mfd_core joydev sg edac_core mei ipmi_msghandler acpi_als video battery rfkill i2c_hid acpi_power_meter kfifo_buf button industrialio mlx4_core(O) mlx_compat(O) devlink ptp pps_core ip_tables x_tables autofs4 ext4 crc16 jbd2 crc32c_generic fscrypto
[28114.715764]  ecb mbcache sd_mod evdev hid_generic usbhid hid mpt3sas crc32c_intel raid_class xhci_pci scsi_transport_sas aesni_intel aes_x86_64 glue_helper xhci_hcd lrw gf128mul ablk_helper scsi_mod cryptd usbcore usb_common shpchp fan thermal [last unloaded: tempesta_tls]
[28114.741458] CPU: 1 PID: 0 Comm: swapper/1 Tainted: G        W  O    4.9.0-tempesta-amd64 #1 Debian 4.9.35-tfw5-1
[28114.752464] Hardware name: Supermicro Super Server/X11SSL-CF, BIOS 1.0a 01/29/2016
[28114.760841]  0000000000000000 ffffffff8832f194 0000000000000000 0000000000000000
[28114.769246]  ffffffff8807adee ffff8f4a37843ee0 ffff8f4a3785a840 0000000000000006
[28114.777561]  000000005f074748 ffff8f4a37843ee8 ffffffffc12a54f8 ffffffffc0e69ccd
[28114.785871] Call Trace:
[28114.789171]  <IRQ> 
[28114.791109]  [<ffffffff8832f194>] ? dump_stack+0x5c/0x78
[28114.797240]  [<ffffffff8807adee>] ? __warn+0xbe/0xe0
[28114.802962]  [<ffffffffc0e69ccd>] ? tfw_wq_pop_ticket+0xbd/0x3f0 [tempesta_fw]
[28114.810966]  [<ffffffffc0e5e990>] ? ss_tx_action+0x250/0x4b0 [tempesta_fw]
[28114.818603]  [<ffffffff880eaacd>] ? hrtimer_get_next_event+0x3d/0x60
[28114.825671]  [<ffffffff885048db>] ? net_tx_action+0x9b/0x1d0
[28114.832120]  [<ffffffff88610d1a>] ? __do_softirq+0x10a/0x29a
[28114.838468]  [<ffffffff88080f4e>] ? irq_exit+0xae/0xb0
[28114.844308]  [<ffffffff886103e2>] ? call_function_single_interrupt+0x82/0x90
[28114.852054]  <EOI> 
[28114.853999]  [<ffffffff8860dd6a>] ? poll_idle+0x2a/0x57
[28114.859902]  [<ffffffff884d282a>] ? cpuidle_enter_state+0xea/0x2b0
[28114.866724]  [<ffffffff880bd884>] ? cpu_startup_entry+0x154/0x240
[28114.873452]  [<ffffffff880480ed>] ? start_secondary+0x14d/0x190
[28114.880037] ---[ end trace f6dc18978cdf8116 ]---
[28114.888640] ------------[ cut here ]------------
[28114.893995] WARNING: CPU: 1 PID: 16 at /root/ik/tempesta/tempesta_fw/ss_skb.c:1067 ss_skb_init_for_xmit+0x288/0x290 [tempesta_fw]
[28114.907023] Modules linked in: tfw_sched_ratio(O) tfw_sched_http(O) tfw_sched_hash(O) tempesta_fw(O) tempesta_db(O) tempesta_tls(O) bridge mlx5_core(O) 8021q garp mrp mlxfw(O) stp llc mlx4_en(O) intel_rapl x86_pkg_temp_thermal intel_powerclamp coretemp kvm_intel kvm irqbypass crct10dif_pclmul crc32_pclmul ghash_clmulni_intel ast intel_cstate iTCO_wdt ttm iTCO_vendor_support hci_uart drm_kms_helper btbcm btqca i2c_i801 drm btintel igb pcspkr intel_uncore intel_lpss_acpi ie31200_edac mei_me intel_lpss intel_rapl_perf i2c_smbus ipmi_si dca i2c_algo_bit bluetooth mfd_core joydev sg edac_core mei ipmi_msghandler acpi_als video battery rfkill i2c_hid acpi_power_meter kfifo_buf button industrialio mlx4_core(O) mlx_compat(O) devlink ptp pps_core ip_tables x_tables autofs4 ext4 crc16 jbd2 crc32c_generic fscrypto
[28114.983914]  ecb mbcache sd_mod evdev hid_generic usbhid hid mpt3sas crc32c_intel raid_class xhci_pci scsi_transport_sas aesni_intel aes_x86_64 glue_helper xhci_hcd lrw gf128mul ablk_helper scsi_mod cryptd usbcore usb_common shpchp fan thermal [last unloaded: tempesta_tls]
[28115.009728] CPU: 1 PID: 16 Comm: ksoftirqd/1 Tainted: G        W  O    4.9.0-tempesta-amd64 #1 Debian 4.9.35-tfw5-1
[28115.020987] Hardware name: Supermicro Super Server/X11SSL-CF, BIOS 1.0a 01/29/2016
[28115.029399]  0000000000000000 ffffffff8832f194 0000000000000000 0000000000000000
[28115.037704]  ffffffff8807adee ffff8f49b767b000 0000000000000000 00000000000001c0
[28115.045991]  ffff8f49b767b100 000000000001a840 ffffffffc12a54f8 ffffffffc0e64d38
[28115.054285] Call Trace:
[28115.057525]  [<ffffffff8832f194>] ? dump_stack+0x5c/0x78
[28115.063665]  [<ffffffff8807adee>] ? __warn+0xbe/0xe0
[28115.069423]  [<ffffffffc0e64d38>] ? ss_skb_init_for_xmit+0x288/0x290 [tempesta_fw]
[28115.077804]  [<ffffffffc0e5eb12>] ? ss_tx_action+0x3d2/0x4b0 [tempesta_fw]
[28115.085451]  [<ffffffff885048db>] ? net_tx_action+0x9b/0x1d0
[28115.091921]  [<ffffffff88610d1a>] ? __do_softirq+0x10a/0x29a
[28115.098324]  [<ffffffff8809dcd0>] ? sort_range+0x20/0x20
[28115.104338]  [<ffffffff88080e15>] ? run_ksoftirqd+0x25/0x40
[28115.110595]  [<ffffffff8809ddce>] ? smpboot_thread_fn+0xfe/0x150
[28115.117270]  [<ffffffff8809a577>] ? kthread+0xd7/0xf0
[28115.122975]  [<ffffffff8809a4a0>] ? kthread_park+0x60/0x60
[28115.129080]  [<ffffffff8860e475>] ? ret_from_fork+0x25/0x30
[28115.135264] ---[ end trace f6dc18978cdf8117 ]---
[28115.140487] ------------[ cut here ]------------
[28115.145717] WARNING: CPU: 1 PID: 16 at /root/ik/tempesta/tempesta_fw/ss_skb.c:1068 ss_skb_init_for_xmit+0x233/0x290 [tempesta_fw]
[28115.158588] Modules linked in: tfw_sched_ratio(O) tfw_sched_http(O) tfw_sched_hash(O) tempesta_fw(O) tempesta_db(O) tempesta_tls(O) bridge mlx5_core(O) 8021q garp mrp mlxfw(O) stp llc mlx4_en(O) intel_rapl x86_pkg_temp_thermal intel_powerclamp coretemp kvm_intel kvm irqbypass crct10dif_pclmul crc32_pclmul ghash_clmulni_intel ast intel_cstate iTCO_wdt ttm iTCO_vendor_support hci_uart drm_kms_helper btbcm btqca i2c_i801 drm btintel igb pcspkr intel_uncore intel_lpss_acpi ie31200_edac mei_me intel_lpss intel_rapl_perf i2c_smbus ipmi_si dca i2c_algo_bit bluetooth mfd_core joydev sg edac_core mei ipmi_msghandler acpi_als video battery rfkill i2c_hid acpi_power_meter kfifo_buf button industrialio mlx4_core(O) mlx_compat(O) devlink ptp pps_core ip_tables x_tables autofs4 ext4 crc16 jbd2 crc32c_generic fscrypto
[28115.235213]  ecb mbcache sd_mod evdev hid_generic usbhid hid mpt3sas crc32c_intel raid_class xhci_pci scsi_transport_sas aesni_intel aes_x86_64 glue_helper xhci_hcd lrw gf128mul ablk_helper scsi_mod cryptd usbcore usb_common shpchp fan thermal [last unloaded: tempesta_tls]
[28115.260818] CPU: 1 PID: 16 Comm: ksoftirqd/1 Tainted: G        W  O    4.9.0-tempesta-amd64 #1 Debian 4.9.35-tfw5-1
[28115.272038] Hardware name: Supermicro Super Server/X11SSL-CF, BIOS 1.0a 01/29/2016
[28115.280399]  0000000000000000 ffffffff8832f194 0000000000000000 0000000000000000
[28115.288667]  ffffffff8807adee ffff8f49b767b000 0000000000000000 00000000000001c0
[28115.296949]  ffff8f49b767b100 000000000001a840 ffffffffc12a54f8 ffffffffc0e64ce3
[28115.305232] Call Trace:
[28115.308472]  [<ffffffff8832f194>] ? dump_stack+0x5c/0x78
[28115.314530]  [<ffffffff8807adee>] ? __warn+0xbe/0xe0
[28115.320261]  [<ffffffffc0e64ce3>] ? ss_skb_init_for_xmit+0x233/0x290 [tempesta_fw]
[28115.328582]  [<ffffffffc0e5eb12>] ? ss_tx_action+0x3d2/0x4b0 [tempesta_fw]
[28115.336194]  [<ffffffff885048db>] ? net_tx_action+0x9b/0x1d0
[28115.342582]  [<ffffffff88610d1a>] ? __do_softirq+0x10a/0x29a
[28115.348951]  [<ffffffff8809dcd0>] ? sort_range+0x20/0x20
[28115.354950]  [<ffffffff88080e15>] ? run_ksoftirqd+0x25/0x40
[28115.361198]  [<ffffffff8809ddce>] ? smpboot_thread_fn+0xfe/0x150
[28115.367718]  [<ffffffff8809a577>] ? kthread+0xd7/0xf0
[28115.373269]  [<ffffffff8809a4a0>] ? kthread_park+0x60/0x60
[28115.379238]  [<ffffffff8860e475>] ? ret_from_fork+0x25/0x30
[28115.385288] ---[ end trace f6dc18978cdf8118 ]---
[28115.390377] ------------[ cut here ]------------
[28115.395469] WARNING: CPU: 1 PID: 16 at /root/ik/tempesta/tempesta_fw/ss_skb.c:1069 ss_skb_init_for_xmit+0x25d/0x290 [tempesta_fw]
[28115.408098] Modules linked in: tfw_sched_ratio(O) tfw_sched_http(O) tfw_sched_hash(O) tempesta_fw(O) tempesta_db(O) tempesta_tls(O) bridge mlx5_core(O) 8021q garp mrp mlxfw(O) stp llc mlx4_en(O) intel_rapl x86_pkg_temp_thermal intel_powerclamp coretemp kvm_intel kvm irqbypass crct10dif_pclmul crc32_pclmul ghash_clmulni_intel ast intel_cstate iTCO_wdt ttm iTCO_vendor_support hci_uart drm_kms_helper btbcm btqca i2c_i801 drm btintel igb pcspkr intel_uncore intel_lpss_acpi ie31200_edac mei_me intel_lpss intel_rapl_perf i2c_smbus ipmi_si dca i2c_algo_bit bluetooth mfd_core joydev sg edac_core mei ipmi_msghandler acpi_als video battery rfkill i2c_hid acpi_power_meter kfifo_buf button industrialio mlx4_core(O) mlx_compat(O) devlink ptp pps_core ip_tables x_tables autofs4 ext4 crc16 jbd2 crc32c_generic fscrypto
[28115.484001]  ecb mbcache sd_mod evdev hid_generic usbhid hid mpt3sas crc32c_intel raid_class xhci_pci scsi_transport_sas aesni_intel aes_x86_64 glue_helper xhci_hcd lrw gf128mul ablk_helper scsi_mod cryptd usbcore usb_common shpchp fan thermal [last unloaded: tempesta_tls]
[28115.509588] CPU: 1 PID: 16 Comm: ksoftirqd/1 Tainted: G        W  O    4.9.0-tempesta-amd64 #1 Debian 4.9.35-tfw5-1
[28115.520625] Hardware name: Supermicro Super Server/X11SSL-CF, BIOS 1.0a 01/29/2016
[28115.528805]  0000000000000000 ffffffff8832f194 0000000000000000 0000000000000000
[28115.536891]  ffffffff8807adee ffff8f49b767b000 0000000000000000 00000000000001c0
[28115.545012]  ffff8f49b767b100 000000000001a840 ffffffffc12a54f8 ffffffffc0e64d0d
[28115.553094] Call Trace:
[28115.556181]  [<ffffffff8832f194>] ? dump_stack+0x5c/0x78
[28115.562099]  [<ffffffff8807adee>] ? __warn+0xbe/0xe0
[28115.567685]  [<ffffffffc0e64d0d>] ? ss_skb_init_for_xmit+0x25d/0x290 [tempesta_fw]
[28115.576037]  [<ffffffffc0e5eb12>] ? ss_tx_action+0x3d2/0x4b0 [tempesta_fw]
[28115.583620]  [<ffffffff885048db>] ? net_tx_action+0x9b/0x1d0
[28115.590007]  [<ffffffff88610d1a>] ? __do_softirq+0x10a/0x29a
[28115.596365]  [<ffffffff8809dcd0>] ? sort_range+0x20/0x20
[28115.602336]  [<ffffffff88080e15>] ? run_ksoftirqd+0x25/0x40
[28115.608551]  [<ffffffff8809ddce>] ? smpboot_thread_fn+0xfe/0x150
[28115.615214]  [<ffffffff8809a577>] ? kthread+0xd7/0xf0
[28115.620911]  [<ffffffff8809a4a0>] ? kthread_park+0x60/0x60
[28115.627023]  [<ffffffff8860e475>] ? ret_from_fork+0x25/0x30
[28115.633181] ---[ end trace f6dc18978cdf8119 ]---
[28115.639797] ------------[ cut here ]------------
[28115.645065] kernel BUG at /home/user/kernel/linux-packages/include/linux/skbuff.h:1380!
[28115.653709] invalid opcode: 0000 [#1] SMP
[28115.658344] Modules linked in: tfw_sched_ratio(O) tfw_sched_http(O) tfw_sched_hash(O) tempesta_fw(O) tempesta_db(O) tempesta_tls(O) bridge mlx5_core(O) 8021q garp mrp mlxfw(O) stp llc mlx4_en(O) intel_rapl x86_pkg_temp_thermal intel_powerclamp coretemp kvm_intel kvm irqbypass crct10dif_pclmul crc32_pclmul ghash_clmulni_intel ast intel_cstate iTCO_wdt ttm iTCO_vendor_support hci_uart drm_kms_helper btbcm btqca i2c_i801 drm btintel igb pcspkr intel_uncore intel_lpss_acpi ie31200_edac mei_me intel_lpss intel_rapl_perf i2c_smbus ipmi_si dca i2c_algo_bit bluetooth mfd_core joydev sg edac_core mei ipmi_msghandler acpi_als video battery rfkill i2c_hid acpi_power_meter kfifo_buf button industrialio mlx4_core(O) mlx_compat(O) devlink ptp pps_core ip_tables x_tables autofs4 ext4 crc16 jbd2 crc32c_generic fscrypto
[28115.734843]  ecb mbcache sd_mod evdev hid_generic usbhid hid mpt3sas crc32c_intel raid_class xhci_pci scsi_transport_sas aesni_intel aes_x86_64 glue_helper xhci_hcd lrw gf128mul ablk_helper scsi_mod cryptd usbcore usb_common shpchp fan thermal [last unloaded: tempesta_tls]
[28115.760387] CPU: 1 PID: 16 Comm: ksoftirqd/1 Tainted: G        W  O    4.9.0-tempesta-amd64 #1 Debian 4.9.35-tfw5-1
[28115.771605] Hardware name: Supermicro Super Server/X11SSL-CF, BIOS 1.0a 01/29/2016
[28115.779970] task: ffff8f49f3910000 task.stack: ffffb12343210000
[28115.786655] RIP: 0010:[<ffffffff885551a7>]  [<ffffffff885551a7>] skb_entail+0x107/0x110
[28115.795471] RSP: 0018:ffffb12343213d70  EFLAGS: 00010202
[28115.801563] RAX: 0000000000000067 RBX: ffff8f49b5f6cb00 RCX: 0000000000000000
[28115.809472] RDX: 0000000000000000 RSI: ffff8f49e866b400 RDI: ffff8f49b5f6cb00
[28115.817359] RBP: ffff8f49b5f6cb88 R08: 0000000000000022 R09: 0000000000000000
[28115.825238] R10: 000000000002d58c R11: 0000000000016ac6 R12: 0000000000000006
[28115.833098] R13: ffff8f49e866b400 R14: 000000000001a840 R15: ffffffffc12a54f8
[28115.840946] FS:  0000000000000000(0000) GS:ffff8f4a37840000(0000) knlGS:0000000000000000
[28115.849758] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[28115.856208] CR2: 0000564b755dcc18 CR3: 000000082fd64000 CR4: 00000000003406e0
[28115.864042] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[28115.871851] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
[28115.879650] Stack:
[28115.882310]  ffffffffc0e5eb1d ffff8f4900000002 ffff8f4a000005a8 0000c5f837859200
[28115.890394]  000000005f074b3e ffff8f49b5f6cb00 0000000000000000 0000000000000000
[28115.898513]  0000000000000002 ffff8f4a37859200 4978e08ad7122930 00000001006a1a2f
[28115.906611] Call Trace:
[28115.909699]  [<ffffffffc0e5eb1d>] ? ss_tx_action+0x3dd/0x4b0 [tempesta_fw]
[28115.917208]  [<ffffffff885048db>] ? net_tx_action+0x9b/0x1d0
[28115.923502]  [<ffffffff88610d1a>] ? __do_softirq+0x10a/0x29a
[28115.929766]  [<ffffffff8809dcd0>] ? sort_range+0x20/0x20
[28115.935717]  [<ffffffff88080e15>] ? run_ksoftirqd+0x25/0x40
[28115.941911]  [<ffffffff8809ddce>] ? smpboot_thread_fn+0xfe/0x150
[28115.948539]  [<ffffffff8809a577>] ? kthread+0xd7/0xf0
[28115.954214]  [<ffffffff8809a4a0>] ? kthread_park+0x60/0x60
[28115.960315]  [<ffffffff8860e475>] ? ret_from_fork+0x25/0x30
[28115.966500] Code: b7 20 04 00 00 77 02 f3 c3 e9 86 01 01 00 48 83 bf d8 06 00 00 00 48 89 b7 48 02 00 00 75 85 48 89 b7 d8 06 00 00 e9 79 ff ff ff <0f> 0b 0f 1f 80 00 00 00 00 0f 1f 44 00 00 48 83 bf 48 02 00 00 
[28115.987700] RIP  [<ffffffff885551a7>] skb_entail+0x107/0x110
[28115.994033]  RSP <ffffb12343213d70>",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,937,2018-03-05T20:43:42Z,2018-03-09T16:51:18Z,2018-03-10T15:20:40Z,MERGED,True,28,18,1,https://github.com/krizhanovsky,Fix #922.,2,[],https://github.com/tempesta-tech/tempesta/pull/937,https://github.com/ikoveshnikov,3,https://github.com/tempesta-tech/tempesta/pull/937#issuecomment-371376872,"The fix sets head_local for a producer before entering to the loop, so a consumer always sees the least heads. See the problem description in #922 (comment)","I can confirm that the issue is fixed. Finally the 10 hours stress test passes:
[118327.462361] [tdb] Start Tempesta DB
[118327.471679] [tempesta] Initializing Tempesta FW kernel module...
[118327.480879] [tempesta] Registering new scheduler: hash
[118327.488541] [tempesta] Registering new scheduler: http
[118327.496222] [tempesta] Registering new scheduler: ratio
[118327.506047] [tempesta] Prepearing for the configuration processing.
[118327.512572] [tempesta] Configuration processing is completed.
[118327.522218] [tdb] Opened table /opt/tempesta/db/filter.tdb: size=16777216 rec_size=20 base=ffff944e96400000
[118327.532356] [tempesta] Open listen socket on: 0.0.0.0
[118327.552471] [tempesta] modules are started
[120053.426820] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[121321.780519] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[121344.702259] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[123356.249372] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[125762.299596] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[128772.337241] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[130336.419756] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[131102.690249] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[131309.985480] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[131916.976693] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[132929.495217] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[133252.862932] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[137647.966448] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[138252.132198] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[139750.857273] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[140431.015035] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[142036.207653] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[143654.481998] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[146166.196297] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[146314.007710] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[146393.176038] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[148845.009495] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[149770.125495] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[150862.419970] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[151551.565076] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[152661.674312] [tempesta] Warning: Paired request missing, HTTP Response Splitting attack?
[154329.372647] [tempesta] Stopping all modules...
[154329.393859] [tdb] Close table 'filter0.tdb'
[154329.398364] [tempesta] modules are stopped
[154329.421860] [tempesta] New configuration is cleaned.
[154329.428400] [tempesta] Un-registering scheduler: hash
[154329.480027] [tempesta] Un-registering scheduler: http
[154329.531748] [tempesta] Un-registering scheduler: ratio
[154329.581872] [tempesta] exiting...
[154329.655036] [tdb] Shutdown Tempesta DB",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,939,2018-03-06T22:30:12Z,2018-03-10T19:36:27Z,2018-03-10T19:36:31Z,MERGED,True,11,7,2,https://github.com/ikoveshnikov,[Tests] Fix server connections failovering functional tests,4,[],https://github.com/tempesta-tech/tempesta/pull/939,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/939,"The regression.test_srv_failovering doesn't use generic_test_routine() to start test, and starting of stateful classes was missed in last tests updates. Issue was reported in #936","The regression.test_srv_failovering doesn't use generic_test_routine() to start test, and starting of stateful classes was missed in last tests updates. Issue was reported in #936",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,942,2018-03-07T10:46:07Z,2018-03-07T20:06:11Z,2018-03-07T20:06:15Z,MERGED,True,144,50,13,https://github.com/ikoveshnikov,Fix restarting without unloading modules,11,[],https://github.com/tempesta-tech/tempesta/pull/942,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/942,fix #893 (point 3),fix #893 (point 3),True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,944,2018-03-10T18:47:59Z,2018-03-11T10:55:02Z,2018-03-11T13:10:00Z,MERGED,True,8,7,1,https://github.com/krizhanovsky,Fix #936: firstly print warning and only after that free the request,1,[],https://github.com/tempesta-tech/tempesta/pull/944,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/944,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,946,2018-03-11T17:15:32Z,2018-03-12T07:55:25Z,2018-03-12T07:55:31Z,MERGED,True,2,2,1,https://github.com/vladtcvs,Fix tf_cfg.ConfigError(),1,[],https://github.com/tempesta-tech/tempesta/pull/946,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/946,Fix ConfigError() constructor,Fix ConfigError() constructor,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,947,2018-03-11T18:43:38Z,2018-03-12T13:11:53Z,2018-03-12T13:12:17Z,MERGED,True,75,3,9,https://github.com/aleksostapenko,Fix #930: Lock tempesta.sh to avoid issues with concurrent execution.,4,[],https://github.com/tempesta-tech/tempesta/pull/947,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/947,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,948,2018-03-11T20:48:49Z,2018-03-16T15:01:08Z,2018-03-16T15:01:11Z,MERGED,True,175,41,22,https://github.com/vladtcvs,Fix 945 - mixed_tests,2,[],https://github.com/tempesta-tech/tempesta/pull/948,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/948,fix #945,fix #945,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,948,2018-03-11T20:48:49Z,2018-03-16T15:01:08Z,2018-03-16T15:01:11Z,MERGED,True,175,41,22,https://github.com/vladtcvs,Fix 945 - mixed_tests,2,[],https://github.com/tempesta-tech/tempesta/pull/948,https://github.com/vladtcvs,2,https://github.com/tempesta-tech/tempesta/pull/948#issuecomment-372195961,fix #945,"Also partly fixes #702 - we can just don't count 502 errors. But it is only a temporary solution, because we should  detect other 502 errors, not related to backend connection errors",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,951,2018-03-12T14:25:00Z,2018-03-12T20:15:15Z,2018-03-12T20:15:20Z,MERGED,True,125,10,9,https://github.com/ikoveshnikov,Func tests: add basic tls test,1,[],https://github.com/tempesta-tech/tempesta/pull/951,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/951,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,952,2018-03-13T11:43:31Z,2018-03-19T19:30:07Z,2018-03-19T20:36:19Z,MERGED,True,120,81,5,https://github.com/aleksostapenko,Fix #903: add logging for all error responses.,9,[],https://github.com/tempesta-tech/tempesta/pull/952,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/952,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,954,2018-03-14T12:51:02Z,2018-03-14T13:29:09Z,2018-03-14T13:29:13Z,MERGED,True,1,1,1,https://github.com/ikoveshnikov,Fix missed semicolon,1,[],https://github.com/tempesta-tech/tempesta/pull/954,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/954,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,955,2018-03-14T18:08:40Z,2018-03-15T23:29:39Z,2018-03-17T17:25:34Z,MERGED,True,79,13,1,https://github.com/krizhanovsky,Fix #926,1,[],https://github.com/tempesta-tech/tempesta/pull/955,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/955,See description in https://github.com/tempesta-tech/linux-4.9.35-tfw/pull/5,See description in https://github.com/tempesta-tech/linux-4.9.35-tfw/pull/5,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,957,2018-03-15T16:52:22Z,2018-03-15T20:03:25Z,2018-03-15T20:03:30Z,MERGED,True,14,6,1,https://github.com/ikoveshnikov,Split skb if can't allocate a new response,2,[],https://github.com/tempesta-tech/tempesta/pull/957,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/957,"If sibling response can't be allocated or paired with any request, then splitting skb is required to send client exactly one response, but not response and rest of data in skb.","If sibling response can't be allocated or paired with any request, then splitting skb is required to send client exactly one response, but not response and rest of data in skb.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,958,2018-03-15T23:42:29Z,2018-03-16T13:46:52Z,2018-03-16T13:46:55Z,MERGED,True,114,100,24,https://github.com/ikoveshnikov,Warn user on config parsing errors and many fixes to functional tests,8,[],https://github.com/tempesta-tech/tempesta/pull/958,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/958,As we debugged some tests with @vladtcvs it turned out that many errors during configuration parsing may not be shown to end user due to rate limiting. Show all warnings and errors during start/stop,As we debugged some tests with @vladtcvs it turned out that many errors during configuration parsing may not be shown to end user due to rate limiting. Show all warnings and errors during start/stop,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,960,2018-03-18T23:45:04Z,2018-03-19T10:24:40Z,2018-03-19T13:26:08Z,MERGED,True,70,36,5,https://github.com/krizhanovsky,Remove requests from fwd_list and put connections of requests freeing,2,[],https://github.com/tempesta-tech/tempesta/pull/960,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/960,"Fix #956: remove req from fwd_list on error in tfw_http_resp_process().
#959: print a warning and let the system crash if we can't remove a
server grooup.
Add req->fwd_list and req->nip_list warnings to make sure that the req
is removed from the list when we go to code where we don't have a pointer
to the server connection.
Replace tfw_http_msg_free() by tfw_http_conn_msg_free() in couple of
places to put connections on requests freeing to avoid memory leakage
on connections reference counters.
Code leanups all around.","Fix #956: remove req from fwd_list on error in tfw_http_resp_process().
#959: print a warning and let the system crash if we can't remove a
server grooup.
Add req->fwd_list and req->nip_list warnings to make sure that the req
is removed from the list when we go to code where we don't have a pointer
to the server connection.
Replace tfw_http_msg_free() by tfw_http_conn_msg_free() in couple of
places to put connections on requests freeing to avoid memory leakage
on connections reference counters.
Code leanups all around.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,961,2018-03-19T06:52:42Z,2018-03-19T07:25:50Z,2018-03-19T07:25:54Z,MERGED,True,1,1,1,https://github.com/ikoveshnikov,func tests: Fix 'too many values to unpack' error,1,['crucial'],https://github.com/tempesta-tech/tempesta/pull/961,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/961,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,964,2018-03-19T13:56:50Z,2018-03-19T14:01:32Z,2018-03-19T14:01:35Z,MERGED,True,1,1,1,https://github.com/vladtcvs,Fix test_deadtime_1M,1,[],https://github.com/tempesta-tech/tempesta/pull/964,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/964,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,966,2018-03-19T17:02:46Z,2018-03-19T21:49:07Z,2018-03-19T21:49:10Z,MERGED,True,2,0,1,https://github.com/vladtcvs,fix wrk command,1,[],https://github.com/tempesta-tech/tempesta/pull/966,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/966,"If number of CPU is more than number of connection, create only number_of_connections threads","If number of CPU is more than number of connection, create only number_of_connections threads",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,967,2018-03-19T22:06:35Z,2018-04-19T12:53:24Z,2018-04-19T12:53:39Z,CLOSED,False,4,0,1,https://github.com/vladtcvs,Warn about number of connections,1,[],https://github.com/tempesta-tech/tempesta/pull/967,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/967,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,967,2018-03-19T22:06:35Z,2018-04-19T12:53:24Z,2018-04-19T12:53:39Z,CLOSED,False,4,0,1,https://github.com/vladtcvs,Warn about number of connections,1,[],https://github.com/tempesta-tech/tempesta/pull/967,https://github.com/vladtcvs,2,https://github.com/tempesta-tech/tempesta/pull/967#issuecomment-382722938,,tempesta-tech/tempesta-test#6,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,968,2018-03-20T09:40:10Z,2018-03-21T14:16:41Z,2018-03-21T14:16:45Z,MERGED,True,7,1,1,https://github.com/vladtcvs,Test control,1,[],https://github.com/tempesta-tech/tempesta/pull/968,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/968,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,969,2018-03-20T11:24:04Z,2018-03-20T14:35:47Z,2018-03-20T14:35:51Z,MERGED,True,34,18,3,https://github.com/ikoveshnikov,Fix releasing of requests and responses on client disconnects,6,['crucial'],https://github.com/tempesta-tech/tempesta/pull/969,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/969,See explanation in #959 (comment).,See explanation in #959 (comment).,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,970,2018-03-20T12:52:03Z,2018-03-20T15:23:48Z,2018-03-21T09:10:06Z,MERGED,True,13,6,3,https://github.com/aleksostapenko,Resolve issues from static analyzer report.,2,[],https://github.com/tempesta-tech/tempesta/pull/970,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/970,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,972,2018-03-20T17:00:18Z,2018-03-20T18:45:57Z,2018-03-21T13:45:56Z,MERGED,True,7,3,2,https://github.com/krizhanovsky,Fix #971,1,['crucial'],https://github.com/tempesta-tech/tempesta/pull/972,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/972,More the assertion to the places where we are unsure about pair of the freed request,More the assertion to the places where we are unsure about pair of the freed request,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,973,2018-03-21T10:57:23Z,2018-03-21T10:57:32Z,2018-03-21T10:57:32Z,CLOSED,False,1,0,1,https://github.com/vladtcvs,Create test,1,[],https://github.com/tempesta-tech/tempesta/pull/973,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/973,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,974,2018-03-21T11:16:32Z,2018-03-21T11:45:12Z,2018-03-21T17:29:32Z,MERGED,True,14,0,1,https://github.com/ikoveshnikov,Update changelog,1,[],https://github.com/tempesta-tech/tempesta/pull/974,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/974,"Prepared release 0.5.0 alpha:

uploaded 0.5.0 deb packages
created branch release-0.5.0
created tag 0.5.0
removed pre-release tags 0.5.0-pre* since every utility thinks that 0.5.0-pre* is higher than 0.5.0. Binaries from previous releases are not removed and still there.

@krizhanovsky Please mark branch release-0.5.0 as protected.","Prepared release 0.5.0 alpha:

uploaded 0.5.0 deb packages
created branch release-0.5.0
created tag 0.5.0
removed pre-release tags 0.5.0-pre* since every utility thinks that 0.5.0-pre* is higher than 0.5.0. Binaries from previous releases are not removed and still there.

@krizhanovsky Please mark branch release-0.5.0 as protected.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,975,2018-03-21T11:45:29Z,2018-03-21T15:01:26Z,2018-10-23T13:36:02Z,CLOSED,False,1,0,1,https://github.com/vladtcvs,test PR - don't merge,1,[],https://github.com/tempesta-tech/tempesta/pull/975,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/975,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,976,2018-03-21T15:01:48Z,2018-03-21T16:13:32Z,2018-10-23T13:35:49Z,CLOSED,False,1,0,1,https://github.com/vladtcvs,Create test PR,1,[],https://github.com/tempesta-tech/tempesta/pull/976,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/976,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,977,2018-03-21T15:43:14Z,2018-03-21T17:29:32Z,2018-10-23T13:35:24Z,CLOSED,False,8,1,2,https://github.com/vladtcvs,test PR,4,[],https://github.com/tempesta-tech/tempesta/pull/977,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/977,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,979,2018-03-22T17:01:54Z,2018-03-26T14:13:08Z,2018-03-26T14:16:13Z,MERGED,True,5,3,2,https://github.com/aleksostapenko,Fix #978: mark started flag as false after failed start on reload.,2,[],https://github.com/tempesta-tech/tempesta/pull/979,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/979,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,982,2018-03-26T15:06:18Z,2018-03-26T18:47:50Z,2018-03-26T18:47:57Z,MERGED,True,8,0,1,https://github.com/vladtcvs,Return 1 for failed unit tests,1,[],https://github.com/tempesta-tech/tempesta/pull/982,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/982,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,983,2018-03-27T10:44:01Z,2018-03-30T16:56:03Z,2018-03-30T16:56:21Z,MERGED,True,46,10,3,https://github.com/aleksostapenko,Fix #918: release connection if its' reference count is zero.,4,[],https://github.com/tempesta-tech/tempesta/pull/983,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/983,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,986,2018-03-28T08:20:31Z,2018-03-29T07:13:40Z,2018-03-29T07:13:44Z,MERGED,True,16,7,3,https://github.com/ikoveshnikov,Fix some issues in functional tests,3,[],https://github.com/tempesta-tech/tempesta/pull/986,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/986,"@vladtcvs  This is not a full solution, not all tests ar fixed.
Test tcp_connection.test_connection_close.CloseClientConnectiononInvalidReq was fixed partially, recent changes in parsing response from server connection in deproxy still breaks the test:
FAIL: test (tcp_connection.test_connection_close.CloseClientConnectiononInvalidReq)
----------------------------------------------------------------------
Traceback (most recent call last):
  File ""/mnt/Storage/Projects/tempesta/tempesta/tempesta_fw/t/functional/tcp_connection/test_connection_close.py"", line 50, in test
    self.run_sniffer()
  File ""/mnt/Storage/Projects/tempesta/tempesta/tempesta_fw/t/functional/tcp_connection/test_connection_close.py"", line 44, in run_sniffer
    self.generic_test_routine('cache 0;\n', self.create_chains())
  File ""/mnt/Storage/Projects/tempesta/tempesta/tempesta_fw/t/functional/testers/functional.py"", line 153, in generic_test_routine
    self.assertTrue(False, msg=err)
AssertionError: Garbage after response end:
'''
HTTP/1.1 400 Bad Request
Date: Wed, 28 Mar 2018 06:43:27 GMT
Content-Length: 0
Server: Tempesta FW/0.5.0

'''

Test regression.test_stress_pipeline.PipelineFaultInjection was fixed, but i'm not sure that the test really checks that it was intended. Please consult to @aleksostapenko . Also note, that the test doesn't copy .stp file to Tempesta node, keeping in mind upcoming splitting Tempesta code and tests framework code this should be changed.","@vladtcvs  This is not a full solution, not all tests ar fixed.
Test tcp_connection.test_connection_close.CloseClientConnectiononInvalidReq was fixed partially, recent changes in parsing response from server connection in deproxy still breaks the test:
FAIL: test (tcp_connection.test_connection_close.CloseClientConnectiononInvalidReq)
----------------------------------------------------------------------
Traceback (most recent call last):
  File ""/mnt/Storage/Projects/tempesta/tempesta/tempesta_fw/t/functional/tcp_connection/test_connection_close.py"", line 50, in test
    self.run_sniffer()
  File ""/mnt/Storage/Projects/tempesta/tempesta/tempesta_fw/t/functional/tcp_connection/test_connection_close.py"", line 44, in run_sniffer
    self.generic_test_routine('cache 0;\n', self.create_chains())
  File ""/mnt/Storage/Projects/tempesta/tempesta/tempesta_fw/t/functional/testers/functional.py"", line 153, in generic_test_routine
    self.assertTrue(False, msg=err)
AssertionError: Garbage after response end:
'''
HTTP/1.1 400 Bad Request
Date: Wed, 28 Mar 2018 06:43:27 GMT
Content-Length: 0
Server: Tempesta FW/0.5.0

'''

Test regression.test_stress_pipeline.PipelineFaultInjection was fixed, but i'm not sure that the test really checks that it was intended. Please consult to @aleksostapenko . Also note, that the test doesn't copy .stp file to Tempesta node, keeping in mind upcoming splitting Tempesta code and tests framework code this should be changed.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,987,2018-03-28T12:26:04Z,2018-05-06T03:54:29Z,2018-10-23T13:44:48Z,CLOSED,False,323,0,2,https://github.com/vladtcvs,In progress: Example of new test description,3,[],https://github.com/tempesta-tech/tempesta/pull/987,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/987,fix: #878,fix: #878,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,987,2018-03-28T12:26:04Z,2018-05-06T03:54:29Z,2018-10-23T13:44:48Z,CLOSED,False,323,0,2,https://github.com/vladtcvs,In progress: Example of new test description,3,[],https://github.com/tempesta-tech/tempesta/pull/987,https://github.com/vladtcvs,2,https://github.com/tempesta-tech/tempesta/pull/987#issuecomment-386851959,fix: #878,See tempesta-tech/tempesta-test#5,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,990,2018-03-29T12:51:46Z,2018-03-29T12:58:55Z,2018-03-29T12:58:59Z,MERGED,True,1,1,1,https://github.com/ikoveshnikov,Fix misprint in configuration handling,1,[],https://github.com/tempesta-tech/tempesta/pull/990,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/990,No other misprints was noticed.,No other misprints was noticed.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,991,2018-03-29T14:30:17Z,2018-11-20T14:56:13Z,2018-11-20T14:56:23Z,CLOSED,False,37,1,1,https://github.com/vladtcvs,In progress: Different failovering tests,2,[],https://github.com/tempesta-tech/tempesta/pull/991,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/991,fix: #821,fix: #821,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,991,2018-03-29T14:30:17Z,2018-11-20T14:56:13Z,2018-11-20T14:56:23Z,CLOSED,False,37,1,1,https://github.com/vladtcvs,In progress: Different failovering tests,2,[],https://github.com/tempesta-tech/tempesta/pull/991,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/991#issuecomment-425652518,fix: #821,@ikoveshnikov please finish the PR.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,991,2018-03-29T14:30:17Z,2018-11-20T14:56:13Z,2018-11-20T14:56:23Z,CLOSED,False,37,1,1,https://github.com/vladtcvs,In progress: Different failovering tests,2,[],https://github.com/tempesta-tech/tempesta/pull/991,https://github.com/ikoveshnikov,3,https://github.com/tempesta-tech/tempesta/pull/991#issuecomment-440301625,fix: #821,"The PR is incomplete: only a few pieces of configuration are provided, no required traffic is sent, no required assertions. It doesn't worth to merge it as is and it doesn't worth to keep it. The tests are to be developed from scratch in tempesta-tech/tempesta-test repo.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,992,2018-03-30T17:13:20Z,2018-03-30T19:08:45Z,2018-03-30T19:09:13Z,MERGED,True,46,10,3,https://github.com/aleksostapenko,Backport fix for #918.,1,[],https://github.com/tempesta-tech/tempesta/pull/992,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/992,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,993,2018-03-31T10:15:44Z,2018-03-31T14:21:06Z,2018-03-31T14:21:12Z,MERGED,True,5,3,2,https://github.com/aleksostapenko,Backport fix for #978.,1,[],https://github.com/tempesta-tech/tempesta/pull/993,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/993,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,994,2018-04-01T20:34:00Z,2018-04-04T11:37:01Z,2018-04-04T11:39:27Z,MERGED,True,318,29,3,https://github.com/krizhanovsky,Fix #938,4,[],https://github.com/tempesta-tech/tempesta/pull/994,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/994,See PoC and benchmarks at tempesta-tech/blog@d0b016d,See PoC and benchmarks at tempesta-tech/blog@d0b016d,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,997,2018-04-03T18:38:19Z,2018-04-09T15:22:20Z,2018-04-09T15:22:26Z,MERGED,True,76,24,3,https://github.com/vladtcvs,Temporary don't measure 502 and 504 errors,6,[],https://github.com/tempesta-tech/tempesta/pull/997,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/997,See #996. This is temporary workaround.,See #996. This is temporary workaround.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,997,2018-04-03T18:38:19Z,2018-04-09T15:22:20Z,2018-04-09T15:22:26Z,MERGED,True,76,24,3,https://github.com/vladtcvs,Temporary don't measure 502 and 504 errors,6,[],https://github.com/tempesta-tech/tempesta/pull/997,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/997#issuecomment-378622210,See #996. This is temporary workaround.,"The only one note: you specified ""Fix #996"", but the issue shouldn't be closed after the merge, instead it should remain open and moved to 0.7.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,998,2018-04-04T11:57:09Z,2018-04-04T11:58:49Z,2018-04-04T12:00:39Z,MERGED,True,318,28,4,https://github.com/krizhanovsky,Backport of the fix of #938,1,[],https://github.com/tempesta-tech/tempesta/pull/998,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/998,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,999,2018-04-04T16:23:30Z,2018-04-05T00:29:47Z,2018-04-05T00:29:51Z,MERGED,True,11,0,1,https://github.com/vladtcvs,Set tcp fin timeout,1,[],https://github.com/tempesta-tech/tempesta/pull/999,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/999,fix: #919,fix: #919,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,999,2018-04-04T16:23:30Z,2018-04-05T00:29:47Z,2018-04-05T00:29:51Z,MERGED,True,11,0,1,https://github.com/vladtcvs,Set tcp fin timeout,1,[],https://github.com/tempesta-tech/tempesta/pull/999,https://github.com/vladtcvs,2,https://github.com/tempesta-tech/tempesta/pull/999#issuecomment-378786057,fix: #919,Rebased above master branch.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1000,2018-04-04T17:58:48Z,2018-04-14T07:47:19Z,2018-04-14T07:47:27Z,MERGED,True,391,569,20,https://github.com/aleksostapenko,Fix #166: transition to standard skb linkage inside TempstaFW.,10,[],https://github.com/tempesta-tech/tempesta/pull/1000,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/1000,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1001,2018-04-05T12:41:10Z,2018-04-06T14:36:19Z,2018-04-06T14:36:54Z,MERGED,True,24,12,3,https://github.com/vladtcvs,Move TCP config to helpers/prepare.py,1,[],https://github.com/tempesta-tech/tempesta/pull/1001,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/1001,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1001,2018-04-05T12:41:10Z,2018-04-06T14:36:19Z,2018-04-06T14:36:54Z,MERGED,True,24,12,3,https://github.com/vladtcvs,Move TCP config to helpers/prepare.py,1,[],https://github.com/tempesta-tech/tempesta/pull/1001,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/1001#issuecomment-378983485,,"Previously I've added code into run_tests.py which checks whether root privileges are required. What do you think, the check is extra now, and root privileges are always required?
Do we have any other code in run_tests.py which better to move into prepare?",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1001,2018-04-05T12:41:10Z,2018-04-06T14:36:19Z,2018-04-06T14:36:54Z,MERGED,True,24,12,3,https://github.com/vladtcvs,Move TCP config to helpers/prepare.py,1,[],https://github.com/tempesta-tech/tempesta/pull/1001,https://github.com/vladtcvs,3,https://github.com/tempesta-tech/tempesta/pull/1001#issuecomment-379193002,,"I think, we should place running as root into remote.py methods. In this way we can run run_tests.py itself not from root, but remote commands will run as root",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1002,2018-04-05T13:24:46Z,2018-04-06T16:16:39Z,2018-10-23T13:42:33Z,CLOSED,False,1,1,1,https://github.com/vladtcvs,Temporary workaround: don't assert on wrk socket errors,1,[],https://github.com/tempesta-tech/tempesta/pull/1002,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/1002,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1004,2018-04-10T13:11:27Z,2018-04-19T12:17:07Z,2018-10-23T13:42:48Z,MERGED,True,0,11049,106,https://github.com/vladtcvs,Move tests to submodule,1,[],https://github.com/tempesta-tech/tempesta/pull/1004,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/1004,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1005,2018-04-11T14:01:49Z,2018-04-15T16:32:43Z,2018-04-15T18:11:35Z,MERGED,True,938,113,8,https://github.com/krizhanovsky,Fix #628: Custom characters set for URI and HTTP headers,2,[],https://github.com/tempesta-tech/tempesta/pull/1005,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1005,PoC and benchmarks at tempesta-tech/blog@0fddf42,PoC and benchmarks at tempesta-tech/blog@0fddf42,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1007,2018-04-23T23:03:31Z,2018-05-04T13:52:27Z,2018-05-04T22:05:11Z,MERGED,True,937,246,40,https://github.com/krizhanovsky,Fix #635,12,[],https://github.com/tempesta-tech/tempesta/pull/1007,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1007,"Please read #635 (comment) for some explanations. The SIMD functions must be written in assembly since gcc requires stdlib.h. For now we use tls/dummy_headers/stdlib.h and it's good to remove the dummy headers, so str_simd.c also should be rewritten in assembly soon. You can just compile the PoCs with -S to get assembly code which I used. I din't use vzeroupper instruction since we save and restore FPU state in softirq and each SIMD function in our code initializes the vector registers.
The change is questionable and I'm curious for you opinions. The change introduces ~1600-line kernel patch with simple replacement for mem{cpy,set,cmp}() functions by their _fast versions. Meantime performance improvements are negligible for pure Linux networking and say some user space daemons, e.g. HAProxy + Nginx - perf shows interrupts (due to poor e1000 in particular) and user-space daemon functions. We get something only for Tempesta FW caching where we have no heavy user space logic and do some our internal mem{cpy,set,cmp}() operations. So probably there is no sense to introduce the large kernel patch. I just was confused by large zeroings and copyings for skbs, e.g. the data structure initialization or cloning. However, probably we can optimize the calls and there is no sense to pay extra if we have a faster implementation....
@vladtcvs could you do a performance study on our hardware testbed to learn whether the patch gives us more performance improvement with good adapters coalescing network interrupts?","Please read #635 (comment) for some explanations. The SIMD functions must be written in assembly since gcc requires stdlib.h. For now we use tls/dummy_headers/stdlib.h and it's good to remove the dummy headers, so str_simd.c also should be rewritten in assembly soon. You can just compile the PoCs with -S to get assembly code which I used. I din't use vzeroupper instruction since we save and restore FPU state in softirq and each SIMD function in our code initializes the vector registers.
The change is questionable and I'm curious for you opinions. The change introduces ~1600-line kernel patch with simple replacement for mem{cpy,set,cmp}() functions by their _fast versions. Meantime performance improvements are negligible for pure Linux networking and say some user space daemons, e.g. HAProxy + Nginx - perf shows interrupts (due to poor e1000 in particular) and user-space daemon functions. We get something only for Tempesta FW caching where we have no heavy user space logic and do some our internal mem{cpy,set,cmp}() operations. So probably there is no sense to introduce the large kernel patch. I just was confused by large zeroings and copyings for skbs, e.g. the data structure initialization or cloning. However, probably we can optimize the calls and there is no sense to pay extra if we have a faster implementation....
@vladtcvs could you do a performance study on our hardware testbed to learn whether the patch gives us more performance improvement with good adapters coalescing network interrupts?",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1007,2018-04-23T23:03:31Z,2018-05-04T13:52:27Z,2018-05-04T22:05:11Z,MERGED,True,937,246,40,https://github.com/krizhanovsky,Fix #635,12,[],https://github.com/tempesta-tech/tempesta/pull/1007,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/1007#issuecomment-383904574,"Please read #635 (comment) for some explanations. The SIMD functions must be written in assembly since gcc requires stdlib.h. For now we use tls/dummy_headers/stdlib.h and it's good to remove the dummy headers, so str_simd.c also should be rewritten in assembly soon. You can just compile the PoCs with -S to get assembly code which I used. I din't use vzeroupper instruction since we save and restore FPU state in softirq and each SIMD function in our code initializes the vector registers.
The change is questionable and I'm curious for you opinions. The change introduces ~1600-line kernel patch with simple replacement for mem{cpy,set,cmp}() functions by their _fast versions. Meantime performance improvements are negligible for pure Linux networking and say some user space daemons, e.g. HAProxy + Nginx - perf shows interrupts (due to poor e1000 in particular) and user-space daemon functions. We get something only for Tempesta FW caching where we have no heavy user space logic and do some our internal mem{cpy,set,cmp}() operations. So probably there is no sense to introduce the large kernel patch. I just was confused by large zeroings and copyings for skbs, e.g. the data structure initialization or cloning. However, probably we can optimize the calls and there is no sense to pay extra if we have a faster implementation....
@vladtcvs could you do a performance study on our hardware testbed to learn whether the patch gives us more performance improvement with good adapters coalescing network interrupts?","Please, replace another memcmp occurrence with memcmp_fast: 
  
    
      tempesta/tempesta_fw/str.c
    
    
        Lines 418 to 420
      in
      f571516
    
  
  
    

        
          
           int (*cmp)(const char *s1, const char *s2, size_t len) = 
        

        
          
           	cs ? (int (*)(const char *, const char *, size_t)) memcmp 
        

        
          
           	   : tfw_stricmp; 
        
    
  


UPD: It was too fast comment. As i see, __memcmp_avx() function is not 100% memcmp() compatible: __memcmp_avx() doesn't say which memory area is greater. So the  __memcmp_avx() must be used with caution, e.g. it can't be used in binary search. And the example above (__tfw_strcmpspn()) is one of that places.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1008,2018-04-25T08:02:51Z,2018-05-07T09:50:35Z,2018-05-07T09:51:09Z,MERGED,True,2294,1414,24,https://github.com/aleksostapenko, Fix #688: Make frang directives location-specific. ,9,[],https://github.com/tempesta-tech/tempesta/pull/1008,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/1008,"Introduction of reconfigurable vhost directive with possible nested location directives and addition of location-specific reconfigurable directives for Frang limits.
Notes:

Global Frang rules remain non-reconfigurable.
Directives hdr_via, cache_purge, cache_purge_acl remain global-level only and non-reconfigurable.
The following configuration order is mandatory: srv_groups/servers -> vhosts -> sched_http_rules.
It is not allowed to specify sched_http_rule with default vhost if there is no explicit default vhost specified.
Directive proxy_pass is mandatory for vhost and location directive blocks.
For explicit default vhost directive - only proxy_pass directives with 'default' srv_groups is allowed to be specified (or proxy_pass directive may be absent at all).
For implicit default vhost - proxy_pass directive is not allowed (since default vhost must point to default server group).","Introduction of reconfigurable vhost directive with possible nested location directives and addition of location-specific reconfigurable directives for Frang limits.
Notes:

Global Frang rules remain non-reconfigurable.
Directives hdr_via, cache_purge, cache_purge_acl remain global-level only and non-reconfigurable.
The following configuration order is mandatory: srv_groups/servers -> vhosts -> sched_http_rules.
It is not allowed to specify sched_http_rule with default vhost if there is no explicit default vhost specified.
Directive proxy_pass is mandatory for vhost and location directive blocks.
For explicit default vhost directive - only proxy_pass directives with 'default' srv_groups is allowed to be specified (or proxy_pass directive may be absent at all).
For implicit default vhost - proxy_pass directive is not allowed (since default vhost must point to default server group).",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1008,2018-04-25T08:02:51Z,2018-05-07T09:50:35Z,2018-05-07T09:51:09Z,MERGED,True,2294,1414,24,https://github.com/aleksostapenko, Fix #688: Make frang directives location-specific. ,9,[],https://github.com/tempesta-tech/tempesta/pull/1008,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/1008#issuecomment-385473323,"Introduction of reconfigurable vhost directive with possible nested location directives and addition of location-specific reconfigurable directives for Frang limits.
Notes:

Global Frang rules remain non-reconfigurable.
Directives hdr_via, cache_purge, cache_purge_acl remain global-level only and non-reconfigurable.
The following configuration order is mandatory: srv_groups/servers -> vhosts -> sched_http_rules.
It is not allowed to specify sched_http_rule with default vhost if there is no explicit default vhost specified.
Directive proxy_pass is mandatory for vhost and location directive blocks.
For explicit default vhost directive - only proxy_pass directives with 'default' srv_groups is allowed to be specified (or proxy_pass directive may be absent at all).
For implicit default vhost - proxy_pass directive is not allowed (since default vhost must point to default server group).","The notes for the PR must be reflected in configuration Wiki: we have some mess what's reconfigurable and what's not, all the limitations may lead to a user inconvenience, so they must be clearly stated in the doc.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1009,2018-04-30T17:17:37Z,2018-05-01T11:36:34Z,2018-05-01T15:40:57Z,MERGED,True,1,1,1,https://github.com/krizhanovsky,Fix SIMD call from non FPU-safe context,1,[],https://github.com/tempesta-tech/tempesta/pull/1009,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1009,Replace tfw_cstricmp() by strncasecmp() as tfw_sg_name_match() is called from process context,Replace tfw_cstricmp() by strncasecmp() as tfw_sg_name_match() is called from process context,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1010,2018-05-01T16:03:21Z,2018-05-05T12:17:33Z,2018-05-05T20:45:57Z,MERGED,True,13751,12128,150,https://github.com/krizhanovsky,Move to mbedTLS 2.8.0,9,[],https://github.com/tempesta-tech/tempesta/pull/1010,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1010,No need for review - just a dummy files copying.,No need for review - just a dummy files copying.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1011,2018-05-06T16:00:47Z,2018-05-07T14:52:29Z,2018-05-07T14:53:11Z,MERGED,True,0,7,1,https://github.com/krizhanovsky,Perl script cleanups,1,[],https://github.com/tempesta-tech/tempesta/pull/1011,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1011,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1012,2018-05-07T14:07:13Z,2018-09-25T12:00:57Z,2019-02-13T15:40:56Z,CLOSED,False,1519,989,33,https://github.com/ikoveshnikov,Add message streaming mode,26,[],https://github.com/tempesta-tech/tempesta/pull/1012,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1012,"fix #498
Streaming of http messages
Directive proxy_buffering defines maximum buffered message size. Messages
shorter than proxy_buffering size are fully buffered, longer messages
contains from two parts: buffered and streamed.
Headers are always buffered. Full set of headers is required for processing
inside of TempestaFW during whole message lifetime.
Body may be split into two part: streamed and buffered. Body is processed only
right after parsing in cache or health monitor and not required in further
processing. Thus body may be safely streamed to target connection and freed
at any time.
Trailer header is also must be buffered. It extends headers, so it may be
required for message processing. Also trailer headers can be modified before
forwarding (e.g. resp_hdr_set directive), this can be done only on fully
buffered trailer.
In the text I say 'headers', 'body' and 'trailer', but 'headers' actually stands
for buffered message part: HTTP headers and buffered part of the body.
Performance impacts
In general case the incoming message can't be streamed to target connection
right away. When a client message is received, it's placed into a server
connection forwarding queue (fwd_queue). Under the load it's never empty, so
immediate streaming is not possible and the message will be scheduled
for forwarding. When a server message is received, it's forwarded to client
with respect to client's seq_queue. If client pipelines requests, seq_queue
may be not empty and the there can be a number of unanswered requests,
so immediate streaming is not possible. Both situations may be worse, if
target connection is occupied by another streamed transmission.
But in the same time servers are much faster than clients, the request
may climb to the begging of the fwd_queue before the client finished the
transmission. Same for the backend to the client transmission: seq_queue
shouldn't be big, and all previous requests from the queue may be responded
faster than transmission of current response.
This means two things:

some times messages can be fully assembled before streaming.
the same message can be processed by two threads, since it's placed into
seq_queue and fwd_queue in incomplete state.

There is a couple solutions to deal with the first problem.

Streaming from backend to clients (response streaming): Configuration level.
Use sticky sessions. In this case all requests from one client will be always
forwarded to the same backend connection. So any response can be effectively
streamed to the client.
Application-aware response streaming. When a new request is received,
user-defined rules are used to check that expected response is to be streamed.
If that true, don't forward the request (and following) to the backends until
all previous requests are responded.
Request streaming. The request is likely to be buffered if fwd_queue is
not empty. Keep a separate pool of backend connections for streaming only
or dynamically allocate a new server connection.

Long-polling requests from multiple clients may fully block backend connections.
Application-aware approach or dynamically allocated backend connections are
required.
This topic requires dedicated discussion.
Processing of streamed messages
The main difference between buffered and streamed messages is processing
stages. Processing of a buffered connection is straight forward:
( receive -> parse ) -> process -> forward
repeat until message
 is fully received

Processing of streamed messages is bit complicated:
( receive -> parse ) -> [ process -> forward ] ->
 repeat until headers     forward headers to
 are fully received       target connection


 -> ( receive -> parse -> process -> stream ) ->
      repeat until all body fragments are
                    streamed


-> ( receive -> parse ) -> process -> stream
     repeat until trailer
     headers are fully
          received

Forwarding may happen in a different tread, so multiple access to the same
message is possible. First idea was to use spinlock to protect the message
from simultaneous parsing and forwarding. But only one spinlock is not enough
and a lot of additional checks and flags are required. Imagine the situation:
Part of request was received, scheduled to backend connection, a new part
is being parsed and processed so the lock is acquired. In the same time
other thread starts forwarding and tries to acquire the lock. Processing error
happens during processing in the first thread and the message must be destroyed.
In this approach reference counting and error flag is required. The same
situation takes place in other cases, so the code becomes very complicated.
Here is the used  solution. Stream message part only from the same thread where
the message is received. Forwarding of headers may (and will) happen in other
thread but that thread must not send streamed message part, only buffered.
So processing looks like:
Thread 1                                    Thread 2
--------                                    --------
    |                                           |
(receive headers)                               |
    |                                           |
(schedule to forward)                           |
    |                                           |
(receive, process body part)                    |
    * N                                         |
    |                                           |
    |                             (forward headers only to target connection)
    |                                           |
(receive, process body parts)                   |
    |                                           |
(stream al pending)                             |
    |                                           |
(receive, process, stream body part)            |
    * N                                         |
    |                                           |
(destroy the message)                           |

Forwarding in Thread 2 may happen only after the whole streamed message was
received. In this case Thead 1 will never forward streamed part, so the Thread 1
is responsible for streaming and releasing the message.
When a streamed message is forwarded to some connection, no messages allowed to
be forwarded though that connection until the forwarded message is fully
transmitted. Thus connection's seq_qlock or fwd_qlock is acuired on
streaming message part. In addition to thread role management described above,
this gives thread safety.
Note, that a response to the streamed request may appear earlier than request
is fully received. E.g. sticky cookie violation, serving message from cache.
In this case, request must be received fully to proceed to the next request.
All functions that processes message body, must be capable to process
the body by parts, since full body is never available for streamed messages.
Close connection on streaming
Sometimes it's needed to close the egress connection after the messaged is fully
transmitted. In this case CONN_CLOSE flag must be added to ss_flags only
when the last message part is streamed.
Error handling
Streamed message is partially received, but not forwarded to target connection.
-> Close ingress connection.
Streamed message is partially received and is being streamed to target
connection. -> Close both connection.
Streamed message is fully received and is being streamed to target
connection. -> Close egress connection.
Request was streamed to backend, but backend connection was closed and reopened.
-> Evict request, it's not stored in Tempesta, so it's not possible to
forward it once more time.
Early response is available for the streamed request (from sticky or cache
modules) but the request failed security limits (frang) or other processing
on receiving a new body fragment. -> If the response
is not sent yet (mostly false condition), drop the response and forward
a new one via tfw_http_error_resp_and_log() if applied. Close client
connection.
Caching streamed responses
Message streaming is used to avoid assembling full messages and spending too
lot of memory for just a couple of messages, e.g. DVD images. Same apply
to cache. A new directive is required to limit cache entry size. Caching 1M
small responses may be more effective, than caching just a couple of big ones.
Cache entry size required to store the response may be unknown for streamed
responses. Response in chunked encoding may be very huge. Content-length header
is not provided in this case. It's required to effectively enlarge cache entry to
save a new response fragment. A new response fragment may be not only body, but
trailer headers too.","fix #498
Streaming of http messages
Directive proxy_buffering defines maximum buffered message size. Messages
shorter than proxy_buffering size are fully buffered, longer messages
contains from two parts: buffered and streamed.
Headers are always buffered. Full set of headers is required for processing
inside of TempestaFW during whole message lifetime.
Body may be split into two part: streamed and buffered. Body is processed only
right after parsing in cache or health monitor and not required in further
processing. Thus body may be safely streamed to target connection and freed
at any time.
Trailer header is also must be buffered. It extends headers, so it may be
required for message processing. Also trailer headers can be modified before
forwarding (e.g. resp_hdr_set directive), this can be done only on fully
buffered trailer.
In the text I say 'headers', 'body' and 'trailer', but 'headers' actually stands
for buffered message part: HTTP headers and buffered part of the body.
Performance impacts
In general case the incoming message can't be streamed to target connection
right away. When a client message is received, it's placed into a server
connection forwarding queue (fwd_queue). Under the load it's never empty, so
immediate streaming is not possible and the message will be scheduled
for forwarding. When a server message is received, it's forwarded to client
with respect to client's seq_queue. If client pipelines requests, seq_queue
may be not empty and the there can be a number of unanswered requests,
so immediate streaming is not possible. Both situations may be worse, if
target connection is occupied by another streamed transmission.
But in the same time servers are much faster than clients, the request
may climb to the begging of the fwd_queue before the client finished the
transmission. Same for the backend to the client transmission: seq_queue
shouldn't be big, and all previous requests from the queue may be responded
faster than transmission of current response.
This means two things:

some times messages can be fully assembled before streaming.
the same message can be processed by two threads, since it's placed into
seq_queue and fwd_queue in incomplete state.

There is a couple solutions to deal with the first problem.

Streaming from backend to clients (response streaming): Configuration level.
Use sticky sessions. In this case all requests from one client will be always
forwarded to the same backend connection. So any response can be effectively
streamed to the client.
Application-aware response streaming. When a new request is received,
user-defined rules are used to check that expected response is to be streamed.
If that true, don't forward the request (and following) to the backends until
all previous requests are responded.
Request streaming. The request is likely to be buffered if fwd_queue is
not empty. Keep a separate pool of backend connections for streaming only
or dynamically allocate a new server connection.

Long-polling requests from multiple clients may fully block backend connections.
Application-aware approach or dynamically allocated backend connections are
required.
This topic requires dedicated discussion.
Processing of streamed messages
The main difference between buffered and streamed messages is processing
stages. Processing of a buffered connection is straight forward:
( receive -> parse ) -> process -> forward
repeat until message
 is fully received

Processing of streamed messages is bit complicated:
( receive -> parse ) -> [ process -> forward ] ->
 repeat until headers     forward headers to
 are fully received       target connection


 -> ( receive -> parse -> process -> stream ) ->
      repeat until all body fragments are
                    streamed


-> ( receive -> parse ) -> process -> stream
     repeat until trailer
     headers are fully
          received

Forwarding may happen in a different tread, so multiple access to the same
message is possible. First idea was to use spinlock to protect the message
from simultaneous parsing and forwarding. But only one spinlock is not enough
and a lot of additional checks and flags are required. Imagine the situation:
Part of request was received, scheduled to backend connection, a new part
is being parsed and processed so the lock is acquired. In the same time
other thread starts forwarding and tries to acquire the lock. Processing error
happens during processing in the first thread and the message must be destroyed.
In this approach reference counting and error flag is required. The same
situation takes place in other cases, so the code becomes very complicated.
Here is the used  solution. Stream message part only from the same thread where
the message is received. Forwarding of headers may (and will) happen in other
thread but that thread must not send streamed message part, only buffered.
So processing looks like:
Thread 1                                    Thread 2
--------                                    --------
    |                                           |
(receive headers)                               |
    |                                           |
(schedule to forward)                           |
    |                                           |
(receive, process body part)                    |
    * N                                         |
    |                                           |
    |                             (forward headers only to target connection)
    |                                           |
(receive, process body parts)                   |
    |                                           |
(stream al pending)                             |
    |                                           |
(receive, process, stream body part)            |
    * N                                         |
    |                                           |
(destroy the message)                           |

Forwarding in Thread 2 may happen only after the whole streamed message was
received. In this case Thead 1 will never forward streamed part, so the Thread 1
is responsible for streaming and releasing the message.
When a streamed message is forwarded to some connection, no messages allowed to
be forwarded though that connection until the forwarded message is fully
transmitted. Thus connection's seq_qlock or fwd_qlock is acuired on
streaming message part. In addition to thread role management described above,
this gives thread safety.
Note, that a response to the streamed request may appear earlier than request
is fully received. E.g. sticky cookie violation, serving message from cache.
In this case, request must be received fully to proceed to the next request.
All functions that processes message body, must be capable to process
the body by parts, since full body is never available for streamed messages.
Close connection on streaming
Sometimes it's needed to close the egress connection after the messaged is fully
transmitted. In this case CONN_CLOSE flag must be added to ss_flags only
when the last message part is streamed.
Error handling
Streamed message is partially received, but not forwarded to target connection.
-> Close ingress connection.
Streamed message is partially received and is being streamed to target
connection. -> Close both connection.
Streamed message is fully received and is being streamed to target
connection. -> Close egress connection.
Request was streamed to backend, but backend connection was closed and reopened.
-> Evict request, it's not stored in Tempesta, so it's not possible to
forward it once more time.
Early response is available for the streamed request (from sticky or cache
modules) but the request failed security limits (frang) or other processing
on receiving a new body fragment. -> If the response
is not sent yet (mostly false condition), drop the response and forward
a new one via tfw_http_error_resp_and_log() if applied. Close client
connection.
Caching streamed responses
Message streaming is used to avoid assembling full messages and spending too
lot of memory for just a couple of messages, e.g. DVD images. Same apply
to cache. A new directive is required to limit cache entry size. Caching 1M
small responses may be more effective, than caching just a couple of big ones.
Cache entry size required to store the response may be unknown for streamed
responses. Response in chunked encoding may be very huge. Content-length header
is not provided in this case. It's required to effectively enlarge cache entry to
save a new response fragment. A new response fragment may be not only body, but
trailer headers too.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1012,2018-05-07T14:07:13Z,2018-09-25T12:00:57Z,2019-02-13T15:40:56Z,CLOSED,False,1519,989,33,https://github.com/ikoveshnikov,Add message streaming mode,26,[],https://github.com/tempesta-tech/tempesta/pull/1012,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/1012#issuecomment-398851148,"fix #498
Streaming of http messages
Directive proxy_buffering defines maximum buffered message size. Messages
shorter than proxy_buffering size are fully buffered, longer messages
contains from two parts: buffered and streamed.
Headers are always buffered. Full set of headers is required for processing
inside of TempestaFW during whole message lifetime.
Body may be split into two part: streamed and buffered. Body is processed only
right after parsing in cache or health monitor and not required in further
processing. Thus body may be safely streamed to target connection and freed
at any time.
Trailer header is also must be buffered. It extends headers, so it may be
required for message processing. Also trailer headers can be modified before
forwarding (e.g. resp_hdr_set directive), this can be done only on fully
buffered trailer.
In the text I say 'headers', 'body' and 'trailer', but 'headers' actually stands
for buffered message part: HTTP headers and buffered part of the body.
Performance impacts
In general case the incoming message can't be streamed to target connection
right away. When a client message is received, it's placed into a server
connection forwarding queue (fwd_queue). Under the load it's never empty, so
immediate streaming is not possible and the message will be scheduled
for forwarding. When a server message is received, it's forwarded to client
with respect to client's seq_queue. If client pipelines requests, seq_queue
may be not empty and the there can be a number of unanswered requests,
so immediate streaming is not possible. Both situations may be worse, if
target connection is occupied by another streamed transmission.
But in the same time servers are much faster than clients, the request
may climb to the begging of the fwd_queue before the client finished the
transmission. Same for the backend to the client transmission: seq_queue
shouldn't be big, and all previous requests from the queue may be responded
faster than transmission of current response.
This means two things:

some times messages can be fully assembled before streaming.
the same message can be processed by two threads, since it's placed into
seq_queue and fwd_queue in incomplete state.

There is a couple solutions to deal with the first problem.

Streaming from backend to clients (response streaming): Configuration level.
Use sticky sessions. In this case all requests from one client will be always
forwarded to the same backend connection. So any response can be effectively
streamed to the client.
Application-aware response streaming. When a new request is received,
user-defined rules are used to check that expected response is to be streamed.
If that true, don't forward the request (and following) to the backends until
all previous requests are responded.
Request streaming. The request is likely to be buffered if fwd_queue is
not empty. Keep a separate pool of backend connections for streaming only
or dynamically allocate a new server connection.

Long-polling requests from multiple clients may fully block backend connections.
Application-aware approach or dynamically allocated backend connections are
required.
This topic requires dedicated discussion.
Processing of streamed messages
The main difference between buffered and streamed messages is processing
stages. Processing of a buffered connection is straight forward:
( receive -> parse ) -> process -> forward
repeat until message
 is fully received

Processing of streamed messages is bit complicated:
( receive -> parse ) -> [ process -> forward ] ->
 repeat until headers     forward headers to
 are fully received       target connection


 -> ( receive -> parse -> process -> stream ) ->
      repeat until all body fragments are
                    streamed


-> ( receive -> parse ) -> process -> stream
     repeat until trailer
     headers are fully
          received

Forwarding may happen in a different tread, so multiple access to the same
message is possible. First idea was to use spinlock to protect the message
from simultaneous parsing and forwarding. But only one spinlock is not enough
and a lot of additional checks and flags are required. Imagine the situation:
Part of request was received, scheduled to backend connection, a new part
is being parsed and processed so the lock is acquired. In the same time
other thread starts forwarding and tries to acquire the lock. Processing error
happens during processing in the first thread and the message must be destroyed.
In this approach reference counting and error flag is required. The same
situation takes place in other cases, so the code becomes very complicated.
Here is the used  solution. Stream message part only from the same thread where
the message is received. Forwarding of headers may (and will) happen in other
thread but that thread must not send streamed message part, only buffered.
So processing looks like:
Thread 1                                    Thread 2
--------                                    --------
    |                                           |
(receive headers)                               |
    |                                           |
(schedule to forward)                           |
    |                                           |
(receive, process body part)                    |
    * N                                         |
    |                                           |
    |                             (forward headers only to target connection)
    |                                           |
(receive, process body parts)                   |
    |                                           |
(stream al pending)                             |
    |                                           |
(receive, process, stream body part)            |
    * N                                         |
    |                                           |
(destroy the message)                           |

Forwarding in Thread 2 may happen only after the whole streamed message was
received. In this case Thead 1 will never forward streamed part, so the Thread 1
is responsible for streaming and releasing the message.
When a streamed message is forwarded to some connection, no messages allowed to
be forwarded though that connection until the forwarded message is fully
transmitted. Thus connection's seq_qlock or fwd_qlock is acuired on
streaming message part. In addition to thread role management described above,
this gives thread safety.
Note, that a response to the streamed request may appear earlier than request
is fully received. E.g. sticky cookie violation, serving message from cache.
In this case, request must be received fully to proceed to the next request.
All functions that processes message body, must be capable to process
the body by parts, since full body is never available for streamed messages.
Close connection on streaming
Sometimes it's needed to close the egress connection after the messaged is fully
transmitted. In this case CONN_CLOSE flag must be added to ss_flags only
when the last message part is streamed.
Error handling
Streamed message is partially received, but not forwarded to target connection.
-> Close ingress connection.
Streamed message is partially received and is being streamed to target
connection. -> Close both connection.
Streamed message is fully received and is being streamed to target
connection. -> Close egress connection.
Request was streamed to backend, but backend connection was closed and reopened.
-> Evict request, it's not stored in Tempesta, so it's not possible to
forward it once more time.
Early response is available for the streamed request (from sticky or cache
modules) but the request failed security limits (frang) or other processing
on receiving a new body fragment. -> If the response
is not sent yet (mostly false condition), drop the response and forward
a new one via tfw_http_error_resp_and_log() if applied. Close client
connection.
Caching streamed responses
Message streaming is used to avoid assembling full messages and spending too
lot of memory for just a couple of messages, e.g. DVD images. Same apply
to cache. A new directive is required to limit cache entry size. Caching 1M
small responses may be more effective, than caching just a couple of big ones.
Cache entry size required to store the response may be unknown for streamed
responses. Response in chunked encoding may be very huge. Content-length header
is not provided in this case. It's required to effectively enlarge cache entry to
save a new response fragment. A new response fragment may be not only body, but
trailer headers too.","Please also consider a fix for #995, probably as a separate pull request like for #639. #995 and #498 seems relating. Point 2 in issue #391 requires implementation of a function(s) to calculate and set our receive window for a clinet, so this also must be considered in upcoming changes.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1012,2018-05-07T14:07:13Z,2018-09-25T12:00:57Z,2019-02-13T15:40:56Z,CLOSED,False,1519,989,33,https://github.com/ikoveshnikov,Add message streaming mode,26,[],https://github.com/tempesta-tech/tempesta/pull/1012,https://github.com/ikoveshnikov,3,https://github.com/tempesta-tech/tempesta/pull/1012#issuecomment-424314758,"fix #498
Streaming of http messages
Directive proxy_buffering defines maximum buffered message size. Messages
shorter than proxy_buffering size are fully buffered, longer messages
contains from two parts: buffered and streamed.
Headers are always buffered. Full set of headers is required for processing
inside of TempestaFW during whole message lifetime.
Body may be split into two part: streamed and buffered. Body is processed only
right after parsing in cache or health monitor and not required in further
processing. Thus body may be safely streamed to target connection and freed
at any time.
Trailer header is also must be buffered. It extends headers, so it may be
required for message processing. Also trailer headers can be modified before
forwarding (e.g. resp_hdr_set directive), this can be done only on fully
buffered trailer.
In the text I say 'headers', 'body' and 'trailer', but 'headers' actually stands
for buffered message part: HTTP headers and buffered part of the body.
Performance impacts
In general case the incoming message can't be streamed to target connection
right away. When a client message is received, it's placed into a server
connection forwarding queue (fwd_queue). Under the load it's never empty, so
immediate streaming is not possible and the message will be scheduled
for forwarding. When a server message is received, it's forwarded to client
with respect to client's seq_queue. If client pipelines requests, seq_queue
may be not empty and the there can be a number of unanswered requests,
so immediate streaming is not possible. Both situations may be worse, if
target connection is occupied by another streamed transmission.
But in the same time servers are much faster than clients, the request
may climb to the begging of the fwd_queue before the client finished the
transmission. Same for the backend to the client transmission: seq_queue
shouldn't be big, and all previous requests from the queue may be responded
faster than transmission of current response.
This means two things:

some times messages can be fully assembled before streaming.
the same message can be processed by two threads, since it's placed into
seq_queue and fwd_queue in incomplete state.

There is a couple solutions to deal with the first problem.

Streaming from backend to clients (response streaming): Configuration level.
Use sticky sessions. In this case all requests from one client will be always
forwarded to the same backend connection. So any response can be effectively
streamed to the client.
Application-aware response streaming. When a new request is received,
user-defined rules are used to check that expected response is to be streamed.
If that true, don't forward the request (and following) to the backends until
all previous requests are responded.
Request streaming. The request is likely to be buffered if fwd_queue is
not empty. Keep a separate pool of backend connections for streaming only
or dynamically allocate a new server connection.

Long-polling requests from multiple clients may fully block backend connections.
Application-aware approach or dynamically allocated backend connections are
required.
This topic requires dedicated discussion.
Processing of streamed messages
The main difference between buffered and streamed messages is processing
stages. Processing of a buffered connection is straight forward:
( receive -> parse ) -> process -> forward
repeat until message
 is fully received

Processing of streamed messages is bit complicated:
( receive -> parse ) -> [ process -> forward ] ->
 repeat until headers     forward headers to
 are fully received       target connection


 -> ( receive -> parse -> process -> stream ) ->
      repeat until all body fragments are
                    streamed


-> ( receive -> parse ) -> process -> stream
     repeat until trailer
     headers are fully
          received

Forwarding may happen in a different tread, so multiple access to the same
message is possible. First idea was to use spinlock to protect the message
from simultaneous parsing and forwarding. But only one spinlock is not enough
and a lot of additional checks and flags are required. Imagine the situation:
Part of request was received, scheduled to backend connection, a new part
is being parsed and processed so the lock is acquired. In the same time
other thread starts forwarding and tries to acquire the lock. Processing error
happens during processing in the first thread and the message must be destroyed.
In this approach reference counting and error flag is required. The same
situation takes place in other cases, so the code becomes very complicated.
Here is the used  solution. Stream message part only from the same thread where
the message is received. Forwarding of headers may (and will) happen in other
thread but that thread must not send streamed message part, only buffered.
So processing looks like:
Thread 1                                    Thread 2
--------                                    --------
    |                                           |
(receive headers)                               |
    |                                           |
(schedule to forward)                           |
    |                                           |
(receive, process body part)                    |
    * N                                         |
    |                                           |
    |                             (forward headers only to target connection)
    |                                           |
(receive, process body parts)                   |
    |                                           |
(stream al pending)                             |
    |                                           |
(receive, process, stream body part)            |
    * N                                         |
    |                                           |
(destroy the message)                           |

Forwarding in Thread 2 may happen only after the whole streamed message was
received. In this case Thead 1 will never forward streamed part, so the Thread 1
is responsible for streaming and releasing the message.
When a streamed message is forwarded to some connection, no messages allowed to
be forwarded though that connection until the forwarded message is fully
transmitted. Thus connection's seq_qlock or fwd_qlock is acuired on
streaming message part. In addition to thread role management described above,
this gives thread safety.
Note, that a response to the streamed request may appear earlier than request
is fully received. E.g. sticky cookie violation, serving message from cache.
In this case, request must be received fully to proceed to the next request.
All functions that processes message body, must be capable to process
the body by parts, since full body is never available for streamed messages.
Close connection on streaming
Sometimes it's needed to close the egress connection after the messaged is fully
transmitted. In this case CONN_CLOSE flag must be added to ss_flags only
when the last message part is streamed.
Error handling
Streamed message is partially received, but not forwarded to target connection.
-> Close ingress connection.
Streamed message is partially received and is being streamed to target
connection. -> Close both connection.
Streamed message is fully received and is being streamed to target
connection. -> Close egress connection.
Request was streamed to backend, but backend connection was closed and reopened.
-> Evict request, it's not stored in Tempesta, so it's not possible to
forward it once more time.
Early response is available for the streamed request (from sticky or cache
modules) but the request failed security limits (frang) or other processing
on receiving a new body fragment. -> If the response
is not sent yet (mostly false condition), drop the response and forward
a new one via tfw_http_error_resp_and_log() if applied. Close client
connection.
Caching streamed responses
Message streaming is used to avoid assembling full messages and spending too
lot of memory for just a couple of messages, e.g. DVD images. Same apply
to cache. A new directive is required to limit cache entry size. Caching 1M
small responses may be more effective, than caching just a couple of big ones.
Cache entry size required to store the response may be unknown for streamed
responses. Response in chunked encoding may be very huge. Content-length header
is not provided in this case. It's required to effectively enlarge cache entry to
save a new response fragment. A new response fragment may be not only body, but
trailer headers too.",Obsoleted by #1067,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1014,2018-05-13T12:02:57Z,2018-05-13T12:03:10Z,2018-05-13T12:06:14Z,MERGED,True,51328,51328,126,https://github.com/krizhanovsky,Trivial & automatic tls coding style adjustments,2,[],https://github.com/tempesta-tech/tempesta/pull/1014,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1014,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1015,2018-05-13T18:11:54Z,2018-05-14T19:38:18Z,2018-05-14T19:54:05Z,MERGED,True,53,25,3,https://github.com/krizhanovsky,Fix #852: don't drop a connection if it coulnd't be created due to an error.,3,[],https://github.com/tempesta-tech/tempesta/pull/1015,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1015,"Move non-configured certificate error to start phase.
Cleanups and more user-friendly error messages.
#715: rename SSL to TLS configuration options (wiki and tests are updated as well)","Move non-configured certificate error to start phase.
Cleanups and more user-friendly error messages.
#715: rename SSL to TLS configuration options (wiki and tests are updated as well)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1016,2018-05-13T18:22:10Z,2018-05-14T19:53:17Z,2018-05-14T19:53:27Z,MERGED,True,53,25,4,https://github.com/krizhanovsky,Fix #852,3,[],https://github.com/tempesta-tech/tempesta/pull/1016,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1016,"Backport of https://github.com/tempesta-tech/tempesta/pull/1015 to 0.5
Fix #852: don't drop a connection if it coulnd't be created due to an error
Move non-configured certificate error to start phase.
Cleanups and more user-friendly error messages.","Backport of https://github.com/tempesta-tech/tempesta/pull/1015 to 0.5
Fix #852: don't drop a connection if it coulnd't be created due to an error
Move non-configured certificate error to start phase.
Cleanups and more user-friendly error messages.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1017,2018-05-15T12:36:30Z,2018-06-09T20:20:54Z,2018-06-09T20:21:00Z,MERGED,True,1704,1135,27,https://github.com/aleksostapenko,Fix #731: HTTP tables introduction.,11,[],https://github.com/tempesta-tech/tempesta/pull/1017,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/1017,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1018,2018-05-16T20:35:27Z,2018-05-18T14:06:37Z,2018-05-18T14:06:41Z,MERGED,True,9,2,1,https://github.com/ikoveshnikov,Fix missed function in unit tests.,1,[],https://github.com/tempesta-tech/tempesta/pull/1018,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1018,tfw_tls_cfg_require() function is missed in unit test. Found by @vladtcvs,tfw_tls_cfg_require() function is missed in unit test. Found by @vladtcvs,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1020,2018-05-22T15:05:22Z,2018-05-22T23:30:12Z,2018-05-22T23:30:15Z,CLOSED,False,20,0,20,https://github.com/vladtcvs,Testing PR - don't merge,20,[],https://github.com/tempesta-tech/tempesta/pull/1020,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/1020,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1022,2018-05-22T23:30:40Z,2018-09-29T14:54:13Z,2018-10-23T13:43:36Z,CLOSED,False,2,0,2,https://github.com/vladtcvs,Create test1,3,[],https://github.com/tempesta-tech/tempesta/pull/1022,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/1022,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1023,2018-05-23T14:58:55Z,2018-05-23T16:20:42Z,2018-05-23T18:50:19Z,MERGED,True,14,7,2,https://github.com/krizhanovsky,Compatibility fast str implementations,2,[],https://github.com/tempesta-tech/tempesta/pull/1023,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1023,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1024,2018-05-23T19:30:05Z,2018-05-24T07:18:04Z,2018-05-24T07:19:02Z,MERGED,True,4,4,1,https://github.com/krizhanovsky,Fix skb leakage on HTTP request processing errors.,2,[],https://github.com/tempesta-tech/tempesta/pull/1024,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1024,"tfw_http_resp_process() calls ss_skb_queue_purge() on bad_msg label, however
tfw_http_req_process() on TFW_BLOCK returned from the parser calls
tfw_client_drop() which not always free the request. (The ingress skb is
linked with the request in tfw_http_msg_process(), so we have to call
ss_skb_queue_purge() even on not parsed request.)
There is a case when we do not free skb on HTTP request processing errors.
tfw_http_cli_error_resp_and_log() -> tfw_http_req_mark_error()
-> __tfw_http_send_resp(): on bad return code from tfw_strcpy_desc()
just returns w/o calling tfw_http_resp_build_error().","tfw_http_resp_process() calls ss_skb_queue_purge() on bad_msg label, however
tfw_http_req_process() on TFW_BLOCK returned from the parser calls
tfw_client_drop() which not always free the request. (The ingress skb is
linked with the request in tfw_http_msg_process(), so we have to call
ss_skb_queue_purge() even on not parsed request.)
There is a case when we do not free skb on HTTP request processing errors.
tfw_http_cli_error_resp_and_log() -> tfw_http_req_mark_error()
-> __tfw_http_send_resp(): on bad return code from tfw_strcpy_desc()
just returns w/o calling tfw_http_resp_build_error().",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1026,2018-05-24T14:39:00Z,2018-05-24T14:53:53Z,2018-05-24T14:53:57Z,MERGED,True,5,1,2,https://github.com/ikoveshnikov,Fix missing configuration attributes check,2,[],https://github.com/tempesta-tech/tempesta/pull/1026,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1026,Relates to #1025,Relates to #1025,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1027,2018-05-25T10:12:23Z,2018-05-25T20:58:08Z,2018-05-25T20:58:12Z,CLOSED,False,100,17,4,https://github.com/ikoveshnikov,Count scheduler misses,2,[],https://github.com/tempesta-tech/tempesta/pull/1027,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1027,"Originally requested by @vladtcvs
Add statistics for scheduler misses: situations when a scheduler can't find live backend connection to forward request. This performance parameter can be valuable for end user. The growing counter means that there is problems with how backends are performing:

too few backend connection / too slow backend performance - backend forwarding queues are mostly full
backends too often close connections from Tempesta, and there are situations with no connections alive
some backends are restricted by health monitor module.

I've also added current group configuration to the statistics. Here is an example how it's look like:

Run wrk against poor configuration:

$ wrk  http://192.168.122.12/
Running 10s test @ http://192.168.122.12/
  2 threads and 12 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   556.77us    1.22ms  35.93ms   99.13%
    Req/Sec    12.24k     1.66k   19.90k    79.10%
  244614 requests in 10.10s, 70.16MB read
  Non-2xx or 3xx responses: 317
Requests/sec:  24220.62
Transfer/sec:      6.95MB


Get statistics:

$ cat /proc/tempesta/servers/default/stat 
Servers						: 1
Maximum forwarding queue size			: 1000
Maximum request forwarding retries		: 5
Maximum number of reconnect attempts		: 10
Maximum age of request				: 60s
Non-idempotent requests forwarding retries	: disabled
Sticky sessions					: disabled
Sticky sessions failovering			: disabled
Attached scheduler				: ratio static
Scheduler misses				: 317

Scheduler misses counter shows that 317 requests was dropped due to no backend connections available.","Originally requested by @vladtcvs
Add statistics for scheduler misses: situations when a scheduler can't find live backend connection to forward request. This performance parameter can be valuable for end user. The growing counter means that there is problems with how backends are performing:

too few backend connection / too slow backend performance - backend forwarding queues are mostly full
backends too often close connections from Tempesta, and there are situations with no connections alive
some backends are restricted by health monitor module.

I've also added current group configuration to the statistics. Here is an example how it's look like:

Run wrk against poor configuration:

$ wrk  http://192.168.122.12/
Running 10s test @ http://192.168.122.12/
  2 threads and 12 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   556.77us    1.22ms  35.93ms   99.13%
    Req/Sec    12.24k     1.66k   19.90k    79.10%
  244614 requests in 10.10s, 70.16MB read
  Non-2xx or 3xx responses: 317
Requests/sec:  24220.62
Transfer/sec:      6.95MB


Get statistics:

$ cat /proc/tempesta/servers/default/stat 
Servers						: 1
Maximum forwarding queue size			: 1000
Maximum request forwarding retries		: 5
Maximum number of reconnect attempts		: 10
Maximum age of request				: 60s
Non-idempotent requests forwarding retries	: disabled
Sticky sessions					: disabled
Sticky sessions failovering			: disabled
Attached scheduler				: ratio static
Scheduler misses				: 317

Scheduler misses counter shows that 317 requests was dropped due to no backend connections available.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1030,2018-05-30T20:11:34Z,2018-06-08T13:14:13Z,2018-06-08T13:14:17Z,MERGED,True,17,2,2,https://github.com/ikoveshnikov,Fix missed connection header,2,[],https://github.com/tempesta-tech/tempesta/pull/1030,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1030,"Fix #1029
Also found that TFW_HTTP_MSG_HDR_DEL macro works incorrect: instead of removing the header, a new header with empty header value is added.","Fix #1029
Also found that TFW_HTTP_MSG_HDR_DEL macro works incorrect: instead of removing the header, a new header with empty header value is added.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1035,2018-07-05T12:36:13Z,2018-07-05T13:30:10Z,2018-07-05T13:30:13Z,MERGED,True,3,4,1,https://github.com/aleksostapenko, Fix #1013: Avoid gcc-7 warning in conditional ternary operator (#1013).,1,[],https://github.com/tempesta-tech/tempesta/pull/1035,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/1035,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1036,2018-07-10T13:06:37Z,2018-07-18T18:32:02Z,2018-07-18T18:32:18Z,MERGED,True,456,249,8,https://github.com/aleksostapenko,Fix #1033: Change header name format in HTTP tables configuration.,4,[],https://github.com/tempesta-tech/tempesta/pull/1036,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/1036,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1037,2018-07-10T22:37:46Z,2018-12-31T12:41:39Z,2019-01-01T15:53:18Z,MERGED,True,24472,67325,199,https://github.com/krizhanovsky,Tempesta TLS performance optimizations,136,[],https://github.com/tempesta-tech/tempesta/pull/1037,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1037,"Fix #614:

Fix the memory leak in TLS;
Remvoed rx and tx copying queues in TLS;
remove copyings skb_{copy,store}_bits(), all crypto is done in-place now;
fix multiple allocations, calloc(), malloc(), free() wrappers are almost eliminated. At least from crucial workflos for now
fully rewritten mbedTLS state machine for TLS handshakes, so that now it works with chunked data in zero-copy fashion;
unification with linux/crypt - we use the crypt, but RSA and ECDSA which seems incomplete in the kernel
encrypt TLS records with dynamic size calculated in tcp_write_xmit() (see tempesta-tech/linux-4.14.32-tfw#3): we encrypt several skbs, but not more than a minimum between TCP congestion window and the receiver's advertised window;
Address #391 point 12: now we can use skb->head as paged fragments;
Introduced unified logging as lib/log.h and unified return values
ss_skb_process(): process skb chains, replace parser->to_go by return value variable, so ss_skb_process() returns how much data was actually processed (seems buggy);
Fix #214
Address RFC7525 by removing weak algorithms.
Many cleanups and coding style adjustments.","Fix #614:

Fix the memory leak in TLS;
Remvoed rx and tx copying queues in TLS;
remove copyings skb_{copy,store}_bits(), all crypto is done in-place now;
fix multiple allocations, calloc(), malloc(), free() wrappers are almost eliminated. At least from crucial workflos for now
fully rewritten mbedTLS state machine for TLS handshakes, so that now it works with chunked data in zero-copy fashion;
unification with linux/crypt - we use the crypt, but RSA and ECDSA which seems incomplete in the kernel
encrypt TLS records with dynamic size calculated in tcp_write_xmit() (see tempesta-tech/linux-4.14.32-tfw#3): we encrypt several skbs, but not more than a minimum between TCP congestion window and the receiver's advertised window;
Address #391 point 12: now we can use skb->head as paged fragments;
Introduced unified logging as lib/log.h and unified return values
ss_skb_process(): process skb chains, replace parser->to_go by return value variable, so ss_skb_process() returns how much data was actually processed (seems buggy);
Fix #214
Address RFC7525 by removing weak algorithms.
Many cleanups and coding style adjustments.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1037,2018-07-10T22:37:46Z,2018-12-31T12:41:39Z,2019-01-01T15:53:18Z,MERGED,True,24472,67325,199,https://github.com/krizhanovsky,Tempesta TLS performance optimizations,136,[],https://github.com/tempesta-tech/tempesta/pull/1037,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/1037#issuecomment-450739173,"Fix #614:

Fix the memory leak in TLS;
Remvoed rx and tx copying queues in TLS;
remove copyings skb_{copy,store}_bits(), all crypto is done in-place now;
fix multiple allocations, calloc(), malloc(), free() wrappers are almost eliminated. At least from crucial workflos for now
fully rewritten mbedTLS state machine for TLS handshakes, so that now it works with chunked data in zero-copy fashion;
unification with linux/crypt - we use the crypt, but RSA and ECDSA which seems incomplete in the kernel
encrypt TLS records with dynamic size calculated in tcp_write_xmit() (see tempesta-tech/linux-4.14.32-tfw#3): we encrypt several skbs, but not more than a minimum between TCP congestion window and the receiver's advertised window;
Address #391 point 12: now we can use skb->head as paged fragments;
Introduced unified logging as lib/log.h and unified return values
ss_skb_process(): process skb chains, replace parser->to_go by return value variable, so ss_skb_process() returns how much data was actually processed (seems buggy);
Fix #214
Address RFC7525 by removing weak algorithms.
Many cleanups and coding style adjustments.","Fixed in #1143 , @ikoveshnikov please review the new PR.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1039,2018-07-14T22:09:55Z,2018-07-18T19:08:12Z,2018-07-18T19:08:17Z,MERGED,True,7,5,2,https://github.com/aleksostapenko, Fix #772: Change 'keepalive' and 'client_body' timeouts applying.,2,[],https://github.com/tempesta-tech/tempesta/pull/1039,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/1039,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1046,2018-07-25T12:57:30Z,2018-10-05T14:44:52Z,2018-10-05T14:44:56Z,MERGED,True,300,243,1,https://github.com/vladtcvs,Describe case of absent proxy_pass,7,[],https://github.com/tempesta-tech/tempesta/pull/1046,https://github.com/vladtcvs,1,https://github.com/tempesta-tech/tempesta/pull/1046,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1046,2018-07-25T12:57:30Z,2018-10-05T14:44:52Z,2018-10-05T14:44:56Z,MERGED,True,300,243,1,https://github.com/vladtcvs,Describe case of absent proxy_pass,7,[],https://github.com/tempesta-tech/tempesta/pull/1046,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/1046#issuecomment-425651688,,"@vladtcvs is on another project now, so @ikoveshnikov could you please finish and merge the PR.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1047,2018-07-27T11:35:06Z,2018-09-07T11:41:02Z,2018-09-07T11:41:09Z,MERGED,True,1110,202,17,https://github.com/aleksostapenko,Fix #535: Block clients which requests have no session cookie.,7,[],https://github.com/tempesta-tech/tempesta/pull/1047,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/1047,Fix for #962 is also included in this PR.,Fix for #962 is also included in this PR.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1047,2018-07-27T11:35:06Z,2018-09-07T11:41:02Z,2018-09-07T11:41:09Z,MERGED,True,1110,202,17,https://github.com/aleksostapenko,Fix #535: Block clients which requests have no session cookie.,7,[],https://github.com/tempesta-tech/tempesta/pull/1047,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/1047#issuecomment-409711641,Fix for #962 is also included in this PR.,"The implementation is correct in context of #535, but I agree with @ikoveshnikov that the new limit is just a duplication of redirect limitation.

It also becomes hard to predict when the ip address blocking may be triggered, since the counter is saved in TfwClient instance which is destroyed when all client from that IP closes connections to Tempesta server.

A fix for this particular issue is requested in #488 (comment)
I don't see why a bot can not always send resource?attempt=1. So I propose to use cryptographically strong (relatively) hash function and current timestamp to prevent repetition attacks (just like we do this in the cookie itself), so we need to send something like resource?attempt=<attempt_no | jiffies | hash(attempt_no,jiffies,secret) and check the attempt number and the timestamp. Block the user if timestamp is older that configured number of seconds (please add the one more option to the configuration directive).
UPD. Actually, resource can contain query string (e.g. /show?a=1) or not (/index.html), so we need to use different gluing for both the cases: &attempt=.... and ?attempt=... correspondingly. So it'd be easier to remove attempt= part at all, leaving only <attempt_no | jiffies | hash(attempt_no,jiffies,secret) and put it in front of the whole URI, e.g. /hash/show?a=1 or /hash/index.html for the examples above. Probably, to make the life easier and faster, we can encode attempt_no in fixed length, e.g. limit with 3 hex digist, e.g. 00a, so you'll have fixed length part of URI which is easier to process and cut/add.",True,"{'THUMBS_UP': ['https://github.com/ikoveshnikov', 'https://github.com/aleksostapenko']}"
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1047,2018-07-27T11:35:06Z,2018-09-07T11:41:02Z,2018-09-07T11:41:09Z,MERGED,True,1110,202,17,https://github.com/aleksostapenko,Fix #535: Block clients which requests have no session cookie.,7,[],https://github.com/tempesta-tech/tempesta/pull/1047,https://github.com/ikoveshnikov,3,https://github.com/tempesta-tech/tempesta/pull/1047#issuecomment-410698490,Fix for #962 is also included in this PR.,"Seems like authorizing URI format of /<HASH>/<ORIGINAL_URI> can cause some troubles. E.g. some sites with user generated content and forums may use large decimal integers to address resources such as topics, articles, comments.
If the discussed option is switched on, that integer resource URI can be mistakenly treated as invalid hash value and the client would be blocked. We still have to add literal marker before hash to prevent such errors. The resulting authorizing URI format should be /<MARKER>_<HASH>/<ORIGINAL_URI>. <MARKER> should be literal value not expected for protected resource, e.g. same as sticky cookie name which is __tfw by default.",True,{'THUMBS_UP': ['https://github.com/krizhanovsky']}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1047,2018-07-27T11:35:06Z,2018-09-07T11:41:02Z,2018-09-07T11:41:09Z,MERGED,True,1110,202,17,https://github.com/aleksostapenko,Fix #535: Block clients which requests have no session cookie.,7,[],https://github.com/tempesta-tech/tempesta/pull/1047,https://github.com/krizhanovsky,4,https://github.com/tempesta-tech/tempesta/pull/1047#issuecomment-410720323,Fix for #962 is also included in this PR.,"Yeah, agree. The marker should be configurable and I think there is no sense to handle two markers, for the cookie and the URL, so let's ask a user for the same marker and use it from the config file.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1051,2018-08-05T07:45:05Z,2018-08-10T15:11:11Z,2018-08-10T15:11:16Z,MERGED,True,28,12,2,https://github.com/aleksostapenko,Fix #900: Change some comments and add unit tests.,2,[],https://github.com/tempesta-tech/tempesta/pull/1051,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/1051,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1055,2018-08-14T20:55:29Z,2018-10-22T12:43:27Z,2018-10-22T12:43:33Z,MERGED,True,42,15,2,https://github.com/ikoveshnikov,Preserve correct fsm state when moving to a next state,6,[],https://github.com/tempesta-tech/tempesta/pull/1055,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1055,fix #1032,fix #1032,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1057,2018-08-16T13:37:05Z,2018-08-16T14:26:40Z,2018-08-16T14:26:44Z,MERGED,True,19,0,2,https://github.com/ikoveshnikov,Fix build on release 0.5.3,2,[],https://github.com/tempesta-tech/tempesta/pull/1057,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1057,This line was removed during latest backports,This line was removed during latest backports,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1057,2018-08-16T13:37:05Z,2018-08-16T14:26:40Z,2018-08-16T14:26:44Z,MERGED,True,19,0,2,https://github.com/ikoveshnikov,Fix build on release 0.5.3,2,[],https://github.com/tempesta-tech/tempesta/pull/1057,https://github.com/vladtcvs,2,https://github.com/tempesta-tech/tempesta/pull/1057#issuecomment-413553777,This line was removed during latest backports,"Please add this to pkg/debin/changelog
tempesta-fw-dkms (0.5.3) stretch; urgency=medium

  * Fix #852: don't drop a connection if it coulnd't be created due to an error
    Move non-configured certificate error to start phase.
    Cleanups and more user-friendly error messages.

 -- Tempesta Technologies, Inc. <info@tempesta-tech.com>  Wed, 16 Aug 2018 14:48:56 +0500

tempesta-fw-dkms (0.5.1) stretch; urgency=medium

  * Add HTTP health monitoring
  * Performance optimisation and fixes for the On-the-fly reconfiguration
  * Add Referer header support to HTTP match rules
  * Add JavaScript challenge to Sticky Cookie module
  * Add user defined headers to forwarded messages
  * Whitelist requests from web search engines
  * Protect from manual unloading under load
  * Fix of response-request pairing for pipelined messages
  * Many other minor fixes. See git log for more information.
 
 -- Tempesta Technologies, Inc. <info@tempesta-tech.com>  Wed, 16 Aug 2018 14:48:56 +0500",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1060,2018-09-04T13:48:36Z,2018-10-05T17:16:24Z,2018-10-05T17:16:34Z,MERGED,True,32,28,4,https://github.com/aleksostapenko,Fix #1058: Protocol/port persistence support during redirection.,4,[],https://github.com/tempesta-tech/tempesta/pull/1060,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/1060,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1062,2018-09-06T10:09:40Z,2018-09-14T19:11:56Z,2018-09-14T19:12:00Z,MERGED,True,61,28,1,https://github.com/ikoveshnikov,Don't treat message parsing as successful unless message has expected length,3,[],https://github.com/tempesta-tech/tempesta/pull/1062,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1062,"Normally string buffer represents full message from start to end, we can't treat parsing as successful, if http parser returned TFW_PASS, but parsing was stopped before the buffer end.","Normally string buffer represents full message from start to end, we can't treat parsing as successful, if http parser returned TFW_PASS, but parsing was stopped before the buffer end.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1067,2018-09-25T12:00:08Z,2019-01-26T22:04:32Z,2019-01-26T22:04:32Z,CLOSED,False,14,7,1,https://github.com/ikoveshnikov,Streaming mode of operation. Part I: request streaming,2381,[],https://github.com/tempesta-tech/tempesta/pull/1067,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1067,"Obsoletes #1012 . Original implementation was full of missed questions, trying to solve them has brought me to a new design. I've spilt the full PR in two parts: streaming of requests and streaming of responses. It's too gigantic for single PR and there tons of very specific changes hard to track altogether.
I. Per-connection memory limit and receive window steering
The idea behind is to have only one virtual buffer shared between receive queue and requests stored inside Tempesta. Advertised receive window must not overcome free space in that virtual buffer.
To implement this, SOCK_RCVBUF_LOCK user lock is set for the client connection socket and sk->sk_rcvbuf size is manually controlled by Tempesta. Unlike to userspace behaviour of the SO_RCVBUF option, sk->sk_rcvbuf is not fixed. Instead it's Initialized with net.ipv4.tcp_rmem[1] as usual TCP connection and is increased if the client has a good transmission rate. The new client_rmem replaces net.ipv4.tcp_rmem[2], so client connections has theirs' own memory limits, while system-wide limit describes the limits for the server connections.
Second thing changed here - tracking per socket memory. Once skb added to the receive queue, the sk->sk_rmem_alloc counter is increased by skb_true_size. The odd between sk->sk_rcvbuf size and sk->sk_rmem_alloc is used to calculate a new receive window size. When an skb is detached from the receive queue it's not tracked by sk->sk_rmem_alloc any more, and receive window size returns back to it's original size. In the proposed solution after skb is orphaned and a new HTTP request is parsed from the skb, original size of HTTP request is added to sk->sk_rmem_alloc to calculate new and smaller window size. After response is sent to the client, the request is destroyed and sk->sk_rmem_alloc is decreased to produce bigger receive window size and allow the client to send more data. No other changes are made in window calculation, so all the other features works well: advertised widow is always multiples of mss, advertised window is never shrank and so on.
Actually limit is 2*client_rmem bytes. It's done to provide the same behaviour as well-known SO_RCVBUF socket option. If the receive buffer is depleted, zero window size is advertised by the kernel code and the client sends window probes, after keepalive_timeout seconds client will be disconnected.
II. Streaming requests to server connections
Basic idea: request requests longer than client_msg_buffering bytes are send by parts, as soon as a new chunk arrives. Headers are always fully buffered, even if header part is longer than the limit. To reduce extra work, a newly parsed skb is added to buffered part in full without breaking it into parts.
client_msg_buffering must be less than client_rmem. Default configuration must safe, so buffering limit is set to 1Mb by default.
Streamed requests brings new problems, which doesn't appear in full buffered mode:


Request processing starts right after end of buffered part. The rest of request may be received and processed after buffered pard is assigned to a backend connection for transmission.


Streamed message can't be re-sent. Streamed part of the request is destroyed once sent to backend, there is nothing to re-send.


If only a part of request is sent out to the backend, but an error happen during receiving a new request chunk, backend connection must be closed to recover.


Imagine that first N of requests in the server connection's forward queue was streamed to backend and (N+1) request is partly streamed. If an error happen during receiving a new chunk of that partly streamed request, backend connection must be closed. But immediate close of backend connection will degrade quality of service, since previous request can't be re-sent and evicted. To provide a better level of service, we have to wait until all sent requests will be responded. Another option is streaming requests one-by-one without pipelining, but that will cause extra buffering overhead and overall performance impact. The implementation provides the first solution.


Backend may respond to streamed request earlier that request is fully received. E.g. Nginx sends 200 OK reply to the GET request with chunked body before the body is received; or backend may send 4xx or 5xx error and close the connection before request is fully received (Just like Tempesta in case of attacks or errors). In case of early responses all the following request chuncks must be forwarded to the backend.


A new chunk of streamed request may be unneeded and should be dropped without processing, if request is served from cache, redirect response is prepared (sticky cookie module), or backend responded already responded


More than one response may be created for a single request, e.g. response may be built from cache, but later an error is detected in a new request chunk, and Tempesta is configured to send a reply. The proposed solution doesn't send a response before request is fully received, and never shares the content with clients that sends errors. But responses from backend are treated as primary action: if the error happen, but backend is already responded, backend response will be used.


Forwarding from backend's forward queue and parsing a new request chunk may be happen simultaneously, and multiple access to the same request may happen. Some kind of synchronisation is required. In the proposed solution streamed message is split into two parts: TfwHttpReq which mustn't be modified after enlisting into forward queue, and TfwHttpMsgPart - streamed part of the request, which can contain the rest of the body and trailer part headers and can be modified at any time.


As for me, client_rmem is highly recommended for using with client_msg_buffering. Multiple clients may stream to the same backend connection, but Tempesta may stream only one int the same time.
Two options are possible: pause other clients by sending them zero windows, or buffer streamed requests until backend is ready. The later is implemented.


According to RFC trailer headers can be excluded from processing by streaming proxy and forwarded. But we aimed to check consistence of every forwarded header, and we provide some options to modify headers before forwarding. No exclusions for trailer headers in streamed message part.


III. Other fixes and improvements.


Fix #899: check sticky cookie before forwarding request to cache, (the same fix also partly implements #1043).


Fix #962: Drop client connections on response blocking.


Block messages with not allowed trailer headers. Partly done: all headers known by Tempesta by this moment are prohibited in trailer part. The list must be extended according to RFC (Todo comment is provided).


Don't try to send error message to client on response parse errors, if client is the Health Monitor subsystem.


Drop request/response and close the connection if splitting skb for sibling messages has failed. In this case original message will contain more than one message.


Replace TFW_HTTP_SUSPECTED request flag with usual TFW_HTTP_CONN_CLOSE flag to set up correct Connection: header value.


Bit operations with message flags are replaced by common test_bit/set_bit() API.


TfwHttpParser is allocated on per-connection, not on per-message basis.


Some other minor improvements.","Obsoletes #1012 . Original implementation was full of missed questions, trying to solve them has brought me to a new design. I've spilt the full PR in two parts: streaming of requests and streaming of responses. It's too gigantic for single PR and there tons of very specific changes hard to track altogether.
I. Per-connection memory limit and receive window steering
The idea behind is to have only one virtual buffer shared between receive queue and requests stored inside Tempesta. Advertised receive window must not overcome free space in that virtual buffer.
To implement this, SOCK_RCVBUF_LOCK user lock is set for the client connection socket and sk->sk_rcvbuf size is manually controlled by Tempesta. Unlike to userspace behaviour of the SO_RCVBUF option, sk->sk_rcvbuf is not fixed. Instead it's Initialized with net.ipv4.tcp_rmem[1] as usual TCP connection and is increased if the client has a good transmission rate. The new client_rmem replaces net.ipv4.tcp_rmem[2], so client connections has theirs' own memory limits, while system-wide limit describes the limits for the server connections.
Second thing changed here - tracking per socket memory. Once skb added to the receive queue, the sk->sk_rmem_alloc counter is increased by skb_true_size. The odd between sk->sk_rcvbuf size and sk->sk_rmem_alloc is used to calculate a new receive window size. When an skb is detached from the receive queue it's not tracked by sk->sk_rmem_alloc any more, and receive window size returns back to it's original size. In the proposed solution after skb is orphaned and a new HTTP request is parsed from the skb, original size of HTTP request is added to sk->sk_rmem_alloc to calculate new and smaller window size. After response is sent to the client, the request is destroyed and sk->sk_rmem_alloc is decreased to produce bigger receive window size and allow the client to send more data. No other changes are made in window calculation, so all the other features works well: advertised widow is always multiples of mss, advertised window is never shrank and so on.
Actually limit is 2*client_rmem bytes. It's done to provide the same behaviour as well-known SO_RCVBUF socket option. If the receive buffer is depleted, zero window size is advertised by the kernel code and the client sends window probes, after keepalive_timeout seconds client will be disconnected.
II. Streaming requests to server connections
Basic idea: request requests longer than client_msg_buffering bytes are send by parts, as soon as a new chunk arrives. Headers are always fully buffered, even if header part is longer than the limit. To reduce extra work, a newly parsed skb is added to buffered part in full without breaking it into parts.
client_msg_buffering must be less than client_rmem. Default configuration must safe, so buffering limit is set to 1Mb by default.
Streamed requests brings new problems, which doesn't appear in full buffered mode:


Request processing starts right after end of buffered part. The rest of request may be received and processed after buffered pard is assigned to a backend connection for transmission.


Streamed message can't be re-sent. Streamed part of the request is destroyed once sent to backend, there is nothing to re-send.


If only a part of request is sent out to the backend, but an error happen during receiving a new request chunk, backend connection must be closed to recover.


Imagine that first N of requests in the server connection's forward queue was streamed to backend and (N+1) request is partly streamed. If an error happen during receiving a new chunk of that partly streamed request, backend connection must be closed. But immediate close of backend connection will degrade quality of service, since previous request can't be re-sent and evicted. To provide a better level of service, we have to wait until all sent requests will be responded. Another option is streaming requests one-by-one without pipelining, but that will cause extra buffering overhead and overall performance impact. The implementation provides the first solution.


Backend may respond to streamed request earlier that request is fully received. E.g. Nginx sends 200 OK reply to the GET request with chunked body before the body is received; or backend may send 4xx or 5xx error and close the connection before request is fully received (Just like Tempesta in case of attacks or errors). In case of early responses all the following request chuncks must be forwarded to the backend.


A new chunk of streamed request may be unneeded and should be dropped without processing, if request is served from cache, redirect response is prepared (sticky cookie module), or backend responded already responded


More than one response may be created for a single request, e.g. response may be built from cache, but later an error is detected in a new request chunk, and Tempesta is configured to send a reply. The proposed solution doesn't send a response before request is fully received, and never shares the content with clients that sends errors. But responses from backend are treated as primary action: if the error happen, but backend is already responded, backend response will be used.


Forwarding from backend's forward queue and parsing a new request chunk may be happen simultaneously, and multiple access to the same request may happen. Some kind of synchronisation is required. In the proposed solution streamed message is split into two parts: TfwHttpReq which mustn't be modified after enlisting into forward queue, and TfwHttpMsgPart - streamed part of the request, which can contain the rest of the body and trailer part headers and can be modified at any time.


As for me, client_rmem is highly recommended for using with client_msg_buffering. Multiple clients may stream to the same backend connection, but Tempesta may stream only one int the same time.
Two options are possible: pause other clients by sending them zero windows, or buffer streamed requests until backend is ready. The later is implemented.


According to RFC trailer headers can be excluded from processing by streaming proxy and forwarded. But we aimed to check consistence of every forwarded header, and we provide some options to modify headers before forwarding. No exclusions for trailer headers in streamed message part.


III. Other fixes and improvements.


Fix #899: check sticky cookie before forwarding request to cache, (the same fix also partly implements #1043).


Fix #962: Drop client connections on response blocking.


Block messages with not allowed trailer headers. Partly done: all headers known by Tempesta by this moment are prohibited in trailer part. The list must be extended according to RFC (Todo comment is provided).


Don't try to send error message to client on response parse errors, if client is the Health Monitor subsystem.


Drop request/response and close the connection if splitting skb for sibling messages has failed. In this case original message will contain more than one message.


Replace TFW_HTTP_SUSPECTED request flag with usual TFW_HTTP_CONN_CLOSE flag to set up correct Connection: header value.


Bit operations with message flags are replaced by common test_bit/set_bit() API.


TfwHttpParser is allocated on per-connection, not on per-message basis.


Some other minor improvements.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1068,2018-09-27T09:57:18Z,2018-09-28T06:15:00Z,2018-09-28T06:15:03Z,MERGED,True,2,2,2,https://github.com/aleksostapenko, Backport fix for #1066. ,2,[],https://github.com/tempesta-tech/tempesta/pull/1068,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/1068,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1069,2018-09-27T11:57:03Z,2018-09-27T14:06:47Z,2018-09-27T14:06:47Z,MERGED,True,1,1,1,https://github.com/craig,Correct link to patchset,2,[],https://github.com/tempesta-tech/tempesta/pull/1069,https://github.com/craig,1,https://github.com/tempesta-tech/tempesta/pull/1069,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1070,2018-09-28T07:27:35Z,2018-09-28T07:50:28Z,2018-09-28T07:50:31Z,MERGED,True,6,0,1,https://github.com/ikoveshnikov,update changelog for release 0.5.4,1,[],https://github.com/tempesta-tech/tempesta/pull/1070,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1070,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1071,2018-09-28T08:55:04Z,2018-09-28T09:05:58Z,2018-09-28T09:06:01Z,MERGED,True,2,1,2,https://github.com/ikoveshnikov,Exclude functional tests from the package,1,[],https://github.com/tempesta-tech/tempesta/pull/1071,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1071,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1072,2018-09-28T13:54:17Z,2018-10-15T11:43:09Z,2018-10-15T11:43:13Z,MERGED,True,77,30,5,https://github.com/aleksostapenko, Fix #806: Reduce count of IPI during work_queue processing.,5,[],https://github.com/tempesta-tech/tempesta/pull/1072,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/1072,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1077,2018-10-10T21:14:24Z,2018-10-22T14:17:04Z,2018-10-23T13:32:43Z,MERGED,True,88,61,5,https://github.com/ikoveshnikov,Fix unstable JS challange passing,4,[],https://github.com/tempesta-tech/tempesta/pull/1077,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1077,"Related to JS challenge issue described in #1074

Synchronize computation of delay in JS Challange between JS and  Tempesta code
Don't close client connection if unchallenged resources was requested before JS challenge is passed. Blocking of clients that makes too many requests with incorrect cookie  values is subject for #598 .

@krizhanovsky  @aleksostapenko Please, test this fix in your environment. I could reproduce the issue, but I couldn't reproduce the exact behaviour you had.","Related to JS challenge issue described in #1074

Synchronize computation of delay in JS Challange between JS and  Tempesta code
Don't close client connection if unchallenged resources was requested before JS challenge is passed. Blocking of clients that makes too many requests with incorrect cookie  values is subject for #598 .

@krizhanovsky  @aleksostapenko Please, test this fix in your environment. I could reproduce the issue, but I couldn't reproduce the exact behaviour you had.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1077,2018-10-10T21:14:24Z,2018-10-22T14:17:04Z,2018-10-23T13:32:43Z,MERGED,True,88,61,5,https://github.com/ikoveshnikov,Fix unstable JS challange passing,4,[],https://github.com/tempesta-tech/tempesta/pull/1077,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/1077#issuecomment-432248129,"Related to JS challenge issue described in #1074

Synchronize computation of delay in JS Challange between JS and  Tempesta code
Don't close client connection if unchallenged resources was requested before JS challenge is passed. Blocking of clients that makes too many requests with incorrect cookie  values is subject for #598 .

@krizhanovsky  @aleksostapenko Please, test this fix in your environment. I could reproduce the issue, but I couldn't reproduce the exact behaviour you had.","@i-rinat Thank you for comments! The PR is already merged, but I'll fix this in my next PR.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1079,2018-10-15T12:33:25Z,2018-10-17T13:53:38Z,2018-10-17T13:53:42Z,MERGED,True,2,1,1,https://github.com/aleksostapenko,Reset default vhost during start of Tempesta FW,1,[],https://github.com/tempesta-tech/tempesta/pull/1079,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/1079,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1081,2018-10-16T18:05:22Z,2018-10-19T15:24:28Z,2018-10-19T15:43:32Z,MERGED,True,380,339,20,https://github.com/i-rinat,Use struct sockaddr_in6 for all addresses,1,[],https://github.com/tempesta-tech/tempesta/pull/1081,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1081,IPv4 addresses are represented as IPv4-mapped IPv6.,IPv4 addresses are represented as IPv4-mapped IPv6.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1081,2018-10-16T18:05:22Z,2018-10-19T15:24:28Z,2018-10-19T15:43:32Z,MERGED,True,380,339,20,https://github.com/i-rinat,Use struct sockaddr_in6 for all addresses,1,[],https://github.com/tempesta-tech/tempesta/pull/1081,https://github.com/i-rinat,2,https://github.com/tempesta-tech/tempesta/pull/1081#issuecomment-431192258,IPv4 addresses are represented as IPv4-mapped IPv6.,"Addressed (almost all of) comments. That lead to further changes:

ss_bind(), ss_connect(), and tfw_filter_block_ip() now use TfwAddr * for the address;
set of macros TFW_*_ADDR() and TFW_*_ADDR6() were combined into the set of TFW_*_ADDR(). Additionally, those macros now take an additional boolean parameter, controlling whenever a port is included into the string;
tfw_addr_fmt_v4 and tfw_addr_fmt_v6 were merged into tfw_addr_fmt().",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1082,2018-10-16T18:15:58Z,2018-10-16T20:34:33Z,2018-10-16T20:35:08Z,MERGED,True,1,1,1,https://github.com/i-rinat,tdb: make tdbq depend on libtdb,1,[],https://github.com/tempesta-tech/tempesta/pull/1082,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1082,"Sometimes with make -jN, tdbq fails to link with libtdb, since there is
no libtdb yet.","Sometimes with make -jN, tdbq fails to link with libtdb, since there is
no libtdb yet.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1083,2018-10-22T21:11:37Z,2018-10-23T13:11:53Z,2018-10-23T13:12:31Z,MERGED,True,2,2,1,https://github.com/i-rinat,"drop unused ""unused"" parameter of frang_conn_limit()",1,[],https://github.com/tempesta-tech/tempesta/pull/1083,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1083,"In previous versions of code, frang_conn_limit() was required to have a specific prototype, as it was one of a number of similar functions. However, code changed, that's not the case anymore, so the parameter can be safely removed.","In previous versions of code, frang_conn_limit() was required to have a specific prototype, as it was one of a number of similar functions. However, code changed, that's not the case anymore, so the parameter can be safely removed.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1087,2018-10-26T15:05:50Z,2018-10-30T14:10:30Z,2018-10-30T15:35:21Z,MERGED,True,88,61,5,https://github.com/ikoveshnikov,Backport JS Challange fixes to 0.5 release,3,[],https://github.com/tempesta-tech/tempesta/pull/1087,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1087,All review comments applied to original patchset was merged into current patchset.,All review comments applied to original patchset was merged into current patchset.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1087,2018-10-26T15:05:50Z,2018-10-30T14:10:30Z,2018-10-30T15:35:21Z,MERGED,True,88,61,5,https://github.com/ikoveshnikov,Backport JS Challange fixes to 0.5 release,3,[],https://github.com/tempesta-tech/tempesta/pull/1087,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/1087#issuecomment-434350194,All review comments applied to original patchset was merged into current patchset.,"OK, but please don't forget to increment the patch level digit in TFW_VERSION with each backported patch.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1088,2018-10-26T22:29:04Z,2018-10-30T19:51:31Z,2018-10-30T20:53:16Z,MERGED,True,107,6,3,https://github.com/i-rinat,fixups for sticky cookie calculation in case of segmented data,3,[],https://github.com/tempesta-tech/tempesta/pull/1088,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1088,"If request comes in more than one packet, sticky cookie value may be in chunks. The patches handle that case, and also force cookie to be regenerated if inbound cookie was of wrong length.","If request comes in more than one packet, sticky cookie value may be in chunks. The patches handle that case, and also force cookie to be regenerated if inbound cookie was of wrong length.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1088,2018-10-26T22:29:04Z,2018-10-30T19:51:31Z,2018-10-30T20:53:16Z,MERGED,True,107,6,3,https://github.com/i-rinat,fixups for sticky cookie calculation in case of segmented data,3,[],https://github.com/tempesta-tech/tempesta/pull/1088,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/1088#issuecomment-433922801,"If request comes in more than one packet, sticky cookie value may be in chunks. The patches handle that case, and also force cookie to be regenerated if inbound cookie was of wrong length.","I've tried to run this branch, but it still seems to be unstable if cookie value is split between chunks.

Start Tempesta with config:

server 127.0.0.1:8080;
sticky enforce;
sticky_secret ""f00)9eR59*_/22"";


start nc and send a couple of requests:

% nc 192.168.122.12 80                                                                                                              :(
GET /hello HTTP/1.1
Host: 192.168.122.12
User-Agent: curl/7.61.1
Accept: */*

HTTP/1.1 302 Found
Date: Mon, 29 Oct 2018 14:01:53 GMT
Location: http://192.168.122.12/hello
Set-Cookie: __tfw=000000010016beaefe7b50e07fbd97c049f3ddbdb8629d1691a84167
Content-Length: 0

GET /hello HTTP/1.1
Host: 192.168.122.12
Cookie: __tfw=000000010016beaefe7b50e07fbd97c049f3ddbdb8629d1691a84167
My-Hdrff: sdffsf
User-Agent: curl/7.61.155fff
Accept: */*

HTTP/1.1 302 Found
Date: Mon, 29 Oct 2018 14:02:13 GMT
Location: http://192.168.122.12/hello
Set-Cookie: __tfw=000000010016beae6a86104393bc02de1f2a3b8cc7f154d16a4ffdeb
Content-Length: 0



In the same time I see  following issues in the logs:

[ 6295.920463] [tempesta] Warning: http_sess: bad received HMAC value for 192.168.122.1: f(pos=0), ts=0x10016beae orig_hmac=[6a86104393bc02de1f2a3b8cc7f154d16a4ffdeb]


If I use the cookie from the last 302 response, I got my 200 OK reply.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1088,2018-10-26T22:29:04Z,2018-10-30T19:51:31Z,2018-10-30T20:53:16Z,MERGED,True,107,6,3,https://github.com/i-rinat,fixups for sticky cookie calculation in case of segmented data,3,[],https://github.com/tempesta-tech/tempesta/pull/1088,https://github.com/i-rinat,3,https://github.com/tempesta-tech/tempesta/pull/1088#issuecomment-433998102,"If request comes in more than one packet, sticky cookie value may be in chunks. The patches handle that case, and also force cookie to be regenerated if inbound cookie was of wrong length.","@ikoveshnikov,
it looks like you're using different user agent in the second request: curl/7.61.155fff, while in the first one it was curl/7.61.1. I believe that's the reason hmac value is different.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1088,2018-10-26T22:29:04Z,2018-10-30T19:51:31Z,2018-10-30T20:53:16Z,MERGED,True,107,6,3,https://github.com/i-rinat,fixups for sticky cookie calculation in case of segmented data,3,[],https://github.com/tempesta-tech/tempesta/pull/1088,https://github.com/ikoveshnikov,4,https://github.com/tempesta-tech/tempesta/pull/1088#issuecomment-434208945,"If request comes in more than one packet, sticky cookie value may be in chunks. The patches handle that case, and also force cookie to be regenerated if inbound cookie was of wrong length.","Ah, yes, shame on me. I should have checked it before posting the comment.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1089,2018-10-30T23:14:59Z,2018-10-31T12:59:00Z,2018-10-31T12:59:04Z,MERGED,True,1,0,1,https://github.com/i-rinat,resolve missing symbol warning in sticky cookie test,1,[],https://github.com/tempesta-tech/tempesta/pull/1089,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1089,"694140f added code that calls tfw_tls_cfg_require() from tls.c. Without direct including tls.c, there is a missing symbol warning, which in turn prevents unit tests from starting. (At least on my machine.)","694140f added code that calls tfw_tls_cfg_require() from tls.c. Without direct including tls.c, there is a missing symbol warning, which in turn prevents unit tests from starting. (At least on my machine.)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1090,2018-10-31T14:47:35Z,2018-11-01T13:54:56Z,2018-11-01T13:57:24Z,MERGED,True,19,4,1,https://github.com/i-rinat,Backport chunked sticky cookie handling to 0.5,2,[],https://github.com/tempesta-tech/tempesta/pull/1090,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1090,"If request comes in multiple packets, cookie may be split into a number of chunks. These changes address such a case.
This is a backport of #1088.","If request comes in multiple packets, cookie may be split into a number of chunks. These changes address such a case.
This is a backport of #1088.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1092,2018-10-31T20:48:16Z,2018-11-01T13:46:58Z,2018-11-01T13:47:16Z,MERGED,True,56,2,1,https://github.com/i-rinat,test cookie parser splitting string in the right places,1,[],https://github.com/tempesta-tech/tempesta/pull/1092,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1092,"Sticky cookie processing relies on the parser to split data in such way that both key and value of a cookie start at the left border of a chunk. However, there were no tests for that before.","Sticky cookie processing relies on the parser to split data in such way that both key and value of a cookie start at the left border of a chunk. However, there were no tests for that before.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1093,2018-11-01T11:04:13Z,2018-11-01T13:54:09Z,2018-11-01T13:54:12Z,MERGED,True,56,2,1,https://github.com/i-rinat,test cookie parser splitting string in the right places (backport to 0.5),1,[],https://github.com/tempesta-tech/tempesta/pull/1093,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1093,"This is the same as #1092, but for release-0.5.","This is the same as #1092, but for release-0.5.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1094,2018-11-07T22:11:40Z,2018-11-08T22:10:57Z,2018-11-08T22:11:36Z,MERGED,True,18,13,5,https://github.com/i-rinat,Contrived integer overflows,4,[],https://github.com/tempesta-tech/tempesta/pull/1094,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1094,"In some cases it's possible to specify numbers in the configuration file that may cause integer overflows. In such cases timeouts, for example, may be different from expected. Explicit up-casting before multiplications should prevent that.
fixes #1091","In some cases it's possible to specify numbers in the configuration file that may cause integer overflows. In such cases timeouts, for example, may be different from expected. Explicit up-casting before multiplications should prevent that.
fixes #1091",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1095,2018-11-07T23:06:37Z,2018-11-09T14:12:33Z,2018-11-09T14:13:17Z,MERGED,True,14,11,5,https://github.com/i-rinat,Contrived integer overflows (backport to 0.5),1,[],https://github.com/tempesta-tech/tempesta/pull/1095,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1095,This is the backport of #1094 to release-0.5 branch.,This is the backport of #1094 to release-0.5 branch.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1097,2018-11-12T13:39:05Z,2018-11-21T13:32:32Z,2018-11-21T13:32:39Z,MERGED,True,119,30,2,https://github.com/aleksostapenko,Fix #1073: Add support MSI/MSI-X interrupts during NIC queues configuration,5,[],https://github.com/tempesta-tech/tempesta/pull/1097,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/1097,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1098,2018-11-12T20:41:46Z,2018-11-13T13:53:49Z,2018-11-13T14:08:48Z,MERGED,True,14,5,1,https://github.com/krizhanovsky,Small cleanup in the perl JS generator,1,[],https://github.com/tempesta-tech/tempesta/pull/1098,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1098,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1100,2018-11-14T22:56:32Z,2018-11-15T11:24:42Z,2018-11-15T11:25:46Z,MERGED,True,26,25,1,https://github.com/i-rinat,copy network headers in ss_skb_split(),1,[],https://github.com/tempesta-tech/tempesta/pull/1100,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1100,"With HTTP request pipelining, multiple requests can fit into a single network packet, and so end up sharing the same struct sk_buff. In that case, after processing the first request, struct sk_buff is split into two, with remaining data going into another sk_buff. However, newly created struct sk_buff has no IP header, albeit has enough room reserved. That causes ss_skb_fmt_src_addr() used in address extraction for X-Forwarded-For header field, to use uninitialized data.
The patch adds needed header copying.
(related to #1099)","With HTTP request pipelining, multiple requests can fit into a single network packet, and so end up sharing the same struct sk_buff. In that case, after processing the first request, struct sk_buff is split into two, with remaining data going into another sk_buff. However, newly created struct sk_buff has no IP header, albeit has enough room reserved. That causes ss_skb_fmt_src_addr() used in address extraction for X-Forwarded-For header field, to use uninitialized data.
The patch adds needed header copying.
(related to #1099)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1101,2018-11-15T12:26:59Z,2018-11-15T14:27:45Z,2018-11-15T14:27:53Z,MERGED,True,26,25,1,https://github.com/i-rinat,copy network headers in ss_skb_split() (backport to 0.5),1,[],https://github.com/tempesta-tech/tempesta/pull/1101,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1101,"With HTTP request pipelining, multiple requests can fit into a single network packet, and so end up sharing the same struct sk_buff. In that case, after processing the first request, struct sk_buff is split into two, with remaining data going into another sk_buff. However, newly created struct sk_buff has no IP header, albeit has enough room reserved. That causes ss_skb_fmt_src_addr() used in address extraction for X-Forwarded-For header field, to use uninitialized data.
The patch adds needed header copying.
(backport of #1100)
(related to #1099)","With HTTP request pipelining, multiple requests can fit into a single network packet, and so end up sharing the same struct sk_buff. In that case, after processing the first request, struct sk_buff is split into two, with remaining data going into another sk_buff. However, newly created struct sk_buff has no IP header, albeit has enough room reserved. That causes ss_skb_fmt_src_addr() used in address extraction for X-Forwarded-For header field, to use uninitialized data.
The patch adds needed header copying.
(backport of #1100)
(related to #1099)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1109,2018-11-21T13:47:51Z,2018-11-23T13:50:11Z,2018-11-23T13:50:15Z,MERGED,True,30,25,2,https://github.com/ikoveshnikov,Limit upper border for JS challenge to deny hardcoding the challenge,1,[],https://github.com/tempesta-tech/tempesta/pull/1109,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1109,Detailed information in my comment to #1102 issue,Detailed information in my comment to #1102 issue,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1110,2018-11-22T13:41:26Z,2018-11-23T11:17:22Z,2018-11-23T11:17:26Z,MERGED,True,1,0,1,https://github.com/i-rinat,remove request from seq_list when errors occur,1,[],https://github.com/tempesta-tech/tempesta/pull/1110,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1110,"Adds missing error handling. If a request cannot be forwarded, it's dropped. In that case we need to remove it from the connection's queue.
(fixes #1099)","Adds missing error handling. If a request cannot be forwarded, it's dropped. In that case we need to remove it from the connection's queue.
(fixes #1099)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1110,2018-11-22T13:41:26Z,2018-11-23T11:17:22Z,2018-11-23T11:17:26Z,MERGED,True,1,0,1,https://github.com/i-rinat,remove request from seq_list when errors occur,1,[],https://github.com/tempesta-tech/tempesta/pull/1110,https://github.com/i-rinat,2,https://github.com/tempesta-tech/tempesta/pull/1110#issuecomment-441101149,"Adds missing error handling. If a request cannot be forwarded, it's dropped. In that case we need to remove it from the connection's queue.
(fixes #1099)",Updated patch according to the comments. Now it's just single list_del_init(&req->msg.seq_list);.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1113,2018-11-23T16:15:12Z,2018-11-26T11:31:06Z,2018-11-26T11:31:10Z,MERGED,True,1,0,1,https://github.com/i-rinat,remove request from seq_list when errors occur (backport to 0.5),1,[],https://github.com/tempesta-tech/tempesta/pull/1113,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1113,"Adds missing error handling. If a request cannot be forwarded, it's dropped. In that case we need to remove it from the connection's queue.
(backport of #1110)","Adds missing error handling. If a request cannot be forwarded, it's dropped. In that case we need to remove it from the connection's queue.
(backport of #1110)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1117,2018-11-26T12:37:14Z,2018-11-26T14:06:55Z,2018-11-26T14:06:58Z,MERGED,True,32,27,2,https://github.com/ikoveshnikov,[Backport to 0.5] Limit upper border for JS challenge to deny hardcoding the challenge,1,['backport'],https://github.com/tempesta-tech/tempesta/pull/1117,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1117,Backport of #1109,Backport of #1109,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1118,2018-11-27T12:54:06Z,2018-11-30T18:07:16Z,2018-11-30T18:07:20Z,MERGED,True,85,47,6,https://github.com/aleksostapenko,Fix #1034: Counting of client objects to avoid use-after-free case.,2,[],https://github.com/tempesta-tech/tempesta/pull/1118,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/1118,"The cause of the crash is attempt to access to TfwClient object (from frang_conn_close() callback during socket removal) - after the object had already been destroyed in Tempesta exit procedure. In fact there were three problems:

In ss_tcp_state_change() if client connection successfully acquired SS_V_ACT_NEWCONN guard, but ss_stop occurred before acquiring SS_V_ACT_LIVECONN - this will lead to mismatching in __ss_act_cnt (-1 live connections) since we did not check return value of guard operation in SS_CALL_GUARD_ENTER.
The above problem was hidden because in ss_synchronize() we were collecting the value of four lower bytes (instead of four upper ones) of __ss_act_cnt, which constantly resulted in zero live connections on exit.
However correction of the second problem does not guarantee complete avoidance of use-after-free case with TfwClient object: frang_conn_close() callback is called from sk_free() function which in turn called from sock_put() when the socket's refcount becomes zero, and this can happen in the TСP/IP stack - after releasing of all connection guards inside Tempesta. As a solution in this PR, a general accounting of TfwClient objects was added.","The cause of the crash is attempt to access to TfwClient object (from frang_conn_close() callback during socket removal) - after the object had already been destroyed in Tempesta exit procedure. In fact there were three problems:

In ss_tcp_state_change() if client connection successfully acquired SS_V_ACT_NEWCONN guard, but ss_stop occurred before acquiring SS_V_ACT_LIVECONN - this will lead to mismatching in __ss_act_cnt (-1 live connections) since we did not check return value of guard operation in SS_CALL_GUARD_ENTER.
The above problem was hidden because in ss_synchronize() we were collecting the value of four lower bytes (instead of four upper ones) of __ss_act_cnt, which constantly resulted in zero live connections on exit.
However correction of the second problem does not guarantee complete avoidance of use-after-free case with TfwClient object: frang_conn_close() callback is called from sk_free() function which in turn called from sock_put() when the socket's refcount becomes zero, and this can happen in the TСP/IP stack - after releasing of all connection guards inside Tempesta. As a solution in this PR, a general accounting of TfwClient objects was added.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1120,2018-11-27T20:54:34Z,2018-11-28T20:43:38Z,2018-11-28T22:48:38Z,MERGED,True,112,19,3,https://github.com/i-rinat,"Parse ""pragma"" field in response, honor ""pragma"" field in request",3,[],https://github.com/tempesta-tech/tempesta/pull/1120,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1120,"The patchset extends ""pragma"" field processing a bit. It's now parsed in both request and response headers. Also, both sources are used to decide whenever to cache a response.
Although RFC 7234, 5.4 doesn't explicitly specify meaning of ""Pragma: no-cache"" in response header, it is still used by various user agents — at least Firefox and Chromium — perhaps for compatibility reasons. So we probably want to abstain from caching if response comes with ""pragma: no-cache"" too, even if it's not a standard-compliant behavior.
(fixes #1116)","The patchset extends ""pragma"" field processing a bit. It's now parsed in both request and response headers. Also, both sources are used to decide whenever to cache a response.
Although RFC 7234, 5.4 doesn't explicitly specify meaning of ""Pragma: no-cache"" in response header, it is still used by various user agents — at least Firefox and Chromium — perhaps for compatibility reasons. So we probably want to abstain from caching if response comes with ""pragma: no-cache"" too, even if it's not a standard-compliant behavior.
(fixes #1116)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1123,2018-11-28T21:55:24Z,2018-12-02T15:02:25Z,2018-12-02T15:02:31Z,MERGED,True,25,8,1,https://github.com/i-rinat,relax Content-Length limit from UINT_MAX to ULONG_MAX,1,[],https://github.com/tempesta-tech/tempesta/pull/1123,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1123,"Allows larger numbers in Content-Length.
(fixes #1122)","Allows larger numbers in Content-Length.
(fixes #1122)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1123,2018-11-28T21:55:24Z,2018-12-02T15:02:25Z,2018-12-02T15:02:31Z,MERGED,True,25,8,1,https://github.com/i-rinat,relax Content-Length limit from UINT_MAX to ULONG_MAX,1,[],https://github.com/tempesta-tech/tempesta/pull/1123,https://github.com/i-rinat,2,https://github.com/tempesta-tech/tempesta/pull/1123#issuecomment-442620378,"Allows larger numbers in Content-Length.
(fixes #1122)",It may be worth to defer merging of this pull request until streaming mode is implemented/merged (see #1067). Current effective limit of 4GB protects Tempesta from eating all memory.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1123,2018-11-28T21:55:24Z,2018-12-02T15:02:25Z,2018-12-02T15:02:31Z,MERGED,True,25,8,1,https://github.com/i-rinat,relax Content-Length limit from UINT_MAX to ULONG_MAX,1,[],https://github.com/tempesta-tech/tempesta/pull/1123,https://github.com/i-rinat,3,https://github.com/tempesta-tech/tempesta/pull/1123#issuecomment-443363770,"Allows larger numbers in Content-Length.
(fixes #1122)",Rearranged code according to the comments.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1124,2018-11-28T22:47:06Z,2018-11-29T10:46:11Z,2018-11-29T10:48:05Z,MERGED,True,3,4,1,https://github.com/i-rinat,reorder enum a bit in http parser,1,[],https://github.com/tempesta-tech/tempesta/pull/1124,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1124,cosmetic changes,cosmetic changes,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1126,2018-12-04T12:50:23Z,2018-12-04T17:23:36Z,2018-12-04T17:23:41Z,MERGED,True,7,3,1,https://github.com/aleksostapenko,Fix #1019: Unload Tempesta modules after failed start.,1,[],https://github.com/tempesta-tech/tempesta/pull/1126,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/1126,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1127,2018-12-06T14:00:28Z,2018-12-07T08:10:11Z,2018-12-07T08:10:15Z,MERGED,True,2,1,2,https://github.com/ikoveshnikov,Fix bugs affecting load balancers,2,[],https://github.com/tempesta-tech/tempesta/pull/1127,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1127,"Fix incorrect bit operation, leading to incorrect scheduler otions
Fix resetting of APM data. Minimal response time is initialised as 0, and can't be updated with real values here:

  
    
      tempesta/tempesta_fw/apm.c
    
    
        Lines 319 to 327
      in
      8bd88c9
    
  
  
    

        
          
           static inline bool 
        

        
          
           tfw_stats_adj_min(TfwPcntRanges *rng, unsigned int r_time) 
        

        
          
           { 
        

        
          
           	if (r_time < rng->min_val) { 
        

        
          
           		rng->min_val = r_time; 
        

        
          
           		return true; 
        

        
          
           	} 
        

        
          
           	return false; 
        

        
          
           } 
        
    
  


This lead to incorrect balancing in ratio [dynamic|predict] minimal","Fix incorrect bit operation, leading to incorrect scheduler otions
Fix resetting of APM data. Minimal response time is initialised as 0, and can't be updated with real values here:

  
    
      tempesta/tempesta_fw/apm.c
    
    
        Lines 319 to 327
      in
      8bd88c9
    
  
  
    

        
          
           static inline bool 
        

        
          
           tfw_stats_adj_min(TfwPcntRanges *rng, unsigned int r_time) 
        

        
          
           { 
        

        
          
           	if (r_time < rng->min_val) { 
        

        
          
           		rng->min_val = r_time; 
        

        
          
           		return true; 
        

        
          
           	} 
        

        
          
           	return false; 
        

        
          
           } 
        
    
  


This lead to incorrect balancing in ratio [dynamic|predict] minimal",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1129,2018-12-07T13:03:06Z,2019-01-26T22:04:24Z,2019-01-26T22:04:24Z,CLOSED,False,14,12,2,https://github.com/aleksostapenko,Fix #1003: Store requests for resending if connection became inactive.,2600,[],https://github.com/tempesta-tech/tempesta/pull/1129,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/1129,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1129,2018-12-07T13:03:06Z,2019-01-26T22:04:24Z,2019-01-26T22:04:24Z,CLOSED,False,14,12,2,https://github.com/aleksostapenko,Fix #1003: Store requests for resending if connection became inactive.,2600,[],https://github.com/tempesta-tech/tempesta/pull/1129,https://github.com/aleksostapenko,2,https://github.com/tempesta-tech/tempesta/pull/1129#issuecomment-448942968,,"Addressing @ikoveshnikov comment:

First, about issues in the PR. tfw_http_req_resched() is called, when the srv_conn->fwd_qlock is acquired. A request can be rescheduled to the same connection, so deadlock may happen.

The TFW_CONN_B_BUSY bit is intentionally set for connection at very beginning of rescheduling procedure on EBUSY (in tfw_http_req_fwd_busy_resched), so current connection is evicted from subsequent rescheduling and deadlock is avoided.

Request processing become messy and infinite loops are possible.


loop 3-4-3 is possible.

The possibility of infinite recursive rescheduling is intentionally excluded - via introduction of special forwarding state FWD_STATE_RESCH: if we already are in rescheduling state and the error is occurred, we just give up with this connection, leave it as is with all its requests, and move on to try next connection. Moreover, we do that on any error in FWD_STATE_RESCH state, so we do not spend much time with useless connections during busy rescheduling.
Besides, the number of reschedule attempts on EBUSY error is limited by some not big budget (now its value is 10, but it is subject to be discussed, of course), therefore, there cannot be recursive or any other infinite looping.

In very unlucky situations all connections of the server group can be marked with TFW_CONN_B_BUSY flag and the whole service would be unavailable while all server connections are alive. This situation is very unlikely, but also possible.

Described situation can appear in two cases:

All connections of server group are from the same work queue (i.e. CPU) - in this case rescheduling is needed to try send requests through another work queues;
All work queues are busy - we have system overflow, and after limited number of reschedule attempts (as mentioned above) we just drop requests.


at least one request was sent to the server (msg_sent != 0). Nothing to do is required here, the next attempt to forward unsent requests will happened after a new request is scheduled to the connection or at response receiving.

This case is implemented in current PR.

there is no requests forwarded (msg_sent == 0). Ideally is to repeat forwarding attempt after some time, if no new requests are assigned to the connection and no forwarding has happened. But this closely connected to tho #687. At this moment we can add a TODO and close server connection to recover. Nothing bad will happen if we close close server connection: no extra re-send will happen.

I agree that the drawback of solution in current PR - is some additional complexity, introduced into existent code.
Closing server connection on EBUSY error - is possible workaround for the problem of hanged requests in fwd_queue, but this way has its own drawbacks: we need to close valid serviceable connection due to Tempesta internal EBUSY error and to start rather heavy failovering procedure instead of making some attempts to solve situation here and now - via rescheduling requests through another work queues; the case with infinite busy->failover->busy looping is possible, so we need additional counter in TfwSrvConn and some kind of limit (maybe configurable) for this situation, dropping all the requests after the limit will be exhausted; besides, I cannot see in context of #687 the possible solution for the problem with requests hanged in fwd_queue - as I understand, that task is more about lock-free (or some kind of that) fwd_queue. I think the additional discussion with @krizhanovsky is needed, to make conclusive choice.

We talked about rescheduling of requests that can't be forwarded, but server connection failovering process are already cares about rescheduling, there is no need to add extra rescheduling routines.
Same should be done for tfw_http_conn_fwd_repair().

Yes, I left busy rescheduling for failovering procedures, but I'm not sure about that, and it is the subject to be discussed. For tfw_http_conn_shrink_fwdq_resched() - maybe, rescheduling on EBUSY error is indeed redundant here; but from the other side, we are rescheduling requests initially - due to entire connection fail (connection error or connection closing), not due to EBUSY error, so if we faced EBUSY during this first rescheduling - we can decide to give the requests the ""second chance"" on the other, less loaded work queue. For tfw_http_conn_repair() and tfw_http_conn_fwd_repair() - motivation is almost the same: initially, we are re-sending requests due to connection failover, we are not rescheduling them due to EBUSY error, so in this case we also can decide to try on another connection if EBUSY appear.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1130,2018-12-08T13:59:20Z,2018-12-08T22:53:32Z,2018-12-10T13:39:22Z,MERGED,True,1,1,1,https://github.com/i-rinat,fix a typo in the http_parser comment,1,[],https://github.com/tempesta-tech/tempesta/pull/1130,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1130,subj,subj,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1132,2018-12-13T12:43:04Z,2018-12-14T19:12:43Z,2018-12-14T19:12:47Z,MERGED,True,252,250,65,https://github.com/ikoveshnikov,Fix various misspells,2,[],https://github.com/tempesta-tech/tempesta/pull/1132,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1132,"I've fixed some misspells in changed files in PR #1067. But that PR is too big and it's bad idea to mix everything up, so i've gone through other files, fixed errors there and created this PR.","I've fixed some misspells in changed files in PR #1067. But that PR is too big and it's bad idea to mix everything up, so i've gone through other files, fixed errors there and created this PR.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1133,2018-12-13T12:45:51Z,2018-12-27T21:21:09Z,2018-12-27T21:21:13Z,MERGED,True,40,26,1,https://github.com/ikoveshnikov,Correctly delist request on response parsing errors,3,[],https://github.com/tempesta-tech/tempesta/pull/1133,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1133,"When a server sends invalid response, Tempesta sends an error
message to the client and destroys the request. But if the request
was the only request in server connection fwd_queue,  msg_sent
is not updated and contains invalid pointer. Later during server
connection repair this invalid pointer is used and a crash may happen.
Steps to reproduce the issue:

Configure exactly one server connection: server 127.0.0.1:8080
Send a request
Force server to send invalid request
Send another request, most likely that crash will happen","When a server sends invalid response, Tempesta sends an error
message to the client and destroys the request. But if the request
was the only request in server connection fwd_queue,  msg_sent
is not updated and contains invalid pointer. Later during server
connection repair this invalid pointer is used and a crash may happen.
Steps to reproduce the issue:

Configure exactly one server connection: server 127.0.0.1:8080
Send a request
Force server to send invalid request
Send another request, most likely that crash will happen",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1133,2018-12-13T12:45:51Z,2018-12-27T21:21:09Z,2018-12-27T21:21:13Z,MERGED,True,40,26,1,https://github.com/ikoveshnikov,Correctly delist request on response parsing errors,3,[],https://github.com/tempesta-tech/tempesta/pull/1133,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/1133#issuecomment-447559167,"When a server sends invalid response, Tempesta sends an error
message to the client and destroys the request. But if the request
was the only request in server connection fwd_queue,  msg_sent
is not updated and contains invalid pointer. Later during server
connection repair this invalid pointer is used and a crash may happen.
Steps to reproduce the issue:

Configure exactly one server connection: server 127.0.0.1:8080
Send a request
Force server to send invalid request
Send another request, most likely that crash will happen","Added function description, to make it more explicit and easy to understand.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1134,2018-12-13T13:54:34Z,2018-12-28T14:24:15Z,2018-12-28T14:24:19Z,MERGED,True,104,71,1,https://github.com/ikoveshnikov,split skb as soon http_parser returned TFW_PASS,3,[],https://github.com/tempesta-tech/tempesta/pull/1134,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1134,"If ss_skb_split() fails, a part of the next http message will be added to the end of last parsed message. Forwarding such message will break response-request sequence. There is no sense to process the parsed message if split will fail: such message can't be forwarded and connection must be closed to recover.
Current master is also vulnerable for attack on response-request sequence attack:

cilent sends a pack of pipilined requests, but the first request in the pack has a Connection: close header
on current master Tempesta creates a subling message AND splits the skb only if Connection: close header is not set. So no split is performed.","If ss_skb_split() fails, a part of the next http message will be added to the end of last parsed message. Forwarding such message will break response-request sequence. There is no sense to process the parsed message if split will fail: such message can't be forwarded and connection must be closed to recover.
Current master is also vulnerable for attack on response-request sequence attack:

cilent sends a pack of pipilined requests, but the first request in the pack has a Connection: close header
on current master Tempesta creates a subling message AND splits the skb only if Connection: close header is not set. So no split is performed.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1138,2018-12-17T13:13:27Z,2018-12-27T23:16:15Z,2018-12-27T23:16:18Z,MERGED,True,226,165,15,https://github.com/ikoveshnikov,Move http parser to connection,3,[],https://github.com/tempesta-tech/tempesta/pull/1138,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1138,There is no need to allocate a new instance of http parser for each incoming message. It can be allocated once per connection.,There is no need to allocate a new instance of http parser for each incoming message. It can be allocated once per connection.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1139,2018-12-18T17:40:28Z,2019-01-17T14:01:14Z,2019-01-18T17:13:41Z,MERGED,True,634,11,7,https://github.com/i-rinat,Sanitize Content-Type for multipart/form-data requests,1,[],https://github.com/tempesta-tech/tempesta/pull/1139,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1139,"Some application servers parse Content-Type header field in a non-standard way, which is used to bypass web application firewalls. For example, PHP checks whenever parameter name contains substring boundary, and that way matches xxboundaryxx and the like.
To make life easier for backend servers, this patch makes Tempesta to validate Content-Type header field format by parsing it in a strict way. More over it makes possible to recompose its value from parsed data, with any other unrelated parameter dropped. Behavior is controlled by http_post_validate configuration parameter; valid in vhost and location context.
(partially addresses #902)","Some application servers parse Content-Type header field in a non-standard way, which is used to bypass web application firewalls. For example, PHP checks whenever parameter name contains substring boundary, and that way matches xxboundaryxx and the like.
To make life easier for backend servers, this patch makes Tempesta to validate Content-Type header field format by parsing it in a strict way. More over it makes possible to recompose its value from parsed data, with any other unrelated parameter dropped. Behavior is controlled by http_post_validate configuration parameter; valid in vhost and location context.
(partially addresses #902)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1139,2018-12-18T17:40:28Z,2019-01-17T14:01:14Z,2019-01-18T17:13:41Z,MERGED,True,634,11,7,https://github.com/i-rinat,Sanitize Content-Type for multipart/form-data requests,1,[],https://github.com/tempesta-tech/tempesta/pull/1139,https://github.com/i-rinat,2,https://github.com/tempesta-tech/tempesta/pull/1139#issuecomment-448993737,"Some application servers parse Content-Type header field in a non-standard way, which is used to bypass web application firewalls. For example, PHP checks whenever parameter name contains substring boundary, and that way matches xxboundaryxx and the like.
To make life easier for backend servers, this patch makes Tempesta to validate Content-Type header field format by parsing it in a strict way. More over it makes possible to recompose its value from parsed data, with any other unrelated parameter dropped. Behavior is controlled by http_post_validate configuration parameter; valid in vhost and location context.
(partially addresses #902)",There was a NULL-dereference due to req->location being NULL. Fixed that by checking for NULL.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1139,2018-12-18T17:40:28Z,2019-01-17T14:01:14Z,2019-01-18T17:13:41Z,MERGED,True,634,11,7,https://github.com/i-rinat,Sanitize Content-Type for multipart/form-data requests,1,[],https://github.com/tempesta-tech/tempesta/pull/1139,https://github.com/ikoveshnikov,3,https://github.com/tempesta-tech/tempesta/pull/1139#issuecomment-449023074,"Some application servers parse Content-Type header field in a non-standard way, which is used to bypass web application firewalls. For example, PHP checks whenever parameter name contains substring boundary, and that way matches xxboundaryxx and the like.
To make life easier for backend servers, this patch makes Tempesta to validate Content-Type header field format by parsing it in a strict way. More over it makes possible to recompose its value from parsed data, with any other unrelated parameter dropped. Behavior is controlled by http_post_validate configuration parameter; valid in vhost and location context.
(partially addresses #902)","As I understood, unescaped req->multipart_boundary will be used to validate/parse multipart payload. We're going to add feature to proxy messages without assembling. This means that first headers are forwarded and only then payload is validated using req->multipart_boundary .  As soon as Content-Type header is overwritten before forwarding, req->multipart_boundary may contain garbage data. We have to make a deep copy of boundary value into req->multipart_boundary.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1139,2018-12-18T17:40:28Z,2019-01-17T14:01:14Z,2019-01-18T17:13:41Z,MERGED,True,634,11,7,https://github.com/i-rinat,Sanitize Content-Type for multipart/form-data requests,1,[],https://github.com/tempesta-tech/tempesta/pull/1139,https://github.com/i-rinat,4,https://github.com/tempesta-tech/tempesta/pull/1139#issuecomment-454013061,"Some application servers parse Content-Type header field in a non-standard way, which is used to bypass web application firewalls. For example, PHP checks whenever parameter name contains substring boundary, and that way matches xxboundaryxx and the like.
To make life easier for backend servers, this patch makes Tempesta to validate Content-Type header field format by parsing it in a strict way. More over it makes possible to recompose its value from parsed data, with any other unrelated parameter dropped. Behavior is controlled by http_post_validate configuration parameter; valid in vhost and location context.
(partially addresses #902)","We have to make a deep copy of boundary value into req->multipart_boundary.

The patch now makes deep copies of both req->multipart_boundary_raw and req->multipart_boundary for both reason you mentioned and ability to call tfw_http_msg_hdr_xfrm_str() without being afraid of intersecting buffers in memcpy.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1140,2018-12-21T11:47:37Z,2018-12-28T21:46:15Z,2019-01-24T08:14:49Z,MERGED,True,179,153,11,https://github.com/ikoveshnikov,Use standart bitops functions for message flags.,5,[],https://github.com/tempesta-tech/tempesta/pull/1140,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1140,"There was a discussion that a HTTP message flags defined as enum and a set of macroses doesn't look good, in the same time usage of standard bit operations looks cleaner and provide atomic possibilities.","There was a discussion that a HTTP message flags defined as enum and a set of macroses doesn't look good, in the same time usage of standard bit operations looks cleaner and provide atomic possibilities.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1140,2018-12-21T11:47:37Z,2018-12-28T21:46:15Z,2019-01-24T08:14:49Z,MERGED,True,179,153,11,https://github.com/ikoveshnikov,Use standart bitops functions for message flags.,5,[],https://github.com/tempesta-tech/tempesta/pull/1140,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/1140#issuecomment-449592729,"There was a discussion that a HTTP message flags defined as enum and a set of macroses doesn't look good, in the same time usage of standard bit operations looks cleaner and provide atomic possibilities.",@keshonok  Thanks for review!,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1141,2018-12-21T13:57:24Z,2019-01-24T13:12:45Z,2019-01-24T13:12:53Z,MERGED,True,280,139,5,https://github.com/ikoveshnikov,Fixes on serving requests with errors,7,[],https://github.com/tempesta-tech/tempesta/pull/1141,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1141,"Requires #1140 and built upon it. Required for #1043
Changes:

If error has happened during request processing, don't close client connection immediately, send all pending requests first. Don't silently drop request to avoid breaking of the request-response sequence of client. #962
Replace TFW_HTTP_SUSPECTED flag with TFW_HTTP_CONN_CLOSE. Later is more generic and Connection:  is not set correctly with TFW_HTTP_SUSPECTED flag
Check sticky session cookie before forward request to cache. Don't allow unauthorised client to stress cache and receive protected information. #899","Requires #1140 and built upon it. Required for #1043
Changes:

If error has happened during request processing, don't close client connection immediately, send all pending requests first. Don't silently drop request to avoid breaking of the request-response sequence of client. #962
Replace TFW_HTTP_SUSPECTED flag with TFW_HTTP_CONN_CLOSE. Later is more generic and Connection:  is not set correctly with TFW_HTTP_SUSPECTED flag
Check sticky session cookie before forward request to cache. Don't allow unauthorised client to stress cache and receive protected information. #899",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1141,2018-12-21T13:57:24Z,2019-01-24T13:12:45Z,2019-01-24T13:12:53Z,MERGED,True,280,139,5,https://github.com/ikoveshnikov,Fixes on serving requests with errors,7,[],https://github.com/tempesta-tech/tempesta/pull/1141,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/1141#issuecomment-449575364,"Requires #1140 and built upon it. Required for #1043
Changes:

If error has happened during request processing, don't close client connection immediately, send all pending requests first. Don't silently drop request to avoid breaking of the request-response sequence of client. #962
Replace TFW_HTTP_SUSPECTED flag with TFW_HTTP_CONN_CLOSE. Later is more generic and Connection:  is not set correctly with TFW_HTTP_SUSPECTED flag
Check sticky session cookie before forward request to cache. Don't allow unauthorised client to stress cache and receive protected information. #899",Tests must be patched to pass the tests. Build 361 on CI passes for this branch and tempesta-tech/tempesta-test#70,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1143,2019-01-01T15:49:59Z,2019-01-10T14:11:44Z,2019-01-27T17:02:05Z,MERGED,True,7,6,2,https://github.com/krizhanovsky,Fix review comments for #1037,1,[],https://github.com/tempesta-tech/tempesta/pull/1143,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1143,"Fix usage of uninitialized valiables, wrong usage of unsigned variables, some code mess.
@ikoveshnikov the build is failed in CI because of old kernel. Could you please deploy the new kernel version?","Fix usage of uninitialized valiables, wrong usage of unsigned variables, some code mess.
@ikoveshnikov the build is failed in CI because of old kernel. Could you please deploy the new kernel version?",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1143,2019-01-01T15:49:59Z,2019-01-10T14:11:44Z,2019-01-27T17:02:05Z,MERGED,True,7,6,2,https://github.com/krizhanovsky,Fix review comments for #1037,1,[],https://github.com/tempesta-tech/tempesta/pull/1143,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/1143#issuecomment-452591165,"Fix usage of uninitialized valiables, wrong usage of unsigned variables, some code mess.
@ikoveshnikov the build is failed in CI because of old kernel. Could you please deploy the new kernel version?","the build is failed in CI because of old kernel. Could you please deploy the new kernel version?

Yep, just remembered about that. I'll update it today.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1144,2019-01-10T13:16:31Z,2019-01-10T14:46:49Z,2019-01-10T14:46:54Z,MERGED,True,2,2,2,https://github.com/ikoveshnikov,Fix build of TLS module,2,[],https://github.com/tempesta-tech/tempesta/pull/1144,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1144,Error is trivial: extra whitespace in Makefile which prevented to include /lib directory. I've also replaced direct include of lib/log.h with debug.h which also defines required BANNER variable.,Error is trivial: extra whitespace in Makefile which prevented to include /lib directory. I've also replaced direct include of lib/log.h with debug.h which also defines required BANNER variable.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1145,2019-01-10T20:28:10Z,2019-01-26T22:04:31Z,2019-02-12T11:38:12Z,CLOSED,False,182,75,3,https://github.com/avbelov23,Storing client data in tdb,2430,[],https://github.com/tempesta-tech/tempesta/pull/1145,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1145,"Requires #1115
Changes:

Transfer tfw_current_timestamp() to library
Keep client data in TDB (client_db and client_tbl_size options) after the last client connection is closed and use their some time (client_lifetime option)","Requires #1115
Changes:

Transfer tfw_current_timestamp() to library
Keep client data in TDB (client_db and client_tbl_size options) after the last client connection is closed and use their some time (client_lifetime option)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1145,2019-01-10T20:28:10Z,2019-01-26T22:04:31Z,2019-02-12T11:38:12Z,CLOSED,False,182,75,3,https://github.com/avbelov23,Storing client data in tdb,2430,[],https://github.com/tempesta-tech/tempesta/pull/1145,https://github.com/avbelov23,2,https://github.com/tempesta-tech/tempesta/pull/1145#issuecomment-453520091,"Requires #1115
Changes:

Transfer tfw_current_timestamp() to library
Keep client data in TDB (client_db and client_tbl_size options) after the last client connection is closed and use their some time (client_lifetime option)",DONE,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1148,2019-01-14T19:10:18Z,2019-01-15T11:42:18Z,2019-01-15T11:42:28Z,MERGED,True,0,5172,10,https://github.com/i-rinat,remove rebase artifacts,1,[],https://github.com/tempesta-tech/tempesta/pull/1148,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1148,"Various backup file copies were accidentally added to the repo recently.
They are not needed to build from source. Moreover, they are deleted when make clean is called, and thus show up as spurious changes. Let's remove them.","Various backup file copies were accidentally added to the repo recently.
They are not needed to build from source. Moreover, they are deleted when make clean is called, and thus show up as spurious changes. Let's remove them.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1149,2019-01-15T12:07:03Z,2019-01-26T22:04:39Z,2019-01-26T22:04:39Z,CLOSED,False,25,22,1,https://github.com/ikoveshnikov,fix #1147 : init frag variable before use.,2599,[],https://github.com/tempesta-tech/tempesta/pull/1149,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1149,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1149,2019-01-15T12:07:03Z,2019-01-26T22:04:39Z,2019-01-26T22:04:39Z,CLOSED,False,25,22,1,https://github.com/ikoveshnikov,fix #1147 : init frag variable before use.,2599,[],https://github.com/tempesta-tech/tempesta/pull/1149,https://github.com/i-rinat,2,https://github.com/tempesta-tech/tempesta/pull/1149#issuecomment-455653513,,"except that frag is checked from NULL at the begin of TFW_STR_FOR_EACH_CHUNK() loop, so it's still needed to initialize frag before first entry to the loop.

That check looks like a remainder from the older code. The current version tests whenever frag is NULL, but then before it's used, frag is changed again anyway.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1150,2019-01-15T15:35:43Z,2019-01-24T08:26:38Z,2019-01-24T08:26:57Z,MERGED,True,464,462,22,https://github.com/avbelov23,Replace void ptr by union,1,[],https://github.com/tempesta-tech/tempesta/pull/1150,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1150,"Part 1 by #865
Replace casts of ptr field to char * and TfwStr [] by union","Part 1 by #865
Replace casts of ptr field to char * and TfwStr [] by union",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1150,2019-01-15T15:35:43Z,2019-01-24T08:26:38Z,2019-01-24T08:26:57Z,MERGED,True,464,462,22,https://github.com/avbelov23,Replace void ptr by union,1,[],https://github.com/tempesta-tech/tempesta/pull/1150,https://github.com/avbelov23,2,https://github.com/tempesta-tech/tempesta/pull/1150#issuecomment-454845791,"Part 1 by #865
Replace casts of ptr field to char * and TfwStr [] by union",DONE,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1150,2019-01-15T15:35:43Z,2019-01-24T08:26:38Z,2019-01-24T08:26:57Z,MERGED,True,464,462,22,https://github.com/avbelov23,Replace void ptr by union,1,[],https://github.com/tempesta-tech/tempesta/pull/1150,https://github.com/avbelov23,3,https://github.com/tempesta-tech/tempesta/pull/1150#issuecomment-455652118,"Part 1 by #865
Replace casts of ptr field to char * and TfwStr [] by union",DONE,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1151,2019-01-16T18:30:27Z,2019-01-26T22:04:38Z,2019-01-26T22:04:38Z,CLOSED,False,123,134,13,https://github.com/avbelov23,Separate number of chunks from flags,2605,[],https://github.com/tempesta-tech/tempesta/pull/1151,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1151,"Part 2 by #865
Replace current TfwStr->flags by bit field with 3 bytes for number of chunks and 1 byte for actual flags","Part 2 by #865
Replace current TfwStr->flags by bit field with 3 bytes for number of chunks and 1 byte for actual flags",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1151,2019-01-16T18:30:27Z,2019-01-26T22:04:38Z,2019-01-26T22:04:38Z,CLOSED,False,123,134,13,https://github.com/avbelov23,Separate number of chunks from flags,2605,[],https://github.com/tempesta-tech/tempesta/pull/1151,https://github.com/avbelov23,2,https://github.com/tempesta-tech/tempesta/pull/1151#issuecomment-457533005,"Part 2 by #865
Replace current TfwStr->flags by bit field with 3 bytes for number of chunks and 1 byte for actual flags",DONE,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1153,2019-01-18T14:03:14Z,2019-01-26T22:04:21Z,2019-01-26T22:04:21Z,CLOSED,False,322,0,1,https://github.com/avbelov23,Add tests for strings ,2597,[],https://github.com/tempesta-tech/tempesta/pull/1153,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1153,"Add tests for:

tfw_str_add_compound(),
tfw_str_add_duplicate(),
tfw_str_to_cstr(),
tfw_str_del_chunk() and
tfw_str_next_str_val()","Add tests for:

tfw_str_add_compound(),
tfw_str_add_duplicate(),
tfw_str_to_cstr(),
tfw_str_del_chunk() and
tfw_str_next_str_val()",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1153,2019-01-18T14:03:14Z,2019-01-26T22:04:21Z,2019-01-26T22:04:21Z,CLOSED,False,322,0,1,https://github.com/avbelov23,Add tests for strings ,2597,[],https://github.com/tempesta-tech/tempesta/pull/1153,https://github.com/avbelov23,2,https://github.com/tempesta-tech/tempesta/pull/1153#issuecomment-457534029,"Add tests for:

tfw_str_add_compound(),
tfw_str_add_duplicate(),
tfw_str_to_cstr(),
tfw_str_del_chunk() and
tfw_str_next_str_val()",DONE,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1154,2019-01-18T17:09:23Z,2019-01-18T19:05:25Z,2019-01-18T19:05:56Z,MERGED,True,3,3,3,https://github.com/i-rinat,follow-up changes (see #1139),1,[],https://github.com/tempesta-tech/tempesta/pull/1154,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1154,"req->vhost is expected to be non-NULL, as it was checked before;
disallow multiple instances of http_post_validate at topmost level;
a typo.","req->vhost is expected to be non-NULL, as it was checked before;
disallow multiple instances of http_post_validate at topmost level;
a typo.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1155,2019-01-20T22:07:57Z,2019-01-26T22:04:19Z,2019-01-27T20:46:15Z,CLOSED,False,123,78,3,https://github.com/krizhanovsky,Fix #984,2588,[],https://github.com/tempesta-tech/tempesta/pull/1155,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1155,"Actually there are several fixes around skb->truesize and splitting, please see the commits comments for the details. Now the tests from #984 pass.","Actually there are several fixes around skb->truesize and splitting, please see the commits comments for the details. Now the tests from #984 pass.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1156,2019-01-24T20:01:50Z,2019-01-26T22:04:18Z,2019-01-26T22:04:18Z,CLOSED,False,130,96,7,https://github.com/krizhanovsky,Fix #1146 + some coding style cleanups,2605,[],https://github.com/tempesta-tech/tempesta/pull/1156,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1156,"Fix #1146: ttls_update_checksum() can be called for chunk of ClientHello,
while we still don't know the cipher suite. So calculate two checksums
in parallel and copy SHA256 contex if necessary when ClientHello
sets xfrm.ciphersuite_info.
The rest of the patch, besides ttls_update_checksum() changes, is
coding style adjustments.","Fix #1146: ttls_update_checksum() can be called for chunk of ClientHello,
while we still don't know the cipher suite. So calculate two checksums
in parallel and copy SHA256 contex if necessary when ClientHello
sets xfrm.ciphersuite_info.
The rest of the patch, besides ttls_update_checksum() changes, is
coding style adjustments.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1156,2019-01-24T20:01:50Z,2019-01-26T22:04:18Z,2019-01-26T22:04:18Z,CLOSED,False,130,96,7,https://github.com/krizhanovsky,Fix #1146 + some coding style cleanups,2605,[],https://github.com/tempesta-tech/tempesta/pull/1156,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/1156#issuecomment-457580647,"Fix #1146: ttls_update_checksum() can be called for chunk of ClientHello,
while we still don't know the cipher suite. So calculate two checksums
in parallel and copy SHA256 contex if necessary when ClientHello
sets xfrm.ciphersuite_info.
The rest of the patch, besides ttls_update_checksum() changes, is
coding style adjustments.","Didn't finish the review yet. But it seems that the issue is still here. I've tried to run tests on the CI, and crash on tls.test_tls_stress.StressTls.test_tls still happens. See http://93.115.28.191:4010/#/builders/5/builds/416 . The test was configured to 10 concurrent connections and 10 seconds duration.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1156,2019-01-24T20:01:50Z,2019-01-26T22:04:18Z,2019-01-26T22:04:18Z,CLOSED,False,130,96,7,https://github.com/krizhanovsky,Fix #1146 + some coding style cleanups,2605,[],https://github.com/tempesta-tech/tempesta/pull/1156,https://github.com/ikoveshnikov,3,https://github.com/tempesta-tech/tempesta/pull/1156#issuecomment-457586607,"Fix #1146: ttls_update_checksum() can be called for chunk of ClientHello,
while we still don't know the cipher suite. So calculate two checksums
in parallel and copy SHA256 contex if necessary when ClientHello
sets xfrm.ciphersuite_info.
The rest of the patch, besides ttls_update_checksum() changes, is
coding style adjustments.","May be related: #1157 . There also a lot of warnings in kernel log during the test. Please see shell_15 output on CI. It's not really readable, but there are some schedule while atomic warnings and a lot of more messages (partly garbaged).",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1158,2019-01-26T18:34:57Z,2019-01-26T22:04:37Z,2019-01-26T22:04:37Z,CLOSED,False,415,340,3,https://github.com/krizhanovsky,Fix #1157,2605,[],https://github.com/tempesta-tech/tempesta/pull/1158,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1158,"The probles in in nested __kernel_fpu_begin_bh() calls: firstly in DEFINE_TLS_TEST()->kernel_fpu_begin() and secondly in
ttls_ecp_group_free()->ttls_bzero_safe()->kernel_fpu_begin().
The fix moves all the TLS unit tests to test_tls.c from tls/ and
make each test responsible for calling kernel_fpu_{begin,end}().
The crypto routines can be split into 2 groups: called from process
context of Tempesta FW initialization and called in run-time, softirq
context. Only the second group must be called with saved FPU context.
In fact, current crypto routines (covered by the test) don't use SIMD
much and this is going to change in #1064.","The probles in in nested __kernel_fpu_begin_bh() calls: firstly in DEFINE_TLS_TEST()->kernel_fpu_begin() and secondly in
ttls_ecp_group_free()->ttls_bzero_safe()->kernel_fpu_begin().
The fix moves all the TLS unit tests to test_tls.c from tls/ and
make each test responsible for calling kernel_fpu_{begin,end}().
The crypto routines can be split into 2 groups: called from process
context of Tempesta FW initialization and called in run-time, softirq
context. Only the second group must be called with saved FPU context.
In fact, current crypto routines (covered by the test) don't use SIMD
much and this is going to change in #1064.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1159,2019-01-27T14:19:22Z,2019-01-28T18:41:50Z,2019-01-28T19:58:35Z,MERGED,True,415,340,3,https://github.com/krizhanovsky,Fix #1157,1,[],https://github.com/tempesta-tech/tempesta/pull/1159,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1159,"The probles in in nested __kernel_fpu_begin_bh() calls firstly in DEFINE_TLS_TEST()->kernel_fpu_begin() and secondly in
ttls_ecp_group_free()->ttls_bzero_safe()->kernel_fpu_begin().
The fix moves all the TLS unit tests to test_tls.c from tls/ and
make each test responsible for calling kernel_fpu_{begin,end}().
The crypto routines can be split into 2 groups: called from process
context of Tempesta FW initialization and called in run-time, softirq
context. Only the second group must be called with saved FPU context.
In fact, current crypto routines (covered by the test) don't use SIMD
much and this is going to change in #1064.
Original PR #1158.","The probles in in nested __kernel_fpu_begin_bh() calls firstly in DEFINE_TLS_TEST()->kernel_fpu_begin() and secondly in
ttls_ecp_group_free()->ttls_bzero_safe()->kernel_fpu_begin().
The fix moves all the TLS unit tests to test_tls.c from tls/ and
make each test responsible for calling kernel_fpu_{begin,end}().
The crypto routines can be split into 2 groups: called from process
context of Tempesta FW initialization and called in run-time, softirq
context. Only the second group must be called with saved FPU context.
In fact, current crypto routines (covered by the test) don't use SIMD
much and this is going to change in #1064.
Original PR #1158.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1160,2019-01-27T17:42:20Z,2019-01-29T20:51:45Z,2019-02-13T11:36:02Z,MERGED,True,129,96,7,https://github.com/krizhanovsky,Fix #1146 + some coding style cleanups (orig PR #1156),2,[],https://github.com/tempesta-tech/tempesta/pull/1160,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1160,"Fix #1146: ttls_update_checksum() can be called for chunk of ClientHello,
while we still don't know the cipher suite. So calculate two checksums
in parallel and copy SHA256 contex if necessary when ClientHello
sets xfrm.ciphersuite_info.
The rest of the patch, besides ttls_update_checksum() changes, is
coding style adjustments.
Comments still to fix:
#1156 (comment)
#1156 (comment)","Fix #1146: ttls_update_checksum() can be called for chunk of ClientHello,
while we still don't know the cipher suite. So calculate two checksums
in parallel and copy SHA256 contex if necessary when ClientHello
sets xfrm.ciphersuite_info.
The rest of the patch, besides ttls_update_checksum() changes, is
coding style adjustments.
Comments still to fix:
#1156 (comment)
#1156 (comment)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1161,2019-01-27T23:22:48Z,2019-01-28T18:39:10Z,2019-01-28T18:46:25Z,MERGED,True,173,99,5,https://github.com/krizhanovsky,Fix #984,15,[],https://github.com/tempesta-tech/tempesta/pull/1161,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1161,Original PR is #1155 plus fixed code review comments and added fix of TSO segments. All the comments were addressed except #1155 (comment) - see motivation under the comment.,Original PR is #1155 plus fixed code review comments and added fix of TSO segments. All the comments were addressed except #1155 (comment) - see motivation under the comment.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1162,2019-01-28T06:28:27Z,2019-02-12T06:42:03Z,2019-02-12T06:42:06Z,MERGED,True,28,26,3,https://github.com/ikoveshnikov,fix #1147 : init frag variable before use.,6,[],https://github.com/tempesta-tech/tempesta/pull/1162,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1162,Original PR is #1149,Original PR is #1149,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1163,2019-01-28T10:38:38Z,2019-02-01T08:13:20Z,2019-02-01T08:13:30Z,MERGED,True,26,13,1,https://github.com/aleksostapenko,Fix the skb fragments extending.,4,[],https://github.com/tempesta-tech/tempesta/pull/1163,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/1163,"Patch fixes two problems:

In __extend_pgfrags() - in case of n == 2 && si->nr_frags == MAX_SKB_FRAGS && from == MAX_SKB_FRAGS - 1: a) resolve issue with incorrect fragments shift; b) avoid possible BUG_ON if n_shift < 0;
In __split_pgfrag_add() - in case of i == MAX_SKB_FRAGS - 1: resolve issue with incorrect determination of destination frag and, as a result, wrong it->data and it->skb output.","Patch fixes two problems:

In __extend_pgfrags() - in case of n == 2 && si->nr_frags == MAX_SKB_FRAGS && from == MAX_SKB_FRAGS - 1: a) resolve issue with incorrect fragments shift; b) avoid possible BUG_ON if n_shift < 0;
In __split_pgfrag_add() - in case of i == MAX_SKB_FRAGS - 1: resolve issue with incorrect determination of destination frag and, as a result, wrong it->data and it->skb output.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1164,2019-01-28T10:49:44Z,2019-02-19T09:04:15Z,2019-02-19T09:04:19Z,MERGED,True,346,112,7,https://github.com/aleksostapenko,Fix #1003: Store requests for resending if connection became inactive.,11,[],https://github.com/tempesta-tech/tempesta/pull/1164,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/1164,The original PR is #1129. All code review comments from original PR were addressed.,The original PR is #1129. All code review comments from original PR were addressed.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1165,2019-01-28T13:32:11Z,2019-01-30T05:27:51Z,2019-01-30T05:27:55Z,MERGED,True,2,2,1,https://github.com/ikoveshnikov,makefile: use shell to get current variable,1,[],https://github.com/tempesta-tech/tempesta/pull/1165,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1165,"Calling make test is not possible for unprivileged user since
there is no enough rights to load the kernel modules. If the user
uses sudo to obtain required privileges, then some variables
including PWD are reset and not available.","Calling make test is not possible for unprivileged user since
there is no enough rights to load the kernel modules. If the user
uses sudo to obtain required privileges, then some variables
including PWD are reset and not available.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1166,2019-01-28T17:36:55Z,2019-02-04T14:19:02Z,2019-02-04T14:25:48Z,MERGED,True,233,250,17,https://github.com/avbelov23,Separate number of chunks from flags,5,[],https://github.com/tempesta-tech/tempesta/pull/1166,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1166,"Part 2 by #865
#1151","Part 2 by #865
#1151",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1166,2019-01-28T17:36:55Z,2019-02-04T14:19:02Z,2019-02-04T14:25:48Z,MERGED,True,233,250,17,https://github.com/avbelov23,Separate number of chunks from flags,5,[],https://github.com/tempesta-tech/tempesta/pull/1166,https://github.com/avbelov23,2,https://github.com/tempesta-tech/tempesta/pull/1166#issuecomment-458534022,"Part 2 by #865
#1151",DONE,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1167,2019-01-28T17:37:55Z,2019-01-29T19:06:29Z,2019-01-29T19:06:35Z,MERGED,True,322,0,1,https://github.com/avbelov23,Add tests for strings,1,[],https://github.com/tempesta-tech/tempesta/pull/1167,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1167,#1153,#1153,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1168,2019-01-28T19:42:37Z,2019-01-28T19:43:06Z,2019-01-28T19:45:41Z,MERGED,True,31,42,1,https://github.com/krizhanovsky,Use standard testing framework checks,1,[],https://github.com/tempesta-tech/tempesta/pull/1168,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1168,"Fix review comments from #1159 , no need for review.","Fix review comments from #1159 , no need for review.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1169,2019-01-29T14:51:07Z,2019-01-30T14:18:08Z,2019-02-01T13:01:54Z,MERGED,True,24,18,1,https://github.com/ikoveshnikov,Update server APM stats right after response was received,2,[],https://github.com/tempesta-tech/tempesta/pull/1169,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1169,"APM update should happen earlier than cache actions: copying response to cache, cache logic is to become more complex and it adds some Tempesta's latancy delays to the APM stats. In the same time APM stats are used for scheduling and must provide information only about backend, not about Tempesta-backend chain.
Another reason for early updates - HM monitor responses are dropped before response can reach tfw_http_resp_cache_cb()","APM update should happen earlier than cache actions: copying response to cache, cache logic is to become more complex and it adds some Tempesta's latancy delays to the APM stats. In the same time APM stats are used for scheduling and must provide information only about backend, not about Tempesta-backend chain.
Another reason for early updates - HM monitor responses are dropped before response can reach tfw_http_resp_cache_cb()",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1172,2019-01-30T15:42:20Z,2019-01-30T16:04:26Z,2019-01-30T16:04:31Z,MERGED,True,5,2,1,https://github.com/ikoveshnikov,Followup #1169: modify comment as suggested in review,1,[],https://github.com/tempesta-tech/tempesta/pull/1172,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1172,Mistakenly merged 1169 before the comment was added.,Mistakenly merged 1169 before the comment was added.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1173,2019-01-31T19:32:41Z,2019-02-12T21:13:23Z,2019-02-13T11:35:10Z,MERGED,True,1242,1182,27,https://github.com/krizhanovsky,Fix #1170,5,[],https://github.com/tempesta-tech/tempesta/pull/1173,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1173,"Most changes are in kernel tempesta-tech/linux-4.14.32-tfw#6 :
Kernel:

Split crypto_alloc_tfm() into crypto_find_*() sleepable part and atomic,
suitable for calling from softirq, crypto_alloc_*_atomic().
Previously crypto_find_alg() called moules loading and used semaphore
synchronization, so we had softlockups in TLS handshakes.

Tempesta TLS:

1. Call crypto_find_*() for all configured algorithms on start phase,
   so in run-time we have the ready algs and can quickly allocate
   crypt contexts;

2. Determine maximum size of crypt request also on start phase and
   use it for per-cpu requests allocation instead of wrong 8-byte
   constant.

3. Remove some dead code (crypto.h definitions mostly).

Also merge md.[ch] with cipher.[ch]","Most changes are in kernel tempesta-tech/linux-4.14.32-tfw#6 :
Kernel:

Split crypto_alloc_tfm() into crypto_find_*() sleepable part and atomic,
suitable for calling from softirq, crypto_alloc_*_atomic().
Previously crypto_find_alg() called moules loading and used semaphore
synchronization, so we had softlockups in TLS handshakes.

Tempesta TLS:

1. Call crypto_find_*() for all configured algorithms on start phase,
   so in run-time we have the ready algs and can quickly allocate
   crypt contexts;

2. Determine maximum size of crypt request also on start phase and
   use it for per-cpu requests allocation instead of wrong 8-byte
   constant.

3. Remove some dead code (crypto.h definitions mostly).

Also merge md.[ch] with cipher.[ch]",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1174,2019-02-01T08:32:43Z,2019-02-01T14:57:50Z,2019-02-01T14:57:53Z,MERGED,True,1,1,1,https://github.com/ikoveshnikov,Fix TDB build issue,1,[],https://github.com/tempesta-tech/tempesta/pull/1174,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1174,"At some random moment without any preconditions, my IDE has started to fail building the TDB. tdbq is trying to be built before libtdb. This happens even with the single make  job. I couldn't reproduce the issue manually.
According to the documentation PHONY property is not inherited and must be set for both targets individually. This fixes the issue for me.","At some random moment without any preconditions, my IDE has started to fail building the TDB. tdbq is trying to be built before libtdb. This happens even with the single make  job. I couldn't reproduce the issue manually.
According to the documentation PHONY property is not inherited and must be set for both targets individually. This fixes the issue for me.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1176,2019-02-02T19:50:11Z,2019-12-30T23:02:06Z,2019-12-30T23:04:07Z,CLOSED,False,12291,1,33,https://github.com/krizhanovsky,HTTP/2 (reopened #694),13,[],https://github.com/tempesta-tech/tempesta/pull/1176,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1176,Just need to review the code and understand which changes/extensions/fixes are required for #309. After that the branch can be closed and the code can be recommited to a new branch. The PR is just for documentation what is still for TODO.,Just need to review the code and understand which changes/extensions/fixes are required for #309. After that the branch can be closed and the code can be recommited to a new branch. The PR is just for documentation what is still for TODO.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1176,2019-02-02T19:50:11Z,2019-12-30T23:02:06Z,2019-12-30T23:04:07Z,CLOSED,False,12291,1,33,https://github.com/krizhanovsky,HTTP/2 (reopened #694),13,[],https://github.com/tempesta-tech/tempesta/pull/1176,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/1176#issuecomment-569681806,Just need to review the code and understand which changes/extensions/fixes are required for #309. After that the branch can be closed and the code can be recommited to a new branch. The PR is just for documentation what is still for TODO.,"Most of the changes from this PR was reworked and integrated into #1368, so the PR can be closed now.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1178,2019-02-07T19:01:24Z,2019-02-28T17:54:23Z,2019-02-28T17:54:51Z,MERGED,True,614,189,19,https://github.com/avbelov23,Temporal client accounting,6,[],https://github.com/tempesta-tech/tempesta/pull/1178,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1178,"Requires #1115
#1145","Requires #1115
#1145",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1179,2019-02-08T13:29:18Z,2019-02-14T13:46:03Z,2019-02-14T13:46:20Z,MERGED,True,169,119,5,https://github.com/aleksostapenko,Fix #1175: Add synchronization of disconnect procedure for server con…,6,[],https://github.com/tempesta-tech/tempesta/pull/1179,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/1179,…nections.,…nections.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1180,2019-02-08T14:33:47Z,2019-02-08T15:05:45Z,2019-02-08T15:18:53Z,MERGED,True,0,15,1,https://github.com/i-rinat,remove unused type TfwTlsCtx,1,[],https://github.com/tempesta-tech/tempesta/pull/1180,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1180,"The type is defined, but not used anymore. Let's remove it.","The type is defined, but not used anymore. Let's remove it.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1182,2019-02-11T16:25:44Z,2019-02-11T19:45:37Z,2019-02-13T11:35:00Z,MERGED,True,9,1,1,https://github.com/krizhanovsky,Free all queued skbs in IO TLS contexts on connection drop handler.,1,[],https://github.com/tempesta-tech/tempesta/pull/1182,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1182,"Thanks to @i-rinat for pointing me out the problem with dirty freed skb leaving the skb_list in bad sate. Actually, I completely forget to free the lists on connection drop and it's better to do it there, for both the contexts, rather than free skbs ad hoc.","Thanks to @i-rinat for pointing me out the problem with dirty freed skb leaving the skb_list in bad sate. Actually, I completely forget to free the lists on connection drop and it's better to do it there, for both the contexts, rather than free skbs ad hoc.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1183,2019-02-12T01:03:43Z,,2020-09-02T14:13:25Z,OPEN,False,2038,515,24,https://github.com/ikoveshnikov,A new iteration of #498: message streaming mode. NOT done and work in process,13,[],https://github.com/tempesta-tech/tempesta/pull/1183,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1183,"The task is not completed yet and the work is still in progress. It's here to make a very high level review to estimate the pros and cons of the used approach.
The code compiles and it even works in some scenarios, but it doesn't look good for now. Last week I've tried to fix issues I had in streaming, especially in scenarios when one (or both) of the streaming peers suddenly disconnects during streaming, but I completely ruined the streaming process and the code became over sophisticated, unreliable and tending to crash. So I tried to revert to very beginning and move forward commit-by-commit trying to simplify the code and make it more straight forward, but I didn't manage to finish it yet and some pieces of code are too messy and unreliable.
Here the issues that appeared during implementation.
TCP window steering
TCP receive window steering. There are only two situations, when the window steering is required. In first, client feeds us tons of pipelined requests. Not very big problem and can be resolved via Frang limits. Frang will block too fast clients, normally clients are slower than the servers. Probably closing client connections with 429 status code is acceptable. The second case is message streaming. We don't want to allow client to eat all the memory by a sing request (e.g. POST request with Blue-Ray image encapsulated).
Note, that the window steering can't slow down clients that doesn't use request pipelining. It sends request - window gets lower, it receives the response - window is maximum agains.
The task is to set N as buffer size for both unparsed skbs in receive queue and parsed requests in TfwCliConn->seq_queue. If requests strored in seq_queue are already filled the buffer, then advertize a zero window to the client. If a response is forwarded to the client, then the corresponding request must be destroyed and the advertised window should grow on.
To control window size, we need to force the kernel to take into account the space occupied by the requests in the seq_queue. If we look at tcp bufers we will see two buffers: ""network"" buffer advertised as receive window and ""application"" buffer used to isolate application from network. Currently skbs are orphaned from the tcp socket right after receive, so the TCP stack sees that there is no allocated memory from the socket and advertises the maximum window size. My idea was to register size of parsed HTTP message in the sk->sk_rmem_alloc to make the Kernel aware of the used memory and avoid manual window size calculations. The trick worked. While client was filling the ""application"" buffer, he was advertised a maximum window size, but while ""network"" buffer was used the window got smaller, up to zero size. Another great result was possibility to set different buffer limits for client and server connections.
The code worked in all scenarios. Except one. Closing connections in very concurrent environment. Dropped requests might be deregistered twice from the sk->sk_rmem_alloc, so it wasn't empty on socket destruction, so kernel might to generate a pretty long traces on wrk stops. The issue has a sporadic character.
Streaming tricky situations
Streamed messages can be buffered.
This happen, when the receiver is not ready to receive a stream. E.g. client requested two pipelined uris: first is very slow to complete, second is fast, but it can be a full BD image. It's not possible to stream the BD image until the first request is responsed. We can't put server connection on hold. Client may intentionally slow down receiving, so the server connection would get stack.  That is why window steering can't be applied to server connections.
Some parts of a streamed messages must be buffered for some time
Some high level http processing can't work with partial data. E.g. trailer headers can't be processed by parts, we have to buffer them fully before process. Although RFC allow to ignore trailer headers in stream mode, we still want to validate the headers and modify them if req_hdr_set directive is set.
Response can appear at any time.
Http is request-response protocol. Response is sent only after request was received. Well, forget about that during the streaming. Imagine, that a part of the request was streamed to backend and a new part is being parsed. There can be already a response received from the backend. Scenario 1: try to stream GET request with a long body to Nginx and make a pause, Nginx will respond immediately without waiting for the message end. Scenario 2: stream a part of request and make a syntax error, backend will respond with 4xx code immediately (Tempesta has the same behaviour).
Target connections to stream a message can dissappear at any time.
Imagine a request is streamed, a part of it was already received by the backend. It already sent a response. Now error happens and backend connection is closed. We still need to receive the rest of the stream, but there is no need to send it anywhere since response is received. Just drop it part by part.
Client disconnected when streamed message wasn't received in full
If the partly received request wasn't sent to backend, simply evict it. It it was, then there is no recovery possibilities, only to close server connection.
(The list is not finished ind to be continued shortly.)","The task is not completed yet and the work is still in progress. It's here to make a very high level review to estimate the pros and cons of the used approach.
The code compiles and it even works in some scenarios, but it doesn't look good for now. Last week I've tried to fix issues I had in streaming, especially in scenarios when one (or both) of the streaming peers suddenly disconnects during streaming, but I completely ruined the streaming process and the code became over sophisticated, unreliable and tending to crash. So I tried to revert to very beginning and move forward commit-by-commit trying to simplify the code and make it more straight forward, but I didn't manage to finish it yet and some pieces of code are too messy and unreliable.
Here the issues that appeared during implementation.
TCP window steering
TCP receive window steering. There are only two situations, when the window steering is required. In first, client feeds us tons of pipelined requests. Not very big problem and can be resolved via Frang limits. Frang will block too fast clients, normally clients are slower than the servers. Probably closing client connections with 429 status code is acceptable. The second case is message streaming. We don't want to allow client to eat all the memory by a sing request (e.g. POST request with Blue-Ray image encapsulated).
Note, that the window steering can't slow down clients that doesn't use request pipelining. It sends request - window gets lower, it receives the response - window is maximum agains.
The task is to set N as buffer size for both unparsed skbs in receive queue and parsed requests in TfwCliConn->seq_queue. If requests strored in seq_queue are already filled the buffer, then advertize a zero window to the client. If a response is forwarded to the client, then the corresponding request must be destroyed and the advertised window should grow on.
To control window size, we need to force the kernel to take into account the space occupied by the requests in the seq_queue. If we look at tcp bufers we will see two buffers: ""network"" buffer advertised as receive window and ""application"" buffer used to isolate application from network. Currently skbs are orphaned from the tcp socket right after receive, so the TCP stack sees that there is no allocated memory from the socket and advertises the maximum window size. My idea was to register size of parsed HTTP message in the sk->sk_rmem_alloc to make the Kernel aware of the used memory and avoid manual window size calculations. The trick worked. While client was filling the ""application"" buffer, he was advertised a maximum window size, but while ""network"" buffer was used the window got smaller, up to zero size. Another great result was possibility to set different buffer limits for client and server connections.
The code worked in all scenarios. Except one. Closing connections in very concurrent environment. Dropped requests might be deregistered twice from the sk->sk_rmem_alloc, so it wasn't empty on socket destruction, so kernel might to generate a pretty long traces on wrk stops. The issue has a sporadic character.
Streaming tricky situations
Streamed messages can be buffered.
This happen, when the receiver is not ready to receive a stream. E.g. client requested two pipelined uris: first is very slow to complete, second is fast, but it can be a full BD image. It's not possible to stream the BD image until the first request is responsed. We can't put server connection on hold. Client may intentionally slow down receiving, so the server connection would get stack.  That is why window steering can't be applied to server connections.
Some parts of a streamed messages must be buffered for some time
Some high level http processing can't work with partial data. E.g. trailer headers can't be processed by parts, we have to buffer them fully before process. Although RFC allow to ignore trailer headers in stream mode, we still want to validate the headers and modify them if req_hdr_set directive is set.
Response can appear at any time.
Http is request-response protocol. Response is sent only after request was received. Well, forget about that during the streaming. Imagine, that a part of the request was streamed to backend and a new part is being parsed. There can be already a response received from the backend. Scenario 1: try to stream GET request with a long body to Nginx and make a pause, Nginx will respond immediately without waiting for the message end. Scenario 2: stream a part of request and make a syntax error, backend will respond with 4xx code immediately (Tempesta has the same behaviour).
Target connections to stream a message can dissappear at any time.
Imagine a request is streamed, a part of it was already received by the backend. It already sent a response. Now error happens and backend connection is closed. We still need to receive the rest of the stream, but there is no need to send it anywhere since response is received. Just drop it part by part.
Client disconnected when streamed message wasn't received in full
If the partly received request wasn't sent to backend, simply evict it. It it was, then there is no recovery possibilities, only to close server connection.
(The list is not finished ind to be continued shortly.)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1183,2019-02-12T01:03:43Z,,2020-09-02T14:13:25Z,OPEN,False,2038,515,24,https://github.com/ikoveshnikov,A new iteration of #498: message streaming mode. NOT done and work in process,13,[],https://github.com/tempesta-tech/tempesta/pull/1183,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/1183#issuecomment-463163138,"The task is not completed yet and the work is still in progress. It's here to make a very high level review to estimate the pros and cons of the used approach.
The code compiles and it even works in some scenarios, but it doesn't look good for now. Last week I've tried to fix issues I had in streaming, especially in scenarios when one (or both) of the streaming peers suddenly disconnects during streaming, but I completely ruined the streaming process and the code became over sophisticated, unreliable and tending to crash. So I tried to revert to very beginning and move forward commit-by-commit trying to simplify the code and make it more straight forward, but I didn't manage to finish it yet and some pieces of code are too messy and unreliable.
Here the issues that appeared during implementation.
TCP window steering
TCP receive window steering. There are only two situations, when the window steering is required. In first, client feeds us tons of pipelined requests. Not very big problem and can be resolved via Frang limits. Frang will block too fast clients, normally clients are slower than the servers. Probably closing client connections with 429 status code is acceptable. The second case is message streaming. We don't want to allow client to eat all the memory by a sing request (e.g. POST request with Blue-Ray image encapsulated).
Note, that the window steering can't slow down clients that doesn't use request pipelining. It sends request - window gets lower, it receives the response - window is maximum agains.
The task is to set N as buffer size for both unparsed skbs in receive queue and parsed requests in TfwCliConn->seq_queue. If requests strored in seq_queue are already filled the buffer, then advertize a zero window to the client. If a response is forwarded to the client, then the corresponding request must be destroyed and the advertised window should grow on.
To control window size, we need to force the kernel to take into account the space occupied by the requests in the seq_queue. If we look at tcp bufers we will see two buffers: ""network"" buffer advertised as receive window and ""application"" buffer used to isolate application from network. Currently skbs are orphaned from the tcp socket right after receive, so the TCP stack sees that there is no allocated memory from the socket and advertises the maximum window size. My idea was to register size of parsed HTTP message in the sk->sk_rmem_alloc to make the Kernel aware of the used memory and avoid manual window size calculations. The trick worked. While client was filling the ""application"" buffer, he was advertised a maximum window size, but while ""network"" buffer was used the window got smaller, up to zero size. Another great result was possibility to set different buffer limits for client and server connections.
The code worked in all scenarios. Except one. Closing connections in very concurrent environment. Dropped requests might be deregistered twice from the sk->sk_rmem_alloc, so it wasn't empty on socket destruction, so kernel might to generate a pretty long traces on wrk stops. The issue has a sporadic character.
Streaming tricky situations
Streamed messages can be buffered.
This happen, when the receiver is not ready to receive a stream. E.g. client requested two pipelined uris: first is very slow to complete, second is fast, but it can be a full BD image. It's not possible to stream the BD image until the first request is responsed. We can't put server connection on hold. Client may intentionally slow down receiving, so the server connection would get stack.  That is why window steering can't be applied to server connections.
Some parts of a streamed messages must be buffered for some time
Some high level http processing can't work with partial data. E.g. trailer headers can't be processed by parts, we have to buffer them fully before process. Although RFC allow to ignore trailer headers in stream mode, we still want to validate the headers and modify them if req_hdr_set directive is set.
Response can appear at any time.
Http is request-response protocol. Response is sent only after request was received. Well, forget about that during the streaming. Imagine, that a part of the request was streamed to backend and a new part is being parsed. There can be already a response received from the backend. Scenario 1: try to stream GET request with a long body to Nginx and make a pause, Nginx will respond immediately without waiting for the message end. Scenario 2: stream a part of request and make a syntax error, backend will respond with 4xx code immediately (Tempesta has the same behaviour).
Target connections to stream a message can dissappear at any time.
Imagine a request is streamed, a part of it was already received by the backend. It already sent a response. Now error happens and backend connection is closed. We still need to receive the rest of the stream, but there is no need to send it anywhere since response is received. Just drop it part by part.
Client disconnected when streamed message wasn't received in full
If the partly received request wasn't sent to backend, simply evict it. It it was, then there is no recovery possibilities, only to close server connection.
(The list is not finished ind to be continued shortly.)",Previous versions of the pull request with comments - #1012 and #1067,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1186,2019-02-13T19:49:34Z,2019-02-13T21:57:57Z,2019-02-13T21:58:01Z,MERGED,True,1,1,1,https://github.com/ikoveshnikov,tests: fix ttls_rsa_context initialisation,1,[],https://github.com/tempesta-tech/tempesta/pull/1186,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1186,"The ttls_rsa_context structure is not initialised and filled with garbage.
The crash may happen since the code relies on uninitialised struct
members.
The issue happens only in unit tests since in normal code it's  prepended by kzalloc zeroing the memory.
Very funny that I looked to this issue in clang analysis report this evening and just got it on my VM.","The ttls_rsa_context structure is not initialised and filled with garbage.
The crash may happen since the code relies on uninitialised struct
members.
The issue happens only in unit tests since in normal code it's  prepended by kzalloc zeroing the memory.
Very funny that I looked to this issue in clang analysis report this evening and just got it on my VM.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1190,2019-02-19T14:31:02Z,2019-02-19T15:36:03Z,2019-02-19T17:32:49Z,MERGED,True,15,10,1,https://github.com/ikoveshnikov,Fix section mismatch in unittests,2,[],https://github.com/tempesta-tech/tempesta/pull/1190,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1190,Fix buildtime warning described in #1187,Fix buildtime warning described in #1187,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1191,2019-02-19T18:47:34Z,2019-02-26T02:09:13Z,2019-02-26T02:09:18Z,MERGED,True,257,33,9,https://github.com/ikoveshnikov,Encode message to chunked encoding,8,[],https://github.com/tempesta-tech/tempesta/pull/1191,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1191,"Fix #639 If response has no framing information, server closes the connection to indicate message end. There is three ways how Tempesta can forward this message to the client:

Forward as is and close connection. It's the worst variant, there can be newer requests from that client already forwarded to backends and will be discarded.
Add Content-Length header. Better, but still problematic solution: the message must be fully assembled to supply valid content-length value. This is current approach.
Transform message to chunked encoding. No need to assemlbe message fully, and it's possible to stream the message by parts.  This is the approach in the patch set.","Fix #639 If response has no framing information, server closes the connection to indicate message end. There is three ways how Tempesta can forward this message to the client:

Forward as is and close connection. It's the worst variant, there can be newer requests from that client already forwarded to backends and will be discarded.
Add Content-Length header. Better, but still problematic solution: the message must be fully assembled to supply valid content-length value. This is current approach.
Transform message to chunked encoding. No need to assemlbe message fully, and it's possible to stream the message by parts.  This is the approach in the patch set.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1191,2019-02-19T18:47:34Z,2019-02-26T02:09:13Z,2019-02-26T02:09:18Z,MERGED,True,257,33,9,https://github.com/ikoveshnikov,Encode message to chunked encoding,8,[],https://github.com/tempesta-tech/tempesta/pull/1191,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/1191#issuecomment-465575527,"Fix #639 If response has no framing information, server closes the connection to indicate message end. There is three ways how Tempesta can forward this message to the client:

Forward as is and close connection. It's the worst variant, there can be newer requests from that client already forwarded to backends and will be discarded.
Add Content-Length header. Better, but still problematic solution: the message must be fully assembled to supply valid content-length value. This is current approach.
Transform message to chunked encoding. No need to assemlbe message fully, and it's possible to stream the message by parts.  This is the approach in the patch set.","All tests have passed on CI build 479, a tempesta-tech/tempesta-test#89 tests branch was required.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1191,2019-02-19T18:47:34Z,2019-02-26T02:09:13Z,2019-02-26T02:09:18Z,MERGED,True,257,33,9,https://github.com/ikoveshnikov,Encode message to chunked encoding,8,[],https://github.com/tempesta-tech/tempesta/pull/1191,https://github.com/avbelov23,3,https://github.com/tempesta-tech/tempesta/pull/1191#issuecomment-466458999,"Fix #639 If response has no framing information, server closes the connection to indicate message end. There is three ways how Tempesta can forward this message to the client:

Forward as is and close connection. It's the worst variant, there can be newer requests from that client already forwarded to backends and will be discarded.
Add Content-Length header. Better, but still problematic solution: the message must be fully assembled to supply valid content-length value. This is current approach.
Transform message to chunked encoding. No need to assemlbe message fully, and it's possible to stream the message by parts.  This is the approach in the patch set.","Looks good for me, only one change is proposed.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1191,2019-02-19T18:47:34Z,2019-02-26T02:09:13Z,2019-02-26T02:09:18Z,MERGED,True,257,33,9,https://github.com/ikoveshnikov,Encode message to chunked encoding,8,[],https://github.com/tempesta-tech/tempesta/pull/1191,https://github.com/i-rinat,4,https://github.com/tempesta-tech/tempesta/pull/1191#issuecomment-467059451,"Fix #639 If response has no framing information, server closes the connection to indicate message end. There is three ways how Tempesta can forward this message to the client:

Forward as is and close connection. It's the worst variant, there can be newer requests from that client already forwarded to backends and will be discarded.
Add Content-Length header. Better, but still problematic solution: the message must be fully assembled to supply valid content-length value. This is current approach.
Transform message to chunked encoding. No need to assemlbe message fully, and it's possible to stream the message by parts.  This is the approach in the patch set.",Looks good to me.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1192,2019-02-19T21:09:50Z,2019-02-25T06:54:22Z,2019-02-25T06:54:26Z,MERGED,True,110,20,2,https://github.com/ikoveshnikov,frang: make 'http_body_len' limit common for requests and responses,2,[],https://github.com/tempesta-tech/tempesta/pull/1192,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1192,fix #1184,fix #1184,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1192,2019-02-19T21:09:50Z,2019-02-25T06:54:22Z,2019-02-25T06:54:26Z,MERGED,True,110,20,2,https://github.com/ikoveshnikov,frang: make 'http_body_len' limit common for requests and responses,2,[],https://github.com/tempesta-tech/tempesta/pull/1192,https://github.com/avbelov23,2,https://github.com/tempesta-tech/tempesta/pull/1192#issuecomment-466448180,fix #1184,"Looks good for me, only one cleanup are required.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1193,2019-02-20T11:47:27Z,2019-02-28T05:32:12Z,2019-02-28T05:32:16Z,MERGED,True,10,11,1,https://github.com/ikoveshnikov,Fix race condition in client connection drop,2,[],https://github.com/tempesta-tech/tempesta/pull/1193,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1193,fix #1171,fix #1171,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1195,2019-02-21T22:32:10Z,2019-02-22T11:46:21Z,2019-02-22T11:52:05Z,MERGED,True,38,38,2,https://github.com/i-rinat,fix tail length calculation in tfw_hash_str(),1,[],https://github.com/tempesta-tech/tempesta/pull/1195,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1195,"tfw_hash_str() tries to hash strings in blocks of 16 bytes. To achieve that it tracks the number of remainder bytes, and then computes hashes byte-by-byte until total number of bytes processed becomes a multiple of 16. Since that effectively cuts the size of the current piece, remaining length (e - p) should be used instead of the chunk length (c->len) in tail length calculation for the next round. Existing test wasn't reproducing conditions to trigger the issue, so it was also updated.","tfw_hash_str() tries to hash strings in blocks of 16 bytes. To achieve that it tracks the number of remainder bytes, and then computes hashes byte-by-byte until total number of bytes processed becomes a multiple of 16. Since that effectively cuts the size of the current piece, remaining length (e - p) should be used instead of the chunk length (c->len) in tail length calculation for the next round. Existing test wasn't reproducing conditions to trigger the issue, so it was also updated.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1197,2019-02-25T23:22:50Z,2019-03-13T12:53:11Z,2019-03-13T12:53:14Z,MERGED,True,8,14,3,https://github.com/i-rinat,tls: stop changing io->rlen at buffer end,1,[],https://github.com/tempesta-tech/tempesta/pull/1197,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1197,"io->rlen is used to track how many bytes were processed by a particular FSM state. It should not be touched when we exit the state machine in TTLS_HS_FSM_FINISH().
Having io->rlen increased in TTLS_HS_FSM_FINISH() causes #1187. Here is why.
Let's assume we are entering T_FSM_STATE(TTLS_CH_HS_SESS) and there are some unprocessed data bytes left. Say, it's 10. We copy ten bytes of session ID into the tls->sess.id, then increase io->rlen by 10, making it 10. As 10 bytes are not the full session ID, we call T_FSM_EXIT(), which jumps out of state machine, causing io->rlen to be increased by size of data processed so far, which may be about 50 bytes. io->rlen becomes 60. Next time we enter state machine, statement BUG_ON(io->rlen >= tls->sess.id_len); triggers.
(related: #1187)","io->rlen is used to track how many bytes were processed by a particular FSM state. It should not be touched when we exit the state machine in TTLS_HS_FSM_FINISH().
Having io->rlen increased in TTLS_HS_FSM_FINISH() causes #1187. Here is why.
Let's assume we are entering T_FSM_STATE(TTLS_CH_HS_SESS) and there are some unprocessed data bytes left. Say, it's 10. We copy ten bytes of session ID into the tls->sess.id, then increase io->rlen by 10, making it 10. As 10 bytes are not the full session ID, we call T_FSM_EXIT(), which jumps out of state machine, causing io->rlen to be increased by size of data processed so far, which may be about 50 bytes. io->rlen becomes 60. Next time we enter state machine, statement BUG_ON(io->rlen >= tls->sess.id_len); triggers.
(related: #1187)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1197,2019-02-25T23:22:50Z,2019-03-13T12:53:11Z,2019-03-13T12:53:14Z,MERGED,True,8,14,3,https://github.com/i-rinat,tls: stop changing io->rlen at buffer end,1,[],https://github.com/tempesta-tech/tempesta/pull/1197,https://github.com/i-rinat,2,https://github.com/tempesta-tech/tempesta/pull/1197#issuecomment-472150002,"io->rlen is used to track how many bytes were processed by a particular FSM state. It should not be touched when we exit the state machine in TTLS_HS_FSM_FINISH().
Having io->rlen increased in TTLS_HS_FSM_FINISH() causes #1187. Here is why.
Let's assume we are entering T_FSM_STATE(TTLS_CH_HS_SESS) and there are some unprocessed data bytes left. Say, it's 10. We copy ten bytes of session ID into the tls->sess.id, then increase io->rlen by 10, making it 10. As 10 bytes are not the full session ID, we call T_FSM_EXIT(), which jumps out of state machine, causing io->rlen to be increased by size of data processed so far, which may be about 50 bytes. io->rlen becomes 60. Next time we enter state machine, statement BUG_ON(io->rlen >= tls->sess.id_len); triggers.
(related: #1187)","It's better than the current fix because of smaller FSM code which is easer to work with and the code becomes faster.

I've just removed explicit io->rlen updates. But surprisingly that made code 16 bytes larger. I did not investigate reasons in depth, but can speculate that added state_p = p assignment now appearing in every state transition macro instantiation may have introduced that difference.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1198,2019-02-26T21:36:27Z,2019-02-27T12:12:29Z,2019-02-27T12:13:02Z,MERGED,True,3,0,1,https://github.com/i-rinat,tls: free ciphers when tls context is cleared,1,[],https://github.com/tempesta-tech/tempesta/pull/1198,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1198,Code was allocating but never releasing ciphers for both encryption and decryption.,Code was allocating but never releasing ciphers for both encryption and decryption.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1200,2019-03-01T07:16:18Z,2019-08-01T13:37:09Z,2019-08-01T13:37:14Z,MERGED,True,2537,1332,32,https://github.com/ikoveshnikov,Fix farious frang errors,36,['crucial'],https://github.com/tempesta-tech/tempesta/pull/1200,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1200,"fix #1028
Fixed:

test trailer headers across frang limits after body is processed: maximum header len, don't allow same header  in header and trailer parts. Last check requires to know, whether is message is fully parsed.
close|block client connection immediately once response breaking code block rules is encountered
fix possible null pointer dereferencing while testing response code block rules for Health Monitor originated requests.
add missing frang limits names to tempesta_fw.conf
TfwHttpReq->frang_st duplicates existing Gfsm state in frang FSM and it was removed. Frang states are hookable now, so advanced analytics can be attached to it.

UPD
Major updates in handling frang directives.


Frang directives now are really per-vhost and per-location. Each vhost and location may include frang_limits section now. Previous behaviour: frang limits may be defined only globally and only inside locations (and not inside vhosts!), but limits was listed in locations without grouping into section frang_limits


Nested locations and vhosts inherit Frang configuration from parents. frang_limits section now can appear many times on the same level to force new defaults before new bunch of vhosts|locations. Previous behaviour: no inheritance, every location must define it's own frang settings, so less copy-paste now.


Frang limits was split into two groups: global and per-vhost. Since messages are received by parts, it's not possible to deduce which per-vhost limits should be applied before the whole message is received. So some limits has no sense in beeing per-vhost, they're global now.","fix #1028
Fixed:

test trailer headers across frang limits after body is processed: maximum header len, don't allow same header  in header and trailer parts. Last check requires to know, whether is message is fully parsed.
close|block client connection immediately once response breaking code block rules is encountered
fix possible null pointer dereferencing while testing response code block rules for Health Monitor originated requests.
add missing frang limits names to tempesta_fw.conf
TfwHttpReq->frang_st duplicates existing Gfsm state in frang FSM and it was removed. Frang states are hookable now, so advanced analytics can be attached to it.

UPD
Major updates in handling frang directives.


Frang directives now are really per-vhost and per-location. Each vhost and location may include frang_limits section now. Previous behaviour: frang limits may be defined only globally and only inside locations (and not inside vhosts!), but limits was listed in locations without grouping into section frang_limits


Nested locations and vhosts inherit Frang configuration from parents. frang_limits section now can appear many times on the same level to force new defaults before new bunch of vhosts|locations. Previous behaviour: no inheritance, every location must define it's own frang settings, so less copy-paste now.


Frang limits was split into two groups: global and per-vhost. Since messages are received by parts, it's not possible to deduce which per-vhost limits should be applied before the whole message is received. So some limits has no sense in beeing per-vhost, they're global now.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1200,2019-03-01T07:16:18Z,2019-08-01T13:37:09Z,2019-08-01T13:37:14Z,MERGED,True,2537,1332,32,https://github.com/ikoveshnikov,Fix farious frang errors,36,['crucial'],https://github.com/tempesta-tech/tempesta/pull/1200,https://github.com/avbelov23,2,https://github.com/tempesta-tech/tempesta/pull/1200#issuecomment-511589562,"fix #1028
Fixed:

test trailer headers across frang limits after body is processed: maximum header len, don't allow same header  in header and trailer parts. Last check requires to know, whether is message is fully parsed.
close|block client connection immediately once response breaking code block rules is encountered
fix possible null pointer dereferencing while testing response code block rules for Health Monitor originated requests.
add missing frang limits names to tempesta_fw.conf
TfwHttpReq->frang_st duplicates existing Gfsm state in frang FSM and it was removed. Frang states are hookable now, so advanced analytics can be attached to it.

UPD
Major updates in handling frang directives.


Frang directives now are really per-vhost and per-location. Each vhost and location may include frang_limits section now. Previous behaviour: frang limits may be defined only globally and only inside locations (and not inside vhosts!), but limits was listed in locations without grouping into section frang_limits


Nested locations and vhosts inherit Frang configuration from parents. frang_limits section now can appear many times on the same level to force new defaults before new bunch of vhosts|locations. Previous behaviour: no inheritance, every location must define it's own frang settings, so less copy-paste now.


Frang limits was split into two groups: global and per-vhost. Since messages are received by parts, it's not possible to deduce which per-vhost limits should be applied before the whole message is received. So some limits has no sense in beeing per-vhost, they're global now.","Corrected tests, because in this PR blocking by http_resp_code_block occurs at the response stage, and this correct.
tempesta-tech/tempesta-test#90",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1201,2019-03-04T06:18:15Z,2019-03-23T06:17:09Z,2019-03-24T18:52:50Z,MERGED,True,1099,1505,16,https://github.com/krizhanovsky,Fix #1131: use GCC jumps to labels stored as pointers.,10,[],https://github.com/tempesta-tech/tempesta/pull/1201,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1201,"The FSM becomes complex, so lib/fsm.h left as is (all the instances of the FSM definition don't use so many labels after all).
Fix objtool warnings about sibling call in cfg.c (also due to usage of the same GCC extension).
Remove HTTP normalization zero logic - #2 defines the logic in different way.
Fix the tests mess with not-passed DEBUG define and redifinition hell in test_http_sticky.c.
Move Tempesta FW version to 0.7.
I tested the patch on my 4 core VM with Apache HTTP as a backend serving 3 byte index.html and wrk running from the host as:
./wrk -t 4 -c 128 -d 60s --header 'Connection: keep-alive' --header 'Upgrade-Insecure-Requests: 1' --header 'User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36' --header 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8' --header 'Accept-Encoding: gzip, deflate, sdch' --header 'Accept-Language: en-US,en;q=0.8,ru;q=0.6' --header 'Cookie: a=sdfasd; sdf=3242u389erfhhs; djcnjhe=sdfsdafsdjfb324te1267dd; sdaf=mo2u8943478t67437461746rfdgfcdc; ityu=9u489573484duifhd; GTYFT=nsdjhcbyq3te76ewgfcZ; uityut=23Y746756247856425784657; GA=URHUFVHHVSDNFDHGYSDGF; a=%45345%dfdfg%4656%4534sdfjhsdb.sdfsg.sdfgsf' http://192.168.100.4:80/

Tempesta config:
listen 192.168.100.4:80;
srv_group default {
	server 127.0.0.1:8080; # apache
}
vhost default {
	proxy_pass default;
}
cache 1;
cache_fulfill * *;
http_chain {
	-> default;
}

Before the patch:
     7.64%  [tempesta_fw]  [k] tfw_http_parse_req
     2.79%  [e1000]        [k] e1000_xmit_frame
     2.32%  [tempesta_fw]  [k] __tfw_strspn_simd
     2.31%  [tempesta_fw]  [k] __tfw_http_msg_add_str_data
     1.60%  [tempesta_fw]  [k] __new_pgfrag
     1.58%  [kernel]       [k] skb_release_data
     1.55%  [tempesta_fw]  [k] __str_grow_tree
     1.41%  [kernel]       [k] __inet_lookup_established
     1.35%  [tempesta_fw]  [k] tfw_cache_do_action
     1.35%  [tempesta_fw]  [k] __tfw_strcmpspn

After the patch:
     5.78%  [tempesta_fw]  [k] tfw_http_parse_req
     2.90%  [e1000]        [k] e1000_xmit_frame
     2.29%  [tempesta_fw]  [k] __tfw_http_msg_add_str_data
     2.14%  [tempesta_fw]  [k] __tfw_strspn_simd
     2.06%  [kernel]       [k] swiotlb_tbl_unmap_single
     1.53%  [kernel]       [k] skb_release_data
     1.43%  [tempesta_fw]  [k] tfw_cache_do_action
     1.41%  [tempesta_fw]  [k] __str_grow_tree
     1.40%  [kernel]       [k] __inet_lookup_established
     1.29%  [kernel]       [k] queued_spin_lock_slowpath","The FSM becomes complex, so lib/fsm.h left as is (all the instances of the FSM definition don't use so many labels after all).
Fix objtool warnings about sibling call in cfg.c (also due to usage of the same GCC extension).
Remove HTTP normalization zero logic - #2 defines the logic in different way.
Fix the tests mess with not-passed DEBUG define and redifinition hell in test_http_sticky.c.
Move Tempesta FW version to 0.7.
I tested the patch on my 4 core VM with Apache HTTP as a backend serving 3 byte index.html and wrk running from the host as:
./wrk -t 4 -c 128 -d 60s --header 'Connection: keep-alive' --header 'Upgrade-Insecure-Requests: 1' --header 'User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36' --header 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8' --header 'Accept-Encoding: gzip, deflate, sdch' --header 'Accept-Language: en-US,en;q=0.8,ru;q=0.6' --header 'Cookie: a=sdfasd; sdf=3242u389erfhhs; djcnjhe=sdfsdafsdjfb324te1267dd; sdaf=mo2u8943478t67437461746rfdgfcdc; ityu=9u489573484duifhd; GTYFT=nsdjhcbyq3te76ewgfcZ; uityut=23Y746756247856425784657; GA=URHUFVHHVSDNFDHGYSDGF; a=%45345%dfdfg%4656%4534sdfjhsdb.sdfsg.sdfgsf' http://192.168.100.4:80/

Tempesta config:
listen 192.168.100.4:80;
srv_group default {
	server 127.0.0.1:8080; # apache
}
vhost default {
	proxy_pass default;
}
cache 1;
cache_fulfill * *;
http_chain {
	-> default;
}

Before the patch:
     7.64%  [tempesta_fw]  [k] tfw_http_parse_req
     2.79%  [e1000]        [k] e1000_xmit_frame
     2.32%  [tempesta_fw]  [k] __tfw_strspn_simd
     2.31%  [tempesta_fw]  [k] __tfw_http_msg_add_str_data
     1.60%  [tempesta_fw]  [k] __new_pgfrag
     1.58%  [kernel]       [k] skb_release_data
     1.55%  [tempesta_fw]  [k] __str_grow_tree
     1.41%  [kernel]       [k] __inet_lookup_established
     1.35%  [tempesta_fw]  [k] tfw_cache_do_action
     1.35%  [tempesta_fw]  [k] __tfw_strcmpspn

After the patch:
     5.78%  [tempesta_fw]  [k] tfw_http_parse_req
     2.90%  [e1000]        [k] e1000_xmit_frame
     2.29%  [tempesta_fw]  [k] __tfw_http_msg_add_str_data
     2.14%  [tempesta_fw]  [k] __tfw_strspn_simd
     2.06%  [kernel]       [k] swiotlb_tbl_unmap_single
     1.53%  [kernel]       [k] skb_release_data
     1.43%  [tempesta_fw]  [k] tfw_cache_do_action
     1.41%  [tempesta_fw]  [k] __str_grow_tree
     1.40%  [kernel]       [k] __inet_lookup_established
     1.29%  [kernel]       [k] queued_spin_lock_slowpath",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1201,2019-03-04T06:18:15Z,2019-03-23T06:17:09Z,2019-03-24T18:52:50Z,MERGED,True,1099,1505,16,https://github.com/krizhanovsky,Fix #1131: use GCC jumps to labels stored as pointers.,10,[],https://github.com/tempesta-tech/tempesta/pull/1201,https://github.com/avbelov23,2,https://github.com/tempesta-tech/tempesta/pull/1201#issuecomment-475507234,"The FSM becomes complex, so lib/fsm.h left as is (all the instances of the FSM definition don't use so many labels after all).
Fix objtool warnings about sibling call in cfg.c (also due to usage of the same GCC extension).
Remove HTTP normalization zero logic - #2 defines the logic in different way.
Fix the tests mess with not-passed DEBUG define and redifinition hell in test_http_sticky.c.
Move Tempesta FW version to 0.7.
I tested the patch on my 4 core VM with Apache HTTP as a backend serving 3 byte index.html and wrk running from the host as:
./wrk -t 4 -c 128 -d 60s --header 'Connection: keep-alive' --header 'Upgrade-Insecure-Requests: 1' --header 'User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36' --header 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8' --header 'Accept-Encoding: gzip, deflate, sdch' --header 'Accept-Language: en-US,en;q=0.8,ru;q=0.6' --header 'Cookie: a=sdfasd; sdf=3242u389erfhhs; djcnjhe=sdfsdafsdjfb324te1267dd; sdaf=mo2u8943478t67437461746rfdgfcdc; ityu=9u489573484duifhd; GTYFT=nsdjhcbyq3te76ewgfcZ; uityut=23Y746756247856425784657; GA=URHUFVHHVSDNFDHGYSDGF; a=%45345%dfdfg%4656%4534sdfjhsdb.sdfsg.sdfgsf' http://192.168.100.4:80/

Tempesta config:
listen 192.168.100.4:80;
srv_group default {
	server 127.0.0.1:8080; # apache
}
vhost default {
	proxy_pass default;
}
cache 1;
cache_fulfill * *;
http_chain {
	-> default;
}

Before the patch:
     7.64%  [tempesta_fw]  [k] tfw_http_parse_req
     2.79%  [e1000]        [k] e1000_xmit_frame
     2.32%  [tempesta_fw]  [k] __tfw_strspn_simd
     2.31%  [tempesta_fw]  [k] __tfw_http_msg_add_str_data
     1.60%  [tempesta_fw]  [k] __new_pgfrag
     1.58%  [kernel]       [k] skb_release_data
     1.55%  [tempesta_fw]  [k] __str_grow_tree
     1.41%  [kernel]       [k] __inet_lookup_established
     1.35%  [tempesta_fw]  [k] tfw_cache_do_action
     1.35%  [tempesta_fw]  [k] __tfw_strcmpspn

After the patch:
     5.78%  [tempesta_fw]  [k] tfw_http_parse_req
     2.90%  [e1000]        [k] e1000_xmit_frame
     2.29%  [tempesta_fw]  [k] __tfw_http_msg_add_str_data
     2.14%  [tempesta_fw]  [k] __tfw_strspn_simd
     2.06%  [kernel]       [k] swiotlb_tbl_unmap_single
     1.53%  [kernel]       [k] skb_release_data
     1.43%  [tempesta_fw]  [k] tfw_cache_do_action
     1.41%  [tempesta_fw]  [k] __str_grow_tree
     1.40%  [kernel]       [k] __inet_lookup_established
     1.29%  [kernel]       [k] queued_spin_lock_slowpath",Looks good to me,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1204,2019-03-05T23:20:11Z,2019-03-06T11:59:22Z,2019-03-06T11:59:43Z,MERGED,True,1,0,1,https://github.com/i-rinat,reset data offset in ss_skb_process after first data processed,1,[],https://github.com/tempesta-tech/tempesta/pull/1204,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1204,"off needs to be reset to 0 after the first meaningful data chunk. Leaving it as is results in subsequent data skip.
(related to #1187)","off needs to be reset to 0 after the first meaningful data chunk. Leaving it as is results in subsequent data skip.
(related to #1187)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1205,2019-03-07T02:28:11Z,2019-03-07T17:16:19Z,2019-03-07T18:11:27Z,MERGED,True,32,120,2,https://github.com/krizhanovsky,Add forgotten http_ctext_vchar_brange config option.,1,['crucial'],https://github.com/tempesta-tech/tempesta/pull/1205,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1205,Also generalize config handling for custom character sets. https://github.com/tempesta-tech/tempesta/wiki/HTTP-security is already updated.,Also generalize config handling for custom character sets. https://github.com/tempesta-tech/tempesta/wiki/HTTP-security is already updated.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1206,2019-03-07T11:57:13Z,2019-03-13T18:12:49Z,2019-03-13T18:12:54Z,MERGED,True,71,9,4,https://github.com/ikoveshnikov,"fix encoding to chunked: chunk size is hex digit, not decimal",2,[],https://github.com/tempesta-tech/tempesta/pull/1206,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1206,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1206,2019-03-07T11:57:13Z,2019-03-13T18:12:49Z,2019-03-13T18:12:54Z,MERGED,True,71,9,4,https://github.com/ikoveshnikov,"fix encoding to chunked: chunk size is hex digit, not decimal",2,[],https://github.com/tempesta-tech/tempesta/pull/1206,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/1206#issuecomment-472478658,,Please backport the fix to release-0.6,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1209,2019-03-11T13:36:53Z,2019-03-26T20:02:52Z,2019-03-26T20:02:55Z,MERGED,True,122,141,5,https://github.com/ikoveshnikov,fix #1189: correctly fill header part of skb when writing data into p…,4,[],https://github.com/tempesta-tech/tempesta/pull/1209,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1209,"…aged fragments
See commit messages for the changes descriptions.","…aged fragments
See commit messages for the changes descriptions.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1212,2019-03-13T22:18:17Z,2019-03-14T13:47:59Z,2019-03-14T13:48:02Z,MERGED,True,32,0,3,https://github.com/i-rinat,tls: free memory allocated during handshake,1,[],https://github.com/tempesta-tech/tempesta/pull/1212,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1212,Structures used on handshake phase may use dynamically allocated memory which needs to be freed.,Structures used on handshake phase may use dynamically allocated memory which needs to be freed.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1213,2019-03-13T22:27:30Z,2019-03-15T13:02:25Z,2019-03-15T13:02:29Z,MERGED,True,144,76,1,https://github.com/i-rinat,Update kernel patch to the current version,1,[],https://github.com/tempesta-tech/tempesta/pull/1213,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1213,Synchronize with tempesta-tech/linux-4.14.32-tfw@580e5dd,Synchronize with tempesta-tech/linux-4.14.32-tfw@580e5dd,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1215,2019-03-15T13:25:14Z,2019-03-21T13:41:21Z,2019-03-21T15:08:29Z,MERGED,True,258,101,12,https://github.com/i-rinat,Backport changes to release-0.6 branch,7,[],https://github.com/tempesta-tech/tempesta/pull/1215,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1215,"Backports of #1197, #1204, #1206, #1212, and #1213 to the release-0.6 branch.
(fixes #1211)","Backports of #1197, #1204, #1206, #1212, and #1213 to the release-0.6 branch.
(fixes #1211)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1215,2019-03-15T13:25:14Z,2019-03-21T13:41:21Z,2019-03-21T15:08:29Z,MERGED,True,258,101,12,https://github.com/i-rinat,Backport changes to release-0.6 branch,7,[],https://github.com/tempesta-tech/tempesta/pull/1215,https://github.com/i-rinat,2,https://github.com/tempesta-tech/tempesta/pull/1215#issuecomment-473898530,"Backports of #1197, #1204, #1206, #1212, and #1213 to the release-0.6 branch.
(fixes #1211)","Please move Tempesta FW version to 0.6.1 and TempestaTLS to 0.2.3 and correspondingly create a new tag 0.6.1.

Changed versions.
As for the tag, I suppose it's better to create it after this branch is merged.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1215,2019-03-15T13:25:14Z,2019-03-21T13:41:21Z,2019-03-21T15:08:29Z,MERGED,True,258,101,12,https://github.com/i-rinat,Backport changes to release-0.6 branch,7,[],https://github.com/tempesta-tech/tempesta/pull/1215,https://github.com/i-rinat,3,https://github.com/tempesta-tech/tempesta/pull/1215#issuecomment-473978658,"Backports of #1197, #1204, #1206, #1212, and #1213 to the release-0.6 branch.
(fixes #1211)",Added squashed version of #1206.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1215,2019-03-15T13:25:14Z,2019-03-21T13:41:21Z,2019-03-21T15:08:29Z,MERGED,True,258,101,12,https://github.com/i-rinat,Backport changes to release-0.6 branch,7,[],https://github.com/tempesta-tech/tempesta/pull/1215,https://github.com/i-rinat,4,https://github.com/tempesta-tech/tempesta/pull/1215#issuecomment-475268296,"Backports of #1197, #1204, #1206, #1212, and #1213 to the release-0.6 branch.
(fixes #1211)",Tag added: https://github.com/tempesta-tech/tempesta/releases/tag/0.6.1,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1216,2019-03-20T22:17:23Z,2019-03-21T13:45:19Z,2019-03-21T14:17:51Z,CLOSED,False,21,21,11,https://github.com/i-rinat,always expand debug macros into expressions,1,[],https://github.com/tempesta-tech/tempesta/pull/1216,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1216,"Upd. I was wrong, see comments below for details.
In release builds, debug macros like T_DBG() are expanded to nothing. This allows to remove debug code from resulting build completely, but makes code counter-intuitive and bug-prone. Such macros are expected to behave like statements, but they are not. For example, code:
int
ttls_md_update(TlsMdCtx *ctx, const unsigned char *input, size_t ilen)
{
        int r;

        BUG_ON(!ctx || !ctx->md_info);

        r = crypto_shash_update(&ctx->md_ctx, input, ilen);
        if (r)
                T_DBG(""cannot update hash ctx, %d\n"", r);

        return r;
}
expands to
int
ttls_md_update(TlsMdCtx *ctx, const unsigned char *input, size_t ilen)
{
        int r;

        BUG_ON(!ctx || !ctx->md_info);

        r = crypto_shash_update(&ctx->md_ctx, input, ilen);
        if (r)
                

        return r;
}
Note that return r is conditional, and is called only when r is not 0. Function returning value now doesn't return anything. It just happens to work as expected since rax register is filled with correct return code.
Rather than fixing all places where such macros are used, it's easier to change macros themselves to expand to empty expressions. This also prevents similar issues in the future.","Upd. I was wrong, see comments below for details.
In release builds, debug macros like T_DBG() are expanded to nothing. This allows to remove debug code from resulting build completely, but makes code counter-intuitive and bug-prone. Such macros are expected to behave like statements, but they are not. For example, code:
int
ttls_md_update(TlsMdCtx *ctx, const unsigned char *input, size_t ilen)
{
        int r;

        BUG_ON(!ctx || !ctx->md_info);

        r = crypto_shash_update(&ctx->md_ctx, input, ilen);
        if (r)
                T_DBG(""cannot update hash ctx, %d\n"", r);

        return r;
}
expands to
int
ttls_md_update(TlsMdCtx *ctx, const unsigned char *input, size_t ilen)
{
        int r;

        BUG_ON(!ctx || !ctx->md_info);

        r = crypto_shash_update(&ctx->md_ctx, input, ilen);
        if (r)
                

        return r;
}
Note that return r is conditional, and is called only when r is not 0. Function returning value now doesn't return anything. It just happens to work as expected since rax register is filled with correct return code.
Rather than fixing all places where such macros are used, it's easier to change macros themselves to expand to empty expressions. This also prevents similar issues in the future.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1216,2019-03-20T22:17:23Z,2019-03-21T13:45:19Z,2019-03-21T14:17:51Z,CLOSED,False,21,21,11,https://github.com/i-rinat,always expand debug macros into expressions,1,[],https://github.com/tempesta-tech/tempesta/pull/1216,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/1216#issuecomment-475125373,"Upd. I was wrong, see comments below for details.
In release builds, debug macros like T_DBG() are expanded to nothing. This allows to remove debug code from resulting build completely, but makes code counter-intuitive and bug-prone. Such macros are expected to behave like statements, but they are not. For example, code:
int
ttls_md_update(TlsMdCtx *ctx, const unsigned char *input, size_t ilen)
{
        int r;

        BUG_ON(!ctx || !ctx->md_info);

        r = crypto_shash_update(&ctx->md_ctx, input, ilen);
        if (r)
                T_DBG(""cannot update hash ctx, %d\n"", r);

        return r;
}
expands to
int
ttls_md_update(TlsMdCtx *ctx, const unsigned char *input, size_t ilen)
{
        int r;

        BUG_ON(!ctx || !ctx->md_info);

        r = crypto_shash_update(&ctx->md_ctx, input, ilen);
        if (r)
                

        return r;
}
Note that return r is conditional, and is called only when r is not 0. Function returning value now doesn't return anything. It just happens to work as expected since rax register is filled with correct return code.
Rather than fixing all places where such macros are used, it's easier to change macros themselves to expand to empty expressions. This also prevents similar issues in the future.","I believe the statement with an empty macro expands to ;

Agreed. -E gcc option gives the preprocessored version:
. . .

# 5 ""t.c""
int main(int argc, char *argv[])
{
 printf(""argc = %d\n"", argc);
 if (argc > 1)
  ;
 printf(""not under if\n"");
 return 0;
}
More over, if the return statement is moved into if clause, then gcc with all the compilation flags we use will throw a compilation error:
error: control reaches end of non-void function [-Werror=return-type]
So it seems that the patch doesn't really change anything. @i-rinat Maybe there was some different type of error? Where exactly the issue had happen?",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1216,2019-03-20T22:17:23Z,2019-03-21T13:45:19Z,2019-03-21T14:17:51Z,CLOSED,False,21,21,11,https://github.com/i-rinat,always expand debug macros into expressions,1,[],https://github.com/tempesta-tech/tempesta/pull/1216,https://github.com/i-rinat,3,https://github.com/tempesta-tech/tempesta/pull/1216#issuecomment-475233848,"Upd. I was wrong, see comments below for details.
In release builds, debug macros like T_DBG() are expanded to nothing. This allows to remove debug code from resulting build completely, but makes code counter-intuitive and bug-prone. Such macros are expected to behave like statements, but they are not. For example, code:
int
ttls_md_update(TlsMdCtx *ctx, const unsigned char *input, size_t ilen)
{
        int r;

        BUG_ON(!ctx || !ctx->md_info);

        r = crypto_shash_update(&ctx->md_ctx, input, ilen);
        if (r)
                T_DBG(""cannot update hash ctx, %d\n"", r);

        return r;
}
expands to
int
ttls_md_update(TlsMdCtx *ctx, const unsigned char *input, size_t ilen)
{
        int r;

        BUG_ON(!ctx || !ctx->md_info);

        r = crypto_shash_update(&ctx->md_ctx, input, ilen);
        if (r)
                

        return r;
}
Note that return r is conditional, and is called only when r is not 0. Function returning value now doesn't return anything. It just happens to work as expected since rax register is filled with correct return code.
Rather than fixing all places where such macros are used, it's easier to change macros themselves to expand to empty expressions. This also prevents similar issues in the future.","I was wrong, there are no issues with macros. There probably can be some excuses to introduce changes from this PR, but they are not required.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1219,2019-03-23T15:33:34Z,2019-03-26T18:22:55Z,2019-03-26T18:24:41Z,MERGED,True,59,5,6,https://github.com/krizhanovsky,#1181: GCOV compilation option,2,[],https://github.com/tempesta-tech/tempesta/pull/1219,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1219,"The option is useful for profile guided optimization (PGO). I tried to build
http_parser.c with ""profile-use=/root/tempesta/http_parser.c.gcov"" in #pragma
GCC optimize. http_parser.c.gcov is generated by
$ cd ~/tempesta
$ ./scripts/gcov_gather.sh /tmp/gcov.tgz
$ cd /tmp && tar -zxf gcov.tgz && cd -
$ gcov -o /tmp/sys/kernel/debug/gcov/root/tempesta/tempesta_fw http_parser.c
perf(1) also can be used for the profile generation, see -fauto-profile GCC
command line option.
PGO generates slightly better code layout, but the profile counts total
samples and doesn't record sequence of called code. E.g. for a normal HTTP
request the parser spends more time in URI processing than in method
processing, so PGO moves URI before method processing which is completely
wrong.
The second drawback of PGO is that each code update requires regeneration of
the profile. Moreover, in general it's tricky to correctly choose the right
workload for the profile, so it looks more like workload programming than the
parser programming.
All in all, I leave the GCOV compilation option only for the test coverage and
we need to use more flexible way to generate proper code layout.","The option is useful for profile guided optimization (PGO). I tried to build
http_parser.c with ""profile-use=/root/tempesta/http_parser.c.gcov"" in #pragma
GCC optimize. http_parser.c.gcov is generated by
$ cd ~/tempesta
$ ./scripts/gcov_gather.sh /tmp/gcov.tgz
$ cd /tmp && tar -zxf gcov.tgz && cd -
$ gcov -o /tmp/sys/kernel/debug/gcov/root/tempesta/tempesta_fw http_parser.c
perf(1) also can be used for the profile generation, see -fauto-profile GCC
command line option.
PGO generates slightly better code layout, but the profile counts total
samples and doesn't record sequence of called code. E.g. for a normal HTTP
request the parser spends more time in URI processing than in method
processing, so PGO moves URI before method processing which is completely
wrong.
The second drawback of PGO is that each code update requires regeneration of
the profile. Moreover, in general it's tricky to correctly choose the right
workload for the profile, so it looks more like workload programming than the
parser programming.
All in all, I leave the GCOV compilation option only for the test coverage and
we need to use more flexible way to generate proper code layout.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1220,2019-03-24T15:36:09Z,2019-03-25T13:57:01Z,2019-03-25T13:57:05Z,MERGED,True,6,2,2,https://github.com/i-rinat,tls: multiple-pieces-handshake fixups,2,[],https://github.com/tempesta-tech/tempesta/pull/1220,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1220,"Update __fsm_const_state before exiting an FSM, since that variable is then used to update state in T_FSM_FINISH():
ensure that handshake length is tracked precisely even if handshake comes in multiple pieces.","Update __fsm_const_state before exiting an FSM, since that variable is then used to update state in T_FSM_FINISH():
ensure that handshake length is tracked precisely even if handshake comes in multiple pieces.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1223,2019-03-25T14:44:27Z,2019-03-26T20:04:47Z,2019-03-26T20:04:55Z,MERGED,True,61,0,1,https://github.com/ikoveshnikov,readme: add packaging readme,1,['doc'],https://github.com/tempesta-tech/tempesta/pull/1223,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1223,"I was sure that the packaging instruction can be found somewhere. But it wasn't. I wrote this file very long time ago, but it's still  relevant.","I was sure that the packaging instruction can be found somewhere. But it wasn't. I wrote this file very long time ago, but it's still  relevant.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1225,2019-03-26T16:35:04Z,2019-03-28T16:59:25Z,2019-03-28T17:02:21Z,MERGED,True,68,48,2,https://github.com/krizhanovsky,Fix #1222,2,[],https://github.com/tempesta-tech/tempesta/pull/1225,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1225,"reset parser->_acc on POSTPONE and other parser errors recovered
by reentrance with the line skipping;
treat connection flags as bits since the first one is 0.

@ikoveshnikov could you please check the functional tests - the suite hangs on deproxy restart in my VM and I'm still not so fluent with the test framework to debug the problem for now.","reset parser->_acc on POSTPONE and other parser errors recovered
by reentrance with the line skipping;
treat connection flags as bits since the first one is 0.

@ikoveshnikov could you please check the functional tests - the suite hangs on deproxy restart in my VM and I'm still not so fluent with the test framework to debug the problem for now.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1226,2019-03-26T17:25:37Z,2019-03-26T22:03:45Z,2019-03-28T23:36:37Z,CLOSED,False,87,26,1,https://github.com/avbelov23,bmi2 check for preload avx2 cripto,1,[],https://github.com/tempesta-tech/tempesta/pull/1226,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1226,"For avx2 crypto modules, the bmi2 instruction set is required.","For avx2 crypto modules, the bmi2 instruction set is required.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1226,2019-03-26T17:25:37Z,2019-03-26T22:03:45Z,2019-03-28T23:36:37Z,CLOSED,False,87,26,1,https://github.com/avbelov23,bmi2 check for preload avx2 cripto,1,[],https://github.com/tempesta-tech/tempesta/pull/1226,https://github.com/i-rinat,2,https://github.com/tempesta-tech/tempesta/pull/1226#issuecomment-477809448,"For avx2 crypto modules, the bmi2 instruction set is required.",(obsoleted by #1227),True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1227,2019-03-26T18:20:14Z,2019-03-28T14:44:23Z,2019-03-28T14:44:29Z,MERGED,True,28,8,1,https://github.com/avbelov23,Request non-specific cryptographic modules,1,[],https://github.com/tempesta-tech/tempesta/pull/1227,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1227,"Requires #1224
We request non-specific cryptographic modules, since on some virtual machines there is no bmi2 instruction set needed for avx2 cryptographic modules","Requires #1224
We request non-specific cryptographic modules, since on some virtual machines there is no bmi2 instruction set needed for avx2 cryptographic modules",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1230,2019-03-26T22:05:04Z,2019-03-27T13:20:14Z,2019-03-27T13:20:18Z,MERGED,True,6,2,2,https://github.com/i-rinat,Backport TLS FSM fixes to release-0.6,2,[],https://github.com/tempesta-tech/tempesta/pull/1230,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1230,Couple of fixes for fragmented TLS handshakes. See #1220 for the original PR.,Couple of fixes for fragmented TLS handshakes. See #1220 for the original PR.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1231,2019-03-28T11:21:45Z,2019-03-28T13:52:02Z,2019-03-28T14:00:04Z,MERGED,True,13,10,2,https://github.com/i-rinat,tls: check handshake length earlier,1,[],https://github.com/tempesta-tech/tempesta/pull/1231,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1231,"If ClientHello comes in multiple chunks, and last chunk is smaller that 38
bytes, code will emit an error even if there is nothing wrong with the
ClientHello message itself. To avoid that, length check is moved to the
earlier stage.","If ClientHello comes in multiple chunks, and last chunk is smaller that 38
bytes, code will emit an error even if there is nothing wrong with the
ClientHello message itself. To avoid that, length check is moved to the
earlier stage.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1232,2019-03-28T13:57:04Z,2019-03-28T14:24:02Z,2019-03-28T14:24:06Z,MERGED,True,13,10,2,https://github.com/i-rinat,tls: check handshake length earlier (backport to release-0.6),1,[],https://github.com/tempesta-tech/tempesta/pull/1232,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1232,"If ClientHello comes in multiple chunks, and last chunk is smaller that 38
bytes, code will emit an error even if there is nothing wrong with the
ClientHello message itself. To avoid that, length check is moved to the
earlier stage.
(this is a copy of changes from #1231)","If ClientHello comes in multiple chunks, and last chunk is smaller that 38
bytes, code will emit an error even if there is nothing wrong with the
ClientHello message itself. To avoid that, length check is moved to the
earlier stage.
(this is a copy of changes from #1231)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1233,2019-03-28T21:06:32Z,2019-05-16T20:23:33Z,2019-05-16T20:23:57Z,MERGED,True,2527,106,17,https://github.com/aleksostapenko,HTTP/2 Framing layer implementation (#309).,17,[],https://github.com/tempesta-tech/tempesta/pull/1233,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/1233,"Working HTTP/2 functionality in PR

PING and SETTINGS frames exchange: receiving, parsing and response with ACK; tested via h2i utility (https://github.com/golang/net/tree/master/http2/h2i);
Establishing HTTP/2 connection; tested via nghttp utility - the part of nghttp2/nghttp2-client packages (https://nghttp2.org):

Client's connection preface (starting magic sequence and SETTINGS frame) receiving and parsing;
Response with server side preface (initial SETTINGS frame);
Send SETTINGS ACK frame (in response to client's preface SETTINGS frame);
Receiving and parsing client's SETTINGS ACK frame (in response to server side preface SETTINGS fram
Receiving and parsing client's PRIORITY frames;
Receiving and parsing client's HEADERS frame;
Applying client's HEADERS as initial frame for new stream creation.



Command:
nghttp -v https://<name_of_host_with_started_tempesta_fw>

Note: to test HTTP/2 connection establishing via nghttp (described above) - it is necessary to replace the implementation of APP_FRAME() macro with simple false value, since upper level for processing of application frames (HEADERS, DATA and CONTINUATION) is not implemented yet.
HTTP/2 Stream Scheduler
In context of #309 only base implementation of priority/dependency scheduler is planned (the rest must be implemented in #1196). So this PR contains only initial form of scheduler: at stage of #309 all streams are assumed to have equal weights and depends on the one root logical stream (with ID equal 0); thus, streams are processed in order of their frames/request/response come from TCP connection, and in this case we need just a simple streams' storage with fast search by ID. In current PR red-black tree based storage is used; this structure has been chosen - compared to hash table - due to lack of per-connection memory overhead, since for hash table some amount of memory (maybe large enough) must be allocated initially - at the connection's creation moment, and besides, this could be a ddos vector.
Considering future priority/dependency scheduler implementation in context of #1196 - an appropriate scheme for the scheduler, in my opinion, would be a tree-like structure (let's call it a dependency tree), built with the help of, ""parent"" and ""child"" pointers (embedded into Stream structure) for vertical links and ""prev"" and ""next"" pointers - for the horizontal links between neighbor streams of the same level. A logical stream with identifier 0 acts as a root of this tree. In addition to the specified links, each stream has a pointer to a special priority queue (based on the binary heap), in which only its child single-level streams with jobs to be processed (frames/requests/responses) are placed.
Thus, the red-black tree, mentioned above, in proposed scheme acts as a basic storage structure for a quick search of streams; on top of it - the dependency tree acts as a structure to track current dependencies between streams and to calculate effective priorities for each stream in the tree — based on their weights (in case of re-prioritization etc.); also dependency tree provides up/down traversals between dependency levels; and the priority queues, in turn, track the next stream to be processed for each level.","Working HTTP/2 functionality in PR

PING and SETTINGS frames exchange: receiving, parsing and response with ACK; tested via h2i utility (https://github.com/golang/net/tree/master/http2/h2i);
Establishing HTTP/2 connection; tested via nghttp utility - the part of nghttp2/nghttp2-client packages (https://nghttp2.org):

Client's connection preface (starting magic sequence and SETTINGS frame) receiving and parsing;
Response with server side preface (initial SETTINGS frame);
Send SETTINGS ACK frame (in response to client's preface SETTINGS frame);
Receiving and parsing client's SETTINGS ACK frame (in response to server side preface SETTINGS fram
Receiving and parsing client's PRIORITY frames;
Receiving and parsing client's HEADERS frame;
Applying client's HEADERS as initial frame for new stream creation.



Command:
nghttp -v https://<name_of_host_with_started_tempesta_fw>

Note: to test HTTP/2 connection establishing via nghttp (described above) - it is necessary to replace the implementation of APP_FRAME() macro with simple false value, since upper level for processing of application frames (HEADERS, DATA and CONTINUATION) is not implemented yet.
HTTP/2 Stream Scheduler
In context of #309 only base implementation of priority/dependency scheduler is planned (the rest must be implemented in #1196). So this PR contains only initial form of scheduler: at stage of #309 all streams are assumed to have equal weights and depends on the one root logical stream (with ID equal 0); thus, streams are processed in order of their frames/request/response come from TCP connection, and in this case we need just a simple streams' storage with fast search by ID. In current PR red-black tree based storage is used; this structure has been chosen - compared to hash table - due to lack of per-connection memory overhead, since for hash table some amount of memory (maybe large enough) must be allocated initially - at the connection's creation moment, and besides, this could be a ddos vector.
Considering future priority/dependency scheduler implementation in context of #1196 - an appropriate scheme for the scheduler, in my opinion, would be a tree-like structure (let's call it a dependency tree), built with the help of, ""parent"" and ""child"" pointers (embedded into Stream structure) for vertical links and ""prev"" and ""next"" pointers - for the horizontal links between neighbor streams of the same level. A logical stream with identifier 0 acts as a root of this tree. In addition to the specified links, each stream has a pointer to a special priority queue (based on the binary heap), in which only its child single-level streams with jobs to be processed (frames/requests/responses) are placed.
Thus, the red-black tree, mentioned above, in proposed scheme acts as a basic storage structure for a quick search of streams; on top of it - the dependency tree acts as a structure to track current dependencies between streams and to calculate effective priorities for each stream in the tree — based on their weights (in case of re-prioritization etc.); also dependency tree provides up/down traversals between dependency levels; and the priority queues, in turn, track the next stream to be processed for each level.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1234,2019-03-29T11:15:36Z,2019-03-29T20:14:22Z,2019-03-29T20:14:25Z,MERGED,True,7,22,3,https://github.com/avbelov23,Update dkms,1,[],https://github.com/tempesta-tech/tempesta/pull/1234,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1234,Update BUILD_EXCLUSIVE_KERNEL to 4.14.32 and remove unused modules,Update BUILD_EXCLUSIVE_KERNEL to 4.14.32 and remove unused modules,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1235,2019-03-29T18:54:44Z,2019-03-29T19:08:17Z,2019-03-29T19:08:21Z,MERGED,True,28,8,1,https://github.com/avbelov23,Request non-specific cryptographic modules,1,[],https://github.com/tempesta-tech/tempesta/pull/1235,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1235,"Requires #1224
We request non-specific cryptographic modules, since on some virtual machines there is no bmi2 instruction set needed for avx2 cryptographic modules","Requires #1224
We request non-specific cryptographic modules, since on some virtual machines there is no bmi2 instruction set needed for avx2 cryptographic modules",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1236,2019-03-29T19:01:43Z,2019-03-29T19:08:26Z,2019-03-29T20:16:26Z,MERGED,True,8,23,4,https://github.com/avbelov23,Update dmks,1,[],https://github.com/tempesta-tech/tempesta/pull/1236,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1236,"Requires #1218
Update BUILD_EXCLUSIVE_KERNEL to 4.14.32 and remove unused modules","Requires #1218
Update BUILD_EXCLUSIVE_KERNEL to 4.14.32 and remove unused modules",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1237,2019-03-29T20:10:10Z,2019-03-29T20:14:39Z,2019-03-29T20:16:10Z,MERGED,True,1,1,1,https://github.com/avbelov23,Update install script,1,[],https://github.com/tempesta-tech/tempesta/pull/1237,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1237,Requires #1218,Requires #1218,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1238,2019-03-29T21:18:34Z,2019-03-30T20:26:38Z,2019-03-30T20:26:41Z,MERGED,True,82,0,1,https://github.com/ikoveshnikov,Add changelog,1,[],https://github.com/tempesta-tech/tempesta/pull/1238,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1238,"Writing a good changelog is very time consuming and manual operation, which is not compatible with CD. When a new feature is implemented or issue is fixed, author should apply changes to CHANGELOG.md. If it would be so, then chandgelog generation for binary packages can be created automatically in CD.","Writing a good changelog is very time consuming and manual operation, which is not compatible with CD. When a new feature is implemented or issue is fixed, author should apply changes to CHANGELOG.md. If it would be so, then chandgelog generation for binary packages can be created automatically in CD.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1238,2019-03-29T21:18:34Z,2019-03-30T20:26:38Z,2019-03-30T20:26:41Z,MERGED,True,82,0,1,https://github.com/ikoveshnikov,Add changelog,1,[],https://github.com/tempesta-tech/tempesta/pull/1238,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/1238#issuecomment-478286707,"Writing a good changelog is very time consuming and manual operation, which is not compatible with CD. When a new feature is implemented or issue is fixed, author should apply changes to CHANGELOG.md. If it would be so, then chandgelog generation for binary packages can be created automatically in CD.","I'm not sure whthere it makes sense to log each closed issue to the file because of quick pollution by minor changes probably not so interested to users

Agreed. I was thinking about that and came to conclusion, that the change log is list of major changes that can significantly affect user experience: crucial  issue fixes, new features, incompatible changes. So the changelog only contains major changes.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1239,2019-03-29T21:19:55Z,2019-03-30T20:26:49Z,2019-03-30T20:26:56Z,MERGED,True,78,0,1,https://github.com/ikoveshnikov,Add changelog for release-0.6,1,[],https://github.com/tempesta-tech/tempesta/pull/1239,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1239,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1240,2019-04-01T12:10:08Z,2019-04-02T06:17:48Z,2019-04-02T06:17:54Z,MERGED,True,5,0,1,https://github.com/avbelov23,Warn about non-AVX2 build at run time,1,[],https://github.com/tempesta-tech/tempesta/pull/1240,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1240,Required for #1229,Required for #1229,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1241,2019-04-03T20:53:52Z,2019-05-06T18:36:03Z,2019-05-06T18:36:11Z,MERGED,True,16,1,1,https://github.com/i-rinat,"tls: avoid updating the checksum with contents of ""Finished"" message",1,[],https://github.com/tempesta-tech/tempesta/pull/1241,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1241,"Sometimes, data come in pieces, and the Finished message may become split into two or more parts. In that case ttls_recv() gets T_POSTPONE from ttls_handshake_step() and feeds the received bytes from the Finished message the the (handshake_messages) checksum, which is not the desired behavior. The patch avoids that by making state TTLS_CLIENT_FINISHED non-checksummable.
As ttls_handshake_server_step() returns T_OK after each part successfully parsed, all data before Finished message will always be checksummed as required.","Sometimes, data come in pieces, and the Finished message may become split into two or more parts. In that case ttls_recv() gets T_POSTPONE from ttls_handshake_step() and feeds the received bytes from the Finished message the the (handshake_messages) checksum, which is not the desired behavior. The patch avoids that by making state TTLS_CLIENT_FINISHED non-checksummable.
As ttls_handshake_server_step() returns T_OK after each part successfully parsed, all data before Finished message will always be checksummed as required.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1241,2019-04-03T20:53:52Z,2019-05-06T18:36:03Z,2019-05-06T18:36:11Z,MERGED,True,16,1,1,https://github.com/i-rinat,"tls: avoid updating the checksum with contents of ""Finished"" message",1,[],https://github.com/tempesta-tech/tempesta/pull/1241,https://github.com/i-rinat,2,https://github.com/tempesta-tech/tempesta/pull/1241#issuecomment-486001880,"Sometimes, data come in pieces, and the Finished message may become split into two or more parts. In that case ttls_recv() gets T_POSTPONE from ttls_handshake_step() and feeds the received bytes from the Finished message the the (handshake_messages) checksum, which is not the desired behavior. The patch avoids that by making state TTLS_CLIENT_FINISHED non-checksummable.
As ttls_handshake_server_step() returns T_OK after each part successfully parsed, all data before Finished message will always be checksummed as required.","if there are no ideas how to make the code better, then at least a good comment explaining each state check is required for ttls_hs_checksumable().

I found no sensible way to change the current checksumming scheme, so I just added a comment with explanation. More to that, checksumming comment in ttls_parse_finished() was also extended, as I misunderstood the reason of including of client's Finished into the sum the first time I read the code.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1242,2019-04-03T21:24:09Z,2019-04-16T00:06:57Z,2019-04-16T00:07:11Z,MERGED,True,1,1,1,https://github.com/i-rinat,tls: change special pointer value to be detectable by IS_ERR_OR_NULL(),1,[],https://github.com/tempesta-tech/tempesta/pull/1242,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1242,"The value of tls->xfrm.ciphersuite_info may be a regular pointer, or a special value which is then detected by IS_ERR_OR_NULL(). To make detection work, pointer value should be inside [-4095, -1] interval. Previous value — 0xdead — wasn't in that interval, was treated as a regular pointer, and caused crashes.","The value of tls->xfrm.ciphersuite_info may be a regular pointer, or a special value which is then detected by IS_ERR_OR_NULL(). To make detection work, pointer value should be inside [-4095, -1] interval. Previous value — 0xdead — wasn't in that interval, was treated as a regular pointer, and caused crashes.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1243,2019-04-15T20:14:21Z,2019-04-16T10:53:33Z,2019-04-16T10:53:37Z,MERGED,True,2,1,1,https://github.com/i-rinat,tls: TlsMdCtx requires 16 bytes more of storage,1,[],https://github.com/tempesta-tech/tempesta/pull/1243,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1243,"HMAC algorithm ""hmac(sha384)"" uses sizeof(struct sha512_state) bytes of storage for its ""sha384"" inner part and additional sizeof(struct shash_desc) for the ""hmac"" wrapper. See hmac_init_tfm() implementation for details (/crypto/hmac.c in the kernel).","HMAC algorithm ""hmac(sha384)"" uses sizeof(struct sha512_state) bytes of storage for its ""sha384"" inner part and additional sizeof(struct shash_desc) for the ""hmac"" wrapper. See hmac_init_tfm() implementation for details (/crypto/hmac.c in the kernel).",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1244,2019-04-15T20:17:15Z,2019-04-16T10:55:47Z,2019-04-16T10:55:50Z,MERGED,True,2,1,1,https://github.com/i-rinat,tls: TlsMdCtx requires 16 bytes more of storage (backport to 0.6),1,[],https://github.com/tempesta-tech/tempesta/pull/1244,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1244,"HMAC algorithm ""hmac(sha384)"" uses sizeof(struct sha512_state) bytes of storage for its ""sha384"" inner part and additional sizeof(struct shash_desc) for the ""hmac"" wrapper. See hmac_init_tfm() implementation for details (/crypto/hmac.c in the kernel).
(Backporting #1243 to release-0.6)","HMAC algorithm ""hmac(sha384)"" uses sizeof(struct sha512_state) bytes of storage for its ""sha384"" inner part and additional sizeof(struct shash_desc) for the ""hmac"" wrapper. See hmac_init_tfm() implementation for details (/crypto/hmac.c in the kernel).
(Backporting #1243 to release-0.6)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1245,2019-04-16T00:10:26Z,2019-04-16T10:56:23Z,2019-04-16T10:56:27Z,MERGED,True,1,1,1,https://github.com/i-rinat,tls: change special pointer value to be detectable by IS_ERR_OR_NULL() (backport to 0.6),1,[],https://github.com/tempesta-tech/tempesta/pull/1245,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1245,"The value of tls->xfrm.ciphersuite_info may be a regular pointer, or a special value which is then detected by IS_ERR_OR_NULL(). To make detection work, pointer value should be inside [-4095, -1] interval. Previous value — 0xdead — wasn't in that interval, was treated as a regular pointer, and caused crashes.
(Backporting of #1242 to release-0.6)","The value of tls->xfrm.ciphersuite_info may be a regular pointer, or a special value which is then detected by IS_ERR_OR_NULL(). To make detection work, pointer value should be inside [-4095, -1] interval. Previous value — 0xdead — wasn't in that interval, was treated as a regular pointer, and caused crashes.
(Backporting of #1242 to release-0.6)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1247,2019-04-25T13:20:37Z,2019-04-25T14:21:12Z,2019-04-25T14:21:16Z,MERGED,True,61,60,35,https://github.com/i-rinat,typo fixes,1,[],https://github.com/tempesta-tech/tempesta/pull/1247,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1247,Fix some typos in the comments and strings.,Fix some typos in the comments and strings.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1248,2019-04-25T13:37:07Z,2019-04-25T14:25:04Z,2019-04-25T14:25:08Z,MERGED,True,60,59,34,https://github.com/i-rinat,typo fixes (release-0.6),1,[],https://github.com/tempesta-tech/tempesta/pull/1248,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1248,"Fix some typos in the comments and strings.
(backport of #1247)","Fix some typos in the comments and strings.
(backport of #1247)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1249,2019-05-06T13:53:38Z,2019-05-16T20:09:15Z,2019-05-16T20:19:37Z,MERGED,True,2806,76,16,https://github.com/krizhanovsky,Rewrite HTTP strings processing in assembler,9,[],https://github.com/tempesta-tech/tempesta/pull/1249,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1249,"Rewrite HTTP strings processing in assembler:

remove tls/dummy_headers
replace dynaic table initialization with static one
shrink tables size
small assembly optimizations

Introduce test_debug_relax() to avoid debug message drop on unit tests with debug.","Rewrite HTTP strings processing in assembler:

remove tls/dummy_headers
replace dynaic table initialization with static one
shrink tables size
small assembly optimizations

Introduce test_debug_relax() to avoid debug message drop on unit tests with debug.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1250,2019-05-06T18:41:02Z,2019-05-06T19:25:12Z,2019-05-06T19:25:15Z,MERGED,True,16,1,1,https://github.com/i-rinat,"tls: avoid updating the checksum with contents of ""Finished"" message (release-0.6)",1,[],https://github.com/tempesta-tech/tempesta/pull/1250,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1250,(backport of #1241 to release-0.6),(backport of #1241 to release-0.6),True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1251,2019-05-06T20:56:26Z,2019-05-13T19:02:28Z,2019-05-14T14:19:29Z,CLOSED,False,145,66,4,https://github.com/i-rinat,tls: check union field accesses in TlsHandshake,2,[],https://github.com/tempesta-tech/tempesta/pull/1251,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1251,"During early stages of handshake process code calculates both sha384 and sha256 sums. Context for the latter is stored where ecdh_ctx is located. It turned out that there are access clashes in the code, and ecdh_ctx may be changed while sha256 sum is still in the process of calculation.
The patchset has a patch for fixing the clash, and another patch, that adds a way to determine such clashes at runtime in debug builds.
Upd. During PR discussion it was found that although there were accesses to edch_ctx while its storage is used for sha256 context, there is no possibility of sha256 context corruption. So it's safe, and this PR doesn't fix anything, but only adds a framework of union field access tracking.","During early stages of handshake process code calculates both sha384 and sha256 sums. Context for the latter is stored where ecdh_ctx is located. It turned out that there are access clashes in the code, and ecdh_ctx may be changed while sha256 sum is still in the process of calculation.
The patchset has a patch for fixing the clash, and another patch, that adds a way to determine such clashes at runtime in debug builds.
Upd. During PR discussion it was found that although there were accesses to edch_ctx while its storage is used for sha256 context, there is no possibility of sha256 context corruption. So it's safe, and this PR doesn't fix anything, but only adds a framework of union field access tracking.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1251,2019-05-06T20:56:26Z,2019-05-13T19:02:28Z,2019-05-14T14:19:29Z,CLOSED,False,145,66,4,https://github.com/i-rinat,tls: check union field accesses in TlsHandshake,2,[],https://github.com/tempesta-tech/tempesta/pull/1251,https://github.com/i-rinat,2,https://github.com/tempesta-tech/tempesta/pull/1251#issuecomment-491945992,"During early stages of handshake process code calculates both sha384 and sha256 sums. Context for the latter is stored where ecdh_ctx is located. It turned out that there are access clashes in the code, and ecdh_ctx may be changed while sha256 sum is still in the process of calculation.
The patchset has a patch for fixing the clash, and another patch, that adds a way to determine such clashes at runtime in debug builds.
Upd. During PR discussion it was found that although there were accesses to edch_ctx while its storage is used for sha256 context, there is no possibility of sha256 context corruption. So it's safe, and this PR doesn't fix anything, but only adds a framework of union field access tracking.",Extracted the non-disputed parts of this PR into #1254.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1253,2019-05-09T21:15:45Z,2019-05-17T21:51:22Z,2019-05-17T21:52:11Z,MERGED,True,87,34,1,https://github.com/krizhanovsky,"Fix #1157, multiple bugs in sending_302 & sending_302_without_preparing tests",1,[],https://github.com/tempesta-tech/tempesta/pull/1253,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1253,"http_sticky_suite_setup() initializes mock.conn_req as TfwCliConn,
while it's declared as TfwConn => memory corruption;
tfw_connection_send() calls parser on mock.resp, while the actual
response was allocated in tfw_http_sticky_build_redirect() and
referenced by mock.req->resp only => bad memory reads;
tfw_http_sticky_build_redirect() uses lightweight message allocation
w/o h_tbl initialization => bad memory reads on parsing;
bad error handling - if tfw_http_sticky_build_redirect() fails, then
mock.req isn't freed and we must not zeroize it.","http_sticky_suite_setup() initializes mock.conn_req as TfwCliConn,
while it's declared as TfwConn => memory corruption;
tfw_connection_send() calls parser on mock.resp, while the actual
response was allocated in tfw_http_sticky_build_redirect() and
referenced by mock.req->resp only => bad memory reads;
tfw_http_sticky_build_redirect() uses lightweight message allocation
w/o h_tbl initialization => bad memory reads on parsing;
bad error handling - if tfw_http_sticky_build_redirect() fails, then
mock.req isn't freed and we must not zeroize it.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1254,2019-05-13T18:37:18Z,2019-05-14T14:41:50Z,2019-05-14T15:11:41Z,MERGED,True,51,16,3,https://github.com/i-rinat,"tls: merge dhm_ctx, ecdh_ctx, and tmp_sha256 fields into a union",1,[],https://github.com/tempesta-tech/tempesta/pull/1254,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1254,"As ecdh_ctx and dhm_ctx share same storage space, their constructors and destructors are now called in a more precise way.
It's not solely an optimization, but also a bugfix. Crashes were possible if client were to disconnect during initial stages of handshake processing. In that case ttls_ecdh_free() would have been called on incorrect data.","As ecdh_ctx and dhm_ctx share same storage space, their constructors and destructors are now called in a more precise way.
It's not solely an optimization, but also a bugfix. Crashes were possible if client were to disconnect during initial stages of handshake processing. In that case ttls_ecdh_free() would have been called on incorrect data.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1255,2019-05-14T15:10:48Z,2019-05-16T22:53:31Z,2019-05-16T22:55:50Z,MERGED,True,60,17,5,https://github.com/i-rinat,"tls: merge dhm_ctx, ecdh_ctx, and tmp_sha256 fields into a union",2,[],https://github.com/tempesta-tech/tempesta/pull/1255,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1255,"As ecdh_ctx and dhm_ctx share same storage space, their constructors and
destructors are now called in a more precise way.
(Backporting #1254, because it's not solely an optimization, but also a bugfix. Crashes were possible if client were to disconnect during initial stages of handshake processing. In that case ttls_ecdh_free() could be called on incorrect data.)","As ecdh_ctx and dhm_ctx share same storage space, their constructors and
destructors are now called in a more precise way.
(Backporting #1254, because it's not solely an optimization, but also a bugfix. Crashes were possible if client were to disconnect during initial stages of handshake processing. In that case ttls_ecdh_free() could be called on incorrect data.)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1255,2019-05-14T15:10:48Z,2019-05-16T22:53:31Z,2019-05-16T22:55:50Z,MERGED,True,60,17,5,https://github.com/i-rinat,"tls: merge dhm_ctx, ecdh_ctx, and tmp_sha256 fields into a union",2,[],https://github.com/tempesta-tech/tempesta/pull/1255,https://github.com/i-rinat,2,https://github.com/tempesta-tech/tempesta/pull/1255#issuecomment-493258283,"As ecdh_ctx and dhm_ctx share same storage space, their constructors and
destructors are now called in a more precise way.
(Backporting #1254, because it's not solely an optimization, but also a bugfix. Crashes were possible if client were to disconnect during initial stages of handshake processing. In that case ttls_ecdh_free() could be called on incorrect data.)","Changed version to 0.6.3, added changelog file entry.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1255,2019-05-14T15:10:48Z,2019-05-16T22:53:31Z,2019-05-16T22:55:50Z,MERGED,True,60,17,5,https://github.com/i-rinat,"tls: merge dhm_ctx, ecdh_ctx, and tmp_sha256 fields into a union",2,[],https://github.com/tempesta-tech/tempesta/pull/1255,https://github.com/i-rinat,3,https://github.com/tempesta-tech/tempesta/pull/1255#issuecomment-493258717,"As ecdh_ctx and dhm_ctx share same storage space, their constructors and
destructors are now called in a more precise way.
(Backporting #1254, because it's not solely an optimization, but also a bugfix. Crashes were possible if client were to disconnect during initial stages of handshake processing. In that case ttls_ecdh_free() could be called on incorrect data.)",Added 0.6.3 tag.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1256,2019-05-16T22:35:10Z,2019-05-16T22:41:29Z,2019-05-16T22:41:33Z,MERGED,True,0,1807,1,https://github.com/i-rinat,remove tempesta_fw/str_simd.c,1,[],https://github.com/tempesta-tech/tempesta/pull/1256,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1256,was accidentally added in 41739da,was accidentally added in 41739da,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1257,2019-05-17T08:32:33Z,2019-05-17T11:42:31Z,2019-05-17T11:42:39Z,MERGED,True,2,1,1,https://github.com/aleksostapenko,HTTP/1.1 enabled if no ALPN negotiated.,1,[],https://github.com/tempesta-tech/tempesta/pull/1257,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/1257,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1258,2019-05-26T00:17:37Z,2019-05-28T13:40:25Z,2019-05-28T13:41:03Z,MERGED,True,185,163,2,https://github.com/krizhanovsky,Improve HTTP parser code layout.,2,[],https://github.com/tempesta-tech/tempesta/pull/1258,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1258,"The most effort was for requests parsing as more performance crucia, but generic macros changes affet responses as well. The overall Tempesta performance is improved for ~3%.

Move rare HTTP methods to the end of the parser;
Most requests have no bodies, so move body parsing also to the end of the function;
Move FSM finishing code and return statement above the improbable states;
Use hot and cold label attributes to explicitly say which state transitions are more probable making the optimizer to generate better code layout;
Use -mno-vzeroupper since we do not have SSE instructions.

I tested performance with more or less realistic requests, but emphasizing the parser FSM states transition (many headers) instead of performance of particular state parser (e.g. long Cookie):
./wrk -t 2 -c 128 -d 30s --header 'Connection: keep-alive' --header 'Upgrade-Insecure-Requests: 1' --header 'User-Agent: Mozilla/5.0 (X11; Linux x86_64)' --header 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8' --header 'Accept-Encoding: gzip, deflate, sdch' --header 'Accept-Language: en-US,en;q=0.8,ru;q=0.6' --header 'Cookie: a=sdfasd; sdf=3242u389erfhhs; djcnjhe=sdfsdafsdj' http://192.168.100.4:80/

wrk was run on my host system with 2 cores (4 HT in total) and Tempesta FW ran in VM with 2 CPUs. Tempesta config:
listen 192.168.100.4:80;
srv_group default {
	server 127.0.0.1:8080; # apache
}
vhost default {
	proxy_pass default;
}
cache 1;
cache_fulfill * *;
http_chain {
	-> default;
}

The backend returned 3-byte file.","The most effort was for requests parsing as more performance crucia, but generic macros changes affet responses as well. The overall Tempesta performance is improved for ~3%.

Move rare HTTP methods to the end of the parser;
Most requests have no bodies, so move body parsing also to the end of the function;
Move FSM finishing code and return statement above the improbable states;
Use hot and cold label attributes to explicitly say which state transitions are more probable making the optimizer to generate better code layout;
Use -mno-vzeroupper since we do not have SSE instructions.

I tested performance with more or less realistic requests, but emphasizing the parser FSM states transition (many headers) instead of performance of particular state parser (e.g. long Cookie):
./wrk -t 2 -c 128 -d 30s --header 'Connection: keep-alive' --header 'Upgrade-Insecure-Requests: 1' --header 'User-Agent: Mozilla/5.0 (X11; Linux x86_64)' --header 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8' --header 'Accept-Encoding: gzip, deflate, sdch' --header 'Accept-Language: en-US,en;q=0.8,ru;q=0.6' --header 'Cookie: a=sdfasd; sdf=3242u389erfhhs; djcnjhe=sdfsdafsdj' http://192.168.100.4:80/

wrk was run on my host system with 2 cores (4 HT in total) and Tempesta FW ran in VM with 2 CPUs. Tempesta config:
listen 192.168.100.4:80;
srv_group default {
	server 127.0.0.1:8080; # apache
}
vhost default {
	proxy_pass default;
}
cache 1;
cache_fulfill * *;
http_chain {
	-> default;
}

The backend returned 3-byte file.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1259,2019-05-27T15:23:04Z,2019-05-28T13:18:28Z,2019-05-28T13:18:31Z,MERGED,True,17,10,1,https://github.com/i-rinat,tls: propagate sequence numbers through the touched parts of tcp write queue,3,[],https://github.com/tempesta-tech/tempesta/pull/1259,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1259,"Currently, we encrypt data in TLS connections in tfw_tls_encrypt(), and during that operation, data chunks are enlarged to fit auxiliary data. As TCP sequence numbers are calculated earlier, we adjust the numbers on the go. To reduce TLS overhead, multiple skb's are aggregated into a single record if possible.
The patchset corrects sequence number calculation in the case where skb's are actually aggregated. Also, couple of side issues are addressed too: a NULL dereference and spurious WARN_ON assertion triggering.
(fixes #1177)","Currently, we encrypt data in TLS connections in tfw_tls_encrypt(), and during that operation, data chunks are enlarged to fit auxiliary data. As TCP sequence numbers are calculated earlier, we adjust the numbers on the go. To reduce TLS overhead, multiple skb's are aggregated into a single record if possible.
The patchset corrects sequence number calculation in the case where skb's are actually aggregated. Also, couple of side issues are addressed too: a NULL dereference and spurious WARN_ON assertion triggering.
(fixes #1177)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1260,2019-05-27T15:27:16Z,2019-05-28T13:19:00Z,2019-05-28T13:19:06Z,MERGED,True,17,10,1,https://github.com/i-rinat,tls: propagate sequence numbers through the touched parts of tcp write queue (release-0.6),3,[],https://github.com/tempesta-tech/tempesta/pull/1260,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1260,"Currently, we encrypt data in TLS connections in tfw_tls_encrypt(), and during that operation, data chunks are enlarged to fit auxiliary data. As TCP sequence numbers are calculated earlier, we adjust the numbers on the go. To reduce TLS overhead, multiple skb's are aggregated into a single record if possible.
The patchset corrects sequence number calculation in the case where skb's are actually aggregated. Also, couple of side issues are addressed too: a NULL dereference and spurious WARN_ON assertion triggering.
(backport of #1259)","Currently, we encrypt data in TLS connections in tfw_tls_encrypt(), and during that operation, data chunks are enlarged to fit auxiliary data. As TCP sequence numbers are calculated earlier, we adjust the numbers on the go. To reduce TLS overhead, multiple skb's are aggregated into a single record if possible.
The patchset corrects sequence number calculation in the case where skb's are actually aggregated. Also, couple of side issues are addressed too: a NULL dereference and spurious WARN_ON assertion triggering.
(backport of #1259)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1260,2019-05-27T15:27:16Z,2019-05-28T13:19:00Z,2019-05-28T13:19:06Z,MERGED,True,17,10,1,https://github.com/i-rinat,tls: propagate sequence numbers through the touched parts of tcp write queue (release-0.6),3,[],https://github.com/tempesta-tech/tempesta/pull/1260,https://github.com/i-rinat,2,https://github.com/tempesta-tech/tempesta/pull/1260#issuecomment-496308923,"Currently, we encrypt data in TLS connections in tfw_tls_encrypt(), and during that operation, data chunks are enlarged to fit auxiliary data. As TCP sequence numbers are calculated earlier, we adjust the numbers on the go. To reduce TLS overhead, multiple skb's are aggregated into a single record if possible.
The patchset corrects sequence number calculation in the case where skb's are actually aggregated. Also, couple of side issues are addressed too: a NULL dereference and spurious WARN_ON assertion triggering.
(backport of #1259)",Synchronized changes with #1259.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1262,2019-05-29T13:49:44Z,2019-06-03T18:14:56Z,2019-06-03T18:15:31Z,MERGED,True,32,14,2,https://github.com/i-rinat,tls: skip excessive cipher suites in ClientHello,1,[],https://github.com/tempesta-tech/tempesta/pull/1262,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1262,"We have a limited space for storing cipher suites declared by a client. There is enough room to store usually sent lists, but there are no room to store all possible lists which may be quite large and exceed 16 KiB. As no sane client will ever send such lists, and since the most important cipher suites are to be mentioned early, we may and should skip and forget the remainder to be able to continue ClientHello parsing.
(fixes #1261)","We have a limited space for storing cipher suites declared by a client. There is enough room to store usually sent lists, but there are no room to store all possible lists which may be quite large and exceed 16 KiB. As no sane client will ever send such lists, and since the most important cipher suites are to be mentioned early, we may and should skip and forget the remainder to be able to continue ClientHello parsing.
(fixes #1261)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1263,2019-05-29T13:52:20Z,2019-06-03T18:18:51Z,2019-06-03T18:18:55Z,MERGED,True,32,14,2,https://github.com/i-rinat,tls: skip excessive cipher suites in ClientHello (release-0.6),1,['backport'],https://github.com/tempesta-tech/tempesta/pull/1263,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1263,"We have a limited space for storing cipher suites declared by a client. There is enough room to store usually sent lists, but there are no room to store all possible lists which may be quite large and exceed 16 KiB. As no sane client will ever send such lists, and since the most important cipher suites are to be mentioned early, we may and should skip and forget the remainder to be able to continue ClientHello parsing.
(backport of #1262)","We have a limited space for storing cipher suites declared by a client. There is enough room to store usually sent lists, but there are no room to store all possible lists which may be quite large and exceed 16 KiB. As no sane client will ever send such lists, and since the most important cipher suites are to be mentioned early, we may and should skip and forget the remainder to be able to continue ClientHello parsing.
(backport of #1262)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1264,2019-05-29T15:55:12Z,2019-07-01T16:02:34Z,2019-07-01T16:02:42Z,MERGED,True,115,12,7,https://github.com/avbelov23,"tls: encrypting in new sk_buff pages, if `sendfile()` is used or response from cache",1,[],https://github.com/tempesta-tech/tempesta/pull/1264,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1264,"#1217
Transfer the tx_flags to the new skb_buff and encrypt in the new sk_buff pages if SKBTX_SHARED_FRAG is set or response from cache when send response via https.","#1217
Transfer the tx_flags to the new skb_buff and encrypt in the new sk_buff pages if SKBTX_SHARED_FRAG is set or response from cache when send response via https.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1264,2019-05-29T15:55:12Z,2019-07-01T16:02:34Z,2019-07-01T16:02:42Z,MERGED,True,115,12,7,https://github.com/avbelov23,"tls: encrypting in new sk_buff pages, if `sendfile()` is used or response from cache",1,[],https://github.com/tempesta-tech/tempesta/pull/1264,https://github.com/avbelov23,2,https://github.com/tempesta-tech/tempesta/pull/1264#issuecomment-504058582,"#1217
Transfer the tx_flags to the new skb_buff and encrypt in the new sk_buff pages if SKBTX_SHARED_FRAG is set or response from cache when send response via https.",DONE,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1266,2019-06-05T18:34:14Z,2019-07-01T13:51:59Z,2019-07-01T13:53:12Z,MERGED,True,99,43,6,https://github.com/i-rinat,vhost selection by sticky sessions,2,[],https://github.com/tempesta-tech/tempesta/pull/1266,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1266,"The patchset adds vhost caching in HTTP sessions. We now save vhost after the first request in a session is processed, and then reuse it for other requests in the session, thus avoiding the selection procedure which may be quite costly.
(fixes #1043)","The patchset adds vhost caching in HTTP sessions. We now save vhost after the first request in a session is processed, and then reuse it for other requests in the session, thus avoiding the selection procedure which may be quite costly.
(fixes #1043)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1266,2019-06-05T18:34:14Z,2019-07-01T13:51:59Z,2019-07-01T13:53:12Z,MERGED,True,99,43,6,https://github.com/i-rinat,vhost selection by sticky sessions,2,[],https://github.com/tempesta-tech/tempesta/pull/1266,https://github.com/i-rinat,2,https://github.com/tempesta-tech/tempesta/pull/1266#issuecomment-499641846,"The patchset adds vhost caching in HTTP sessions. We now save vhost after the first request in a session is processed, and then reuse it for other requests in the session, thus avoiding the selection procedure which may be quite costly.
(fixes #1043)",Changed code to address review comments. However there is still functional tests failure — investigating that.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1266,2019-06-05T18:34:14Z,2019-07-01T13:51:59Z,2019-07-01T13:53:12Z,MERGED,True,99,43,6,https://github.com/i-rinat,vhost selection by sticky sessions,2,[],https://github.com/tempesta-tech/tempesta/pull/1266,https://github.com/i-rinat,3,https://github.com/tempesta-tech/tempesta/pull/1266#issuecomment-506057348,"The patchset adds vhost caching in HTTP sessions. We now save vhost after the first request in a session is processed, and then reuse it for other requests in the session, thus avoiding the selection procedure which may be quite costly.
(fixes #1043)","There was a bug in the previous version of the patchset: reference to a vhost was stored in a session, which through indirection held references to server groups. After configuration reload that references were keeping server group structures in zombie state — not dead, but also not functional, since schedulers were removed from them. That caused 502 responses emitted until client closed their connection.
The issue was resolved by introducing a flag into TfwVhost. It's set during reconfiguration (in tfw_cfgop_vhosts_list_free()) and checked when we are about to reuse cached vhost in tfw_http_sess_obtain().",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1266,2019-06-05T18:34:14Z,2019-07-01T13:51:59Z,2019-07-01T13:53:12Z,MERGED,True,99,43,6,https://github.com/i-rinat,vhost selection by sticky sessions,2,[],https://github.com/tempesta-tech/tempesta/pull/1266,https://github.com/i-rinat,4,https://github.com/tempesta-tech/tempesta/pull/1266#issuecomment-506060196,"The patchset adds vhost caching in HTTP sessions. We now save vhost after the first request in a session is processed, and then reuse it for other requests in the session, thus avoiding the selection procedure which may be quite costly.
(fixes #1043)","thus vhost->main_sg becomes invalid

@ikoveshnikov,
As far as I understand the code, TfwVhost holds a reference to main_sg, indirectly, through instances of TfwLocation. So if TfwVhost instance is alive, so are dependent instances of TfwSrvGroup. That's why I think this is not an issue.
What may happen is zombie TfwSrvGroup, which holds memory, but has ->sched_data cleared. It's not functional, but still safe to access, so no crashes, but misbehavior instead. I believe that issue was addressed in recent changes: by checking if TfwVhost instance was abandoned (TFW_VHOST_B_INVALID bit in flags).",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1267,2019-06-06T20:09:56Z,2019-06-07T20:00:20Z,2019-06-07T20:00:23Z,MERGED,True,1,1,1,https://github.com/i-rinat,fixing a typo in a message,1,[],https://github.com/tempesta-tech/tempesta/pull/1267,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1267,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1268,2019-06-06T20:58:37Z,2019-07-08T13:12:57Z,2019-07-08T13:13:00Z,MERGED,True,0,2,1,https://github.com/kevgs,cleanup tfw_addr_ifmatch() tfw_addr_eq(),1,[],https://github.com/tempesta-tech/tempesta/pull/1268,https://github.com/kevgs,1,https://github.com/tempesta-tech/tempesta/pull/1268,"Remove misleading TODO: v6 case is alredy the same as v4 one.
Replace direct sockaddr_in::sin6_port access with accessor
function tfw_addr_port().","Remove misleading TODO: v6 case is alredy the same as v4 one.
Replace direct sockaddr_in::sin6_port access with accessor
function tfw_addr_port().",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1268,2019-06-06T20:58:37Z,2019-07-08T13:12:57Z,2019-07-08T13:13:00Z,MERGED,True,0,2,1,https://github.com/kevgs,cleanup tfw_addr_ifmatch() tfw_addr_eq(),1,[],https://github.com/tempesta-tech/tempesta/pull/1268,https://github.com/i-rinat,2,https://github.com/tempesta-tech/tempesta/pull/1268#issuecomment-499856839,"Remove misleading TODO: v6 case is alredy the same as v4 one.
Replace direct sockaddr_in::sin6_port access with accessor
function tfw_addr_port().","I still don't feel comfortable with the statement that this PR close #774, since it doesn't. The issue was solved already, and this patch is a cleanup, not a fix.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1268,2019-06-06T20:58:37Z,2019-07-08T13:12:57Z,2019-07-08T13:13:00Z,MERGED,True,0,2,1,https://github.com/kevgs,cleanup tfw_addr_ifmatch() tfw_addr_eq(),1,[],https://github.com/tempesta-tech/tempesta/pull/1268,https://github.com/kevgs,3,https://github.com/tempesta-tech/tempesta/pull/1268#issuecomment-499868139,"Remove misleading TODO: v6 case is alredy the same as v4 one.
Replace direct sockaddr_in::sin6_port access with accessor
function tfw_addr_port().","Right, this is just cleanup. Commit message is fixed.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1268,2019-06-06T20:58:37Z,2019-07-08T13:12:57Z,2019-07-08T13:13:00Z,MERGED,True,0,2,1,https://github.com/kevgs,cleanup tfw_addr_ifmatch() tfw_addr_eq(),1,[],https://github.com/tempesta-tech/tempesta/pull/1268,https://github.com/i-rinat,4,https://github.com/tempesta-tech/tempesta/pull/1268#issuecomment-509219103,"Remove misleading TODO: v6 case is alredy the same as v4 one.
Replace direct sockaddr_in::sin6_port access with accessor
function tfw_addr_port().","I've removed from the patch calls to tfw_addr_port(), as we are already in the file implementing tfw_addr_*, next condition expression explicitly uses IPv6 parts of the address, so there is no sense in hiding implementation inside the implementation.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1271,2019-06-17T11:14:44Z,2019-08-10T17:21:17Z,2019-08-10T17:21:27Z,MERGED,True,978,533,20,https://github.com/aleksostapenko,Incorporation of HTTP/2 processing into general HTTP logic (#309).,10,[],https://github.com/tempesta-tech/tempesta/pull/1271,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/1271,"Changes in context of this PR:

Introducing TfwStream entity in common HTTP logic;
Removal of 'seq_queue' from HTTP/2 processing flow;
Introducing persistent Stream<->Request linkage and synchronization logic for it;
Logic for receiving and assembling of HTTP/2 request;
Common logic for HTTP/2 response (server, error or cache) processing.","Changes in context of this PR:

Introducing TfwStream entity in common HTTP logic;
Removal of 'seq_queue' from HTTP/2 processing flow;
Introducing persistent Stream<->Request linkage and synchronization logic for it;
Logic for receiving and assembling of HTTP/2 request;
Common logic for HTTP/2 response (server, error or cache) processing.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1272,2019-06-17T16:15:35Z,2019-06-17T21:38:13Z,2019-06-17T21:43:56Z,MERGED,True,1,9,1,https://github.com/i-rinat,tls: remove redundant BUG_ON condition in ttls_parse_client_hello(),1,[],https://github.com/tempesta-tech/tempesta/pull/1272,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1272,"There is a BUG_ON statement in ttls_parse_client_hello() which was added to ensure ciphersuite_info is NULL if ciphersuite selection fails. Condition in the statement was inverted, and caused a false-positive (#1270).
One of the solutions was to fix the condition. But it was decided to remove BUG_ON() instead, as ciphersuite_info is set only in ttls_choose_ciphersuite(), and only if the latter succeeds. BUG_ON() therefore has no sense, and should be removed.
fixes #1270","There is a BUG_ON statement in ttls_parse_client_hello() which was added to ensure ciphersuite_info is NULL if ciphersuite selection fails. Condition in the statement was inverted, and caused a false-positive (#1270).
One of the solutions was to fix the condition. But it was decided to remove BUG_ON() instead, as ciphersuite_info is set only in ttls_choose_ciphersuite(), and only if the latter succeeds. BUG_ON() therefore has no sense, and should be removed.
fixes #1270",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1272,2019-06-17T16:15:35Z,2019-06-17T21:38:13Z,2019-06-17T21:43:56Z,MERGED,True,1,9,1,https://github.com/i-rinat,tls: remove redundant BUG_ON condition in ttls_parse_client_hello(),1,[],https://github.com/tempesta-tech/tempesta/pull/1272,https://github.com/i-rinat,2,https://github.com/tempesta-tech/tempesta/pull/1272#issuecomment-502851666,"There is a BUG_ON statement in ttls_parse_client_hello() which was added to ensure ciphersuite_info is NULL if ciphersuite selection fails. Condition in the statement was inverted, and caused a false-positive (#1270).
One of the solutions was to fix the condition. But it was decided to remove BUG_ON() instead, as ciphersuite_info is set only in ttls_choose_ciphersuite(), and only if the latter succeeds. BUG_ON() therefore has no sense, and should be removed.
fixes #1270","During discussion it was decided not to fix condition in BUG_ON(), but to remove it completely. See starting message for details.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1273,2019-06-17T21:48:01Z,2019-06-17T22:35:09Z,2019-06-17T22:35:13Z,MERGED,True,10,11,4,https://github.com/i-rinat,tls: BUG_ON condition in ttls_parse_client_hello() is redundant,2,['backport'],https://github.com/tempesta-tech/tempesta/pull/1273,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1273,"There is a BUG_ON statement in ttls_parse_client_hello() which was added to ensure ciphersuite_info is NULL if ciphersuite selection fails. Condition in the statement was inverted, and caused a false-positive (#1270).
One of the solutions was to fix the condition. But it was decided to remove BUG_ON() instead, as ciphersuite_info is set only in ttls_choose_ciphersuite(), and only if the latter succeeds. BUG_ON() therefore has no sense, and should be removed.
fixes #1270
backport of #1272","There is a BUG_ON statement in ttls_parse_client_hello() which was added to ensure ciphersuite_info is NULL if ciphersuite selection fails. Condition in the statement was inverted, and caused a false-positive (#1270).
One of the solutions was to fix the condition. But it was decided to remove BUG_ON() instead, as ciphersuite_info is set only in ttls_choose_ciphersuite(), and only if the latter succeeds. BUG_ON() therefore has no sense, and should be removed.
fixes #1270
backport of #1272",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1274,2019-06-24T14:00:42Z,2019-07-31T14:13:39Z,2019-07-31T14:13:44Z,MERGED,True,1198,557,21,https://github.com/ikoveshnikov,Per vhost TLS configuratio,16,[],https://github.com/tempesta-tech/tempesta/pull/1274,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1274,"#715
Changes:

Each vhost (virtual server in terms of TLS) may contain up to eight TLS certificates. Eight is just a magic number, no real technical requirements here. Normally you want 2 certificates: RSA and EC, and you may want to add a spare pair of them, so it seems that 8 is enough for everybody. Exact server certificate is chosen based on handshake arguments.
Vhost is chosen at handshake step according to Server Name extension header. Vhost name must be the same as the server name  in the extension header to determine correct vhost instance.
TLS configuration for default vhost have a special meaning. It's used when target vhost is not found in the vhost table or if no TLS keys are provided for desired vhost. This behaviour is configurable and can be enabled/disabled form the config file.
vhosts are now stored in RCU-protected hash table instead of simple linked list. Vhost search based on vhost name is possible as in both process and softirq contexts.
TLS configuration is split into two parts: general configuration, containing mostly callbacks which are the same for every vhost, and peer configuration, containg various information used at handshake  stage.
f_sni() callback behaviour is different from the previous behaviour in mbedTLS. It was designed to allocate key certificates wrappers in runtime at handshake stage, this was changed to preallocate the wrappers and use them on any tls connection to that vhost.","#715
Changes:

Each vhost (virtual server in terms of TLS) may contain up to eight TLS certificates. Eight is just a magic number, no real technical requirements here. Normally you want 2 certificates: RSA and EC, and you may want to add a spare pair of them, so it seems that 8 is enough for everybody. Exact server certificate is chosen based on handshake arguments.
Vhost is chosen at handshake step according to Server Name extension header. Vhost name must be the same as the server name  in the extension header to determine correct vhost instance.
TLS configuration for default vhost have a special meaning. It's used when target vhost is not found in the vhost table or if no TLS keys are provided for desired vhost. This behaviour is configurable and can be enabled/disabled form the config file.
vhosts are now stored in RCU-protected hash table instead of simple linked list. Vhost search based on vhost name is possible as in both process and softirq contexts.
TLS configuration is split into two parts: general configuration, containing mostly callbacks which are the same for every vhost, and peer configuration, containg various information used at handshake  stage.
f_sni() callback behaviour is different from the previous behaviour in mbedTLS. It was designed to allocate key certificates wrappers in runtime at handshake stage, this was changed to preallocate the wrappers and use them on any tls connection to that vhost.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1274,2019-06-24T14:00:42Z,2019-07-31T14:13:39Z,2019-07-31T14:13:44Z,MERGED,True,1198,557,21,https://github.com/ikoveshnikov,Per vhost TLS configuratio,16,[],https://github.com/tempesta-tech/tempesta/pull/1274,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/1274#issuecomment-515011667,"#715
Changes:

Each vhost (virtual server in terms of TLS) may contain up to eight TLS certificates. Eight is just a magic number, no real technical requirements here. Normally you want 2 certificates: RSA and EC, and you may want to add a spare pair of them, so it seems that 8 is enough for everybody. Exact server certificate is chosen based on handshake arguments.
Vhost is chosen at handshake step according to Server Name extension header. Vhost name must be the same as the server name  in the extension header to determine correct vhost instance.
TLS configuration for default vhost have a special meaning. It's used when target vhost is not found in the vhost table or if no TLS keys are provided for desired vhost. This behaviour is configurable and can be enabled/disabled form the config file.
vhosts are now stored in RCU-protected hash table instead of simple linked list. Vhost search based on vhost name is possible as in both process and softirq contexts.
TLS configuration is split into two parts: general configuration, containing mostly callbacks which are the same for every vhost, and peer configuration, containg various information used at handshake  stage.
f_sni() callback behaviour is different from the previous behaviour in mbedTLS. It was designed to allocate key certificates wrappers in runtime at handshake stage, this was changed to preallocate the wrappers and use them on any tls connection to that vhost.",I had to force-push to apply other TLS-related patches and resolve merge errors. Changes related to this PR only since last review: 7ae8485...d6aa46f,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1279,2019-06-28T13:25:51Z,2019-06-28T13:28:11Z,2019-06-28T13:29:01Z,MERGED,True,4,4,1,https://github.com/avbelov23,Replacing `ssl` with `tls` in config,1,[],https://github.com/tempesta-tech/tempesta/pull/1279,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1279,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1280,2019-06-28T14:48:29Z,2019-06-28T15:12:03Z,2019-08-28T14:15:53Z,MERGED,True,4,1,1,https://github.com/krizhanovsky,#1277: fix TLS extension parsing,1,['crucial'],https://github.com/tempesta-tech/tempesta/pull/1280,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1280,"Fix fist TLS extension parsing, unfreed handshakes problem still exists.
The issue manifested itself on ClientHello records which had a zero-length extension at the end. Or generally a zero-length extension at the end of the buffer. We called TTLS_HS_FSM_MOVE(), which jumped out of the automaton, and caused T_POSTPONE to be returned to the caller despite a fully-parsed message.
By explicitly jumping to the next state, we give parser a chance to finish parsing.","Fix fist TLS extension parsing, unfreed handshakes problem still exists.
The issue manifested itself on ClientHello records which had a zero-length extension at the end. Or generally a zero-length extension at the end of the buffer. We called TTLS_HS_FSM_MOVE(), which jumped out of the automaton, and caused T_POSTPONE to be returned to the caller despite a fully-parsed message.
By explicitly jumping to the next state, we give parser a chance to finish parsing.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1284,2019-06-30T00:44:25Z,2019-07-01T11:33:13Z,2019-07-01T11:33:16Z,MERGED,True,7,1,3,https://github.com/i-rinat,guard against NULL deref in tfw_client_for_each,2,[],https://github.com/tempesta-tech/tempesta/pull/1284,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1284,"May happen after initialization failure. To reproduce, add return -EINVAL to tfw_filter_start() before tdb_open() call.
Upd. During offline discussion it was decided to add guards to tfw_mods_start() and tfw_mods_end() too.","May happen after initialization failure. To reproduce, add return -EINVAL to tfw_filter_start() before tdb_open() call.
Upd. During offline discussion it was decided to add guards to tfw_mods_start() and tfw_mods_end() too.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1284,2019-06-30T00:44:25Z,2019-07-01T11:33:13Z,2019-07-01T11:33:16Z,MERGED,True,7,1,3,https://github.com/i-rinat,guard against NULL deref in tfw_client_for_each,2,[],https://github.com/tempesta-tech/tempesta/pull/1284,https://github.com/i-rinat,2,https://github.com/tempesta-tech/tempesta/pull/1284#issuecomment-507050652,"May happen after initialization failure. To reproduce, add return -EINVAL to tfw_filter_start() before tdb_open() call.
Upd. During offline discussion it was decided to add guards to tfw_mods_start() and tfw_mods_end() too.","Isn't it better to fix tfw_init()?

Could you please provide some details? I don't think I understand.
As far as I can see, tfw_init() is about registering modules, not really about calling their ""start"" or ""stop"" handlers. The issue happens when we start Tempesta, but fail during the process, in tfw_client_start(). Then we call ""stop"" handler of every module. So that at least requires that every module's ""stop"" handler must check that ""start"" was actually called and succeeded. They do so, but in tfw_sock_clnt_stop() function from another module is called: tfw_client_for_each(). It doesn't check if initialization of module ""client"" was successful, as modules care about themselves only. That leads to a NULL dereference.
So the only solution I can think of, is to add a NULL check to the tfw_client_for_each().",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1286,2019-07-01T16:37:17Z,2019-07-01T17:08:47Z,2019-07-01T21:43:32Z,MERGED,True,3,3,1,https://github.com/avbelov23,Fix compile error,1,[],https://github.com/tempesta-tech/tempesta/pull/1286,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1286,#1217,#1217,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1288,2019-07-01T19:12:02Z,2019-07-01T21:37:06Z,2019-07-01T21:43:49Z,MERGED,True,1,1,1,https://github.com/avbelov23,Initialization `pages_end`,1,[],https://github.com/tempesta-tech/tempesta/pull/1288,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1288,#1287 #1217,#1287 #1217,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1289,2019-07-01T23:33:01Z,2019-07-02T12:16:07Z,2019-07-02T12:16:10Z,MERGED,True,2,0,1,https://github.com/i-rinat,hide BUILD_BUG_ON in __parse_ulong in KASAN builds,1,[],https://github.com/tempesta-tech/tempesta/pull/1289,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1289,"Looks like optimizer doesn't eliminate integer divisions when address sanitizer is active. But the potential slowdown we care about doesn't really matter in KASAN builds anyway.
Since the patch BUILD_BUG_ON(!__builtin_constant_p((limit - 10) / 10)); was added in, one needs to comment that line if they try to build the code with KASAN enabled. That's a bit inconvenient.","Looks like optimizer doesn't eliminate integer divisions when address sanitizer is active. But the potential slowdown we care about doesn't really matter in KASAN builds anyway.
Since the patch BUILD_BUG_ON(!__builtin_constant_p((limit - 10) / 10)); was added in, one needs to comment that line if they try to build the code with KASAN enabled. That's a bit inconvenient.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1290,2019-07-01T23:39:15Z,2019-07-02T12:14:21Z,2019-07-02T12:14:29Z,MERGED,True,4,1,1,https://github.com/i-rinat,backport TLS extension parsing from #1280 to release 0.6 branch,1,['backport'],https://github.com/tempesta-tech/tempesta/pull/1290,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1290,see #1280,see #1280,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1291,2019-07-02T12:01:03Z,2019-07-02T18:10:34Z,2019-07-02T18:14:37Z,MERGED,True,239,154,11,https://github.com/avbelov23,"backport tls encrypting in new sk_buff pages, if `sendfile()` is used or response from cache, from #1264 to release 0.6 branch",6,[],https://github.com/tempesta-tech/tempesta/pull/1291,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1291,#1209 #1264 #1286 #1288,#1209 #1264 #1286 #1288,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1292,2019-07-03T12:15:31Z,2019-07-04T05:35:36Z,2019-07-04T05:35:39Z,MERGED,True,4,4,2,https://github.com/ikoveshnikov,tls: close connection if handshake is not done,1,[],https://github.com/tempesta-tech/tempesta/pull/1292,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1292,"tfw_tls_conn_close() is expected to close connection somehow. It either sends an alert via ttls_close_notify() which closes connection after data departure, or calls ss_close() explicitly if alert cannot be sent. However, ttls_close_notify() may return 0 if TLS handshake wasn't finished yet. In that case connection remains not closed, with keepalive timers armed. Unloading Tempesta from memory makes these timers to crash the kernel.
The patch ensures that connections are closed in all cases.
Fixes #1277.","tfw_tls_conn_close() is expected to close connection somehow. It either sends an alert via ttls_close_notify() which closes connection after data departure, or calls ss_close() explicitly if alert cannot be sent. However, ttls_close_notify() may return 0 if TLS handshake wasn't finished yet. In that case connection remains not closed, with keepalive timers armed. Unloading Tempesta from memory makes these timers to crash the kernel.
The patch ensures that connections are closed in all cases.
Fixes #1277.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1295,2019-07-03T23:24:40Z,2019-07-04T11:02:29Z,2019-07-04T11:02:46Z,MERGED,True,4,4,2,https://github.com/i-rinat,tls: close connection if handshake is not done (release-0.6),1,['backport'],https://github.com/tempesta-tech/tempesta/pull/1295,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1295,"tfw_tls_conn_close() is expected to close connection somehow. It either sends an alert via ttls_close_notify() which closes connection after data departure, or calls ss_close() explicitly if alert cannot be sent. However, ttls_close_notify() may return 0 if TLS handshake wasn't finished yet. In that case connection remains not closed, with keepalive timers armed. Unloading Tempesta from memory makes these timers to crash the kernel.
The patch ensures that connections are closed in all cases.
Backport of #1292.","tfw_tls_conn_close() is expected to close connection somehow. It either sends an alert via ttls_close_notify() which closes connection after data departure, or calls ss_close() explicitly if alert cannot be sent. However, ttls_close_notify() may return 0 if TLS handshake wasn't finished yet. In that case connection remains not closed, with keepalive timers armed. Unloading Tempesta from memory makes these timers to crash the kernel.
The patch ensures that connections are closed in all cases.
Backport of #1292.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1300,2019-07-09T23:22:26Z,2019-07-10T14:54:23Z,2019-07-10T14:54:27Z,MERGED,True,3,0,2,https://github.com/i-rinat,tls: fix decryption of a record spanning over multiple skbs,1,[],https://github.com/tempesta-tech/tempesta/pull/1300,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1300,"There was a couple of issues with parsing medium-sized requests.
First was about missing sg_unmark_end() after skb_to_sgvec(). Latter calls sg_mark_end(), so since we want to pack multiple skb's into a single scatter-list, we must undo the changes.
Second was about cutting TLS-specific data from skb's. We cut them, but only after a whole request is parsed. If a request spans over multiple skb's, information about data offset is lost, so we ended up with passing TLS auxiliary data to a backend. We need to cut data from the head while offset is still known.
Fixes #1299.","There was a couple of issues with parsing medium-sized requests.
First was about missing sg_unmark_end() after skb_to_sgvec(). Latter calls sg_mark_end(), so since we want to pack multiple skb's into a single scatter-list, we must undo the changes.
Second was about cutting TLS-specific data from skb's. We cut them, but only after a whole request is parsed. If a request spans over multiple skb's, information about data offset is lost, so we ended up with passing TLS auxiliary data to a backend. We need to cut data from the head while offset is still known.
Fixes #1299.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1301,2019-07-10T16:03:21Z,2019-07-10T21:39:33Z,2019-07-10T21:40:11Z,MERGED,True,3,0,2,https://github.com/i-rinat,tls: fix decryption of a record spanning over multiple skbs (release-0.6),1,['backport'],https://github.com/tempesta-tech/tempesta/pull/1301,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1301,"There was a couple of issues with parsing medium-sized requests.
First was about missing sg_unmark_end() after skb_to_sgvec(). Latter calls sg_mark_end(), so since we want to pack multiple skb's into a single scatter-list, we must undo the changes.
Second was about cutting TLS-specific data from skb's. We cut them, but only after a whole request is parsed. If a request spans over multiple skb's, information about data offset is lost, so we ended up with passing TLS auxiliary data to a backend. We need to cut data from the head while offset is still known.
Fixes #1299.
Backport of #1300.","There was a couple of issues with parsing medium-sized requests.
First was about missing sg_unmark_end() after skb_to_sgvec(). Latter calls sg_mark_end(), so since we want to pack multiple skb's into a single scatter-list, we must undo the changes.
Second was about cutting TLS-specific data from skb's. We cut them, but only after a whole request is parsed. If a request spans over multiple skb's, information about data offset is lost, so we ended up with passing TLS auxiliary data to a backend. We need to cut data from the head while offset is still known.
Fixes #1299.
Backport of #1300.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1303,2019-07-10T16:58:11Z,2019-07-10T21:39:07Z,2019-07-10T21:39:14Z,MERGED,True,1,1,1,https://github.com/i-rinat,fix a typo in a comment,1,[],https://github.com/tempesta-tech/tempesta/pull/1303,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1303,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1306,2019-07-14T18:20:48Z,2019-07-18T13:40:26Z,2019-07-18T13:42:10Z,MERGED,True,31,14,1,https://github.com/krizhanovsky,Verify extension length before accessing the data,2,[],https://github.com/tempesta-tech/tempesta/pull/1306,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1306,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1309,2019-07-18T15:47:20Z,2019-07-19T17:58:59Z,2019-07-19T17:59:03Z,MERGED,True,1,1,1,https://github.com/avbelov23,Fix warning,1,[],https://github.com/tempesta-tech/tempesta/pull/1309,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1309,"Fixes #1293
According to the formula (https://github.com/tempesta-tech/tempesta/blob/master/tls/bignum.c#L379) with ttls_mpi_bitlen (X) == 4096 we get 512. Therefore, we received a warning","Fixes #1293
According to the formula (https://github.com/tempesta-tech/tempesta/blob/master/tls/bignum.c#L379) with ttls_mpi_bitlen (X) == 4096 we get 512. Therefore, we received a warning",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1311,2019-07-18T21:59:43Z,2019-07-18T23:01:56Z,2019-07-18T23:02:00Z,MERGED,True,31,14,1,https://github.com/i-rinat,Verify extension length before accessing the data (release-0.6),2,['backport'],https://github.com/tempesta-tech/tempesta/pull/1311,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1311,"Avoid buffer overruns by checking length first.
Backport of #1306.","Avoid buffer overruns by checking length first.
Backport of #1306.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1313,2019-07-19T07:51:54Z,2019-07-19T14:36:43Z,2019-07-19T14:36:47Z,MERGED,True,34,8,1,https://github.com/ikoveshnikov,frang: ignore responses if request was originated by HealthMonitor,1,[],https://github.com/tempesta-tech/tempesta/pull/1313,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1313,"Health Monitor requests are generated by Tempesta itself thus
req->conn is NULL for them.
Fix #1312","Health Monitor requests are generated by Tempesta itself thus
req->conn is NULL for them.
Fix #1312",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1315,2019-07-19T15:50:02Z,2019-07-31T14:12:14Z,2019-07-31T14:12:31Z,MERGED,True,18,3,1,https://github.com/avbelov23,Release listen socket if error was,1,[],https://github.com/tempesta-tech/tempesta/pull/1315,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1315,#1314,#1314,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1315,2019-07-19T15:50:02Z,2019-07-31T14:12:14Z,2019-07-31T14:12:31Z,MERGED,True,18,3,1,https://github.com/avbelov23,Release listen socket if error was,1,[],https://github.com/tempesta-tech/tempesta/pull/1315,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/1315#issuecomment-514125433,#1314,"Some modules do clean up if startup fails (tfw_filter_start), some do not (tfw_sock_srv_start).

Yeah, thats a real mess. The TfwMod description must contain description of the of the module contract: when the cleanup functions are called and when - not. Since now only properly started modules are stopped, some doesn't invoke cleanup and the #1314 issue is actually deeper than it seemed.

But I'd prefer not doing that — to keep the clear semantics: one needs to stop only that what was properly started.

I don't see there real difference here. Anyway, clean up on the failed start is mostly the same as the stop() function.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1315,2019-07-19T15:50:02Z,2019-07-31T14:12:14Z,2019-07-31T14:12:31Z,MERGED,True,18,3,1,https://github.com/avbelov23,Release listen socket if error was,1,[],https://github.com/tempesta-tech/tempesta/pull/1315,https://github.com/i-rinat,3,https://github.com/tempesta-tech/tempesta/pull/1315#issuecomment-514226117,#1314,"I don't see there real difference here. Anyway, clean up on the failed start is mostly the same as the stop() function.

Yeah, if there were a significant differences I definitely would've described them. Instead, it's just a personal preference. I like it when APIs move complexity out of my way, thus reducing a number of things I have to worry about.

The TfwMod description must contain description of the of the module contract: when the cleanup functions are called and when - not.

I insist on not doing that. We should select one way and change remaining code to follow that. There is no benefit in having that flexibility, as it's an internal API, and we have the freedom to do as we please there.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1315,2019-07-19T15:50:02Z,2019-07-31T14:12:14Z,2019-07-31T14:12:31Z,MERGED,True,18,3,1,https://github.com/avbelov23,Release listen socket if error was,1,[],https://github.com/tempesta-tech/tempesta/pull/1315,https://github.com/ikoveshnikov,4,https://github.com/tempesta-tech/tempesta/pull/1315#issuecomment-515025915,#1314,@avbelov23 Have you looked to other modules? do we have the same issue anywhere else?,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1315,2019-07-19T15:50:02Z,2019-07-31T14:12:14Z,2019-07-31T14:12:31Z,MERGED,True,18,3,1,https://github.com/avbelov23,Release listen socket if error was,1,[],https://github.com/tempesta-tech/tempesta/pull/1315,https://github.com/avbelov23,5,https://github.com/tempesta-tech/tempesta/pull/1315#issuecomment-516279955,#1314,"What is the issue?

Some modules do clean up if startup fails (tfw_filter_start), some do not (tfw_sock_srv_start).

Is this issue?",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1315,2019-07-19T15:50:02Z,2019-07-31T14:12:14Z,2019-07-31T14:12:31Z,MERGED,True,18,3,1,https://github.com/avbelov23,Release listen socket if error was,1,[],https://github.com/tempesta-tech/tempesta/pull/1315,https://github.com/ikoveshnikov,6,https://github.com/tempesta-tech/tempesta/pull/1315#issuecomment-516310975,#1314,"Yes, that is.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1315,2019-07-19T15:50:02Z,2019-07-31T14:12:14Z,2019-07-31T14:12:31Z,MERGED,True,18,3,1,https://github.com/avbelov23,Release listen socket if error was,1,[],https://github.com/tempesta-tech/tempesta/pull/1315,https://github.com/avbelov23,7,https://github.com/tempesta-tech/tempesta/pull/1315#issuecomment-516820578,#1314,There is no issue in sock_srv. The release of resources occurs during the removal of servers from groups,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1316,2019-07-19T19:33:27Z,2019-07-22T22:51:43Z,2019-07-22T22:51:46Z,MERGED,True,6,7,1,https://github.com/i-rinat,tls: release spinlock before invoking gfsm move,1,[],https://github.com/tempesta-tech/tempesta/pull/1316,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1316,"Invoking the GFSM may cause other code to execute. If that code tries to send an immediate response, for example, on request parsing error, it will try to acquire tls->lock while it's held in tfw_tls_msg_process().
In fact that the way to reproduce the bug: send a malformed HTTPS request. Each such requests causes a deadlock. N such requests deadlock whole machine given it has N cores.","Invoking the GFSM may cause other code to execute. If that code tries to send an immediate response, for example, on request parsing error, it will try to acquire tls->lock while it's held in tfw_tls_msg_process().
In fact that the way to reproduce the bug: send a malformed HTTPS request. Each such requests causes a deadlock. N such requests deadlock whole machine given it has N cores.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1316,2019-07-19T19:33:27Z,2019-07-22T22:51:43Z,2019-07-22T22:51:46Z,MERGED,True,6,7,1,https://github.com/i-rinat,tls: release spinlock before invoking gfsm move,1,[],https://github.com/tempesta-tech/tempesta/pull/1316,https://github.com/i-rinat,2,https://github.com/tempesta-tech/tempesta/pull/1316#issuecomment-513816597,"Invoking the GFSM may cause other code to execute. If that code tries to send an immediate response, for example, on request parsing error, it will try to acquire tls->lock while it's held in tfw_tls_msg_process().
In fact that the way to reproduce the bug: send a malformed HTTPS request. Each such requests causes a deadlock. N such requests deadlock whole machine given it has N cores.","It's better to acquire it below next_msg, remove out_err (there is only one goto there), unlock the lock inside the IF statement, and remove the spin_unlock() at the end of the function.

Changed the patch according to the suggestion.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1317,2019-07-21T12:19:12Z,2019-07-23T14:53:33Z,2019-07-23T14:54:26Z,MERGED,True,64,12,2,https://github.com/krizhanovsky,TLS renegotiation: comliance to RFC 5746 3.6,1,[],https://github.com/tempesta-tech/tempesta/pull/1317,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1317,"While not supporting renegotiation we MUST parse renegotiation info extension and SCSV and send empty renegotiation info in ServerHello.
Check output of
$ openssl s_client -servername  -connect :443 -tls1_2 -CApath /etc/ssl/certs/
""Secure Renegotiation IS supported"" after the patch and ""Secure Renegotiation
IS NOT supported"" before. Command R for s_client leads to correct connection
termination by Tempesta TLS (see ""refusing renegotiation, sending alert"" message
in Tempesta debug log).
No need for backport.","While not supporting renegotiation we MUST parse renegotiation info extension and SCSV and send empty renegotiation info in ServerHello.
Check output of
$ openssl s_client -servername  -connect :443 -tls1_2 -CApath /etc/ssl/certs/
""Secure Renegotiation IS supported"" after the patch and ""Secure Renegotiation
IS NOT supported"" before. Command R for s_client leads to correct connection
termination by Tempesta TLS (see ""refusing renegotiation, sending alert"" message
in Tempesta debug log).
No need for backport.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1319,2019-07-22T23:02:41Z,2019-07-23T11:09:28Z,2019-07-23T11:10:25Z,MERGED,True,6,7,1,https://github.com/i-rinat,tls: release spinlock before invoking gfsm move (release-0.6),1,['backport'],https://github.com/tempesta-tech/tempesta/pull/1319,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1319,"Invoking the GFSM may cause other code to execute. If that code tries to send an immediate response, for example, on request parsing error, it will try to acquire tls->lock while it's held in tfw_tls_msg_process().
In fact that the way to reproduce the bug: send a malformed HTTPS request. Each such requests causes a deadlock. N such requests deadlock whole machine given it has N cores.
Backport of #1316.","Invoking the GFSM may cause other code to execute. If that code tries to send an immediate response, for example, on request parsing error, it will try to acquire tls->lock while it's held in tfw_tls_msg_process().
In fact that the way to reproduce the bug: send a malformed HTTPS request. Each such requests causes a deadlock. N such requests deadlock whole machine given it has N cores.
Backport of #1316.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1320,2019-07-22T23:09:05Z,2019-07-23T15:16:58Z,2019-07-23T15:17:01Z,MERGED,True,0,4,1,https://github.com/i-rinat,tls: remove unused macros,1,[],https://github.com/tempesta-tech/tempesta/pull/1320,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1320,There are macro definitions that are not used.,There are macro definitions that are not used.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1321,2019-07-23T14:25:11Z,2019-07-23T15:16:42Z,2019-07-23T15:16:46Z,MERGED,True,1,0,1,https://github.com/i-rinat,tests: stop Tempesta before starting unittests,1,[],https://github.com/tempesta-tech/tempesta/pull/1321,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1321,"Running unit tests on top of started Tempesta may lead to unwanted interference, so stop Tempesta before that.","Running unit tests on top of started Tempesta may lead to unwanted interference, so stop Tempesta before that.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1322,2019-07-23T23:42:01Z,2019-08-01T21:36:06Z,2019-08-01T21:36:10Z,MERGED,True,22,15,2,https://github.com/i-rinat,tls: ciphertexts larger than 16384 bytes,2,[],https://github.com/tempesta-tech/tempesta/pull/1322,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1322,"TLS records have plaintext size limitation, they cannot be larger than 2^14 bytes. However, ciphertext may be as large as 2^14 + 2048 bytes. But the plaintext obtained from that ciphertext should still be 2^14 bytes or smaller. We need to respect that limits precisely.
The patchset consists of two patches. One changes the limits, and other fixes a defect in the parsed bytes calculation.
Related to #1283, but doesn't fix it entirely yet.","TLS records have plaintext size limitation, they cannot be larger than 2^14 bytes. However, ciphertext may be as large as 2^14 + 2048 bytes. But the plaintext obtained from that ciphertext should still be 2^14 bytes or smaller. We need to respect that limits precisely.
The patchset consists of two patches. One changes the limits, and other fixes a defect in the parsed bytes calculation.
Related to #1283, but doesn't fix it entirely yet.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1322,2019-07-23T23:42:01Z,2019-08-01T21:36:06Z,2019-08-01T21:36:10Z,MERGED,True,22,15,2,https://github.com/i-rinat,tls: ciphertexts larger than 16384 bytes,2,[],https://github.com/tempesta-tech/tempesta/pull/1322,https://github.com/i-rinat,2,https://github.com/tempesta-tech/tempesta/pull/1322#issuecomment-517254379,"TLS records have plaintext size limitation, they cannot be larger than 2^14 bytes. However, ciphertext may be as large as 2^14 + 2048 bytes. But the plaintext obtained from that ciphertext should still be 2^14 bytes or smaller. We need to respect that limits precisely.
The patchset consists of two patches. One changes the limits, and other fixes a defect in the parsed bytes calculation.
Related to #1283, but doesn't fix it entirely yet.",(rebased to the current master branch state),True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1323,2019-07-24T13:25:13Z,2019-09-06T03:09:20Z,2019-09-06T03:09:24Z,MERGED,True,104,115,10,https://github.com/avbelov23,Close the connection after sending tls alerts in the queue,5,[],https://github.com/tempesta-tech/tempesta/pull/1323,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1323,"#1308


Close the socket after sending all pending data on TCP_CLOSE_WAIT and internal errors.


Close the connection after sending fatal tls alerts and close_notify alert in the queue


Not encryption for TTLS_SERVER_FINISHED, because encryption is done in ttls_write_finished().


Sending close_notify alert on close_notify alert.","#1308


Close the socket after sending all pending data on TCP_CLOSE_WAIT and internal errors.


Close the connection after sending fatal tls alerts and close_notify alert in the queue


Not encryption for TTLS_SERVER_FINISHED, because encryption is done in ttls_write_finished().


Sending close_notify alert on close_notify alert.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1323,2019-07-24T13:25:13Z,2019-09-06T03:09:20Z,2019-09-06T03:09:24Z,MERGED,True,104,115,10,https://github.com/avbelov23,Close the connection after sending tls alerts in the queue,5,[],https://github.com/tempesta-tech/tempesta/pull/1323,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/1323#issuecomment-517951892,"#1308


Close the socket after sending all pending data on TCP_CLOSE_WAIT and internal errors.


Close the connection after sending fatal tls alerts and close_notify alert in the queue


Not encryption for TTLS_SERVER_FINISHED, because encryption is done in ttls_write_finished().


Sending close_notify alert on close_notify alert.","Just saw kernel oops on CI http://93.115.28.191:4010/#/builders/5/builds/810/steps/21/logs/stdio:
[  479.832011] ------------[ cut here ]------------
[  479.834442] kernel BUG at /root/tempesta/tempesta/tempesta_fw/http.c:3058!
[  479.837687] invalid opcode: 0000 [#1] SMP PTI
[  479.840053] Modules linked in: tempesta_fw(O) tempesta_db(O) tempesta_tls(O) tempesta_lib(O) sha256_ssse3 sha512_ssse3 sha512_generic ccm fuse ata_generic intel_rapl sb_edac crct10dif_pclmul crc32_pclmul joydev ghash_clmulni_intel ata_piix cirrus ttm libata drm_kms_helper xen_netfront intel_rapl_perf psmouse pcspkr drm scsi_mod i2c_piix4 floppy button ip_tables x_tables autofs4 ext4 crc16 mbcache jbd2 crc32c_generic fscrypto ecb crc32c_intel aesni_intel evdev xen_blkfront aes_x86_64 crypto_simd cryptd glue_helper serio_raw [last unloaded: tempesta_lib]
[  479.860163] CPU: 1 PID: 0 Comm: swapper/1 Tainted: G           O    4.14.0-tempesta-amd64 #1 Debian 4.14.32-tfw6-1
[  479.864413] Hardware name: Xen HVM domU, BIOS 4.8.5 01/11/2019
[  479.867288] task: ffff9799007b9e00 task.stack: ffffb6ff80698000
[  479.870208] RIP: 0010:tfw_http_msg_process_generic+0x968/0xd00 [tempesta_fw]
[  479.873531] RSP: 0018:ffff97990f103970 EFLAGS: 00010216
[  479.876275] RAX: 0000000000000007 RBX: ffff9799019215f0 RCX: 0000000000000010
[  479.879614] RDX: ffff979904029000 RSI: ffff97990f103b50 RDI: ffff979904029600
[  479.882933] RBP: ffff9798b1682020 R08: 0000000000000001 R09: 0000000000000000
[  479.886277] R10: 0000000000000000 R11: ffff9798b16b6140 R12: ffff97990f103b50
[  479.889603] R13: 0000000000000000 R14: 0000000000000000 R15: ffff979904029600
[  479.892912] FS:  0000000000000000(0000) GS:ffff97990f100000(0000) knlGS:0000000000000000
[  479.896496] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  479.899417] CR2: 00007ff8c31215d8 CR3: 000000005c20a005 CR4: 00000000001606e0
[  479.902747] Call Trace:
[  479.904583]  <IRQ>
[  479.906282]  ? generic_gcmaes_decrypt+0x5f/0x80 [aesni_intel]
[  479.909139]  ? ttls_decrypt+0x297/0x580 [tempesta_tls]
[  479.911828]  tfw_http_msg_process+0x9e/0xe0 [tempesta_fw]
[  479.914610]  ? pg_skb_alloc+0x253/0x470
[  479.916842]  __gfsm_fsm_exec+0x56/0x90 [tempesta_fw]
[  479.919446]  ? skb_split+0x1ff/0x2e0
[  479.921594]  tfw_gfsm_move+0x132/0x160 [tempesta_fw]
[  479.924197]  tfw_tls_msg_process+0x1de/0x360 [tempesta_fw]
[  479.926930]  __gfsm_fsm_exec+0x56/0x90 [tempesta_fw]
[  479.929535]  tfw_connection_recv+0x4e/0x70 [tempesta_fw]
[  479.932232]  ? tfw_connection_send+0x30/0x30 [tempesta_fw]
[  479.935009]  ss_tcp_process_data+0x1db/0x440 [tempesta_fw]
[  479.937729]  ss_tcp_data_ready+0x43/0x90 [tempesta_fw]
[  479.940413]  tcp_rcv_established+0x4d2/0x570
[  479.942795]  tcp_v4_do_rcv+0x129/0x1d0
[  479.944992]  tcp_v4_rcv+0x947/0xa50
[  479.947092]  ip_local_deliver_finish+0x9a/0x1c0
[  479.949529]  ip_local_deliver+0x6b/0xe0
[  479.951714]  ? tcp_v4_early_demux+0x112/0x150
[  479.954011]  ? ip_rcv_finish+0x17a/0x400
[  479.956197]  ip_rcv+0x289/0x3c0
[  479.958134]  ? inet_del_offload+0x40/0x40
[  479.960302]  __netif_receive_skb_core+0x84f/0xb30
[  479.962713]  ? process_backlog+0xa3/0x160
[  479.964849]  process_backlog+0xa3/0x160
[  479.966961]  net_rx_action+0x28e/0x3f0
[  479.969026]  __do_softirq+0x10f/0x2a8
[  479.971078]  irq_exit+0xae/0xb0
[  479.972953]  xen_evtchn_do_upcall+0x2c/0x40
[  479.975072]  xen_hvm_callback_vector+0x7d/0x90
[  479.977231]  </IRQ>
[  479.978667] RIP: 0010:native_safe_halt+0x2/0x10
[  479.980787] RSP: 0018:ffffb6ff8069beb8 EFLAGS: 00000246 ORIG_RAX: ffffffffffffff0c
[  479.983908] RAX: ffffffffbc897e60 RBX: ffff9799007b9e00 RCX: 0000000000000000
[  479.986907] RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000
[  479.989835] RBP: 0000000000000001 R08: 00000000593296c0 R09: ffff979901a3ef00
[  479.992813] R10: 0000000000000000 R11: 0000013cfadf1cfb R12: ffff9799007b9e00
[  479.995780] R13: ffff9799007b9e00 R14: 0000000000000000 R15: 0000000000000000
[  479.998696]  ? __sched_text_end+0x3/0x3
[  480.000585]  default_idle+0x1a/0xf0
[  480.002339]  do_idle+0x16e/0x1f0
[  480.004029]  cpu_startup_entry+0x6f/0x80
[  480.005937]  start_secondary+0x1a9/0x200
[  480.007837]  secondary_startup_64+0xa5/0xb0
[  480.009798] Code: 00 00 49 8b 95 80 00 00 00 48 8d b5 c8 00 00 00 e8 6e 86 fe ff 84 c0 0f 84 d4 fd ff ff f0 41 80 a5 a9 00 00 00 fd e9 c6 fd ff ff <0f> 0b 83 f8 03 75 32 41 b8 01 00 00 00 b9 01 00 00 00 48 c7 c2 
[  480.016945] RIP: tfw_http_msg_process_generic+0x968/0xd00 [tempesta_fw] RSP: ffff97990f103970
[  480.020320] ---[ end trace 8c443069c4c3736c ]---
[  480.022479] Kernel panic - not syncing: Fatal exception in interrupt
[  480.025191] Kernel Offset: 0x3b200000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1323,2019-07-24T13:25:13Z,2019-09-06T03:09:20Z,2019-09-06T03:09:24Z,MERGED,True,104,115,10,https://github.com/avbelov23,Close the connection after sending tls alerts in the queue,5,[],https://github.com/tempesta-tech/tempesta/pull/1323,https://github.com/ikoveshnikov,3,https://github.com/tempesta-tech/tempesta/pull/1323#issuecomment-518269346,"#1308


Close the socket after sending all pending data on TCP_CLOSE_WAIT and internal errors.


Close the connection after sending fatal tls alerts and close_notify alert in the queue


Not encryption for TTLS_SERVER_FINISHED, because encryption is done in ttls_write_finished().


Sending close_notify alert on close_notify alert.","Just saw kernel oops

It seems like it doesn't related to this PR, I've got the same on master branch, #1283 (comment)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1327,2019-07-30T16:08:52Z,2019-07-30T16:34:49Z,2019-08-08T19:12:56Z,MERGED,True,45,45,3,https://github.com/krizhanovsky,Reduce Tempesta logging on start/stop,1,[],https://github.com/tempesta-tech/tempesta/pull/1327,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1327,"Tempesta produces too many log records on start & stop operations. This not only is boding, but also makes testing hard since netratelimiting message appears only on next log records, i.e. there is a possibility to loose a log record and learn it only on next start/stop.","Tempesta produces too many log records on start & stop operations. This not only is boding, but also makes testing hard since netratelimiting message appears only on next log records, i.e. there is a possibility to loose a log record and learn it only on next start/stop.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1327,2019-07-30T16:08:52Z,2019-07-30T16:34:49Z,2019-08-08T19:12:56Z,MERGED,True,45,45,3,https://github.com/krizhanovsky,Reduce Tempesta logging on start/stop,1,[],https://github.com/tempesta-tech/tempesta/pull/1327,https://github.com/avbelov23,2,https://github.com/tempesta-tech/tempesta/pull/1327#issuecomment-516497117,"Tempesta produces too many log records on start & stop operations. This not only is boding, but also makes testing hard since netratelimiting message appears only on next log records, i.e. there is a possibility to loose a log record and learn it only on next start/stop.",LGTM,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1328,2019-08-01T22:45:51Z,2019-08-02T15:13:03Z,2019-08-02T15:13:08Z,MERGED,True,10,4,2,https://github.com/i-rinat,propagate tx_flags through the skb chain to honor SKBTX_SHARED_FRAG,1,[],https://github.com/tempesta-tech/tempesta/pull/1328,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1328,"We need to avoid encryption in-place if responses are coming from the cache. Otherwise, data stored in the cache gets mangled, and next time clients get unexpected data. We use SKBTX_SHARED_FRAG flags to figure out which skb's data is shared, and set this flag ourselves when serving response from the cache. However there were cases where not all skb's received the flag.
The patch consists of two parts. First ensures all skb's originating from tfw_http_msg_setup() receive the flag. It's not very likely scenario, but since tfw_http_msg_setup() in theory can generate two or more skb's, it's better be on the safe side. Last part changes __extend_pgfrags() to propagate the skb flags. Missing flag propagation causes response corruption if body is only about 64kB in size.
Fixes some tests from #1283.","We need to avoid encryption in-place if responses are coming from the cache. Otherwise, data stored in the cache gets mangled, and next time clients get unexpected data. We use SKBTX_SHARED_FRAG flags to figure out which skb's data is shared, and set this flag ourselves when serving response from the cache. However there were cases where not all skb's received the flag.
The patch consists of two parts. First ensures all skb's originating from tfw_http_msg_setup() receive the flag. It's not very likely scenario, but since tfw_http_msg_setup() in theory can generate two or more skb's, it's better be on the safe side. Last part changes __extend_pgfrags() to propagate the skb flags. Missing flag propagation causes response corruption if body is only about 64kB in size.
Fixes some tests from #1283.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1329,2019-08-02T16:37:23Z,2019-08-02T21:36:17Z,2019-08-02T21:36:20Z,MERGED,True,45,21,5,https://github.com/i-rinat,Backport code changes related to #1283 (release-0.6),4,['backport'],https://github.com/tempesta-tech/tempesta/pull/1329,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1329,"This is the backport of #1322 and #1328 to release-0.6.
Tempesta's version is updated to 0.6.5.","This is the backport of #1322 and #1328 to release-0.6.
Tempesta's version is updated to 0.6.5.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1330,2019-08-06T21:27:56Z,2019-09-13T13:54:54Z,2019-09-13T13:54:57Z,MERGED,True,92,153,13,https://github.com/i-rinat,"remove ""off"" and ""trail"" fields from TfwFsmData",1,[],https://github.com/tempesta-tech/tempesta/pull/1330,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1330,"TLS layer feeds tfw_http_msg_process() with multiple skb's at a time. As the smallest possible skb can be as small as one byte, the tail where TLS record tag is located, can span over two or more skb's. Previously we assumed that never happens, but it does depending on network conditions.
It's hard to deal with heading and trailing forbidden parts of an skb or an skb chain. So during the discussion of the PR it was decided to eliminate the notion of heading and trailing parts, so that the consumers of the data could work with skb data without tracking those parts. TLS-related code is now cuts off header and the trailing part that contains TLS tag.
This PR handles the case from #1283 with ""kernel BUG at /root/tempesta/tempesta/tempesta_fw/http.c:3058!"".","TLS layer feeds tfw_http_msg_process() with multiple skb's at a time. As the smallest possible skb can be as small as one byte, the tail where TLS record tag is located, can span over two or more skb's. Previously we assumed that never happens, but it does depending on network conditions.
It's hard to deal with heading and trailing forbidden parts of an skb or an skb chain. So during the discussion of the PR it was decided to eliminate the notion of heading and trailing parts, so that the consumers of the data could work with skb data without tracking those parts. TLS-related code is now cuts off header and the trailing part that contains TLS tag.
This PR handles the case from #1283 with ""kernel BUG at /root/tempesta/tempesta/tempesta_fw/http.c:3058!"".",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1330,2019-08-06T21:27:56Z,2019-09-13T13:54:54Z,2019-09-13T13:54:57Z,MERGED,True,92,153,13,https://github.com/i-rinat,"remove ""off"" and ""trail"" fields from TfwFsmData",1,[],https://github.com/tempesta-tech/tempesta/pull/1330,https://github.com/i-rinat,2,https://github.com/tempesta-tech/tempesta/pull/1330#issuecomment-521051493,"TLS layer feeds tfw_http_msg_process() with multiple skb's at a time. As the smallest possible skb can be as small as one byte, the tail where TLS record tag is located, can span over two or more skb's. Previously we assumed that never happens, but it does depending on network conditions.
It's hard to deal with heading and trailing forbidden parts of an skb or an skb chain. So during the discussion of the PR it was decided to eliminate the notion of heading and trailing parts, so that the consumers of the data could work with skb data without tracking those parts. TLS-related code is now cuts off header and the trailing part that contains TLS tag.
This PR handles the case from #1283 with ""kernel BUG at /root/tempesta/tempesta/tempesta_fw/http.c:3058!"".","I've changed the code to pass everywhere a usable data length instead of a tail size. That way we can track whenever we are out of data, so the trailing skb's in a chain can be freed. See changes in tfw_http_msg_process() for details.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1330,2019-08-06T21:27:56Z,2019-09-13T13:54:54Z,2019-09-13T13:54:57Z,MERGED,True,92,153,13,https://github.com/i-rinat,"remove ""off"" and ""trail"" fields from TfwFsmData",1,[],https://github.com/tempesta-tech/tempesta/pull/1330,https://github.com/i-rinat,3,https://github.com/tempesta-tech/tempesta/pull/1330#issuecomment-530599923,"TLS layer feeds tfw_http_msg_process() with multiple skb's at a time. As the smallest possible skb can be as small as one byte, the tail where TLS record tag is located, can span over two or more skb's. Previously we assumed that never happens, but it does depending on network conditions.
It's hard to deal with heading and trailing forbidden parts of an skb or an skb chain. So during the discussion of the PR it was decided to eliminate the notion of heading and trailing parts, so that the consumers of the data could work with skb data without tracking those parts. TLS-related code is now cuts off header and the trailing part that contains TLS tag.
This PR handles the case from #1283 with ""kernel BUG at /root/tempesta/tempesta/tempesta_fw/http.c:3058!"".","There was an off-site discussion that made us to decide that we need to remove off and trail fields from TfwFsmData structure. It will only hold skb and whole skb data are now the usable data. Headers and trailers that... happen, are removed as soon as possible.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1330,2019-08-06T21:27:56Z,2019-09-13T13:54:54Z,2019-09-13T13:54:57Z,MERGED,True,92,153,13,https://github.com/i-rinat,"remove ""off"" and ""trail"" fields from TfwFsmData",1,[],https://github.com/tempesta-tech/tempesta/pull/1330,https://github.com/i-rinat,4,https://github.com/tempesta-tech/tempesta/pull/1330#issuecomment-530912569,"TLS layer feeds tfw_http_msg_process() with multiple skb's at a time. As the smallest possible skb can be as small as one byte, the tail where TLS record tag is located, can span over two or more skb's. Previously we assumed that never happens, but it does depending on network conditions.
It's hard to deal with heading and trailing forbidden parts of an skb or an skb chain. So during the discussion of the PR it was decided to eliminate the notion of heading and trailing parts, so that the consumers of the data could work with skb data without tracking those parts. TLS-related code is now cuts off header and the trailing part that contains TLS tag.
This PR handles the case from #1283 with ""kernel BUG at /root/tempesta/tempesta/tempesta_fw/http.c:3058!"".",Updated the code according to the review comments.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1331,2019-08-08T19:11:01Z,2019-08-09T13:24:03Z,2019-08-09T13:24:55Z,CLOSED,False,2,1,1,https://github.com/krizhanovsky,Fix possible memory corruption.,1,[],https://github.com/tempesta-tech/tempesta/pull/1331,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1331,"TlsHandshake->tmp_sha256 resides in the same union with ecdh_ctx, so
ttls_write_server_key_exchange() -> ttls_ecp_group_load() may find
dirty memory in tls->hs->ecdh_ctx.grp and ttls_ecp_group_free() calls
kfree on bad pointers.
Fix for current 0.7 will be done in context of #1064.","TlsHandshake->tmp_sha256 resides in the same union with ecdh_ctx, so
ttls_write_server_key_exchange() -> ttls_ecp_group_load() may find
dirty memory in tls->hs->ecdh_ctx.grp and ttls_ecp_group_free() calls
kfree on bad pointers.
Fix for current 0.7 will be done in context of #1064.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1331,2019-08-08T19:11:01Z,2019-08-09T13:24:03Z,2019-08-09T13:24:55Z,CLOSED,False,2,1,1,https://github.com/krizhanovsky,Fix possible memory corruption.,1,[],https://github.com/tempesta-tech/tempesta/pull/1331,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/1331#issuecomment-519917464,"TlsHandshake->tmp_sha256 resides in the same union with ecdh_ctx, so
ttls_write_server_key_exchange() -> ttls_ecp_group_load() may find
dirty memory in tls->hs->ecdh_ctx.grp and ttls_ecp_group_free() calls
kfree on bad pointers.
Fix for current 0.7 will be done in context of #1064.","ttls_ecdh_init() initializes the context, so we're good and there is no need for the patch.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1334,2019-08-11T00:44:41Z,2019-08-12T14:15:09Z,2019-08-12T14:16:15Z,MERGED,True,3,3,1,https://github.com/krizhanovsky,Fix MPI zeroizing,1,[],https://github.com/tempesta-tech/tempesta/pull/1334,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1334,mbedtls_mpi_zeroize() was incorrectly replaced with memset() without limbs number multiplication by number of bytes per limb.,mbedtls_mpi_zeroize() was incorrectly replaced with memset() without limbs number multiplication by number of bytes per limb.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1336,2019-08-12T08:33:08Z,2019-08-12T12:17:47Z,2019-08-12T12:17:52Z,MERGED,True,1,1,1,https://github.com/ikoveshnikov,Fix debug build,1,[],https://github.com/tempesta-tech/tempesta/pull/1336,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1336,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1337,2019-08-13T12:00:36Z,2019-08-13T14:06:12Z,2019-08-13T14:06:15Z,MERGED,True,778,805,31,https://github.com/ikoveshnikov,Trivial fixes to logging messages,2,[],https://github.com/tempesta-tech/tempesta/pull/1337,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1337,"Changes:

Decrease log levels for sticky sessions, related to tempesta-tech/tempesta-test#127
replace deprecated TFW_ERR|TFW_WARN|TFW_LOG macroses with newer T_ERR|T_WARN|T_LOG

This PR fix #1152","Changes:

Decrease log levels for sticky sessions, related to tempesta-tech/tempesta-test#127
replace deprecated TFW_ERR|TFW_WARN|TFW_LOG macroses with newer T_ERR|T_WARN|T_LOG

This PR fix #1152",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1338,2019-08-14T07:15:44Z,2019-10-11T20:30:53Z,2019-10-11T20:31:09Z,MERGED,True,5662,51,21,https://github.com/aleksostapenko,HTTP/2 HPACK layer implementation (#309).,12,[],https://github.com/tempesta-tech/tempesta/pull/1338,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/1338,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1339,2019-08-14T22:25:17Z,2019-08-15T14:04:45Z,2019-08-15T14:04:50Z,MERGED,True,30,28,12,https://github.com/i-rinat,make tfw_http_msg_setup() accept skb flags,1,[],https://github.com/tempesta-tech/tempesta/pull/1339,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1339,"When serving responses from the cache, we need to mark generated skbs with the SKBTX_SHARED_FRAG flag to avoid cache pages corruption. Rather than traversing the skb chain, let's set skb flags right after skb allocation.
This patch removes the loop mentioned in #1330 (comment).","When serving responses from the cache, we need to mark generated skbs with the SKBTX_SHARED_FRAG flag to avoid cache pages corruption. Rather than traversing the skb chain, let's set skb flags right after skb allocation.
This patch removes the loop mentioned in #1330 (comment).",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1339,2019-08-14T22:25:17Z,2019-08-15T14:04:45Z,2019-08-15T14:04:50Z,MERGED,True,30,28,12,https://github.com/i-rinat,make tfw_http_msg_setup() accept skb flags,1,[],https://github.com/tempesta-tech/tempesta/pull/1339,https://github.com/avbelov23,2,https://github.com/tempesta-tech/tempesta/pull/1339#issuecomment-521600501,"When serving responses from the cache, we need to mark generated skbs with the SKBTX_SHARED_FRAG flag to avoid cache pages corruption. Rather than traversing the skb chain, let's set skb flags right after skb allocation.
This patch removes the loop mentioned in #1330 (comment).",LGTM,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1341,2019-08-20T08:06:59Z,2019-08-21T02:58:49Z,2019-08-21T03:00:37Z,CLOSED,False,42,16,1,https://github.com/avbelov23,Fix checking curve and add checking hash algorithm,2,[],https://github.com/tempesta-tech/tempesta/pull/1341,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1341,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1342,2019-08-21T13:33:11Z,2019-08-22T23:29:47Z,2019-08-22T23:32:41Z,MERGED,True,3,3,1,https://github.com/i-rinat,gfsm: fix possible value overlaps in shift calculations,1,[],https://github.com/tempesta-tech/tempesta/pull/1342,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1342,"There was a possible overlapping in the fsm_hooks subarray index calculations.
As states are in the [0, 31] closed interval, for each priority increase we need to add 32, which is TFW_GFSM_STATE_N. Smaller values can cause expected behavior, and the previous value was 16.","There was a possible overlapping in the fsm_hooks subarray index calculations.
As states are in the [0, 31] closed interval, for each priority increase we need to add 32, which is TFW_GFSM_STATE_N. Smaller values can cause expected behavior, and the previous value was 16.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1342,2019-08-21T13:33:11Z,2019-08-22T23:29:47Z,2019-08-22T23:32:41Z,MERGED,True,3,3,1,https://github.com/i-rinat,gfsm: fix possible value overlaps in shift calculations,1,[],https://github.com/tempesta-tech/tempesta/pull/1342,https://github.com/i-rinat,2,https://github.com/tempesta-tech/tempesta/pull/1342#issuecomment-524116640,"There was a possible overlapping in the fsm_hooks subarray index calculations.
As states are in the [0, 31] closed interval, for each priority increase we need to add 32, which is TFW_GFSM_STATE_N. Smaller values can cause expected behavior, and the previous value was 16.","we didn't caught the issue before, since all the hooks was added with highest priority (which is 0), so calculations results the same before and after patch.

Indeed so. And it's not likely we'll ever need other priorities. But it won't hurt to have a correct multiplier anyway.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1343,2019-08-21T14:06:45Z,2019-08-23T13:47:19Z,2019-08-23T13:47:25Z,MERGED,True,72,9,1,https://github.com/ikoveshnikov,tests: http parser: catch content-type parsing errors,3,[],https://github.com/tempesta-tech/tempesta/pull/1343,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1343,The unit tests will fail on this branch. Don't merge until the issue is fixed.,The unit tests will fail on this branch. Don't merge until the issue is fixed.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1343,2019-08-21T14:06:45Z,2019-08-23T13:47:19Z,2019-08-23T13:47:25Z,MERGED,True,72,9,1,https://github.com/ikoveshnikov,tests: http parser: catch content-type parsing errors,3,[],https://github.com/tempesta-tech/tempesta/pull/1343,https://github.com/i-rinat,2,https://github.com/tempesta-tech/tempesta/pull/1343#issuecomment-524311321,The unit tests will fail on this branch. Don't merge until the issue is fixed.,"I think we need to add
	FOR_REQ(HEAD ""multitest"" TAIL) {
		EXPECT_TFWSTR_EQ(&req->h_tbl->tbl[TFW_HTTP_HDR_CONTENT_TYPE],
				 ""Content-Type: multitest"");
	}
to cover this line: https://github.com/tempesta-tech/tempesta/pull/1345/files#diff-0a919ed70e9a8fc9bdfce5b5ee1e1e99R1660",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1343,2019-08-21T14:06:45Z,2019-08-23T13:47:19Z,2019-08-23T13:47:25Z,MERGED,True,72,9,1,https://github.com/ikoveshnikov,tests: http parser: catch content-type parsing errors,3,[],https://github.com/tempesta-tech/tempesta/pull/1343,https://github.com/avbelov23,3,https://github.com/tempesta-tech/tempesta/pull/1343#issuecomment-524314041,The unit tests will fail on this branch. Don't merge until the issue is fixed.,DONE,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1345,2019-08-22T15:21:01Z,2019-08-23T13:29:53Z,2019-08-23T13:29:57Z,MERGED,True,2,3,1,https://github.com/avbelov23,Saving not multipart content type,1,[],https://github.com/tempesta-tech/tempesta/pull/1345,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1345,"#1344
If there is one token in the Content-type value, then it is not saved.
Also, part of the value is not saved until the slash.","#1344
If there is one token in the Content-type value, then it is not saved.
Also, part of the value is not saved until the slash.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1348,2019-09-05T15:12:41Z,2019-09-17T14:33:03Z,2019-09-17T14:33:07Z,MERGED,True,21,4,3,https://github.com/avbelov23,Some tls fixes,4,[],https://github.com/tempesta-tech/tempesta/pull/1348,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1348,"fix #1324

add custom macro of jump into state for handshake with initialization of work in a new state otherwise the crash on BUG_ON(io->rlen > ext_sz) in TTLS_CH_HS_EX state.
In function ttls_crypto_req_sglist() skb->len is only the length of the first skb_buff in io->skb_list'. lenis the length of all the data that needs to be decrypted, as inio->skb_list', as in buf.
if after parsing headers not only handshake header was read, we compute handshake checksum for the message body and handshake header in one shot later

The patch (#1330) is also needed","fix #1324

add custom macro of jump into state for handshake with initialization of work in a new state otherwise the crash on BUG_ON(io->rlen > ext_sz) in TTLS_CH_HS_EX state.
In function ttls_crypto_req_sglist() skb->len is only the length of the first skb_buff in io->skb_list'. lenis the length of all the data that needs to be decrypted, as inio->skb_list', as in buf.
if after parsing headers not only handshake header was read, we compute handshake checksum for the message body and handshake header in one shot later

The patch (#1330) is also needed",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1349,2019-09-06T12:34:41Z,2019-09-06T12:44:28Z,2019-09-06T12:44:37Z,MERGED,True,1,1,1,https://github.com/i-rinat,free skb's with __kfree_skb,1,[],https://github.com/tempesta-tech/tempesta/pull/1349,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1349,We need to free skb's with kfree_skb() or __kfree_skb().,We need to free skb's with kfree_skb() or __kfree_skb().,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1351,2019-09-19T10:47:45Z,2019-09-22T04:33:14Z,2019-09-22T04:33:19Z,MERGED,True,203,16,2,https://github.com/avbelov23,parsing accept header according to rfc,2,[],https://github.com/tempesta-tech/tempesta/pull/1351,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1351,"Fix #1203
RFC: https://tools.ietf.org/html/rfc7231#section-5.3.2
The MIME-type must have a type and subtype.
In addition, we validate the parameter q. We do not validate all other parameters.
Also added and fixed tests. In previous tests, there were incorrect values. Two slashes are clearly not the correct value, like the lack of a slash for the Accept.","Fix #1203
RFC: https://tools.ietf.org/html/rfc7231#section-5.3.2
The MIME-type must have a type and subtype.
In addition, we validate the parameter q. We do not validate all other parameters.
Also added and fixed tests. In previous tests, there were incorrect values. Two slashes are clearly not the correct value, like the lack of a slash for the Accept.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1352,2019-09-19T23:02:36Z,2019-09-20T14:46:43Z,2019-09-20T14:46:47Z,MERGED,True,15,11,2,https://github.com/i-rinat,ASAN-induced fixes,3,[],https://github.com/tempesta-tech/tempesta/pull/1352,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1352,"Running Tempesta tests with ASAN-enabled builds generates some warnings. Some of them are known, but they are making it hard to spot any new warnings, so let's fix them.
There are three patches. First ensures enough memory is allocated in tfw_vhost_create(). It was probably fine the way it was since kmalloc allocated more memory than it was asked. Still, it would be nice to have sizes sharp. Next patch introduces more alignment into the same tfw_vhost_create(). Since multiple things are packed one after another into a continuous memory block, a vhost name that can be of any length may cause structures misalignment. Currently I found no atomics there or anything requiring alignment, but even ordinary field accesses may benefit from alignment too, if little. And the third patch fixes state handling in tfw_gfsm_move. As we use only 5 bits for the state number, we need to go defensive and strip other bits if some caller passes them along with the state itself. That actually triggered UBSAN, since shifts were larger than 31. Fortunately, on x86 shift is masked to 5 bits just as we need. Still better to have that in the code explicitly.
Fixes #1246.","Running Tempesta tests with ASAN-enabled builds generates some warnings. Some of them are known, but they are making it hard to spot any new warnings, so let's fix them.
There are three patches. First ensures enough memory is allocated in tfw_vhost_create(). It was probably fine the way it was since kmalloc allocated more memory than it was asked. Still, it would be nice to have sizes sharp. Next patch introduces more alignment into the same tfw_vhost_create(). Since multiple things are packed one after another into a continuous memory block, a vhost name that can be of any length may cause structures misalignment. Currently I found no atomics there or anything requiring alignment, but even ordinary field accesses may benefit from alignment too, if little. And the third patch fixes state handling in tfw_gfsm_move. As we use only 5 bits for the state number, we need to go defensive and strip other bits if some caller passes them along with the state itself. That actually triggered UBSAN, since shifts were larger than 31. Fortunately, on x86 shift is masked to 5 bits just as we need. Still better to have that in the code explicitly.
Fixes #1246.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1353,2019-09-27T00:19:28Z,2019-10-05T14:29:37Z,2019-10-05T14:29:41Z,MERGED,True,10,8,1,https://github.com/i-rinat,TLS record parsing fixes,4,[],https://github.com/tempesta-tech/tempesta/pull/1353,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1353,"There are two related fixes here.
First one is what triggered BUG_ON mentioned in #1318: we were parsing application data records even if they appear early. That doesn't make any sense, since cipher is not ready yet. Conforming client will never send such record before handshake is completed, so it's safe to completely reject connections where such record is seen too early.
Second one was not mentioned explicitly in #1318, but was found later. We were postponing record processing despite all required data were already received. The data were processed when next skb arrived and enqueued into tls->io_in.skb_list. But since that list is cleared after a record is successfully processed, that next skb was thrown away. Later, that results in out-of-buffer accesses during scatter-gather operations inside a cipher.
(part of #1318-related changes)","There are two related fixes here.
First one is what triggered BUG_ON mentioned in #1318: we were parsing application data records even if they appear early. That doesn't make any sense, since cipher is not ready yet. Conforming client will never send such record before handshake is completed, so it's safe to completely reject connections where such record is seen too early.
Second one was not mentioned explicitly in #1318, but was found later. We were postponing record processing despite all required data were already received. The data were processed when next skb arrived and enqueued into tls->io_in.skb_list. But since that list is cleared after a record is successfully processed, that next skb was thrown away. Later, that results in out-of-buffer accesses during scatter-gather operations inside a cipher.
(part of #1318-related changes)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1353,2019-09-27T00:19:28Z,2019-10-05T14:29:37Z,2019-10-05T14:29:41Z,MERGED,True,10,8,1,https://github.com/i-rinat,TLS record parsing fixes,4,[],https://github.com/tempesta-tech/tempesta/pull/1353,https://github.com/i-rinat,2,https://github.com/tempesta-tech/tempesta/pull/1353#issuecomment-538654630,"There are two related fixes here.
First one is what triggered BUG_ON mentioned in #1318: we were parsing application data records even if they appear early. That doesn't make any sense, since cipher is not ready yet. Conforming client will never send such record before handshake is completed, so it's safe to completely reject connections where such record is seen too early.
Second one was not mentioned explicitly in #1318, but was found later. We were postponing record processing despite all required data were already received. The data were processed when next skb arrived and enqueued into tls->io_in.skb_list. But since that list is cleared after a record is successfully processed, that next skb was thrown away. Later, that results in out-of-buffer accesses during scatter-gather operations inside a cipher.
(part of #1318-related changes)","As a result of an off-site discussion, I also removed msglen == 0 special case handling in f5836a1.
Rationale: (a) That workaround is not used in OpenSSL since about 2002. (b) Doesn't apply to TLS 1.2, only TLS 1.0 and SSL 3.0, which we do not support. (c) The workaround was talking about empty plaintext, which can not translate to empty ciphertext in our implementation, as we require encryption.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1354,2019-09-28T03:22:29Z,2019-10-21T22:04:06Z,2019-10-21T22:04:10Z,MERGED,True,1867,1740,22,https://github.com/ikoveshnikov,Per-vhost sticky cookie configuration,13,[],https://github.com/tempesta-tech/tempesta/pull/1354,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1354,fix #685,fix #685,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1355,2019-10-02T20:42:10Z,2019-10-03T14:26:39Z,2019-10-03T14:26:43Z,MERGED,True,1,13,2,https://github.com/i-rinat,tls: remove off field from TlsIOCtx,1,[],https://github.com/tempesta-tech/tempesta/pull/1355,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1355,The field is not needed as its value is unconditionally overwritten just before it's used.,The field is not needed as its value is unconditionally overwritten just before it's used.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1356,2019-10-05T14:35:50Z,2019-10-05T18:06:31Z,2019-10-05T18:07:21Z,MERGED,True,1,1,1,https://github.com/i-rinat,tls: fix a syntax error from f5836a101e6891006850aae58b0cc1dd98b7f7f5,1,[],https://github.com/tempesta-tech/tempesta/pull/1356,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1356,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1357,2019-10-06T00:05:09Z,2019-10-07T13:44:03Z,2019-10-07T13:44:06Z,MERGED,True,6,5,1,https://github.com/i-rinat,tls: more strict length checks of alerts and change_cipher_spec records,1,[],https://github.com/tempesta-tech/tempesta/pull/1357,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1357,"While the checks ttls_parse_record_hdr() ensured we have at least required number of bytes, the skipping code in ttls_recv() expected records to contains exactly one instance of an alert or one instance of a change_cipher_spec. Let's make length checking more strict.
However it seems to be possible to send an alert in two records, it's doubtful any implementation will do that. So we'll most probably get away with it.","While the checks ttls_parse_record_hdr() ensured we have at least required number of bytes, the skipping code in ttls_recv() expected records to contains exactly one instance of an alert or one instance of a change_cipher_spec. Let's make length checking more strict.
However it seems to be possible to send an alert in two records, it's doubtful any implementation will do that. So we'll most probably get away with it.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1358,2019-10-09T13:23:19Z,2019-10-25T16:16:18Z,2019-10-25T16:16:22Z,MERGED,True,533,217,3,https://github.com/avbelov23,closer to rfc parsing date,5,[],https://github.com/tempesta-tech/tempesta/pull/1358,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1358,"Fix #1202

We must set the HTTP flags, if only the date is successfully parse.
Parsing date according to rfc
Fix __year_day_secs().
If-Modified-Since header parsing tests.
Fix date format in tests.","Fix #1202

We must set the HTTP flags, if only the date is successfully parse.
Parsing date according to rfc
Fix __year_day_secs().
If-Modified-Since header parsing tests.
Fix date format in tests.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1358,2019-10-09T13:23:19Z,2019-10-25T16:16:18Z,2019-10-25T16:16:22Z,MERGED,True,533,217,3,https://github.com/avbelov23,closer to rfc parsing date,5,[],https://github.com/tempesta-tech/tempesta/pull/1358,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/1358#issuecomment-540567439,"Fix #1202

We must set the HTTP flags, if only the date is successfully parse.
Parsing date according to rfc
Fix __year_day_secs().
If-Modified-Since header parsing tests.
Fix date format in tests.","It seems like all parts of date except day name are fixed sized, so we can make two-step parsing routine that will perform better but will require a bit of copy operations:
Changes:

Add to TfwHttpParser a char array that can handle the longest valid Date characters (except week day name), let it be char date_str[].
Add to parser a bit array (or reuse any of the currently unused members) to store a date format indicator, let it be int date_format in this example, with possible values 0x1 for IMF-fixdate, 0x2 for obsolete RFC 850 and 0x4 for ANSI C's asctime().
Until the date is fully parsed, the parser->_acc will show the current empty position in date_str

Algorithm:
Preparations:

Statically define three couples of char arrays: min[] and max[] for all the date formats. Since all the formats are fixed sized except day name and case-sensitive, no extra SP are allowed,  for each position of date value we can define minimum and maximum character possible. This will be our compare mark.
set parser->_acc = 0, Clear the parser->date_str (optionally, just to get rid of possible errors).

Validate the date value:

Eat the weekday name. First letter is upper case, the rest is lowercase,
, after weekday name ->  Set parser->date_format to (IMF-fixdate) | (obsolete RFC 850), or SP after weekdayname ->  Set parser->date_format to ANSI C's asctime
The rest of the date value is the fixed-sized value, so compare every new character c to be min[parser->_acc] <= c <= max[parser->_acc], if the condition is true, then copy the c to parser->date_str[parser->_acc], increment the parser->_acc and repeat step 3.  Since we may have three possible date formats, we will need three  pairs of min[] and max[].
If the condition from the point above failed, then drop the format id from the parser->date_format, if no left, then return the CSTR_NEQ
Formats are very different, and only one can be parsed successfully, if one of the formats if fully parsed, then the validation step is over, eat the rest of the line.

Parse validated value into time_t:

Now we know the exact format and hate the full copy of the date value inside the parser->date_str[]. If the parser->date_format == 0, then the date format is invalid and we can't parse the value.
We can directly access day number, month name, year etc. and directly get numerical values, we even can use binary search to parse month name.

No TRY_STR(), no complicated state machines to parse all the three possible date formats, but we have to copy ~25 bytes and can't reject messages with invalid date value, until the full date string is delivered.
Any thoughts?",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1358,2019-10-09T13:23:19Z,2019-10-25T16:16:18Z,2019-10-25T16:16:22Z,MERGED,True,533,217,3,https://github.com/avbelov23,closer to rfc parsing date,5,[],https://github.com/tempesta-tech/tempesta/pull/1358,https://github.com/krizhanovsky,3,https://github.com/tempesta-tech/tempesta/pull/1358#issuecomment-540815974,"Fix #1202

We must set the HTTP flags, if only the date is successfully parse.
Parsing date according to rfc
Fix __year_day_secs().
If-Modified-Since header parsing tests.
Fix date format in tests.","In discussion for #1358 (comment) :
For current implementation (before introducing additional states to handle obsolete dates) we have 29 states and we saw (https://www.slideshare.net/AlexanderKrizhanovsky1/fast-http-string-processing-algorithms , page 22) that plain switch driven FSM behaves poorly.
Basically, I'm fine with the algorithm proposed by @ikoveshnikov , however couple notes :


we do need to shring current FSM - 29 states is too much. I'd say that the FSM should not be more that 20 states.


the other option is to introduce goto driven DSL for nested parsers as we have for the main parsers. The benefit is that we can win in different places, however, this particular case won't be faster having greater number of states even goto-driven.


All in all the propsed algorithms looks good if it can shrink FSM to below 20 states or lower.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1358,2019-10-09T13:23:19Z,2019-10-25T16:16:18Z,2019-10-25T16:16:22Z,MERGED,True,533,217,3,https://github.com/avbelov23,closer to rfc parsing date,5,[],https://github.com/tempesta-tech/tempesta/pull/1358,https://github.com/i-rinat,4,https://github.com/tempesta-tech/tempesta/pull/1358#issuecomment-540823091,"Fix #1202

We must set the HTTP flags, if only the date is successfully parse.
Parsing date according to rfc
Fix __year_day_secs().
If-Modified-Since header parsing tests.
Fix date format in tests.","There is still discrepancies regarding leap years: there are sometimes gaps or overlapping in epoch time that comes out of the parser.
As there is no way such jumps will occur during the days, assuming we don't touch daylight saving time at all. We multiply hours and minutes by constants and add with seconds. There is no way there will be gaps or overlaps. But jumps may occur when date changes. So here is a sample code that iterates through a period and prints dates at which jumps occur. In the ideal case, the should be only one such apparent jump, at 1 Jan 1970, since we start at 0.
diff --git a/tempesta_fw/http_parser.c b/tempesta_fw/http_parser.c
index 69527805..7e0371fc 100644
--- a/tempesta_fw/http_parser.c
+++ b/tempesta_fw/http_parser.c
@@ -5093,3 +5093,64 @@ tfw_http_parse_is_done(TfwHttpMsg *hm)
 {
 	return test_bit(TFW_HTTP_B_FULLY_PARSED, hm->flags);
 }
+
+void
+hp_startup(void)
+{
+    static const int days_in_month[12] =
+        { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
+    static const char *mname[12] =
+        {""Jan"", ""Feb"", ""Mar"", ""Apr"", ""May"", ""Jun"", ""Jul"", ""Aug"", ""Sep"", ""Oct"",
+         ""Nov"", ""Dec""};
+    int year;
+    int month;
+    int day;
+    int r;
+    static char buf[200];
+    time_t prev_day_premidnight = 0;
+
+    printk(""hp_startup begin\n"");
+    for (year = 1970; year < 2020; year++) {
+        int leap = 0;
+        if (year % 4 == 0)
+            leap = 1;
+        if (year % 100 == 0 && year % 400 != 0)
+            leap = 0;
+
+        for (month = 1; month <= 12; month++) {
+            int days_count = days_in_month[month - 1];
+            if (month == 2 && leap)
+                days_count = 29;
+            for (day = 1; day <= days_count; day++) {
+                {
+                    TfwStream stream = {};
+                    TfwHttpMsg hm = {.stream = &stream};
+
+                    sprintf(buf, ""aaa, %02d %s %04d 00:00:00 GMT\r\n"",
+                            day, mname[month-1], year);
+                    r = __parse_http_date(&hm, (unsigned char *)buf, strlen(buf));
+                    if (r <= 0)
+                        printk(""error1, r=%d\n"", r);
+
+                    if (hm.stream->parser._date - prev_day_premidnight != 1)
+                        printk(""%02d %s %04d 00:00:00, delta=%ld\n"", day,
+                               mname[month-1], year,
+                               hm.stream->parser._date - prev_day_premidnight);
+                }
+                {
+                    TfwStream stream = {};
+                    TfwHttpMsg hm = {.stream = &stream};
+
+                    sprintf(buf, ""aaa, %02d %s %04d 23:59:59 GMT\r\n"",
+                            day, mname[month-1], year);
+
+                    r = __parse_http_date(&hm, (unsigned char *)buf, strlen(buf));
+                    if (r <= 0)
+                        printk(""error2, r=%d\n"", r);
+                    prev_day_premidnight = hm.stream->parser._date;
+                }
+            }
+        }
+    }
+    printk(""hp_startup end\n"");
+}
diff --git a/tempesta_fw/main.c b/tempesta_fw/main.c
index b7d8b2e4..fbfbc334 100644
--- a/tempesta_fw/main.c
+++ b/tempesta_fw/main.c
@@ -417,6 +417,9 @@ tfw_exit(void)
 	unregister_net_sysctl_table(tfw_sysctl_hdr);
 }
 
+void
+hp_startup(void);
+
 static int __init
 tfw_init(void)
 {
@@ -463,6 +466,7 @@ tfw_init(void)
 	DO_INIT(sched_hash);
 	DO_INIT(sched_ratio);
 
+	hp_startup();
 	return 0;
 err:
 	tfw_exit();",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1358,2019-10-09T13:23:19Z,2019-10-25T16:16:18Z,2019-10-25T16:16:22Z,MERGED,True,533,217,3,https://github.com/avbelov23,closer to rfc parsing date,5,[],https://github.com/tempesta-tech/tempesta/pull/1358,https://github.com/i-rinat,5,https://github.com/tempesta-tech/tempesta/pull/1358#issuecomment-541077160,"Fix #1202

We must set the HTTP flags, if only the date is successfully parse.
Parsing date according to rfc
Fix __year_day_secs().
If-Modified-Since header parsing tests.
Fix date format in tests.","29 states is too much

We are already using computed goto jumps in the __parse_http_date(), so there is no switch on entry. Does it matter how many states there are then?",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1358,2019-10-09T13:23:19Z,2019-10-25T16:16:18Z,2019-10-25T16:16:22Z,MERGED,True,533,217,3,https://github.com/avbelov23,closer to rfc parsing date,5,[],https://github.com/tempesta-tech/tempesta/pull/1358,https://github.com/krizhanovsky,6,https://github.com/tempesta-tech/tempesta/pull/1358#issuecomment-541171367,"Fix #1202

We must set the HTTP flags, if only the date is successfully parse.
Parsing date according to rfc
Fix __year_day_secs().
If-Modified-Since header parsing tests.
Fix date format in tests.","We are already using computed goto jumps in the __parse_http_date(), so there is no switch on entry. Does it matter how many states there are then?

Oh, forgot about this. Yes, it's less important then. However, the FSM is still sensitive to the number of states.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1359,2019-10-12T23:06:27Z,2019-10-14T11:07:23Z,2019-10-14T11:07:27Z,MERGED,True,5,5,1,https://github.com/i-rinat,replace remaining TFW_DBG3 macros with T_DBG3,1,[],https://github.com/tempesta-tech/tempesta/pull/1359,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1359,Since older TFW_DBG* definitions were removed from the code.,Since older TFW_DBG* definitions were removed from the code.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1360,2019-10-15T11:56:54Z,2019-10-16T10:48:45Z,2019-10-16T10:48:48Z,MERGED,True,2,1,1,https://github.com/i-rinat,tls: print whole encrypted tag in debug mode,1,[],https://github.com/tempesta-tech/tempesta/pull/1360,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1360,"Scatterlist array sg consists of a record payload and a constructed associated authentication data (AAD) block, so the length of all data in sg should also include TLS_AAD_SPACE_SIZE.","Scatterlist array sg consists of a record payload and a constructed associated authentication data (AAD) block, so the length of all data in sg should also include TLS_AAD_SPACE_SIZE.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1361,2019-10-15T12:49:10Z,2019-10-22T16:29:01Z,2019-10-22T16:29:11Z,MERGED,True,46,61,3,https://github.com/i-rinat,tls: move io context resetting to tfw_tls_msg_process(),1,[],https://github.com/tempesta-tech/tempesta/pull/1361,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1361,"Investigation of #1318 revealed an inherent issue with the previous design of the IO context resets. ttls_recv() reset the whole IO context, which in turn dropped skb list collected in a IO context so far, and then continued to parse the supplied data. This was an optimization that allowed ttls_recv() to greedily parse multiple records at a time. But if during TCP fragmentation a single skb ended up containing both an alert (or a handshake-related record) and a part of application data record, the code could forget a first part of the record. Then, when remaining parts of an application data record arrived, scatterlist was filled incorrectly, and reading uninitialized data could occur. As part of  essential enciphered data were discarded without processing, no further data exchange were possible.
The proposed solution is to move context resets out of ttls_recv() to tfw_tls_msg_process(). That makes ttls_recv() process a single record at a time, but also allows tfw_tls_msg_process() to reinitialize tls->io_in->skb_list before each record, thus eliminating the issue.","Investigation of #1318 revealed an inherent issue with the previous design of the IO context resets. ttls_recv() reset the whole IO context, which in turn dropped skb list collected in a IO context so far, and then continued to parse the supplied data. This was an optimization that allowed ttls_recv() to greedily parse multiple records at a time. But if during TCP fragmentation a single skb ended up containing both an alert (or a handshake-related record) and a part of application data record, the code could forget a first part of the record. Then, when remaining parts of an application data record arrived, scatterlist was filled incorrectly, and reading uninitialized data could occur. As part of  essential enciphered data were discarded without processing, no further data exchange were possible.
The proposed solution is to move context resets out of ttls_recv() to tfw_tls_msg_process(). That makes ttls_recv() process a single record at a time, but also allows tfw_tls_msg_process() to reinitialize tls->io_in->skb_list before each record, thus eliminating the issue.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1361,2019-10-15T12:49:10Z,2019-10-22T16:29:01Z,2019-10-22T16:29:11Z,MERGED,True,46,61,3,https://github.com/i-rinat,tls: move io context resetting to tfw_tls_msg_process(),1,[],https://github.com/tempesta-tech/tempesta/pull/1361,https://github.com/i-rinat,2,https://github.com/tempesta-tech/tempesta/pull/1361#issuecomment-543873036,"Investigation of #1318 revealed an inherent issue with the previous design of the IO context resets. ttls_recv() reset the whole IO context, which in turn dropped skb list collected in a IO context so far, and then continued to parse the supplied data. This was an optimization that allowed ttls_recv() to greedily parse multiple records at a time. But if during TCP fragmentation a single skb ended up containing both an alert (or a handshake-related record) and a part of application data record, the code could forget a first part of the record. Then, when remaining parts of an application data record arrived, scatterlist was filled incorrectly, and reading uninitialized data could occur. As part of  essential enciphered data were discarded without processing, no further data exchange were possible.
The proposed solution is to move context resets out of ttls_recv() to tfw_tls_msg_process(). That makes ttls_recv() process a single record at a time, but also allows tfw_tls_msg_process() to reinitialize tls->io_in->skb_list before each record, thus eliminating the issue.",Changed the patch to address review comments so far.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1362,2019-10-16T13:37:33Z,2019-10-24T02:04:03Z,2019-10-24T02:04:06Z,MERGED,True,63,20,4,https://github.com/ikoveshnikov,fix #1221: chunked encoding may be not-final encoding for response,1,[],https://github.com/tempesta-tech/tempesta/pull/1362,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1362,"RFC allows to add more encodings to chunked response, but correct
framing is possible only by connection close.","RFC allows to add more encodings to chunked response, but correct
framing is possible only by connection close.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1362,2019-10-16T13:37:33Z,2019-10-24T02:04:03Z,2019-10-24T02:04:06Z,MERGED,True,63,20,4,https://github.com/ikoveshnikov,fix #1221: chunked encoding may be not-final encoding for response,1,[],https://github.com/tempesta-tech/tempesta/pull/1362,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/1362#issuecomment-544808795,"RFC allows to add more encodings to chunked response, but correct
framing is possible only by connection close.","The whole PR was reworked, tests was added in tempesta-tech/tempesta-test#145
Every thing is clear with requests: request is blocked if chunked is not last encoding.
It's allowed to use chunked encoding as not the final encoding for response. When a ""unlimited"" body is received from backend server TempestaFW needs some how indicate the message end for the client. In most cases it's possible to apply the chunked encoding as the final encoding and pass the response to a client. But if the chunked encoding was already applied to the payload, RFC doesn't allow to apply it second time, even if the chunked wasn't the final encoding. In this case we have to close the connection with a client to indicate the message end.
The following message flags are used:

TFW_HTTP_B_CHUNKED - chunked is the final encoding, message framing is valid, no need to modify response.
TFW_HTTP_B_CHUNKED_APPLIED - chunked encoding is not the final encoding, so we can't modify the message to indicate the message end, and have to close the client connection. To accomplish that the TFW_HTTP_B_CONN_CLOSE flag is set for corresponding request in tfw_http_resp_terminate().
TFW_HTTP_B_UNLIMITED - the response body is to be parsed in unlimited mode - fin up the response on connection error event if the flag set, otherwise drop the response as incompletely received.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1363,2019-10-20T22:10:54Z,2019-11-04T17:52:30Z,2019-11-06T00:56:13Z,MERGED,True,3884,7026,50,https://github.com/krizhanovsky,#1064: small MPI cleanups and improvements,4,[],https://github.com/tempesta-tech/tempesta/pull/1363,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1363,"All changes are small, except bignum.[ch] where some small pieceis of logic were fully reworked.

MPI small optimizations and improvements:
1.1. introduce used to avoid zero skipping loops;
1.2. remove copies in several places;
1.3. reduce number and sizes of memset() calls
Reworked MPI debugging facilities and debug.[ch]
Remove secp192r1 as deprecated by RFC8422 5.1.1.
Finally get rid of config.h
Add MPI unit tests for basic operations to simplify debugging of new changes and adjust ECP and RSA tests.
Massive coding style fixes.
Proper reference to mbed TLS in licensing.","All changes are small, except bignum.[ch] where some small pieceis of logic were fully reworked.

MPI small optimizations and improvements:
1.1. introduce used to avoid zero skipping loops;
1.2. remove copies in several places;
1.3. reduce number and sizes of memset() calls
Reworked MPI debugging facilities and debug.[ch]
Remove secp192r1 as deprecated by RFC8422 5.1.1.
Finally get rid of config.h
Add MPI unit tests for basic operations to simplify debugging of new changes and adjust ECP and RSA tests.
Massive coding style fixes.
Proper reference to mbed TLS in licensing.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1364,2019-10-22T06:11:18Z,2019-10-25T08:27:22Z,2019-10-25T08:27:25Z,MERGED,True,28,23,1,https://github.com/ikoveshnikov,Remove compare operations in __http_msg_hdr_val and use smaller table…,1,[],https://github.com/tempesta-tech/tempesta/pull/1364,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1364,… sizes,… sizes,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1365,2019-10-22T15:19:34Z,2019-10-28T15:29:01Z,2019-11-06T11:29:03Z,CLOSED,False,12,1306,20,https://github.com/i-rinat,tls: remove unused macro definitions and macro conditionals,1,[],https://github.com/tempesta-tech/tempesta/pull/1365,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1365,"There was a number of macro-definitions which were used to enable selected features in the code. As we have no need to support conditional compilation, those macros can be removed along with the unneeded code.
This patch was originally a part of #1363.","There was a number of macro-definitions which were used to enable selected features in the code. As we have no need to support conditional compilation, those macros can be removed along with the unneeded code.
This patch was originally a part of #1363.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1366,2019-10-23T11:24:43Z,2019-10-23T12:33:10Z,2019-10-23T12:33:14Z,MERGED,True,27,18,1,https://github.com/ikoveshnikov,JS challenge: update js challenge templates on (re-)starting TempestaFW,1,[],https://github.com/tempesta-tech/tempesta/pull/1366,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1366,"The file was missed in #1354 PR.
Before that PR we had only one JS challenge configuration, but now it's per-vhost. The js_challenge directive was moved into sticky {} section. tempesta.sh now greps all sticky { } sections from the configuration file and updates the templates one-by-one.
The grep rules are still naive (commented keywords can be grepped, commented curly braces breaks section extraction and so on), but the configuration process will be significantly changed, so I don't think we should really pay attention to this.","The file was missed in #1354 PR.
Before that PR we had only one JS challenge configuration, but now it's per-vhost. The js_challenge directive was moved into sticky {} section. tempesta.sh now greps all sticky { } sections from the configuration file and updates the templates one-by-one.
The grep rules are still naive (commented keywords can be grepped, commented curly braces breaks section extraction and so on), but the configuration process will be significantly changed, so I don't think we should really pay attention to this.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1367,2019-10-25T06:28:39Z,2019-10-30T18:27:58Z,2019-10-31T06:31:01Z,MERGED,True,72,54,11,https://github.com/avbelov23,fix errors found by static analysers,7,[],https://github.com/tempesta-tech/tempesta/pull/1367,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1367,"Fix #1185

Fix dead assignments.
Fix dereference of null pointer (curr_cert_conf).
Fix dereference of null pointer (pos).
Fix use uninitialized argument value.
Add check on NULL in tests.","Fix #1185

Fix dead assignments.
Fix dereference of null pointer (curr_cert_conf).
Fix dereference of null pointer (pos).
Fix use uninitialized argument value.
Add check on NULL in tests.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1368,2019-10-26T16:20:03Z,2020-03-05T12:14:21Z,2020-03-05T12:27:27Z,MERGED,True,12887,3241,44,https://github.com/aleksostapenko,HTTP/2 Parser implementation (#309).,69,[],https://github.com/tempesta-tech/tempesta/pull/1368,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/1368,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1368,2019-10-26T16:20:03Z,2020-03-05T12:14:21Z,2020-03-05T12:27:27Z,MERGED,True,12887,3241,44,https://github.com/aleksostapenko,HTTP/2 Parser implementation (#309).,69,[],https://github.com/tempesta-tech/tempesta/pull/1368,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/1368#issuecomment-557837885,,"While HTTP/2 usage is still less than HTTP/1.1, it actually means that site owners don't deploy HTTP/2 and just stay on current (old) configurations. Meantime, it seems the most modern web clients do support HTTP/2, so

it's safe to make proto attribute of listen option h2 by default. Please patch etc/tempesta_fw.conf and adjust the Wiki
basically there is no sense to care about HTTP/1 performance on client side (only backend side matters for compatibility with the legacy backends).",True,{'THUMBS_UP': ['https://github.com/aleksostapenko']}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1370,2019-11-06T00:54:33Z,2019-11-06T14:00:46Z,2019-11-06T14:00:50Z,MERGED,True,7,3,2,https://github.com/i-rinat,tls: pr-1363-related follow-up changes,4,[],https://github.com/tempesta-tech/tempesta/pull/1370,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1370,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1371,2019-11-12T08:54:10Z,2019-11-14T12:33:17Z,2019-11-14T12:33:21Z,MERGED,True,398,3,8,https://github.com/ikoveshnikov,Process method override,3,[],https://github.com/tempesta-tech/tempesta/pull/1371,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1371,"fix #1369
Method override masks real request properties, non-idempotent methods can hide behind idempotent, method is used as a key in cache subsystem to store and look up cached responses. Thus hiding real method can spoil responses for other clients. Use the real method for accurate processing.
Don't rewrite the method string and don't remove override header since there can be additional intermediates between TempestaFW and backend.","fix #1369
Method override masks real request properties, non-idempotent methods can hide behind idempotent, method is used as a key in cache subsystem to store and look up cached responses. Thus hiding real method can spoil responses for other clients. Use the real method for accurate processing.
Don't rewrite the method string and don't remove override header since there can be additional intermediates between TempestaFW and backend.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1372,2019-11-24T20:17:50Z,2019-11-25T14:04:42Z,2019-11-25T14:04:46Z,MERGED,True,89,125,3,https://github.com/i-rinat,tls: mark-up temporary storage for clienthello parser,1,[],https://github.com/tempesta-tech/tempesta/pull/1372,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1372,"Transform the uniform tls->hs->tmp array into an object with named fields, to (hopefully) make its usage more explicit in the code. Additionally, all stored values are now stored in host byte order to avoid calling ntohs() or htons() each time we want to access the numbers.
Previously, a single buffer was used for both ciphersuite list and temporary extension linear buffer. Ciphersuite list could occupate almost the whole buffer, however 32 bytes were reserved for the temporary extension buffer. If ciphersuite list took less amount of storage, extension buffer had more capacity. It turns out that 32 bytes is not enough, and even in tests there are extensions which are at least 34 bytes in length. So if a client sends an unusually large list of ciphersuites, parse will fail at extension parsing stage.
This patch modifies code behavior a little bit. Now both ciphersuite list buffer and extension buffer are fixed-length. Extension buffer is 256 bytes long, and ciphersuite list takes what remains of about 1k of space. Should be enough for both.
Fixes #1265.","Transform the uniform tls->hs->tmp array into an object with named fields, to (hopefully) make its usage more explicit in the code. Additionally, all stored values are now stored in host byte order to avoid calling ntohs() or htons() each time we want to access the numbers.
Previously, a single buffer was used for both ciphersuite list and temporary extension linear buffer. Ciphersuite list could occupate almost the whole buffer, however 32 bytes were reserved for the temporary extension buffer. If ciphersuite list took less amount of storage, extension buffer had more capacity. It turns out that 32 bytes is not enough, and even in tests there are extensions which are at least 34 bytes in length. So if a client sends an unusually large list of ciphersuites, parse will fail at extension parsing stage.
This patch modifies code behavior a little bit. Now both ciphersuite list buffer and extension buffer are fixed-length. Extension buffer is 256 bytes long, and ciphersuite list takes what remains of about 1k of space. Should be enough for both.
Fixes #1265.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1373,2019-12-04T14:03:35Z,2019-12-30T13:36:31Z,2019-12-31T04:54:04Z,MERGED,True,9750,10649,103,https://github.com/ikoveshnikov,Cleanups for #1368,79,[],https://github.com/tempesta-tech/tempesta/pull/1373,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1373,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1374,2019-12-24T13:09:14Z,2020-01-21T13:01:09Z,2020-01-21T13:01:13Z,MERGED,True,516,413,11,https://github.com/ikoveshnikov,Fix request h2 -> http1.1 conversion,21,[],https://github.com/tempesta-tech/tempesta/pull/1374,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1374,"Main changes:

Keep h_tbl always valid since we need to read the table during
response caching. Keep the unsent skbs within request to avoid huge
updates of h_tbl
Optimize header alteration for h2, use compatibility mode for http1.1
Use tfw_msg_write functions to take care of all possible caveats at
message creation stage. (E.g. headers may be longer than one page)

Known issues:

Body and trailer conversion is not tested due to parsing issues:
body is not appended to the request and WARN_ON is triggered.","Main changes:

Keep h_tbl always valid since we need to read the table during
response caching. Keep the unsent skbs within request to avoid huge
updates of h_tbl
Optimize header alteration for h2, use compatibility mode for http1.1
Use tfw_msg_write functions to take care of all possible caveats at
message creation stage. (E.g. headers may be longer than one page)

Known issues:

Body and trailer conversion is not tested due to parsing issues:
body is not appended to the request and WARN_ON is triggered.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1375,2019-12-26T23:44:40Z,2020-04-28T09:23:04Z,2020-04-28T11:26:43Z,MERGED,True,22308,14976,143,https://github.com/krizhanovsky,#1064: TLS performance imporovements,154,[],https://github.com/tempesta-tech/tempesta/pull/1375,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1375,"#1064 point 1.
Introduce memory pools for the MPIs. MPI memory profile is an MPI memory pool filled at configuration time, so that we can use stream copy to quickly create ready to use MPI image for a particular PK computation.
#1064 point 2
Reduce number of public key checkings and assembly implementations for the core math.
TODO
The PR is buggy and to be fixed during the review.
Sorry for the large commits of mixed logical changes and cleanups.","#1064 point 1.
Introduce memory pools for the MPIs. MPI memory profile is an MPI memory pool filled at configuration time, so that we can use stream copy to quickly create ready to use MPI image for a particular PK computation.
#1064 point 2
Reduce number of public key checkings and assembly implementations for the core math.
TODO
The PR is buggy and to be fixed during the review.
Sorry for the large commits of mixed logical changes and cleanups.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1375,2019-12-26T23:44:40Z,2020-04-28T09:23:04Z,2020-04-28T11:26:43Z,MERGED,True,22308,14976,143,https://github.com/krizhanovsky,#1064: TLS performance imporovements,154,[],https://github.com/tempesta-tech/tempesta/pull/1375,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/1375#issuecomment-619010725,"#1064 point 1.
Introduce memory pools for the MPIs. MPI memory profile is an MPI memory pool filled at configuration time, so that we can use stream copy to quickly create ready to use MPI image for a particular PK computation.
#1064 point 2
Reduce number of public key checkings and assembly implementations for the core math.
TODO
The PR is buggy and to be fixed during the review.
Sorry for the large commits of mixed logical changes and cleanups.","With Tempesta configuration if RSA key is used (never reproduced with EC keys):
listen 80;
listen 443 proto=https;
cache 0;

tls_certificate /home/user/cert/tfw-root.crt;
tls_certificate_key /home/user/cert/tfw-root.key;

srv_group default {
    server 127.0.0.1:8080 conns_n=1;
}

block_action attack reply;

vhost default {
    proxy_pass default;
}

http_chain {
     -> default;
}

After running several attempts of tls-perf
./tls-perf -T 10  192.168.122.12 443 

debian login: [193427.134548] [tempesta tls] Warning: None of the common ciphersuites is usable (e.g. no suitable certificate)
[193427.136826] [tempesta fw] Warning: Unrecognized TLS receive return code -22, drop packet
[193527.406298] [tempesta fw] Warning: Unrecognized TLS receive return code -28288, drop packet
[193527.409931] [tempesta fw] Warning: Unrecognized TLS receive return code -28288, drop packet
[193527.413461] ------------[ cut here ]------------
[193527.415771] WARNING: CPU: 1 PID: 16 at /home/user/qtc/release/tempesta/tls/bignum.c:1223 ttls_mpi_exp_mod+0x6b3/0x9e0 [tempesta_tls]
[193527.421587] Modules linked in: tempesta_fw(O) tempesta_db(O) tempesta_tls(O) tempesta_lib(O) sha256_ssse3 sha512_ssse3 sha512_generic ccm kvm_intel binfmt_misc snd_hda_codec_generic iTCO_wdt iTCO_vendor_support kvm snd_hda_intel irqbypass crct10dif_pclmul crc32_pclmul snd_hda_codec ghash_clmulni_intel snd_hda_core snd_hwdep snd_pcm snd_timer snd sg soundcore virtio_console virtio_balloon virtio_gpu ttm pcspkr evdev lpc_ich serio_raw drm_kms_helper mfd_core drm shpchp button ip_tables x_tables autofs4 ext4 crc16 mbcache jbd2 fscrypto ecb aesni_intel crypto_simd cryptd glue_helper aes_x86_64 crc32c_generic sr_mod cdrom virtio_blk virtio_net crc32c_intel psmouse ahci i2c_i801 libahci libata sym53c8xx ehci_pci scsi_transport_spi uhci_hcd ehci_hcd scsi_mod virtio_pci virtio_ring virtio usbcore usb_common
[193527.448064]  [last unloaded: tempesta_lib]
[193527.449526] CPU: 1 PID: 16 Comm: ksoftirqd/1 Tainted: G           O    4.14.0-tempesta-kmemleak-amd64 #1 Debian 4.14.32-tfw7-1
[193527.452856] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS ?-20191223_100556-anatol 04/01/2014
[193527.455129] task: ffff91cb415d3c00 task.stack: ffffa01d006b0000
[193527.456308] RIP: 0010:ttls_mpi_exp_mod+0x6b3/0x9e0 [tempesta_tls]
[193527.457894] RSP: 0018:ffffa01d006b3408 EFLAGS: 00010206
[193527.459354] RAX: 0000000000000000 RBX: ffff91caf5ac1010 RCX: 0000000000000021
[193527.461390] RDX: 0000000000000020 RSI: ffff91caf5ac1018 RDI: ffff91caf5ac1028
[193527.464588] RBP: ffffa01d006b34c8 R08: ffff91caf5ac1040 R09: 0000000000000008
[193527.468112] R10: 0000000000000148 R11: ffff91cb0d740010 R12: ffff91caf5ac1020
[193527.471518] R13: ffffffffffffffff R14: ffff91caf5ac1040 R15: ffff91caf5ac1018
[193527.474295] FS:  0000000000000000(0000) GS:ffff91cb65500000(0000) knlGS:0000000000000000
[193527.476345] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[193527.477465] CR2: 00007fbd3f3c9018 CR3: 000000004ac0a006 CR4: 00000000003606e0
[193527.478678] Call Trace:
[193527.479456]  ? ttls_mpool+0x18/0x110 [tempesta_tls]
[193527.480394]  ? ttls_mpi_sub_int+0x4f/0xc0 [tempesta_tls]
[193527.481289]  ttls_dhm_make_params+0xa0/0x210 [tempesta_tls]
[193527.482261]  ttls_handshake_server_hello+0xd7c/0x1080 [tempesta_tls]
[193527.483772]  ? ttls_update_checksum+0x96/0x160 [tempesta_tls]
[193527.486626]  ttls_handshake_server_step+0x378/0x1a80 [tempesta_tls]
[193527.489689]  ? shash_async_import+0x40/0x40
[193527.490587]  ttls_recv+0x147/0x680 [tempesta_tls]
[193527.491529]  ? ttls_decrypt+0x5d0/0x5d0 [tempesta_tls]
[193527.493000]  ss_skb_process+0x11b/0x140 [tempesta_fw]
[193527.495499]  ? ip_finish_output2+0x19f/0x3b0
[193527.497245]  tfw_tls_msg_process+0xc0/0x4d0 [tempesta_fw]
[193527.499405]  ? ip_output+0x71/0xe0
[193527.501001]  ? ip_queue_xmit+0x5c/0x3b0
[193527.502922]  __gfsm_fsm_exec+0x56/0x90 [tempesta_fw]
[193527.504117]  tfw_connection_recv+0x41/0x60 [tempesta_fw]
[193527.506733]  ? tfw_connection_send+0x30/0x30 [tempesta_fw]
[193527.508318]  ss_tcp_process_data+0x1ea/0x480 [tempesta_fw]
[193527.509647]  ? dev_hard_start_xmit+0x31/0x1f0
[193527.511152]  ss_tcp_data_ready+0x43/0x90 [tempesta_fw]
[193527.512477]  tcp_data_queue+0x4f5/0xc50
[193527.513134]  tcp_rcv_established+0x27c/0x570
[193527.513847]  tcp_v4_do_rcv+0x129/0x1d0
[193527.514474]  tcp_v4_rcv+0x947/0xa50
[193527.515295]  ip_local_deliver_finish+0x9a/0x1c0
[193527.517538]  ip_local_deliver+0x6b/0xe0
[193527.519457]  ? tcp_v4_early_demux+0x112/0x150
[193527.521606]  ? ip_rcv_finish+0x17a/0x400
[193527.523205]  ip_rcv+0x289/0x3c0
[193527.524626]  ? inet_del_offload+0x40/0x40
[193527.525545]  __netif_receive_skb_core+0x84f/0xb30
[193527.526328]  ? lock_timer_base+0x74/0x90
[193527.527340]  ? process_backlog+0xa3/0x160
[193527.528969]  process_backlog+0xa3/0x160
[193527.530352]  net_rx_action+0x28e/0x3f0
[193527.531587]  __do_softirq+0x10f/0x2a8
[193527.532913]  run_ksoftirqd+0x1c/0x40
[193527.533918]  smpboot_thread_fn+0x10e/0x160
[193527.535624]  kthread+0xff/0x130
[193527.536592]  ? sort_range+0x20/0x20
[193527.537851]  ? kthread_create_on_node+0x70/0x70
[193527.539564]  ret_from_fork+0x35/0x40
[193527.540512] Code: 45 b6 66 44 89 4d b0 66 44 89 55 b2 e8 f7 d9 ff ff 48 8b 8d 70 ff ff ff 41 bb 01 00 00 00 66 44 89 5d b0 49 89 cf e9 da fa ff ff <0f> 0b b9 f4 ff ff ff e9 d4 fe ff ff 48 8b 85 78 ff ff ff 48 8b 
[193527.545381] ---[ end trace 00f20e676f79f25b ]---

Can't give more details this happend once ocasionally.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1375,2019-12-26T23:44:40Z,2020-04-28T09:23:04Z,2020-04-28T11:26:43Z,MERGED,True,22308,14976,143,https://github.com/krizhanovsky,#1064: TLS performance imporovements,154,[],https://github.com/tempesta-tech/tempesta/pull/1375,https://github.com/krizhanovsky,3,https://github.com/tempesta-tech/tempesta/pull/1375#issuecomment-619116619,"#1064 point 1.
Introduce memory pools for the MPIs. MPI memory profile is an MPI memory pool filled at configuration time, so that we can use stream copy to quickly create ready to use MPI image for a particular PK computation.
#1064 point 2
Reduce number of public key checkings and assembly implementations for the core math.
TODO
The PR is buggy and to be fixed during the review.
Sorry for the large commits of mixed logical changes and cleanups.","The call trace #1375 (comment) is quite weird. tls-perf produces only ECC handshakes, so ClientHello step should fail and it does fail - Warning: None of the common ciphersuites is usable is thrown exactly on the step. Meantime the call trace is from the later ServerHello step.
The script while :; do ./tls-perf -T 10 192.168.100.4 443; sleep 1; done even w/o the sleep 1 can not reveal the problem.
Having that the problem has appeared on a5c5143 commit, before the last memory leak and corruption fixes, I assume that the problem is in the corrupted memory.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1383,2020-02-18T18:03:34Z,2020-03-04T11:03:27Z,2020-03-04T13:36:32Z,MERGED,True,2643,1204,21,https://github.com/aleksostapenko,HTTP/2 implementation: HTTP/2-cache (#309).,7,[],https://github.com/tempesta-tech/tempesta/pull/1383,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/1383,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1384,2020-02-25T14:47:05Z,2020-02-26T11:28:12Z,2020-02-26T11:28:18Z,MERGED,True,18,1,3,https://github.com/ikoveshnikov,Fix memleaks on TLS processing,2,[],https://github.com/tempesta-tech/tempesta/pull/1384,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1384,fix #1382,fix #1382,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1385,2020-03-01T13:02:04Z,2020-03-03T11:00:07Z,2020-03-03T11:00:14Z,MERGED,True,240,226,4,https://github.com/ikoveshnikov,A few review comment fixes for http2 parser,3,[],https://github.com/tempesta-tech/tempesta/pull/1385,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1385,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1389,2020-03-16T09:29:16Z,2020-03-17T07:11:04Z,2020-03-17T07:11:10Z,MERGED,True,56,10,3,https://github.com/ikoveshnikov,Set correct Via header in responses served from cache,2,[],https://github.com/tempesta-tech/tempesta/pull/1389,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1389,Fix #1388,Fix #1388,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1395,2020-03-27T13:16:39Z,2020-03-31T03:48:04Z,2020-03-31T03:48:08Z,MERGED,True,119,90,6,https://github.com/ikoveshnikov,Fix issues when running JS challenge,7,[],https://github.com/tempesta-tech/tempesta/pull/1395,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1395,"Fix #1393
Changes:

Don't treat */* token in Accept: header as allowing to send JS challenge
Lower pressure on Tempesta by legitimate clients processing JS challenge by eliminating favicon.ico request. Empty favicon is integrated into JS challenge template.
Don't allow 'unchallengeable' requests to pass the challenge by mistake
Restart challenge if client has a cookie value from the last run. E.g. If the the challenge is failed, user still can reload the page and try challenge once again.","Fix #1393
Changes:

Don't treat */* token in Accept: header as allowing to send JS challenge
Lower pressure on Tempesta by legitimate clients processing JS challenge by eliminating favicon.ico request. Empty favicon is integrated into JS challenge template.
Don't allow 'unchallengeable' requests to pass the challenge by mistake
Restart challenge if client has a cookie value from the last run. E.g. If the the challenge is failed, user still can reload the page and try challenge once again.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1397,2020-03-30T19:21:13Z,2020-03-31T04:15:30Z,2020-03-31T04:15:36Z,MERGED,True,13,20,1,https://github.com/ikoveshnikov,Use unified redirect mark name on Sticky cookie redirects,2,[],https://github.com/tempesta-tech/tempesta/pull/1397,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1397,"Address #1393 (comment)
Redirect marks are checked on very early parsing stage, when target vhost is not yet known. In this case we can't use req->vhost->sticky->name to grab the redirection mark from the uri, just because req->vhost is not set. So we always use __tfw as redirect mark name.
Thus, when we build redirect, we can't use cookie name as redirect. This bring us to inconsistency problems: one rmark name is given, but other is validated. We missed that in functional tests, because we use default sticky coookie name which is perfectly equals to redirect mark name.
In this patch I replaced cookie name with common rmark name in redirect.
Other minor change: don't use compound string of cookie name and = character for redirects, since we have cookie name with extra = at the end exactly for such cases.","Address #1393 (comment)
Redirect marks are checked on very early parsing stage, when target vhost is not yet known. In this case we can't use req->vhost->sticky->name to grab the redirection mark from the uri, just because req->vhost is not set. So we always use __tfw as redirect mark name.
Thus, when we build redirect, we can't use cookie name as redirect. This bring us to inconsistency problems: one rmark name is given, but other is validated. We missed that in functional tests, because we use default sticky coookie name which is perfectly equals to redirect mark name.
In this patch I replaced cookie name with common rmark name in redirect.
Other minor change: don't use compound string of cookie name and = character for redirects, since we have cookie name with extra = at the end exactly for such cases.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1400,2020-04-03T11:33:10Z,2020-05-28T12:37:37Z,2020-05-28T12:37:42Z,MERGED,True,551,281,10,https://github.com/ikoveshnikov,Frame forwarded h2 message to never overflow max frame size on receive side,17,[],https://github.com/tempesta-tech/tempesta/pull/1400,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1400,#1378,#1378,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1401,2020-04-10T09:10:19Z,2020-04-20T07:47:12Z,2020-04-20T07:47:17Z,MERGED,True,21,9,1,https://github.com/ikoveshnikov,Process multiple 'Cookie:' header in http2 requests,2,[],https://github.com/tempesta-tech/tempesta/pull/1401,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1401,"Fix #1396.
A degradation was found in sticky module, introduced in 0937fed : a redirection mark is always added to 302 redirect even if disabled. Functional tests doesn't validate redirect uri, thus the degradation passed through CI tests. Functional tests are to be updated shortly. Fixed that.
The PR doesn't fix  #1396 (comment) yet.","Fix #1396.
A degradation was found in sticky module, introduced in 0937fed : a redirection mark is always added to 302 redirect even if disabled. Functional tests doesn't validate redirect uri, thus the degradation passed through CI tests. Functional tests are to be updated shortly. Fixed that.
The PR doesn't fix  #1396 (comment) yet.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1402,2020-04-15T12:29:43Z,2020-04-20T08:56:17Z,2020-11-14T15:38:34Z,CLOSED,False,2,0,1,https://github.com/ikoveshnikov,DONT MERGE: tcommit to test CI hooks,2,[],https://github.com/tempesta-tech/tempesta/pull/1402,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1402,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1402,2020-04-15T12:29:43Z,2020-04-20T08:56:17Z,2020-11-14T15:38:34Z,CLOSED,False,2,0,1,https://github.com/ikoveshnikov,DONT MERGE: tcommit to test CI hooks,2,[],https://github.com/tempesta-tech/tempesta/pull/1402,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/1402#issuecomment-616408999,,"CI throws an exception, need to fix it, I close pr , it never was required.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1405,2020-05-03T20:20:06Z,2020-08-10T18:59:32Z,2020-08-10T19:01:36Z,MERGED,True,6821,4012,51,https://github.com/krizhanovsky,NIST p256 EC performance optimizations,39,[],https://github.com/tempesta-tech/tempesta/pull/1405,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1405,"This pull request isn't ready for code review yet.

Improve TLS unit tests with more testing on EC point multiplication
Benchmark for ECDSA and ECDHE server operations
Specialized and optimized computation of m * G
Fast optimized non-constant time variant of modular inversion by Bernstein and Yang
Optimized FIPS 186-3 D.2 modular reduction
Get rid of most MPI wrappers on the hot path","This pull request isn't ready for code review yet.

Improve TLS unit tests with more testing on EC point multiplication
Benchmark for ECDSA and ECDHE server operations
Specialized and optimized computation of m * G
Fast optimized non-constant time variant of modular inversion by Bernstein and Yang
Optimized FIPS 186-3 D.2 modular reduction
Get rid of most MPI wrappers on the hot path",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1405,2020-05-03T20:20:06Z,2020-08-10T18:59:32Z,2020-08-10T19:01:36Z,MERGED,True,6821,4012,51,https://github.com/krizhanovsky,NIST p256 EC performance optimizations,39,[],https://github.com/tempesta-tech/tempesta/pull/1405,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/1405#issuecomment-671531568,"This pull request isn't ready for code review yet.

Improve TLS unit tests with more testing on EC point multiplication
Benchmark for ECDSA and ECDHE server operations
Specialized and optimized computation of m * G
Fast optimized non-constant time variant of modular inversion by Bernstein and Yang
Optimized FIPS 186-3 D.2 modular reduction
Get rid of most MPI wrappers on the hot path","@ikoveshnikov I merged the PR, but please do the review - I'll fix the issues in a new PR",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1407,2020-05-12T14:45:24Z,2020-05-15T12:55:40Z,2020-05-15T12:55:45Z,MERGED,True,29,0,1,https://github.com/avbelov23,Adding Content-Length to the request during transforming h2 to h1,1,[],https://github.com/tempesta-tech/tempesta/pull/1407,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1407,"#1409
When transforming h2 to h1, the request may contain a body, so Content-Length must be added for it","#1409
When transforming h2 to h1, the request may contain a body, so Content-Length must be added for it",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1410,2020-05-15T14:09:57Z,2020-11-04T18:40:37Z,2020-11-04T18:40:43Z,CLOSED,False,246,77,16,https://github.com/aleksostapenko,HTTP/2: remove chunked encoding during h1 -> h2 response transformation,1,[],https://github.com/tempesta-tech/tempesta/pull/1410,https://github.com/aleksostapenko,1,https://github.com/tempesta-tech/tempesta/pull/1410,"#1379
TODO:

While forwarding chunked encoded response to the client: a) in case of H2 client the body of the response is not needed to be edited, since all unnecessary chunked descriptors had been cut on the parsing stage; if response contains headers in trailer-part, they need to be placed after the DATA frame in the resulting H2 response - into the HEADERS/CONTINUATION frames; this can be done in tfw_h2_resp_adjust_fwd() - via iterating in tfw_h2_resp_next_hdr() only until the first header with TFW_STR_TRAILER flag, and applying the tfw_h2_resp_next_hdr() one more time - after the DATA frame(s) assembled - continuing from the first trailer header (with subsequent insertion of frame headers for trailer HEADERS/CONTINUATION frames); b) in the case of H1 client the new chunked descriptors should inserted (at least one - to define one chunk for entire body), but if the response does not have the trailer-part - perhaps it will be enough just to add Content-Length header with appropriate length of the body;
When saving the response into the cache, only H2 form of the response is written; thus, if chunked encoded response contains headers in trailer-part - it is better to save these headers after the body (to avoid double iteration over headers list during H2/H1 response generation from cache); it seems that this goal can be achieved via iteration through resp->mit.map (instead of iteration through resp->h_tbl, as now) in tfw_cache_copy_resp(), since in the map the headers are located in the order of their appearance in the message, and it makes possible sequentially storing into the cache the main headers, then body, and in the end - the headers of trailer-part. In the same time, the response body is not needed to be adjusted, since this work is already done during HTTP-parsing stage.
While generating H2 response from the cache (considering p.2) no any additional work should be done - it is needed only to read and send unchanged H2 response to the client. For the H1 case - the chunked-encoded response should be re-created similarly as described in p.1 (b).","#1379
TODO:

While forwarding chunked encoded response to the client: a) in case of H2 client the body of the response is not needed to be edited, since all unnecessary chunked descriptors had been cut on the parsing stage; if response contains headers in trailer-part, they need to be placed after the DATA frame in the resulting H2 response - into the HEADERS/CONTINUATION frames; this can be done in tfw_h2_resp_adjust_fwd() - via iterating in tfw_h2_resp_next_hdr() only until the first header with TFW_STR_TRAILER flag, and applying the tfw_h2_resp_next_hdr() one more time - after the DATA frame(s) assembled - continuing from the first trailer header (with subsequent insertion of frame headers for trailer HEADERS/CONTINUATION frames); b) in the case of H1 client the new chunked descriptors should inserted (at least one - to define one chunk for entire body), but if the response does not have the trailer-part - perhaps it will be enough just to add Content-Length header with appropriate length of the body;
When saving the response into the cache, only H2 form of the response is written; thus, if chunked encoded response contains headers in trailer-part - it is better to save these headers after the body (to avoid double iteration over headers list during H2/H1 response generation from cache); it seems that this goal can be achieved via iteration through resp->mit.map (instead of iteration through resp->h_tbl, as now) in tfw_cache_copy_resp(), since in the map the headers are located in the order of their appearance in the message, and it makes possible sequentially storing into the cache the main headers, then body, and in the end - the headers of trailer-part. In the same time, the response body is not needed to be adjusted, since this work is already done during HTTP-parsing stage.
While generating H2 response from the cache (considering p.2) no any additional work should be done - it is needed only to read and send unchanged H2 response to the client. For the H1 case - the chunked-encoded response should be re-created similarly as described in p.1 (b).",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1413,2020-05-22T15:19:33Z,2020-05-30T09:23:41Z,2020-05-30T09:23:45Z,MERGED,True,34,1,2,https://github.com/ikoveshnikov,Fix parsing short headers,2,[],https://github.com/tempesta-tech/tempesta/pull/1413,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1413,fix #1412,fix #1412,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1418,2020-06-09T11:32:45Z,,2021-03-08T15:54:11Z,OPEN,False,390,126,13,https://github.com/ikoveshnikov,Remove chunked encoding in http/1 responses,2,[],https://github.com/tempesta-tech/tempesta/pull/1418,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1418,"Chunked encoding is stripped from the response while it's
being parsed, if the response is forwarded to h1 client, the
encoding is applied back for correct message framing.
Since HTTP/2 is first citizen, we don't worry about performance
degradation for http1 clients, and this solution allows us to
avoid any further worries about unneeded chunked encoding in other
subsystems like cache.
Obsoletes #1410 Fixes #1379
Instead of stripping skb fragments during parsing, another approach is used:
a new TfwStr cut member was added into http parser object to track all the fragments to be removed from the message. It's generic enough to allow removal of any fragments from
both response and request.
Once parser has finished its job (on both TFW_POSTPONE TFW_PASS return codes), the
cut storage is stripped from the message. Since http message is processed skb-by-skb, the cut function will be called for every skb only once. This approach doesn't modify skb in parser internals, thus there is no need to pass modified skb parts to lower levels, which complicates code and makes it hardly tangled.
Since cut may (and will!) grow together with usual strings not supposed to be removed, a realloc-race is possible: both strings will grow together, which will block zero-copy realloc operations. To avoid that I've created a new TfwPool for parser needs. It's created for every new server connection. Once message is parsed and whole cut object was stripped, the memory required for cut object is released. This is not usual, since we normally never free objects from pools manually, but it allows to have only one pool for all messages in the single connections, and it shouldn't be exhausted.
Thus during parsing, the body from h1 responses is split into two parts: resp->body and parser->cut. First contains only data, the second - only chunk descriptors. Current realisation uses the same code for request and response parsing, and makes it effectively: usually MOVE_fixup macroses creates a lot of chunks with 1 or two characters, which is not suitable for large bodies. Instead chunks are combined together by their role, i.e. adjastment TfwStr chunks with chunk descriptors are glued together. According to my observations, it allows to have 3-6 times less TfwStr chunks to store single chunk descriptor.
Unfortunately the same approach can't be used to remove chunked token from the  Transfer-Encoding header. Server is allowed to apply chunked as not final encoding, so chunked token must be stripped only if it's final encoding. We can't guarantee this during parsing, so the chunked token is marked with flag, and removed later manually.","Chunked encoding is stripped from the response while it's
being parsed, if the response is forwarded to h1 client, the
encoding is applied back for correct message framing.
Since HTTP/2 is first citizen, we don't worry about performance
degradation for http1 clients, and this solution allows us to
avoid any further worries about unneeded chunked encoding in other
subsystems like cache.
Obsoletes #1410 Fixes #1379
Instead of stripping skb fragments during parsing, another approach is used:
a new TfwStr cut member was added into http parser object to track all the fragments to be removed from the message. It's generic enough to allow removal of any fragments from
both response and request.
Once parser has finished its job (on both TFW_POSTPONE TFW_PASS return codes), the
cut storage is stripped from the message. Since http message is processed skb-by-skb, the cut function will be called for every skb only once. This approach doesn't modify skb in parser internals, thus there is no need to pass modified skb parts to lower levels, which complicates code and makes it hardly tangled.
Since cut may (and will!) grow together with usual strings not supposed to be removed, a realloc-race is possible: both strings will grow together, which will block zero-copy realloc operations. To avoid that I've created a new TfwPool for parser needs. It's created for every new server connection. Once message is parsed and whole cut object was stripped, the memory required for cut object is released. This is not usual, since we normally never free objects from pools manually, but it allows to have only one pool for all messages in the single connections, and it shouldn't be exhausted.
Thus during parsing, the body from h1 responses is split into two parts: resp->body and parser->cut. First contains only data, the second - only chunk descriptors. Current realisation uses the same code for request and response parsing, and makes it effectively: usually MOVE_fixup macroses creates a lot of chunks with 1 or two characters, which is not suitable for large bodies. Instead chunks are combined together by their role, i.e. adjastment TfwStr chunks with chunk descriptors are glued together. According to my observations, it allows to have 3-6 times less TfwStr chunks to store single chunk descriptor.
Unfortunately the same approach can't be used to remove chunked token from the  Transfer-Encoding header. Server is allowed to apply chunked as not final encoding, so chunked token must be stripped only if it's final encoding. We can't guarantee this during parsing, so the chunked token is marked with flag, and removed later manually.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1421,2020-06-16T12:07:49Z,2020-06-16T14:15:28Z,2020-06-16T16:34:46Z,MERGED,True,2,3,1,https://github.com/keshonok,Avoid a potential it->skb NULL pointer dereference.,1,[],https://github.com/tempesta-tech/tempesta/pull/1421,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/1421,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1424,2020-06-22T10:11:00Z,2020-06-22T11:33:28Z,2020-06-22T11:37:18Z,MERGED,True,6,6,1,https://github.com/keshonok,Fix a typo in the name of a definition.,1,[],https://github.com/tempesta-tech/tempesta/pull/1424,https://github.com/keshonok,1,https://github.com/tempesta-tech/tempesta/pull/1424,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1425,2020-06-24T07:18:53Z,2020-06-24T09:21:11Z,2020-06-24T09:21:15Z,MERGED,True,4,0,1,https://github.com/ikoveshnikov,fix debug builds,1,[],https://github.com/tempesta-tech/tempesta/pull/1425,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1425,bignum.h uses DEBUG macro directly while it's depended from DBG_TLS,bignum.h uses DEBUG macro directly while it's depended from DBG_TLS,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1426,2020-06-25T15:00:21Z,2020-06-25T18:27:02Z,2020-06-25T18:27:06Z,MERGED,True,11,7,2,https://github.com/ikoveshnikov,fix #1420,1,[],https://github.com/tempesta-tech/tempesta/pull/1426,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1426,"When the Tempesta is started using systemd daemon, service management
in tempesta.sh conflicts with systemd unit management. This happens
because flock daemonizes and immediately exits. Systemd unit was
configured to run oneshot command thus tempesta-fw.service immediately
switches  to state started. It's highly likely that Tempesta is
not started by that moment.
Situation may became worse if concurrent start and stop happens:
flock process may be killed and lock file may become forever locked.
To fix all the issues:

don't manage concurrent starts manually, it's systemd job
use  ExecStopPost instead of ExecStop to call stop functions even on
unclean start
set TimeoutSec to handle cases with really long commands processings,
i.e. reconfiguration under heavy load.","When the Tempesta is started using systemd daemon, service management
in tempesta.sh conflicts with systemd unit management. This happens
because flock daemonizes and immediately exits. Systemd unit was
configured to run oneshot command thus tempesta-fw.service immediately
switches  to state started. It's highly likely that Tempesta is
not started by that moment.
Situation may became worse if concurrent start and stop happens:
flock process may be killed and lock file may become forever locked.
To fix all the issues:

don't manage concurrent starts manually, it's systemd job
use  ExecStopPost instead of ExecStop to call stop functions even on
unclean start
set TimeoutSec to handle cases with really long commands processings,
i.e. reconfiguration under heavy load.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1427,2020-06-25T15:28:40Z,2020-06-25T18:27:46Z,2020-06-25T18:27:51Z,MERGED,True,30,7,3,https://github.com/ikoveshnikov,backport #1426 to 0.6,2,[],https://github.com/tempesta-tech/tempesta/pull/1427,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1427,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1429,2020-07-07T16:40:53Z,2020-08-27T14:40:08Z,2020-08-27T14:51:56Z,MERGED,True,39,11,3,https://github.com/avbelov23,Delete keep-alive timer on connection_drop hook,3,[],https://github.com/tempesta-tech/tempesta/pull/1429,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1429,"#1428
The keep-alive timer may work after https://github.com/tempesta-tech/tempesta/blob/master/tempesta_fw/tls.c#L582, but before https://github.com/tempesta-tech/tempesta/blob /master/tempesta_fw/tls.c#L584 (where the timer is deleted) and we will catch the bug https://github.com/tempesta-tech/tempesta/blob/master/tls/ttls.c#L2242 (tfw_sock_cli_keepalive_timer_cb () tfw_connection_close () -> tfw_tls_conn_close () -> ttls_close_notify ()), because The tls context will be filled with zeros and tls-> conf == NULL after https://github.com/tempesta-tech/tempesta/blob/master/tempesta_fw/tls.c#L582","#1428
The keep-alive timer may work after https://github.com/tempesta-tech/tempesta/blob/master/tempesta_fw/tls.c#L582, but before https://github.com/tempesta-tech/tempesta/blob /master/tempesta_fw/tls.c#L584 (where the timer is deleted) and we will catch the bug https://github.com/tempesta-tech/tempesta/blob/master/tls/ttls.c#L2242 (tfw_sock_cli_keepalive_timer_cb () tfw_connection_close () -> tfw_tls_conn_close () -> ttls_close_notify ()), because The tls context will be filled with zeros and tls-> conf == NULL after https://github.com/tempesta-tech/tempesta/blob/master/tempesta_fw/tls.c#L582",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1430,2020-07-09T11:37:24Z,2020-08-07T11:24:53Z,2020-12-04T17:26:38Z,MERGED,True,911,509,11,https://github.com/ikoveshnikov,TLS session tickets,13,[],https://github.com/tempesta-tech/tempesta/pull/1430,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1430,"fix #1054
Not all requirements from 1054 is fulfilled yet. But the ticket subsystem works well under heavy load.
Basic tests can be done using:
openssl s_client -connect 192.168.122.12:443 -debug  -tls1_2  -reconnect -state -msg -tlsextdebug -security_debug_verbose

and https://github.com/vincentbernat/rfc5077/blob/master/rfc5077-client.c tool
Still in todo:

handshake limits
NewTicketMessage is sent separately from ChangeCipherSpec and Finished. The same apply to ServerHello and ChangeCipherSpec and Finished durin abbreviated handshake. Need to send them in one tcp frame.","fix #1054
Not all requirements from 1054 is fulfilled yet. But the ticket subsystem works well under heavy load.
Basic tests can be done using:
openssl s_client -connect 192.168.122.12:443 -debug  -tls1_2  -reconnect -state -msg -tlsextdebug -security_debug_verbose

and https://github.com/vincentbernat/rfc5077/blob/master/rfc5077-client.c tool
Still in todo:

handshake limits
NewTicketMessage is sent separately from ChangeCipherSpec and Finished. The same apply to ServerHello and ChangeCipherSpec and Finished durin abbreviated handshake. Need to send them in one tcp frame.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1436,2020-08-10T19:29:23Z,2020-08-10T20:07:53Z,2020-08-10T20:07:58Z,MERGED,True,26,0,2,https://github.com/krizhanovsky,Mock timer for TLS tests,1,[],https://github.com/tempesta-tech/tempesta/pull/1436,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1436,Fixes after merge of NIST p256 optimizations and TLS session resumption branches.,Fixes after merge of NIST p256 optimizations and TLS session resumption branches.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1437,2020-08-10T20:30:08Z,2020-08-10T20:44:43Z,2020-08-10T20:44:50Z,MERGED,True,3,1,1,https://github.com/ikoveshnikov,tls tickets: don't fail configuration if tls_tickets value is not needed,1,[],https://github.com/tempesta-tech/tempesta/pull/1437,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1437,"Even if explicit default vhost is created, an attempt to add an implicit tls_tickets directive with default value still happens. Since global-level  tls_tickets  directive is not allowed after explicit default vhost block configuration error is raised. But it's default implicit value, not configured by user, ignore it and continue configuration process.","Even if explicit default vhost is created, an attempt to add an implicit tls_tickets directive with default value still happens. Since global-level  tls_tickets  directive is not allowed after explicit default vhost block configuration error is raised. But it's default implicit value, not configured by user, ignore it and continue configuration process.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1443,2020-08-14T13:04:08Z,2020-08-14T17:22:55Z,2020-08-17T06:40:29Z,MERGED,True,3,0,1,https://github.com/avbelov23,Zero some vars as expected by the reconfiguration procedure ,1,[],https://github.com/tempesta-tech/tempesta/pull/1443,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1443,#1439,#1439,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1444,2020-08-19T07:57:32Z,2020-08-21T15:28:33Z,2020-08-21T15:28:37Z,MERGED,True,2,0,1,https://github.com/avbelov23,Restore the response date from the cache,1,[],https://github.com/tempesta-tech/tempesta/pull/1444,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1444,#1282,#1282,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1444,2020-08-19T07:57:32Z,2020-08-21T15:28:33Z,2020-08-21T15:28:37Z,MERGED,True,2,0,1,https://github.com/avbelov23,Restore the response date from the cache,1,[],https://github.com/tempesta-tech/tempesta/pull/1444,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/1444#issuecomment-675947375,#1282,Seems we ignored the test case in functional test. Could you either add it or add a task for the tests?,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1445,2020-08-19T12:36:01Z,2020-08-27T14:37:53Z,2020-08-27T14:52:00Z,MERGED,True,8,4,2,https://github.com/avbelov23, Use only the first duplicate X-Forwarded-For for client accounting,2,[],https://github.com/tempesta-tech/tempesta/pull/1445,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1445,#1403,#1403,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1447,2020-08-27T18:50:56Z,2020-08-31T13:56:53Z,2020-08-31T13:56:56Z,MERGED,True,33,0,1,https://github.com/krizhanovsky,Benchmark for modular multiplication vs squaring.,1,[],https://github.com/tempesta-tech/tempesta/pull/1447,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1447,"In our case we have ratio 0.9 which is much larger than classic 0.8.
This is one more proof that our FIPS modular reduction is too slow.","In our case we have ratio 0.9 which is much larger than classic 0.8.
This is one more proof that our FIPS modular reduction is too slow.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1448,2020-08-28T15:04:39Z,2020-09-11T23:12:45Z,2020-09-11T23:12:51Z,MERGED,True,142,32,7,https://github.com/avbelov23,Resetting the counter of redirected requests after a timeout during which the client must block,5,[],https://github.com/tempesta-tech/tempesta/pull/1448,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1448,"#1398

counting the timeout as a time interval after which the counter of redirected requests is reset
adding the ability to set the path directive for cookies
adding reconfiguration capability for js_challenge","#1398

counting the timeout as a time interval after which the counter of redirected requests is reset
adding the ability to set the path directive for cookies
adding reconfiguration capability for js_challenge",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1448,2020-08-28T15:04:39Z,2020-09-11T23:12:45Z,2020-09-11T23:12:51Z,MERGED,True,142,32,7,https://github.com/avbelov23,Resetting the counter of redirected requests after a timeout during which the client must block,5,[],https://github.com/tempesta-tech/tempesta/pull/1448,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/1448#issuecomment-687488780,"#1398

counting the timeout as a time interval after which the counter of redirected requests is reset
adding the ability to set the path directive for cookies
adding reconfiguration capability for js_challenge","About redirection mark:

it seems it's just ignored at the moment

It is ignored only when JSCH is enabled. Just like in your scenario. This happens because JSCH is sent in 503 response, while Location header is meaningful only for 3xx and 201 responses

it seems we can not track attempts any more

Only attempts for basic cookie challenge can be accounted now. Attempts for JSCH are not accounted, that's true.

rmark logic as a dead code

No, it perfectly works for the basic cookie challenge.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1448,2020-08-28T15:04:39Z,2020-09-11T23:12:45Z,2020-09-11T23:12:51Z,MERGED,True,142,32,7,https://github.com/avbelov23,Resetting the counter of redirected requests after a timeout during which the client must block,5,[],https://github.com/tempesta-tech/tempesta/pull/1448,https://github.com/krizhanovsky,3,https://github.com/tempesta-tech/tempesta/pull/1448#issuecomment-690727627,"#1398

counting the timeout as a time interval after which the counter of redirected requests is reset
adding the ability to set the path directive for cookies
adding reconfiguration capability for js_challenge",I noticed __tfw token in URI after redirection by JSCH. It seems we shouldn't see it with the last modifications,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1448,2020-08-28T15:04:39Z,2020-09-11T23:12:45Z,2020-09-11T23:12:51Z,MERGED,True,142,32,7,https://github.com/avbelov23,Resetting the counter of redirected requests after a timeout during which the client must block,5,[],https://github.com/tempesta-tech/tempesta/pull/1448,https://github.com/krizhanovsky,4,https://github.com/tempesta-tech/tempesta/pull/1448#issuecomment-690787296,"#1398

counting the timeout as a time interval after which the counter of redirected requests is reset
adding the ability to set the path directive for cookies
adding reconfiguration capability for js_challenge","Another usability issue: if a browser doesn't support JavaScript, then we just show the message
 Tempesta FW is verifying your browser, please wait a little bit...

Please add a line like ""Please check that you browser supports JavaScript""",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1449,2020-09-11T16:55:55Z,2020-09-11T23:11:34Z,2020-09-11T23:11:37Z,MERGED,True,11,7,2,https://github.com/avbelov23,Handling the return code of tfw_gfsm_move(),3,[],https://github.com/tempesta-tech/tempesta/pull/1449,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1449,#1441,#1441,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1450,2020-09-21T13:19:28Z,2020-10-09T14:52:15Z,2020-10-09T14:52:20Z,MERGED,True,373,20,3,https://github.com/avbelov23,Fix crash,9,[],https://github.com/tempesta-tech/tempesta/pull/1450,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1450,"fix #1408

copying each header to the cache, we must leave space for the string header, also, if there are duplicate headers, then we must write the duplicate header.

Earlier in the presence of duplicates, there was a double shift at the beginning of the copying procedure:
CSTR_MOVE_HDR
CSTR_WRITE_HDR
CSTR_MOVE_HDR
CSTR_MOVE_HDR
CSTR_WRITE_HDR


eliminated the progressive accumulation of duplicate lengths


some fixes for rebalancing procedure


if hpack rb-tree node was deleted, then we look for a new place to add a node, because the old place may be invalid due to the reducing of the procedure for deleting a node with two children to deleting a node with less than two children","fix #1408

copying each header to the cache, we must leave space for the string header, also, if there are duplicate headers, then we must write the duplicate header.

Earlier in the presence of duplicates, there was a double shift at the beginning of the copying procedure:
CSTR_MOVE_HDR
CSTR_WRITE_HDR
CSTR_MOVE_HDR
CSTR_MOVE_HDR
CSTR_WRITE_HDR


eliminated the progressive accumulation of duplicate lengths


some fixes for rebalancing procedure


if hpack rb-tree node was deleted, then we look for a new place to add a node, because the old place may be invalid due to the reducing of the procedure for deleting a node with two children to deleting a node with less than two children",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1456,2020-10-14T00:54:47Z,2021-05-02T20:52:39Z,2021-07-05T13:59:48Z,CLOSED,False,9,0,1,https://github.com/i-rinat,"frang: during stop procedure, wait until all in-flight sockets are done",1,[],https://github.com/tempesta-tech/tempesta/pull/1456,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1456,"It was possible to stop Tempesta while some sockets were still processed by the kernel network code. If Tempesta was started right after it was stopped, as it happens in restart procedure, a socket from a previous run may be freed during a current run. Rather than changing code logic to handle such ghosts from the past, let's wait in stop procedure until all related sockets are done.","It was possible to stop Tempesta while some sockets were still processed by the kernel network code. If Tempesta was started right after it was stopped, as it happens in restart procedure, a socket from a previous run may be freed during a current run. Rather than changing code logic to handle such ghosts from the past, let's wait in stop procedure until all related sockets are done.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1456,2020-10-14T00:54:47Z,2021-05-02T20:52:39Z,2021-07-05T13:59:48Z,CLOSED,False,9,0,1,https://github.com/i-rinat,"frang: during stop procedure, wait until all in-flight sockets are done",1,[],https://github.com/tempesta-tech/tempesta/pull/1456,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/1456#issuecomment-710982199,"It was possible to stop Tempesta while some sockets were still processed by the kernel network code. If Tempesta was started right after it was stopped, as it happens in restart procedure, a socket from a previous run may be freed during a current run. Rather than changing code logic to handle such ghosts from the past, let's wait in stop procedure until all related sockets are done.","The PR is intended to close the issue #1404 . A wait cycle is added to assure that all the client connections are closed during close.
At the first sight we already has the cycle that does the same: а tfw_sock_clnt_stop() spins until all client connections will receive SS_close() signal. The resource management relies on preemption here: stop() procedure is done in a process context while actual connection close procedures are performed in SoftIRQ. It looks like a week synchronisation and there might be a possibility that some sockets may be closed during stop() operations of further  modules.
Since TfwClient entries may live longer than their connections (to keep Frang accounting data between client reconnects), there is no direct way to assure, that all the client connections were closed. From this perspective an atomic counter of client connection is the only way to assure that all the connections were closed before stop. This is what the PR does.
Happily we already has this counter implemented, the function called ss_synchronize() and called on stop. It  assures that all the open connections used by Tempesta was closed. Some objects can leak there though. But it's a kind of eternal loop protection: if none of the connections was closed during last 5 seconds, then there is an issue in reference counters and there is no sense to wait for release. Thus I don't think we need a new counter in http_limits.c.
By the way, tfw_client_for_each() can cause a scheduler stall message in kernel log. Earlier TfwClients were organised as a list and looping through all the clients  involved a schedule() call like all other long loops in process context. So it was safe to dive into a long  tfw_client_for_each() loop. But after TDB become the storage for TfwClient instances, a new procedure tdb_entry_walk() was introduced, that can grab the scheduler for a long time while interrupts are disabled.
Rinat also described in chat a possible appearance of fantom connections left from the previous run:


Tempesta is started
A client0.tdb file is created and filled with zeros
An ingress connection increments counter of current active connections in client entry in the client0.tdb table
Tempesta restart is requested
An kernel_write() call fails during client0.tdb dumping on disk
Tempesta is started
The client0.tdb is read from disk, current connection counter there - 0
A socket for the ingress connection (established few steps earlier) is destroyed, a hook for sk_free is called.
Finally the frang_conn_close() is called, where the BUG_ON(!ra->conn_curr) is triggered.

kernel_write() errors are rare but possible. So does connections created on the previous run. Both conditions required to trigger the issue.

I don't believe in this case for several reasons. First, ss_syncronize() waits until all open connections are closed and complains if something leaks. Then a sk->sk_security must point to a valid data inside a reloaded  client0.tdb, it's very questionable, that dynamically allocated pointers for client0.tdb will mach between restarts. Well since the TDB structure is not finalised yet and all the databases are removed and fallocated before Tempesta start, we can get an extra luck to point at some random place in db memory area and get zeros from there. But the most important moment - #1404 was spotted without restarts several times, during workloads.
Another Rinat's remark about copying sk_security between sockets because of cloning sockets looks more promising.

sock_copy is called from sk_clone_lock allocating a new struct sock instance. sk_security member pointing on Frang data is simply copied from the old socket without any change to underlying data. Thus at some moment there is two different sockets pointing on the same instance of FrangAcc.

This idea looks more promising. For sk_security we have a function similar to sk_alloc_security() to  allocate TfwClient and bind it with a new client connection, we have sk_free_security() to free the pointer and to decrement reference counter of the corresponding TfwClient. But we have no sk_clone_security() implementation, which is supposed to be called every time, when a sk_security is cloned from one socket to another. Another thing that bothers me - we never set sk_security to zero when a connection is destroyed. Yes, we shouldn't see the socket after  sk_free_security() is called, but it's hard to notice the issue behind it and, more important, sk_free_security() touches two reference counters and can't be called twice.
I didn't figured out all the situations, when the clone() happens, so I can't say, how it's important. First, a socket is cloned from listening socked, when a minisocket is transformed to a full one after syn cookie is processed. We're Ok here, since listening socket has no security data. Second, a socket can be called from the relative one with TCP Fast Open. Not our case at all. Don't know if there are any other cases. But anyway having no sk_clone_security()  implemented looks suspicious while it's called in some situations.
Currently we need an instrumentation to distinguish one of the following situations:

a socket has sk_security pointing on uninitialised data somewhere in the client0.tdb. I don't believe in that though.
an sk_security was copied from another socket.
a  sk_free_security() is called against already closed socket.

Another suggestion came from Alexander: lower BUG_ON error to WARN_ON to avoid immediate crash and get a possibility to debug the issue.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1456,2020-10-14T00:54:47Z,2021-05-02T20:52:39Z,2021-07-05T13:59:48Z,CLOSED,False,9,0,1,https://github.com/i-rinat,"frang: during stop procedure, wait until all in-flight sockets are done",1,[],https://github.com/tempesta-tech/tempesta/pull/1456,https://github.com/krizhanovsky,3,https://github.com/tempesta-tech/tempesta/pull/1456#issuecomment-830870121,"It was possible to stop Tempesta while some sockets were still processed by the kernel network code. If Tempesta was started right after it was stopped, as it happens in restart procedure, a socket from a previous run may be freed during a current run. Rather than changing code logic to handle such ghosts from the past, let's wait in stop procedure until all related sockets are done.","The problem is with sockets on the TCP layer, below the Tempesta FW layer #1404 (comment)",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1457,2020-10-17T09:02:57Z,2021-02-20T16:25:27Z,2021-02-20T16:25:31Z,MERGED,True,137,99,9,https://github.com/ikoveshnikov,Fix framing on long msg,15,[],https://github.com/tempesta-tech/tempesta/pull/1457,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1457,"Although #1400 already fixed the issue, a bug remained hidden there thus client received 500 response instead of huge files over H2 connections. This happened because after H2 frame header is inserted, the message iterator and index pointer in whole represent invalid pointer to skb data. Now the pointer is fixed before iterator move and huge responsed are served as normal.
The second issue fixed in the PR is header modifications of http/1 responses served from cache. Detailed description is provided in commit messages.","Although #1400 already fixed the issue, a bug remained hidden there thus client received 500 response instead of huge files over H2 connections. This happened because after H2 frame header is inserted, the message iterator and index pointer in whole represent invalid pointer to skb data. Now the pointer is fixed before iterator move and huge responsed are served as normal.
The second issue fixed in the PR is header modifications of http/1 responses served from cache. Detailed description is provided in commit messages.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1457,2020-10-17T09:02:57Z,2021-02-20T16:25:27Z,2021-02-20T16:25:31Z,MERGED,True,137,99,9,https://github.com/ikoveshnikov,Fix framing on long msg,15,[],https://github.com/tempesta-tech/tempesta/pull/1457,https://github.com/avbelov23,2,https://github.com/tempesta-tech/tempesta/pull/1457#issuecomment-778192928,"Although #1400 already fixed the issue, a bug remained hidden there thus client received 500 response instead of huge files over H2 connections. This happened because after H2 frame header is inserted, the message iterator and index pointer in whole represent invalid pointer to skb data. Now the pointer is fixed before iterator move and huge responsed are served as normal.
The second issue fixed in the PR is header modifications of http/1 responses served from cache. Detailed description is provided in commit messages.",DONE,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1458,2020-10-22T15:21:03Z,2020-12-30T15:06:33Z,2020-12-30T15:06:38Z,MERGED,True,1535,908,25,https://github.com/ikoveshnikov,Implement frang limits for TLS layer,22,[],https://github.com/tempesta-tech/tempesta/pull/1458,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1458,"This PR implements Frang requirements from the #1054. I've got a few questions with glueing multiple tls messages into a  singe tcp packet, so I decided to move it to a separate PR. In this PR:
Three limits was added:


New TLS sessions rate/burst limit:
Block clients which creates a lot of new full TLS handshakes, which are proven to be expensive. On the first sight the limit duplicates connection rate/burst limit, but it can help mitigate TLS DDoS. Usually default TLS configuration is not redefined on client side, and TLS Tickets are enabled on the client. Using tickets client reduces TLS handshake footprint on a server performance. But in TLS Handshake DDoS client is more interested to stress the server as much as possible, thus it's expected that new full TLS handshakes will be performed more frequently.  With the new limit such clients can be identified and blocked, while the  connection rate/burst limit can remain more relaxed, not to introduce strict  limits on the application level side.


Uncomplete TLS sessions limit:
Block clients, which trigger errors during TLS handshakes or drops the connections before a handshake is completed. The limit represents defence against TLS traffic replays or forged TLS traffic. Such traffic is easy to generate and doesn't require a lot of computation  on client side.


A new limitation is  introduced to the TLS tickets: a session can be resumed with the client only if it's address was not changed: This doesn't badly affect us or normal client when it moves between cellular networks / wifi, but denies distribution  of a single TLS session between group of bots, allowing them to bypass full tls handshake process.","This PR implements Frang requirements from the #1054. I've got a few questions with glueing multiple tls messages into a  singe tcp packet, so I decided to move it to a separate PR. In this PR:
Three limits was added:


New TLS sessions rate/burst limit:
Block clients which creates a lot of new full TLS handshakes, which are proven to be expensive. On the first sight the limit duplicates connection rate/burst limit, but it can help mitigate TLS DDoS. Usually default TLS configuration is not redefined on client side, and TLS Tickets are enabled on the client. Using tickets client reduces TLS handshake footprint on a server performance. But in TLS Handshake DDoS client is more interested to stress the server as much as possible, thus it's expected that new full TLS handshakes will be performed more frequently.  With the new limit such clients can be identified and blocked, while the  connection rate/burst limit can remain more relaxed, not to introduce strict  limits on the application level side.


Uncomplete TLS sessions limit:
Block clients, which trigger errors during TLS handshakes or drops the connections before a handshake is completed. The limit represents defence against TLS traffic replays or forged TLS traffic. Such traffic is easy to generate and doesn't require a lot of computation  on client side.


A new limitation is  introduced to the TLS tickets: a session can be resumed with the client only if it's address was not changed: This doesn't badly affect us or normal client when it moves between cellular networks / wifi, but denies distribution  of a single TLS session between group of bots, allowing them to bypass full tls handshake process.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1458,2020-10-22T15:21:03Z,2020-12-30T15:06:33Z,2020-12-30T15:06:38Z,MERGED,True,1535,908,25,https://github.com/ikoveshnikov,Implement frang limits for TLS layer,22,[],https://github.com/tempesta-tech/tempesta/pull/1458,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/1458#issuecomment-743934572,"This PR implements Frang requirements from the #1054. I've got a few questions with glueing multiple tls messages into a  singe tcp packet, so I decided to move it to a separate PR. In this PR:
Three limits was added:


New TLS sessions rate/burst limit:
Block clients which creates a lot of new full TLS handshakes, which are proven to be expensive. On the first sight the limit duplicates connection rate/burst limit, but it can help mitigate TLS DDoS. Usually default TLS configuration is not redefined on client side, and TLS Tickets are enabled on the client. Using tickets client reduces TLS handshake footprint on a server performance. But in TLS Handshake DDoS client is more interested to stress the server as much as possible, thus it's expected that new full TLS handshakes will be performed more frequently.  With the new limit such clients can be identified and blocked, while the  connection rate/burst limit can remain more relaxed, not to introduce strict  limits on the application level side.


Uncomplete TLS sessions limit:
Block clients, which trigger errors during TLS handshakes or drops the connections before a handshake is completed. The limit represents defence against TLS traffic replays or forged TLS traffic. Such traffic is easy to generate and doesn't require a lot of computation  on client side.


A new limitation is  introduced to the TLS tickets: a session can be resumed with the client only if it's address was not changed: This doesn't badly affect us or normal client when it moves between cellular networks / wifi, but denies distribution  of a single TLS session between group of bots, allowing them to bypass full tls handshake process.","It turns out that there is a problem with the checksum calculation on the abbreviated handshakes. I run the tls.test_tls_tickets.TlsTicketTest.test_empty_ticket test from the current tempesta-tech/tempesta-test#179 (as of 71de2e00b6058898d05e833b50725738aaf815e2) on the merge of this branch and #1479 (the latest fixes for master). Now the test fails in different way than it was in #1310 (comment) (now Tempesta FW sends a correct alert):
======================================================================
ERROR: test_empty_ticket (tls.test_tls_tickets.TlsTicketTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File ""/root/tempesta-test/tls/test_tls_tickets.py"", line 98, in test_empty_ticket
    res = hs_abb.do_12_resume(master_secret, ticket)
  File ""/root/tempesta-test/tls/handshake.py"", line 437, in do_12_resume
    if not self._do_12_hs_resume(master_secret, ticket, fuzzer):
  File ""/root/tempesta-test/tls/handshake.py"", line 400, in _do_12_hs_resume
    self.send_recv(tls.TLS.from_records([msg]))
  File ""/root/tempesta-test/tls/handshake.py"", line 198, in send_recv
    pkt, resp)
TLSProtocolError: FATAL alert returned by server: DECODE_ERROR

The trace for DBG_TLS=3 debug build shows that the test passes normal hanshake, but can not finish the abbreviated handshake, so Tempesta  FW sends TTLS_ALERT_MSG_DECODE_ERROR alert. The full trace is at the below, note the bad hash in finished message message.
trace.txt
Also once I saw failing tls.test_tls_limits.TLSLimitsUncomplete:
======================================================================
FAIL: test (tls.test_tls_limits.TLSLimitsUncomplete)
----------------------------------------------------------------------
Traceback (most recent call last):
  File ""/root/tempesta-test/tls/test_tls_limits.py"", line 429, in test
    self.assertEqual(wc, 1, ""Frang limits warning is not shown"")
AssertionError: Frang limits warning is not shown

----------------------------------------------------------------------",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1458,2020-10-22T15:21:03Z,2020-12-30T15:06:33Z,2020-12-30T15:06:38Z,MERGED,True,1535,908,25,https://github.com/ikoveshnikov,Implement frang limits for TLS layer,22,[],https://github.com/tempesta-tech/tempesta/pull/1458,https://github.com/ikoveshnikov,3,https://github.com/tempesta-tech/tempesta/pull/1458#issuecomment-752361456,"This PR implements Frang requirements from the #1054. I've got a few questions with glueing multiple tls messages into a  singe tcp packet, so I decided to move it to a separate PR. In this PR:
Three limits was added:


New TLS sessions rate/burst limit:
Block clients which creates a lot of new full TLS handshakes, which are proven to be expensive. On the first sight the limit duplicates connection rate/burst limit, but it can help mitigate TLS DDoS. Usually default TLS configuration is not redefined on client side, and TLS Tickets are enabled on the client. Using tickets client reduces TLS handshake footprint on a server performance. But in TLS Handshake DDoS client is more interested to stress the server as much as possible, thus it's expected that new full TLS handshakes will be performed more frequently.  With the new limit such clients can be identified and blocked, while the  connection rate/burst limit can remain more relaxed, not to introduce strict  limits on the application level side.


Uncomplete TLS sessions limit:
Block clients, which trigger errors during TLS handshakes or drops the connections before a handshake is completed. The limit represents defence against TLS traffic replays or forged TLS traffic. Such traffic is easy to generate and doesn't require a lot of computation  on client side.


A new limitation is  introduced to the TLS tickets: a session can be resumed with the client only if it's address was not changed: This doesn't badly affect us or normal client when it moves between cellular networks / wifi, but denies distribution  of a single TLS session between group of bots, allowing them to bypass full tls handshake process.","""BUG: KASAN: stack-out-of-bounds in sha256_finup+0x12c/0x2a0 [sha256_ssse3]""

The root of the issue was incorrect usage of TTLS_TICKET_KEY_LEN macro. Previously ticket keys was 256-bit long, but after some discussion we decided to shrink them into  128 bits. Before the change TTLS_TICKET_KEY_LEN was equal to SHA256_DIGEST_SIZE and nothing bad happened, but after the change the first one become twice shorter and attempt to write 256 bit into 128 bit buffer caused the out-of-border access. Now all the macros was reviewed and fixed.

test_empty_ticket (tls.test_tls_tickets.TlsTicketTest) fails

This is issue of the tests itself: the scapy_ssl-tls dissector tries to split handshake message container into separate handshake messages. It sees the 8-byte long zero IV and treats it as two handshake messages with id==0x00 and len=0x000000. Thus two additional messages appear before the Finished message and Finished message is not asumed as encrypted. This leads to incorrect handhake checksum calculation on scapy side. I'm still looking for the issue and still investigating why the same case on full handshake doesn't involve the issue.

tls.test_tls_limits.TLSLimitsUncomplete

Tried many times but it always pass for me. Excep the cases when a high level of Tempesta debugging is enabled.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1459,2020-10-23T16:12:12Z,2020-11-13T19:02:44Z,2020-11-13T19:02:49Z,MERGED,True,123,107,3,https://github.com/ikoveshnikov,Merge TLS messages sent on session resumption scenario,2,[],https://github.com/tempesta-tech/tempesta/pull/1459,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1459,"Second part of the changes required by the #1054
Merge TLS messages together when sending them to the client. The ttls_handshake_server_hello() and ttls_handshake_finished() declared their own buffers, which represented two separate message sets. In this PR both functions use a single buffer declared in ttls_handshake_server_step(). Now both functions only fills the buffer, while   ttls_handshake_server_step() triggers the send process.","Second part of the changes required by the #1054
Merge TLS messages together when sending them to the client. The ttls_handshake_server_hello() and ttls_handshake_finished() declared their own buffers, which represented two separate message sets. In this PR both functions use a single buffer declared in ttls_handshake_server_step(). Now both functions only fills the buffer, while   ttls_handshake_server_step() triggers the send process.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1460,2020-11-04T12:27:17Z,2020-11-12T13:18:24Z,2020-11-12T13:18:28Z,MERGED,True,376,114,6,https://github.com/ikoveshnikov,Inherit sticky cookie configuration as stated in wiki,3,[],https://github.com/tempesta-tech/tempesta/pull/1460,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1460,"Inherit sticky cookie configuration as stated in wiki
Main changes:

'sticky' directive at top-level now updates default values instead of configuring implicit default vhost. Named vhosts inherit 'sticky' directive if it was defined at top-level.
implicit default vhost now inherits effective defaults from 'sticky'
sticky cookie secret is not stored as plain text for release configuration, but is still available in debug builds.
Sticky cookie secret length is relaxed to 1kb when it overrides default values.   If configured for named vhost, there is no limitation at all. Previously it had length of 20 bytes with very limited entropy since it was defined as a string in the configuration file. Now the length is relaxed, so keys with better entropy can be used.","Inherit sticky cookie configuration as stated in wiki
Main changes:

'sticky' directive at top-level now updates default values instead of configuring implicit default vhost. Named vhosts inherit 'sticky' directive if it was defined at top-level.
implicit default vhost now inherits effective defaults from 'sticky'
sticky cookie secret is not stored as plain text for release configuration, but is still available in debug builds.
Sticky cookie secret length is relaxed to 1kb when it overrides default values.   If configured for named vhost, there is no limitation at all. Previously it had length of 20 bytes with very limited entropy since it was defined as a string in the configuration file. Now the length is relaxed, so keys with better entropy can be used.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1461,2020-11-13T14:12:59Z,2020-11-16T17:00:46Z,2020-11-16T17:00:50Z,MERGED,True,94,29,6,https://github.com/avbelov23,Write header names in lower case when transform h1 responses to h2,2,[],https://github.com/tempesta-tech/tempesta/pull/1461,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1461,"Fix #1380
When placing in the cache and when transforming header names into h2, we transform them to lowercase","Fix #1380
When placing in the cache and when transforming header names into h2, we transform them to lowercase",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1462,2020-11-14T00:16:31Z,2020-11-14T20:34:43Z,2020-11-14T20:34:46Z,MERGED,True,6,1,3,https://github.com/i-rinat,Hide autogenerated code from git,2,[],https://github.com/tempesta-tech/tempesta/pull/1462,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1462,"The project now uses autogenerated tables and a generator to make the tables. They are not tracked by Git, so it would be nice to tell Git to ignore them. It would also be nice to remove the generator tgen_ec256 when make clean is called.","The project now uses autogenerated tables and a generator to make the tables. They are not tracked by Git, so it would be nice to tell Git to ignore them. It would also be nice to remove the generator tgen_ec256 when make clean is called.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1463,2020-11-14T05:57:25Z,2020-11-14T15:17:27Z,2020-11-14T15:25:15Z,MERGED,True,46,16,5,https://github.com/ikoveshnikov,Fix header modification on cached responses,4,[],https://github.com/tempesta-tech/tempesta/pull/1463,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1463,"This PR contain fixes from #1457, review for this part was successfully passed, but other, unrelated, fixes from #1457 require major updates. In order to push the fixes to master faster, I moved the changes to a separate PR.
Tests for this fixes are already merged to master and fails on master but not on this PR.","This PR contain fixes from #1457, review for this part was successfully passed, but other, unrelated, fixes from #1457 require major updates. In order to push the fixes to master faster, I moved the changes to a separate PR.
Tests for this fixes are already merged to master and fails on master but not on this PR.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1465,2020-11-19T13:51:39Z,2021-03-04T12:19:46Z,2021-03-04T12:19:51Z,MERGED,True,16,17,5,https://github.com/avbelov23,Close tls connection after encryption is complete,1,[],https://github.com/tempesta-tech/tempesta/pull/1465,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1465,"Fix #1431
Fix #1435
Close tls connection after encryption is complete, if it is a fatal alert or close notify","Fix #1431
Fix #1435
Close tls connection after encryption is complete, if it is a fatal alert or close notify",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1465,2020-11-19T13:51:39Z,2021-03-04T12:19:46Z,2021-03-04T12:19:51Z,MERGED,True,16,17,5,https://github.com/avbelov23,Close tls connection after encryption is complete,1,[],https://github.com/tempesta-tech/tempesta/pull/1465,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/1465#issuecomment-736581567,"Fix #1431
Fix #1435
Close tls connection after encryption is complete, if it is a fatal alert or close notify","One more notice about current ss_do_close() implementation. At the beginning of the function we just free all peer's data with
        while ((skb = __skb_dequeue(&sk->sk_receive_queue)) != NULL) {
                u32 len = TCP_SKB_CB(skb)->end_seq - TCP_SKB_CB(skb)->seq -            
                          tcp_hdr(skb)->fin;                                           
                data_was_unread += len;
                T_DBG3(""[%d]: free rcv skb %p\n"", smp_processor_id(), skb);            
                __kfree_skb(skb);                                                      
        }
and this isn't what TCP is supposed to do on active closing: we have to be able to read data from the peer. For example, if we forward an HTTP request with Connection: close to the server, we should not drop the response. We also need to read the peer TLS close notify to avoid TLS truncation attacks.
The things are even more complicated by the fact that we have normal and security socket closes: in normal case we need to process ingress data from the peer (e.g. an HTTP client), but if we close a connection on a security event, then we should not read from the socket any more. However, this topic is for #861: we should reset TCP connections and free all the skbs in the receive queue on a security event.
UPD I updated #861. We set SS_F_CONN_CLOSE only for client connections, so we're good with the receive queue draining, but we probably need it in future if we need 'descriptor close' in sense of the appropriate comment from the Linux tcp_close().",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1465,2020-11-19T13:51:39Z,2021-03-04T12:19:46Z,2021-03-04T12:19:51Z,MERGED,True,16,17,5,https://github.com/avbelov23,Close tls connection after encryption is complete,1,[],https://github.com/tempesta-tech/tempesta/pull/1465,https://github.com/avbelov23,3,https://github.com/tempesta-tech/tempesta/pull/1465#issuecomment-780536396,"Fix #1431
Fix #1435
Close tls connection after encryption is complete, if it is a fatal alert or close notify","Using ss_close_force() after the end of encryption (directly close a socket from tcp_write_xmit()) doesn't solve the problems.
In tcp_write_xmit(), at the end, the sending of the loss probe segment is rescheduled, and in the case of a direct ss_do_close() we clear all queues via inet_csk_destroy_sock() and crashes, because reschedule uses the cleared write queue (tcp_schedule_loss_probe()->tcp_rto_delta_us()->tcp_write_queue_head()).
I think ss_close_force() is too rude and I think it is worth using ss_close().",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1465,2020-11-19T13:51:39Z,2021-03-04T12:19:46Z,2021-03-04T12:19:51Z,MERGED,True,16,17,5,https://github.com/avbelov23,Close tls connection after encryption is complete,1,[],https://github.com/tempesta-tech/tempesta/pull/1465,https://github.com/krizhanovsky,4,https://github.com/tempesta-tech/tempesta/pull/1465#issuecomment-787134542,"Fix #1431
Fix #1435
Close tls connection after encryption is complete, if it is a fatal alert or close notify","I believe that the crash with tcp_schedule_loss_probe() is essentially what I'm working on in #1435 (comment) - please confirm that you have tcp_tasklet_fun() on the stack. I.e. the same crash happens on master and/or ak-1435 branch, which use asynchronous connection closing.
Please see the commit e651f28 . Probably it fixes the crashes, however it's still not wished to see sk_user_data == NULL in tfw_tls_encrypt(). Maybe it makes sense to rewrite sk->sk_destruct for Tempesta TLS sockets (with calling the original callback) and only there call the TLS freeing logic.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1466,2020-11-20T04:08:40Z,2020-11-20T17:52:41Z,2020-11-20T17:52:45Z,MERGED,True,5,6,1,https://github.com/ikoveshnikov,tls_tickets: fix buffer overrun during ticket encryption/decryption,1,[],https://github.com/tempesta-tech/tempesta/pull/1466,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1466,"When a TLS ticket is encrypted/decrypted, buffer size should be bigger
than actual size of encrypted data, because buffer starts with associated
data and ends up with tag. Problems was very rare with this code, since
contiguous memory chunk was used as a buffer for both encryption
and decryption.
The fix was originally found by @avbelov23 , but original commit had an issue with with ticket reuse.","When a TLS ticket is encrypted/decrypted, buffer size should be bigger
than actual size of encrypted data, because buffer starts with associated
data and ends up with tag. Problems was very rare with this code, since
contiguous memory chunk was used as a buffer for both encryption
and decryption.
The fix was originally found by @avbelov23 , but original commit had an issue with with ticket reuse.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1467,2020-11-23T21:20:09Z,2020-12-02T10:22:05Z,2020-12-02T10:22:09Z,MERGED,True,130,39,34,https://github.com/krizhanovsky,Fix TLS DEBUG build,4,[],https://github.com/tempesta-tech/tempesta/pull/1467,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1467,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1468,2020-11-25T14:01:13Z,2020-12-01T14:16:45Z,2020-12-01T14:16:49Z,MERGED,True,9,11,4,https://github.com/i-rinat,enforce invariant of TfwMsgIter::frag pointing to a current fragment,1,[],https://github.com/tempesta-tech/tempesta/pull/1468,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1468,"The meaning of TfwMsgIter::frag was not consistent before. In most of the places frag is the currently processed skb fragment. If it's -1, then we are processing a skb's body. If it's 0, the we are processing a first fragment, and that fragment does exist. But in some places, TfwMsgIter::frag pointed to a next-to-add fragment. These two approaches do not mix well, and when combined caused wild memory accesses.
This patch unifies meaning of TfwMsgIter::frag. Now if frag is non-negative, then there is a fragment with that index.
fixes #1399
fixes #1438","The meaning of TfwMsgIter::frag was not consistent before. In most of the places frag is the currently processed skb fragment. If it's -1, then we are processing a skb's body. If it's 0, the we are processing a first fragment, and that fragment does exist. But in some places, TfwMsgIter::frag pointed to a next-to-add fragment. These two approaches do not mix well, and when combined caused wild memory accesses.
This patch unifies meaning of TfwMsgIter::frag. Now if frag is non-negative, then there is a fragment with that index.
fixes #1399
fixes #1438",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1471,2020-12-09T00:12:57Z,2020-12-10T15:27:34Z,2020-12-10T15:27:38Z,MERGED,True,83,124,8,https://github.com/krizhanovsky,Fix #1470,2,[],https://github.com/tempesta-tech/tempesta/pull/1471,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1471,"Do not add TLS header for encrypted alerts - the headers are added
by tfw_tls_encrypt() -> ttls_aad2hdriv().
Process TLS version in the record header before anything else to not
to send alerts with invalid versions.

RFC 8446 (TLS 1.3) actually deprecates the TLS version fields in the
record header and requires them to be equal to 0x0303 (the same as for
TLS 1.2). Since TLS 1.2 and 1.3 are the only interesting for us, the
patch remove the version fields from TlsCtx and ciphersuites and uses
static checks. Thus, now the version handling is simplified a lot.
Add TLS-specific debugging to tempesta_fw/tls.c","Do not add TLS header for encrypted alerts - the headers are added
by tfw_tls_encrypt() -> ttls_aad2hdriv().
Process TLS version in the record header before anything else to not
to send alerts with invalid versions.

RFC 8446 (TLS 1.3) actually deprecates the TLS version fields in the
record header and requires them to be equal to 0x0303 (the same as for
TLS 1.2). Since TLS 1.2 and 1.3 are the only interesting for us, the
patch remove the version fields from TlsCtx and ciphersuites and uses
static checks. Thus, now the version handling is simplified a lot.
Add TLS-specific debugging to tempesta_fw/tls.c",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1476,2020-12-10T21:25:37Z,2020-12-10T21:57:08Z,2020-12-10T21:57:12Z,MERGED,True,0,6,2,https://github.com/krizhanovsky,Remove the couple of unused symbol exports,2,[],https://github.com/tempesta-tech/tempesta/pull/1476,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1476,"tfw_str_dprint() and tfw_dbg_vprint32() are used in tempesta_fw.ko module only, so do not export the symbols.","tfw_str_dprint() and tfw_dbg_vprint32() are used in tempesta_fw.ko module only, so do not export the symbols.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1478,2020-12-11T10:53:22Z,2020-12-11T11:18:42Z,2020-12-11T11:18:46Z,MERGED,True,2,2,1,https://github.com/krizhanovsky,Revert the wrong WARNING replacement with DEBUG message,1,[],https://github.com/tempesta-tech/tempesta/pull/1478,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1478,The reversion for #1471,The reversion for #1471,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1479,2020-12-12T18:15:43Z,2020-12-15T18:41:02Z,2020-12-15T18:41:06Z,MERGED,True,36,29,4,https://github.com/krizhanovsky,Fix tls.test_tls_cert.RSA512_SHA256 test,2,[],https://github.com/tempesta-tech/tempesta/pull/1479,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1479,"Print warning and exit with error if a user tries to load an RSA certificate with a key smaller than 1024 bits.
Do not check ctx->padding since we check it before the function calls.
Small coding style cleanups.
Note that __rsa_setup_ctx() during the for_each_possible_cpu() loop uses current CPU stack for all the big integer allocations, including ttls_mpi_inv_mod() and ttls_mpi_exp_mod(), and that's OK since the function is called on configuration time only and the stack allocations are used for temporal data only.","Print warning and exit with error if a user tries to load an RSA certificate with a key smaller than 1024 bits.
Do not check ctx->padding since we check it before the function calls.
Small coding style cleanups.
Note that __rsa_setup_ctx() during the for_each_possible_cpu() loop uses current CPU stack for all the big integer allocations, including ttls_mpi_inv_mod() and ttls_mpi_exp_mod(), and that's OK since the function is called on configuration time only and the stack allocations are used for temporal data only.",True,{'THUMBS_UP': ['https://github.com/sburn']}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1480,2020-12-24T01:19:59Z,2020-12-24T12:51:31Z,2020-12-24T12:51:37Z,MERGED,True,1,0,1,https://github.com/i-rinat,sess: pin learned sessions to the server they came from,1,[],https://github.com/tempesta-tech/tempesta/pull/1480,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1480,"Since we can't assume that different backend servers share session state, we must assume that sessions that we learn from a cookie supplied by a backend server are tied to that server. To reflect that, we need to take a reference on a structure that represents the server.
There is tfw_http_sess_pin_srv() that does the trick and is more self-explanatory, but in this particular place no unpinning is required, so it's sufficient to use just tfw_server_pin_sess().
Fixes #1469.","Since we can't assume that different backend servers share session state, we must assume that sessions that we learn from a cookie supplied by a backend server are tied to that server. To reflect that, we need to take a reference on a structure that represents the server.
There is tfw_http_sess_pin_srv() that does the trick and is more self-explanatory, but in this particular place no unpinning is required, so it's sufficient to use just tfw_server_pin_sess().
Fixes #1469.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1481,2021-01-01T16:37:26Z,2021-01-12T16:47:14Z,2021-01-12T16:47:17Z,MERGED,True,1226,2061,30,https://github.com/krizhanovsky,Performance optimizations for NIST p256 curve,14,"['performance', 'TLS']",https://github.com/tempesta-tech/tempesta/pull/1481,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1481,"Montgomery arithmetic
Replace mixed coordinates addition with addition in Jacobian coordinates for unknown point multiplication.
Introduce TLS_CONST_TIME compilation option to use constant time EC computations instead of point randomization.
Optimize memory usage in memory pools and some EC computations, reduce memory copyings.
Remove secp384 (#1335)
Workaround for #1404","Montgomery arithmetic
Replace mixed coordinates addition with addition in Jacobian coordinates for unknown point multiplication.
Introduce TLS_CONST_TIME compilation option to use constant time EC computations instead of point randomization.
Optimize memory usage in memory pools and some EC computations, reduce memory copyings.
Remove secp384 (#1335)
Workaround for #1404",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1484,2021-01-13T10:07:24Z,2021-01-13T12:45:31Z,2021-01-13T12:45:35Z,MERGED,True,18,9,3,https://github.com/ikoveshnikov,Fix invalid error messages if js_challenge points to invalid file,3,[],https://github.com/tempesta-tech/tempesta/pull/1484,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1484,fix #1442,fix #1442,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1485,2021-01-17T20:20:26Z,2021-03-08T15:31:50Z,2021-03-08T15:31:53Z,MERGED,True,167,66,4,https://github.com/krizhanovsky,Fix #1435,8,['TLS'],https://github.com/tempesta-tech/tempesta/pull/1485,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1485,"Fix the race between TSQ and socket closing on Tempesta side (the initial crash in tcp_rcv_state_process() -> tcp_schedule_loss_probe())
Fix the warning on keeping skb in the transmission list after an error in ss_send()
Do not destroy the TCP write queue with tcp_reset() called from tcp_write_xmit(). Also more the most TCP cleanup logic into tfw_tls_encrypt().","Fix the race between TSQ and socket closing on Tempesta side (the initial crash in tcp_rcv_state_process() -> tcp_schedule_loss_probe())
Fix the warning on keeping skb in the transmission list after an error in ss_send()
Do not destroy the TCP write queue with tcp_reset() called from tcp_write_xmit(). Also more the most TCP cleanup logic into tfw_tls_encrypt().",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1486,2021-01-19T14:06:37Z,2021-01-27T14:35:17Z,2021-01-27T14:35:22Z,MERGED,True,295,190,5,https://github.com/ikoveshnikov,Fix frang on  h2 requests,8,['h2'],https://github.com/tempesta-tech/tempesta/pull/1486,https://github.com/ikoveshnikov,1,https://github.com/tempesta-tech/tempesta/pull/1486,Fix #1477,Fix #1477,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1486,2021-01-19T14:06:37Z,2021-01-27T14:35:17Z,2021-01-27T14:35:22Z,MERGED,True,295,190,5,https://github.com/ikoveshnikov,Fix frang on  h2 requests,8,['h2'],https://github.com/tempesta-tech/tempesta/pull/1486,https://github.com/ikoveshnikov,2,https://github.com/tempesta-tech/tempesta/pull/1486#issuecomment-767280560,Fix #1477,"Please update 

Done.",True,{'THUMBS_UP': ['https://github.com/krizhanovsky']}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1491,2021-01-26T19:01:33Z,2021-01-26T19:15:43Z,2021-01-26T19:15:48Z,MERGED,True,2,2,1,https://github.com/krizhanovsky,tdb_file_open(): close the right file handle on error,2,[],https://github.com/tempesta-tech/tempesta/pull/1491,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1491,Fix #1040: tdb_file_open(): close the right file handle on error,Fix #1040: tdb_file_open(): close the right file handle on error,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1492,2021-02-01T00:41:44Z,2021-02-24T19:16:45Z,2021-02-24T21:28:30Z,MERGED,True,111,4,7,https://github.com/krizhanovsky,Fixes and tools to fight OOM,5,[],https://github.com/tempesta-tech/tempesta/pull/1492,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1492,"The PR is in progress.

skmem.pl script to track HTTP(S) sockets memory usage
Properly account sk_forward_alloc.
Add couple of unrelated comments","The PR is in progress.

skmem.pl script to track HTTP(S) sockets memory usage
Properly account sk_forward_alloc.
Add couple of unrelated comments",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1493,2021-02-20T12:22:26Z,2021-02-24T11:51:03Z,2021-02-24T11:51:07Z,MERGED,True,1,1,1,https://github.com/avbelov23,The effect of block_action on the absence of a suitable vhost,1,[],https://github.com/tempesta-tech/tempesta/pull/1493,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1493,Fix #1453,Fix #1453,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1495,2021-02-25T18:17:37Z,2021-02-26T12:23:29Z,2021-02-26T12:23:33Z,MERGED,True,22,6,3,https://github.com/i-rinat,parser: check return value of __tfw_http_msg_add_str_data,2,[],https://github.com/tempesta-tech/tempesta/pull/1495,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1495,"In extreme cases string operations may return -ENOMEM. It's better to stop parsing at that point.
Fixes #1494 by early dropping heavily-fragmented responses.","In extreme cases string operations may return -ENOMEM. It's better to stop parsing at that point.
Fixes #1494 by early dropping heavily-fragmented responses.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1495,2021-02-25T18:17:37Z,2021-02-26T12:23:29Z,2021-02-26T12:23:33Z,MERGED,True,22,6,3,https://github.com/i-rinat,parser: check return value of __tfw_http_msg_add_str_data,2,[],https://github.com/tempesta-tech/tempesta/pull/1495,https://github.com/i-rinat,2,https://github.com/tempesta-tech/tempesta/pull/1495#issuecomment-786125487,"In extreme cases string operations may return -ENOMEM. It's better to stop parsing at that point.
Fixes #1494 by early dropping heavily-fragmented responses.","update the TODO comment in __str_grow_tree

Rather than updating, deleted that line. Don't think any explanation of what's going on, will be useful there. That belongs to a separate design note about HTTP parser inner workings and their relationship with strings, I believe.
Added some descriptions instead of the removed TODO.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1496,2021-03-03T12:20:39Z,2021-03-05T20:39:02Z,2021-03-05T20:40:36Z,MERGED,True,53,17,2,https://github.com/avbelov23,Do expand transformation if add or inplace transformation fail,1,[],https://github.com/tempesta-tech/tempesta/pull/1496,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1496,#1488,#1488,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1497,2021-03-11T13:59:23Z,2021-03-26T21:32:22Z,2021-03-26T21:32:26Z,MERGED,True,25,1,1,https://github.com/avbelov23,Handling the case if data is inserted at the end of a fragment and after that there is no other fragment that starts after it ,1,[],https://github.com/tempesta-tech/tempesta/pull/1497,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1497,"#1475
Fix for msg_modification.* tests
If, when inserting/deleting data at the end of the fragment, there is no other fragment that starts immediately after that, then we will not be able to find the fragment to insert/delete data, and we need to add/delete data after the fragment at the end of which we wanted to insert.
Handling cases of looking for space in skbs to add/delete data larger than one chunk","#1475
Fix for msg_modification.* tests
If, when inserting/deleting data at the end of the fragment, there is no other fragment that starts immediately after that, then we will not be able to find the fragment to insert/delete data, and we need to add/delete data after the fragment at the end of which we wanted to insert.
Handling cases of looking for space in skbs to add/delete data larger than one chunk",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1499,2021-03-18T20:34:48Z,2021-03-22T23:15:53Z,2021-03-22T23:15:57Z,MERGED,True,195,342,17,https://github.com/krizhanovsky,Fix #1498: place each certificate of a loaded chain in separate page.,4,[],https://github.com/tempesta-tech/tempesta/pull/1499,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1499,"The previous approach with storing all the certificates in the same set of contiguous pages has several bugs:

the address of a certificate raw data isn't page-aligned, so we got the assertion failure.
we have to prepend each of the certificates with 3 bytes of length, and we didn't do this in the previous approach
a certificate in the chain may cross the page boundaris, so it'd be quite hard to properly write the length bytes and set the skb fragments.","The previous approach with storing all the certificates in the same set of contiguous pages has several bugs:

the address of a certificate raw data isn't page-aligned, so we got the assertion failure.
we have to prepend each of the certificates with 3 bytes of length, and we didn't do this in the previous approach
a certificate in the chain may cross the page boundaris, so it'd be quite hard to properly write the length bytes and set the skb fragments.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1501,2021-03-30T13:53:23Z,2021-04-01T14:51:56Z,2021-04-01T14:51:58Z,MERGED,True,241,102,7,https://github.com/avbelov23,added the ETag specific alphabet,3,[],https://github.com/tempesta-tech/tempesta/pull/1501,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1501,Fix #1500,Fix #1500,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1503,2021-05-03T01:02:14Z,2021-05-04T17:51:08Z,2021-05-04T17:51:11Z,MERGED,True,20,9,4,https://github.com/krizhanovsky,Fix #1404: ,1,[],https://github.com/tempesta-tech/tempesta/pull/1503,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1503,"We fristly shutdown sync_socket and then http_limits (the reverse order of the initialization). So there is a small window on the shutown phase, when all the connections on Tempesta layer are dead, but the sockets are still alive (typically half closed) and can call sk->sk_security callback from http_limits untill we unregester the callbacks.
The fix checks sk->sk_user_data and do not proceed frang_conn_close() all if it's NULL (the Tempesta connection is closed).
Besides the fix, we initialize sk_security and all the callbacks to not to call them, when the socket is unlinked.","We fristly shutdown sync_socket and then http_limits (the reverse order of the initialization). So there is a small window on the shutown phase, when all the connections on Tempesta layer are dead, but the sockets are still alive (typically half closed) and can call sk->sk_security callback from http_limits untill we unregester the callbacks.
The fix checks sk->sk_user_data and do not proceed frang_conn_close() all if it's NULL (the Tempesta connection is closed).
Besides the fix, we initialize sk_security and all the callbacks to not to call them, when the socket is unlinked.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1505,2021-05-15T14:33:03Z,2021-06-08T15:03:25Z,2021-06-08T15:03:26Z,CLOSED,False,1210,2661,173,https://github.com/krizhanovsky,Moving to Linux 5.10.35,7,[],https://github.com/tempesta-tech/tempesta/pull/1505,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1505,"Fix #1049 . Besides the migration:

remove all scheduling and HttpTables unit tests since it's a challenge to support them and we have functional tests
Do not compile the whole code with -mmmx -msse4.2: GCC 8 does much better job in autovectorization than GCC 6, so some of the non-FPU safe code (e.g. sysctl called from process context) may crash or corrupt user space processes. Now pragmas with GCC optimization options are used for specific performance crucial code.
Properly initialize the new skb->tcp_tsorted_anchor list
Employ sk_stream_alloc_skb() to properly use socket memory accounting and take advantage of the new sk->sk_tx_skb_cache
Fix the new sysctl output handling in tempesta.sh
skb->destructor now is a part of the union, so all the assertions against it became invalid
Remove ""tempesta_"" prefix from ""tempesta_fw"" and ""tempesta_db"" directories
Remove EXPORT_SYMBOL()'s used for unit tests only
Many other code cleanups .

Tests passed so far:

 tls unit tests
 tls_perf
 tempesta fw unit tests
 functional tests
 the site workload","Fix #1049 . Besides the migration:

remove all scheduling and HttpTables unit tests since it's a challenge to support them and we have functional tests
Do not compile the whole code with -mmmx -msse4.2: GCC 8 does much better job in autovectorization than GCC 6, so some of the non-FPU safe code (e.g. sysctl called from process context) may crash or corrupt user space processes. Now pragmas with GCC optimization options are used for specific performance crucial code.
Properly initialize the new skb->tcp_tsorted_anchor list
Employ sk_stream_alloc_skb() to properly use socket memory accounting and take advantage of the new sk->sk_tx_skb_cache
Fix the new sysctl output handling in tempesta.sh
skb->destructor now is a part of the union, so all the assertions against it became invalid
Remove ""tempesta_"" prefix from ""tempesta_fw"" and ""tempesta_db"" directories
Remove EXPORT_SYMBOL()'s used for unit tests only
Many other code cleanups .

Tests passed so far:

 tls unit tests
 tls_perf
 tempesta fw unit tests
 functional tests
 the site workload",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1507,2021-06-11T18:31:35Z,2021-06-11T18:31:44Z,2021-06-11T18:31:47Z,MERGED,True,4,3,2,https://github.com/krizhanovsky,Build cleanups,1,[],https://github.com/tempesta-tech/tempesta/pull/1507,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1507,"Kernel: auto-select crypto chain modes for Tempesta TLS
Remove unnecessary fallthrough.","Kernel: auto-select crypto chain modes for Tempesta TLS
Remove unnecessary fallthrough.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1508,2021-06-30T20:55:09Z,2021-06-30T21:43:17Z,2021-06-30T21:43:21Z,MERGED,True,10,0,1,https://github.com/i-rinat,Initialize sk->sk_cgrp_data in ss_sock_create/ss_inet_create,1,[],https://github.com/tempesta-tech/tempesta/pull/1508,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1508,"When CONFIG_CGROUP_BPF is enabled, but CONFIG_CGROUP_NET_PRIO and/or
CONFIG_CGROUP_NET_CLASSID are not, sock_cgroup_ptr() just returns
sk->sk_cgrp_data.val as is, without checking for NULL. Other functions in
the networking stack, say __cgroup_bpf_run_filter_sock_addr(), may then
try to dereference the pointer, causing the kernel to crash. As sk_alloc()
doesn't initialize sk->sk_cgrp_data when called from an interrupt
context, we need to do the initialization work themselves.","When CONFIG_CGROUP_BPF is enabled, but CONFIG_CGROUP_NET_PRIO and/or
CONFIG_CGROUP_NET_CLASSID are not, sock_cgroup_ptr() just returns
sk->sk_cgrp_data.val as is, without checking for NULL. Other functions in
the networking stack, say __cgroup_bpf_run_filter_sock_addr(), may then
try to dereference the pointer, causing the kernel to crash. As sk_alloc()
doesn't initialize sk->sk_cgrp_data when called from an interrupt
context, we need to do the initialization work themselves.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1509,2021-06-30T21:10:20Z,2021-06-30T21:43:39Z,2021-06-30T21:43:41Z,MERGED,True,4,2,1,https://github.com/i-rinat,update .gitignore ,1,[],https://github.com/tempesta-tech/tempesta/pull/1509,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1509,"Pull-request #1505 renamed tempesta_db/ to db/, so we need to update paths mentioned. And the newer Kbuild version started to create .mod and .cmd files that need to be ignored too.","Pull-request #1505 renamed tempesta_db/ to db/, so we need to update paths mentioned. And the newer Kbuild version started to create .mod and .cmd files that need to be ignored too.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1510,2021-07-04T00:21:12Z,2021-07-05T13:47:26Z,2021-07-05T13:47:28Z,MERGED,True,10,2,2,https://github.com/i-rinat,Fix unit test failures,2,[],https://github.com/tempesta-tech/tempesta/pull/1510,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1510,"There is a caching in the pool implementation that uses per-cpu arrays which must be allocated. Caches seems to work without initialization too, but they point to the beginning of %gs segment. That may cause false positive of the GCC's stack protector feature, as it relies on (%gs:0x28) keeping the same value all the time.","There is a caching in the pool implementation that uses per-cpu arrays which must be allocated. Caches seems to work without initialization too, but they point to the beginning of %gs segment. That may cause false positive of the GCC's stack protector feature, as it relies on (%gs:0x28) keeping the same value all the time.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1512,2021-07-07T13:52:02Z,2021-07-07T22:57:00Z,2021-07-07T22:57:03Z,MERGED,True,9,6,2,https://github.com/i-rinat,muffle UBSAN warnings caused by DECLARE_MPI_AUTO(),1,[],https://github.com/tempesta-tech/tempesta/pull/1512,https://github.com/i-rinat,1,https://github.com/tempesta-tech/tempesta/pull/1512,"DECLARE_MPI_AUTO() declares limbs just above TlsMpi instance on the stack, and subsequent accesses to limbs through MPI_P() make UB sanitizer to notice an access outside a TlsMpi structure instance. Technically it does cause an undefined behavior, but as I can't figure out how to make the same but without UB, we'll have to live with that.
Initializing limbs early in DECLARE_MPI_AUTO_INITLIMBS() makes UB accesses seem to go away. At least for the current UBSAN implementation.","DECLARE_MPI_AUTO() declares limbs just above TlsMpi instance on the stack, and subsequent accesses to limbs through MPI_P() make UB sanitizer to notice an access outside a TlsMpi structure instance. Technically it does cause an undefined behavior, but as I can't figure out how to make the same but without UB, we'll have to live with that.
Initializing limbs early in DECLARE_MPI_AUTO_INITLIMBS() makes UB accesses seem to go away. At least for the current UBSAN implementation.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1514,2021-08-08T20:41:37Z,2021-08-21T12:35:32Z,2021-08-21T12:35:35Z,MERGED,True,22,14,4,https://github.com/krizhanovsky,Handling web cache size configuration,4,[],https://github.com/tempesta-tech/tempesta/pull/1514,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1514,"Fixes for #1513:

use unsigned long to handle values up to the maximum TDB table size
of 128GB;
require multiplication of 2MB and range [16MB; 128GB].
Pick a huge pages memory region if it's exactly of requested size","Fixes for #1513:

use unsigned long to handle values up to the maximum TDB table size
of 128GB;
require multiplication of 2MB and range [16MB; 128GB].
Pick a huge pages memory region if it's exactly of requested size",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1517,2021-08-30T14:23:42Z,2021-08-30T14:24:08Z,2021-08-30T14:24:08Z,CLOSED,False,210,2,9,https://github.com/IronBug,Purge cache update,2,[],https://github.com/tempesta-tech/tempesta/pull/1517,https://github.com/IronBug,1,https://github.com/tempesta-tech/tempesta/pull/1517,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1518,2021-08-30T14:25:55Z,2021-11-11T23:26:41Z,2022-05-07T13:21:44Z,CLOSED,False,447,31,11,https://github.com/IronBug,Purge cache update,26,[],https://github.com/tempesta-tech/tempesta/pull/1518,https://github.com/IronBug,1,https://github.com/tempesta-tech/tempesta/pull/1518,Draft for PURGE with X-Tempesta-Cache flag (issue #1516),Draft for PURGE with X-Tempesta-Cache flag (issue #1516),True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1518,2021-08-30T14:25:55Z,2021-11-11T23:26:41Z,2022-05-07T13:21:44Z,CLOSED,False,447,31,11,https://github.com/IronBug,Purge cache update,26,[],https://github.com/tempesta-tech/tempesta/pull/1518,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/1518#issuecomment-966697170,Draft for PURGE with X-Tempesta-Cache flag (issue #1516),#1533 is the successor of the PR,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1519,2021-09-08T13:23:33Z,2021-09-10T12:59:47Z,2021-09-10T13:00:02Z,MERGED,True,61,27,3,https://github.com/snizovtsev,Fix IPv4/port decimals formatting issue,3,['bug'],https://github.com/tempesta-tech/tempesta/pull/1519,https://github.com/snizovtsev,1,https://github.com/tempesta-tech/tempesta/pull/1519,"A bug in tfw_put_dec() cause a garbage printed on some rare IPv4/port
decimals. May fire in places calling tfw_addr_fmt() or tfw_addr_ntop(),
like log entries or X-Forwarded-For header.
Wrongly formatted address looks like '104.131.181.:/', where ':/'
stands for '99'. On 0..255 range only 69, 79, 89 and 99 affected.
To fix this issue we re-examined original code found in
https://elixir.bootlin.com/linux/v3.10.25/source/lib/vsprintf.c#L131
and check all valid inputs against dumb algorithm.
Found in #1511.","A bug in tfw_put_dec() cause a garbage printed on some rare IPv4/port
decimals. May fire in places calling tfw_addr_fmt() or tfw_addr_ntop(),
like log entries or X-Forwarded-For header.
Wrongly formatted address looks like '104.131.181.:/', where ':/'
stands for '99'. On 0..255 range only 69, 79, 89 and 99 affected.
To fix this issue we re-examined original code found in
https://elixir.bootlin.com/linux/v3.10.25/source/lib/vsprintf.c#L131
and check all valid inputs against dumb algorithm.
Found in #1511.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1521,2021-09-13T14:08:56Z,2022-03-24T15:37:34Z,2022-03-24T15:37:38Z,MERGED,True,6640,2868,83,https://github.com/snizovtsev,Fix poor connection error messages,106,[],https://github.com/tempesta-tech/tempesta/pull/1521,https://github.com/snizovtsev,1,https://github.com/tempesta-tech/tempesta/pull/1521,"Remove server requested by client is not known where it is duplicated with unknown server name sni warning;
Otherwise replace server requested by client is not known with client requested misconfigured vhost;
Raise TLS server errors to WARN level to complement 0x7900 code with more details;
Add cipher suite name into None of the common ciphersuites is usable message;
Print unsupported algorithm OIDs;
Print peer address in catch-all-errors block.

Hint: please review commit by commit, not the whole changes.
Tests modified: tempesta-tech/tempesta-test#190
Closes #1511","Remove server requested by client is not known where it is duplicated with unknown server name sni warning;
Otherwise replace server requested by client is not known with client requested misconfigured vhost;
Raise TLS server errors to WARN level to complement 0x7900 code with more details;
Add cipher suite name into None of the common ciphersuites is usable message;
Print unsupported algorithm OIDs;
Print peer address in catch-all-errors block.

Hint: please review commit by commit, not the whole changes.
Tests modified: tempesta-tech/tempesta-test#190
Closes #1511",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1526,2021-09-23T10:21:38Z,2021-10-12T07:21:06Z,2021-10-12T07:23:10Z,MERGED,True,2198,1544,5,https://github.com/voodam,Add unit tests for headers and fix some parser bugs,2,[],https://github.com/tempesta-tech/tempesta/pull/1526,https://github.com/voodam,1,https://github.com/tempesta-tech/tempesta/pull/1526,"After approving I will also refactor suitable macros usage to more concise analogs: FOR_REQ_SIMPLE, FOR_RESP_SIMPLE and other (I don't want mess fixes and refactoring in commits).","After approving I will also refactor suitable macros usage to more concise analogs: FOR_REQ_SIMPLE, FOR_RESP_SIMPLE and other (I don't want mess fixes and refactoring in commits).",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1529,2021-10-12T15:59:19Z,2021-10-14T13:58:43Z,2021-10-14T13:58:46Z,MERGED,True,162,65,4,https://github.com/voodam,Improve Accept header tests and fix it's parsing a bit,2,[],https://github.com/tempesta-tech/tempesta/pull/1529,https://github.com/voodam,1,https://github.com/tempesta-tech/tempesta/pull/1529,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1531,2021-10-20T04:11:40Z,2021-10-20T13:40:21Z,2021-10-20T13:40:29Z,MERGED,True,63,8,3,None,FW shutdown clean-up,2,[],https://github.com/tempesta-tech/tempesta/pull/1531,None,1,https://github.com/tempesta-tech/tempesta/pull/1531,"This patch fixes several problems related to FW shutdown.


Run 'tfw_stop' when the module exit function is called. Right now
all kinds of things break, if the module is unloaded before FW is
propery shut down with a sysctl write.


Expose the module state using a separate procfs file. This allows
userland utilities and tests to look for this file rather than parse
the dmesg buffer.


The start/shutdown banners are written using a non-limited
logger. I think it doesn't make a lot of sense to rate-limit these.","This patch fixes several problems related to FW shutdown.


Run 'tfw_stop' when the module exit function is called. Right now
all kinds of things break, if the module is unloaded before FW is
propery shut down with a sysctl write.


Expose the module state using a separate procfs file. This allows
userland utilities and tests to look for this file rather than parse
the dmesg buffer.


The start/shutdown banners are written using a non-limited
logger. I think it doesn't make a lot of sense to rate-limit these.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1531,2021-10-20T04:11:40Z,2021-10-20T13:40:21Z,2021-10-20T13:40:29Z,MERGED,True,63,8,3,None,FW shutdown clean-up,2,[],https://github.com/tempesta-tech/tempesta/pull/1531,None,2,https://github.com/tempesta-tech/tempesta/pull/1531#issuecomment-947315490,"This patch fixes several problems related to FW shutdown.


Run 'tfw_stop' when the module exit function is called. Right now
all kinds of things break, if the module is unloaded before FW is
propery shut down with a sysctl write.


Expose the module state using a separate procfs file. This allows
userland utilities and tests to look for this file rather than parse
the dmesg buffer.


The start/shutdown banners are written using a non-limited
logger. I think it doesn't make a lot of sense to rate-limit these.",I added a new file instead of putting more stuff to perfstats. I think this will be easier to work with,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1531,2021-10-20T04:11:40Z,2021-10-20T13:40:21Z,2021-10-20T13:40:29Z,MERGED,True,63,8,3,None,FW shutdown clean-up,2,[],https://github.com/tempesta-tech/tempesta/pull/1531,https://github.com/snizovtsev,3,https://github.com/tempesta-tech/tempesta/pull/1531#issuecomment-947348960,"This patch fixes several problems related to FW shutdown.


Run 'tfw_stop' when the module exit function is called. Right now
all kinds of things break, if the module is unloaded before FW is
propery shut down with a sysctl write.


Expose the module state using a separate procfs file. This allows
userland utilities and tests to look for this file rather than parse
the dmesg buffer.


The start/shutdown banners are written using a non-limited
logger. I think it doesn't make a lot of sense to rate-limit these.",Fixes #1530 on my setup 👍,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1532,2021-10-26T11:54:59Z,2021-10-27T13:00:20Z,2021-10-27T13:00:24Z,MERGED,True,87,33,3,None,fix cache invalidation and live entry search,3,[],https://github.com/tempesta-tech/tempesta/pull/1532,None,1,https://github.com/tempesta-tech/tempesta/pull/1532,"This patch makes PURGE requests work as intended: cache entries are
invalidated and aren't served to clients, but subsequently cached
upstream responses can be found by tfw_cache_dbce_get.
Cache entry invalidation that is triggered by PURGE requests resets
lifetime on all matching entries, rather than only those found by
tfw_cache_dbce_get.
tfw_cache_dbce_get is now only used to find a cache entry that can
be returned downstream, including possibly stale entries, if we don't
have anything better.","This patch makes PURGE requests work as intended: cache entries are
invalidated and aren't served to clients, but subsequently cached
upstream responses can be found by tfw_cache_dbce_get.
Cache entry invalidation that is triggered by PURGE requests resets
lifetime on all matching entries, rather than only those found by
tfw_cache_dbce_get.
tfw_cache_dbce_get is now only used to find a cache entry that can
be returned downstream, including possibly stale entries, if we don't
have anything better.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1532,2021-10-26T11:54:59Z,2021-10-27T13:00:20Z,2021-10-27T13:00:24Z,MERGED,True,87,33,3,None,fix cache invalidation and live entry search,3,[],https://github.com/tempesta-tech/tempesta/pull/1532,None,2,https://github.com/tempesta-tech/tempesta/pull/1532#issuecomment-951862596,"This patch makes PURGE requests work as intended: cache entries are
invalidated and aren't served to clients, but subsequently cached
upstream responses can be found by tfw_cache_dbce_get.
Cache entry invalidation that is triggered by PURGE requests resets
lifetime on all matching entries, rather than only those found by
tfw_cache_dbce_get.
tfw_cache_dbce_get is now only used to find a cache entry that can
be returned downstream, including possibly stale entries, if we don't
have anything better.",See also #788 (comment),True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1533,2021-11-03T10:48:52Z,2021-11-15T11:56:15Z,2021-11-15T11:56:31Z,MERGED,True,228,11,6,None,PURGE w/ update implementation (#1516),1,[],https://github.com/tempesta-tech/tempesta/pull/1533,None,1,https://github.com/tempesta-tech/tempesta/pull/1533,"Note that while this seems to work for me, there are some quirks I didn't fix yet. For example:

""X-Tempesta-Cache"" is forwarded to an upstream. Probably need to mark it as an HBH header somewhere.
The upstream GET request comes with a ""Content-Length: 0"" header.

There might be other similar problems. I need to properly test everything now.
The original commit message:


During the request parsing, if there is an ""X-Tempesta-Cache""
header, set the TFW_HTTP_B_PURGE_GET request flag. If the request
method isn't PURGE, the flag is cleared at a later processing
stage.


PURGE request handling is mostly the same as before, i.e. it will
invalidate all matching cache entries, but also invoke a ""cache
action"" callback if the request flag (1) is set, so the request may
be forwarded to an upstream.


The message adjustment functions that are called before forwarding
(in both directions) now support PURGE requests.


During downstream to upstream forwarding, we rewrite the request
method to ""GET"" directly in an underlying SKB.


During upstream to downstream forwarding, the response body is
removed and the ""Content-Length"" is set to zero. So clients can
see original headers and a response status.




HTTP/2 is not supported for such requests.","Note that while this seems to work for me, there are some quirks I didn't fix yet. For example:

""X-Tempesta-Cache"" is forwarded to an upstream. Probably need to mark it as an HBH header somewhere.
The upstream GET request comes with a ""Content-Length: 0"" header.

There might be other similar problems. I need to properly test everything now.
The original commit message:


During the request parsing, if there is an ""X-Tempesta-Cache""
header, set the TFW_HTTP_B_PURGE_GET request flag. If the request
method isn't PURGE, the flag is cleared at a later processing
stage.


PURGE request handling is mostly the same as before, i.e. it will
invalidate all matching cache entries, but also invoke a ""cache
action"" callback if the request flag (1) is set, so the request may
be forwarded to an upstream.


The message adjustment functions that are called before forwarding
(in both directions) now support PURGE requests.


During downstream to upstream forwarding, we rewrite the request
method to ""GET"" directly in an underlying SKB.


During upstream to downstream forwarding, the response body is
removed and the ""Content-Length"" is set to zero. So clients can
see original headers and a response status.




HTTP/2 is not supported for such requests.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1534,2021-11-25T13:17:04Z,2021-12-13T09:30:22Z,2021-12-13T09:34:09Z,MERGED,True,74,5,3,https://github.com/Dmitry-Gouriev,Proposals for #1061 issue,19,[],https://github.com/tempesta-tech/tempesta/pull/1534,https://github.com/Dmitry-Gouriev,1,https://github.com/tempesta-tech/tempesta/pull/1534,"This request is for review, not for real pull!
The main idea of #1061 was to allow an optional single CTRL before HTTP request and block the request if there is smth else before the request. A single LF is to be allowed as well.
The proposed code will also allow a single CR at that place. This contradicts a little with #1061 however, I suppose, this difference is not important.
As a summary one of the CRLF, LF or CR is allowed and any other prepending character sequences will block the request.
The single CR can be disallowed by inserting one more ""state"" in func.","This request is for review, not for real pull!
The main idea of #1061 was to allow an optional single CTRL before HTTP request and block the request if there is smth else before the request. A single LF is to be allowed as well.
The proposed code will also allow a single CR at that place. This contradicts a little with #1061 however, I suppose, this difference is not important.
As a summary one of the CRLF, LF or CR is allowed and any other prepending character sequences will block the request.
The single CR can be disallowed by inserting one more ""state"" in func.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1534,2021-11-25T13:17:04Z,2021-12-13T09:30:22Z,2021-12-13T09:34:09Z,MERGED,True,74,5,3,https://github.com/Dmitry-Gouriev,Proposals for #1061 issue,19,[],https://github.com/tempesta-tech/tempesta/pull/1534,https://github.com/Dmitry-Gouriev,2,https://github.com/tempesta-tech/tempesta/pull/1534#issuecomment-983203082,"This request is for review, not for real pull!
The main idea of #1061 was to allow an optional single CTRL before HTTP request and block the request if there is smth else before the request. A single LF is to be allowed as well.
The proposed code will also allow a single CR at that place. This contradicts a little with #1061 however, I suppose, this difference is not important.
As a summary one of the CRLF, LF or CR is allowed and any other prepending character sequences will block the request.
The single CR can be disallowed by inserting one more ""state"" in func.","Sorry,
my technical commits will appear here.
I use the branch to move changes between VM and VPS,
and also for backup purpose.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1534,2021-11-25T13:17:04Z,2021-12-13T09:30:22Z,2021-12-13T09:34:09Z,MERGED,True,74,5,3,https://github.com/Dmitry-Gouriev,Proposals for #1061 issue,19,[],https://github.com/tempesta-tech/tempesta/pull/1534,https://github.com/Dmitry-Gouriev,3,https://github.com/tempesta-tech/tempesta/pull/1534#issuecomment-988773444,"This request is for review, not for real pull!
The main idea of #1061 was to allow an optional single CTRL before HTTP request and block the request if there is smth else before the request. A single LF is to be allowed as well.
The proposed code will also allow a single CR at that place. This contradicts a little with #1061 however, I suppose, this difference is not important.
As a summary one of the CRLF, LF or CR is allowed and any other prepending character sequences will block the request.
The single CR can be disallowed by inserting one more ""state"" in func.","I thought about rearranging the order of Req_0, Req_0_Wait_LF, Req_0_CheckExtraLeadingCRLF fragments in tfw_http_parse_req() (http_parser.c) to make the execution faster, but it seems that the compiler is making this job well by itself, so no further optimization required.
...
	__FSM_START(parser->state);
   21823:	49 8b 47 50          	mov    0x50(%r15),%rax
   21827:	48 85 c0             	test   %rax,%rax
   2182a:	0f 85 da 04 00 00    	jne    21d0a <tfw_http_parse_req+0x51a>
	__FSM_STATE(Req_0, hot) {
   21830:	0f b6 06             	movzbl (%rsi),%eax
		if (unlikely(c == '\r')) {
   21833:	3c 0d                	cmp    $0xd,%al
   21835:	0f 84 d7 04 00 00    	je     21d12 <tfw_http_parse_req+0x522>
	__FSM_DECLARE_VARS(req);
   2183b:	49 89 f4             	mov    %rsi,%r12
		if (unlikely(c == '\n')) {
   2183e:	3c 0a                	cmp    $0xa,%al
   21840:	0f 84 26 06 00 00    	je     21e6c <tfw_http_parse_req+0x67c>
	__FSM_STATE(Req_0_CheckExtraLeadingCRLF, hot) {
   21846:	45 0f b6 34 24       	movzbl (%r12),%r14d
		if (unlikely(c <= 0x20))
   2184b:	41 80 fe 20          	cmp    $0x20,%r14b
   2184f:	0f 86 e0 05 00 00    	jbe    21e35 <tfw_http_parse_req+0x645>
		if (likely(__data_available(p, 9))) {
   21855:	4c 89 e2             	mov    %r12,%rdx
   21858:	4c 89 e8             	mov    %r13,%rax
	__FSM_STATE(Req_Method, hot) {
   2185b:	41 0f b6 0c 24       	movzbl (%r12),%ecx
		if (likely(__data_available(p, 9))) {
   21860:	48 29 da             	sub    %rbx,%rdx
   21863:	48 29 d0             	sub    %rdx,%rax
   21866:	48 83 f8 08          	cmp    $0x8,%rax
   2186a:	0f 86 25 06 00 00    	jbe    21e95 <tfw_http_parse_req+0x6a5>
			if (PI(p) == TFW_CHAR4_INT('G', 'E', 'T', ' ')) {
...",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1534,2021-11-25T13:17:04Z,2021-12-13T09:30:22Z,2021-12-13T09:34:09Z,MERGED,True,74,5,3,https://github.com/Dmitry-Gouriev,Proposals for #1061 issue,19,[],https://github.com/tempesta-tech/tempesta/pull/1534,https://github.com/Dmitry-Gouriev,4,https://github.com/tempesta-tech/tempesta/pull/1534#issuecomment-989425155,"This request is for review, not for real pull!
The main idea of #1061 was to allow an optional single CTRL before HTTP request and block the request if there is smth else before the request. A single LF is to be allowed as well.
The proposed code will also allow a single CR at that place. This contradicts a little with #1061 however, I suppose, this difference is not important.
As a summary one of the CRLF, LF or CR is allowed and any other prepending character sequences will block the request.
The single CR can be disallowed by inserting one more ""state"" in func.","@krizhanovsky I follow all your comments in the last commit, except 2 comments in question (see discussion above).",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1534,2021-11-25T13:17:04Z,2021-12-13T09:30:22Z,2021-12-13T09:34:09Z,MERGED,True,74,5,3,https://github.com/Dmitry-Gouriev,Proposals for #1061 issue,19,[],https://github.com/tempesta-tech/tempesta/pull/1534,https://github.com/Dmitry-Gouriev,5,https://github.com/tempesta-tech/tempesta/pull/1534#issuecomment-990241035,"This request is for review, not for real pull!
The main idea of #1061 was to allow an optional single CTRL before HTTP request and block the request if there is smth else before the request. A single LF is to be allowed as well.
The proposed code will also allow a single CR at that place. This contradicts a little with #1061 however, I suppose, this difference is not important.
As a summary one of the CRLF, LF or CR is allowed and any other prepending character sequences will block the request.
The single CR can be disallowed by inserting one more ""state"" in func.","In current state CRLF parser skips and mark for subsequent deletion single CRLF and single LF sequences.
Blocking requests which start from multipe CRLF and LF sequences or sequences of other unusual characters is assingned to subsequent method parser.
It was detected that http parser in current state accidentally accepts the sequences of double LF.
As the result, double LF tests in CRLF test set show negative result.
Investigations show that the first LF is processed by CRLF parser and the second LF is eaten by
 4411         default:
 4412                 __FSM_MOVE_nofixup(Req_MethodUnknown);


in non-chunked processing ( Req_Method_RareMethods section )
and by
 4442         __FSM_MOVE_nofixup(Req_MethodUnknown);

in 1-char processing ( Req_Method_1CharStep section),
and the request seems to be legal for subsequent parser states.
Replacing 4412 with
 4412                 __FSM_JMP(Req_MethodUnknown);

solves the problem for non-chunked processing.
Similar change in 4442 line breaks in some way processing of piplined messages,
and double LF test shows positive results whereas some pipelined tests show negative results.
Anyway more analisys and testing is required to make these or similar replacements.
The case is a subject of #1536 issue.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1538,2021-12-17T01:21:23Z,2022-01-18T14:34:37Z,2022-05-07T13:42:49Z,MERGED,True,117,57,2,https://github.com/Dmitry-Gouriev,Solutions for #1536 issue,25,[],https://github.com/tempesta-tech/tempesta/pull/1538,https://github.com/Dmitry-Gouriev,1,https://github.com/tempesta-tech/tempesta/pull/1538,"This PR contains solution for initial #1536 problem, as well as additional problems with HTTP Method parser, gathered on the way.
The following text is a candidate for description of the squashing commit.
The problems solved:

double LF sequence before method name
zero-length method name
illegal characters inside method name

Requests with any of these incorrectnesses now are rejected.
The main method of solution is replacing __FSM_MOVE_nofixup() macro, accidentaly inserted instead of __FSM_JMP() macro, with the __FSM_JMP() everywhere over a code of HTTP Method parser. However, the problem of zero-length method name requires different method which is now implemented as well.
To detect these bugs (and to be sure they no more exist) the following tests were added to unit tests:

double LF before request line
double CRLF before request line
the request with zero-length method "" /filename HTTP/1.1""
the requests with mangled method name


""\tOST""




""P\tST""




""PO\tT""




""POS\t""


tests for number of leading bytes to strip, which complement pre-existed tests for allowed 0, 1 (LF) and 2 (CRLF) characters before request line (the tests for #1061 issue).

The new chunking procedure based on fixed CHUNK_SIZES list is introduced in this PR insteand of conevntional one
based on PRIMES array and pseudorandomness, because the PRIMES procedure do not detect some of listed errors.
Two additional bugs in the parser were detected on the way:

the #1537 - solved here,
the 1537-bis - solution imported from PR #1546.","This PR contains solution for initial #1536 problem, as well as additional problems with HTTP Method parser, gathered on the way.
The following text is a candidate for description of the squashing commit.
The problems solved:

double LF sequence before method name
zero-length method name
illegal characters inside method name

Requests with any of these incorrectnesses now are rejected.
The main method of solution is replacing __FSM_MOVE_nofixup() macro, accidentaly inserted instead of __FSM_JMP() macro, with the __FSM_JMP() everywhere over a code of HTTP Method parser. However, the problem of zero-length method name requires different method which is now implemented as well.
To detect these bugs (and to be sure they no more exist) the following tests were added to unit tests:

double LF before request line
double CRLF before request line
the request with zero-length method "" /filename HTTP/1.1""
the requests with mangled method name


""\tOST""




""P\tST""




""PO\tT""




""POS\t""


tests for number of leading bytes to strip, which complement pre-existed tests for allowed 0, 1 (LF) and 2 (CRLF) characters before request line (the tests for #1061 issue).

The new chunking procedure based on fixed CHUNK_SIZES list is introduced in this PR insteand of conevntional one
based on PRIMES array and pseudorandomness, because the PRIMES procedure do not detect some of listed errors.
Two additional bugs in the parser were detected on the way:

the #1537 - solved here,
the 1537-bis - solution imported from PR #1546.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1538,2021-12-17T01:21:23Z,2022-01-18T14:34:37Z,2022-05-07T13:42:49Z,MERGED,True,117,57,2,https://github.com/Dmitry-Gouriev,Solutions for #1536 issue,25,[],https://github.com/tempesta-tech/tempesta/pull/1538,https://github.com/Dmitry-Gouriev,2,https://github.com/tempesta-tech/tempesta/pull/1538#issuecomment-1013303380,"This PR contains solution for initial #1536 problem, as well as additional problems with HTTP Method parser, gathered on the way.
The following text is a candidate for description of the squashing commit.
The problems solved:

double LF sequence before method name
zero-length method name
illegal characters inside method name

Requests with any of these incorrectnesses now are rejected.
The main method of solution is replacing __FSM_MOVE_nofixup() macro, accidentaly inserted instead of __FSM_JMP() macro, with the __FSM_JMP() everywhere over a code of HTTP Method parser. However, the problem of zero-length method name requires different method which is now implemented as well.
To detect these bugs (and to be sure they no more exist) the following tests were added to unit tests:

double LF before request line
double CRLF before request line
the request with zero-length method "" /filename HTTP/1.1""
the requests with mangled method name


""\tOST""




""P\tST""




""PO\tT""




""POS\t""


tests for number of leading bytes to strip, which complement pre-existed tests for allowed 0, 1 (LF) and 2 (CRLF) characters before request line (the tests for #1061 issue).

The new chunking procedure based on fixed CHUNK_SIZES list is introduced in this PR insteand of conevntional one
based on PRIMES array and pseudorandomness, because the PRIMES procedure do not detect some of listed errors.
Two additional bugs in the parser were detected on the way:

the #1537 - solved here,
the 1537-bis - solution imported from PR #1546.",Bound to issue #1537 as well.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1538,2021-12-17T01:21:23Z,2022-01-18T14:34:37Z,2022-05-07T13:42:49Z,MERGED,True,117,57,2,https://github.com/Dmitry-Gouriev,Solutions for #1536 issue,25,[],https://github.com/tempesta-tech/tempesta/pull/1538,https://github.com/Dmitry-Gouriev,3,https://github.com/tempesta-tech/tempesta/pull/1538#issuecomment-1013305894,"This PR contains solution for initial #1536 problem, as well as additional problems with HTTP Method parser, gathered on the way.
The following text is a candidate for description of the squashing commit.
The problems solved:

double LF sequence before method name
zero-length method name
illegal characters inside method name

Requests with any of these incorrectnesses now are rejected.
The main method of solution is replacing __FSM_MOVE_nofixup() macro, accidentaly inserted instead of __FSM_JMP() macro, with the __FSM_JMP() everywhere over a code of HTTP Method parser. However, the problem of zero-length method name requires different method which is now implemented as well.
To detect these bugs (and to be sure they no more exist) the following tests were added to unit tests:

double LF before request line
double CRLF before request line
the request with zero-length method "" /filename HTTP/1.1""
the requests with mangled method name


""\tOST""




""P\tST""




""PO\tT""




""POS\t""


tests for number of leading bytes to strip, which complement pre-existed tests for allowed 0, 1 (LF) and 2 (CRLF) characters before request line (the tests for #1061 issue).

The new chunking procedure based on fixed CHUNK_SIZES list is introduced in this PR insteand of conevntional one
based on PRIMES array and pseudorandomness, because the PRIMES procedure do not detect some of listed errors.
Two additional bugs in the parser were detected on the way:

the #1537 - solved here,
the 1537-bis - solution imported from PR #1546.","Additionaly, the test fills_hdr_tbl_for_req and similar test fills_hdr_tbl_for_resp have a serios defect:
At the first step the test call the message parsing test, which iterates over various chunk sizes,
and at the second step the test compares contents of parsed headers with expected ones,
so that the only result of the last iteration over chunk sizes is compared with expected content of the headers.

( #1537  )
This problem is just solved in 4c9d287#diff-b1785da4f54bd40909398a1a64bcdeef768a8a30c0764f23cb706d2102cfc657",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1538,2021-12-17T01:21:23Z,2022-01-18T14:34:37Z,2022-05-07T13:42:49Z,MERGED,True,117,57,2,https://github.com/Dmitry-Gouriev,Solutions for #1536 issue,25,[],https://github.com/tempesta-tech/tempesta/pull/1538,https://github.com/Dmitry-Gouriev,4,https://github.com/tempesta-tech/tempesta/pull/1538#issuecomment-1013571729,"This PR contains solution for initial #1536 problem, as well as additional problems with HTTP Method parser, gathered on the way.
The following text is a candidate for description of the squashing commit.
The problems solved:

double LF sequence before method name
zero-length method name
illegal characters inside method name

Requests with any of these incorrectnesses now are rejected.
The main method of solution is replacing __FSM_MOVE_nofixup() macro, accidentaly inserted instead of __FSM_JMP() macro, with the __FSM_JMP() everywhere over a code of HTTP Method parser. However, the problem of zero-length method name requires different method which is now implemented as well.
To detect these bugs (and to be sure they no more exist) the following tests were added to unit tests:

double LF before request line
double CRLF before request line
the request with zero-length method "" /filename HTTP/1.1""
the requests with mangled method name


""\tOST""




""P\tST""




""PO\tT""




""POS\t""


tests for number of leading bytes to strip, which complement pre-existed tests for allowed 0, 1 (LF) and 2 (CRLF) characters before request line (the tests for #1061 issue).

The new chunking procedure based on fixed CHUNK_SIZES list is introduced in this PR insteand of conevntional one
based on PRIMES array and pseudorandomness, because the PRIMES procedure do not detect some of listed errors.
Two additional bugs in the parser were detected on the way:

the #1537 - solved here,
the 1537-bis - solution imported from PR #1546.","With the da79636 commit:

the initial #1537 parser fault fixed
the same test fills_hdr_tbl_for_req now shows another fault: The Accept: header is not parsed correctly when chunk_size = 8.

The new fault ""1537-bis"" is for further study.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1538,2021-12-17T01:21:23Z,2022-01-18T14:34:37Z,2022-05-07T13:42:49Z,MERGED,True,117,57,2,https://github.com/Dmitry-Gouriev,Solutions for #1536 issue,25,[],https://github.com/tempesta-tech/tempesta/pull/1538,https://github.com/Dmitry-Gouriev,5,https://github.com/tempesta-tech/tempesta/pull/1538#issuecomment-1014937376,"This PR contains solution for initial #1536 problem, as well as additional problems with HTTP Method parser, gathered on the way.
The following text is a candidate for description of the squashing commit.
The problems solved:

double LF sequence before method name
zero-length method name
illegal characters inside method name

Requests with any of these incorrectnesses now are rejected.
The main method of solution is replacing __FSM_MOVE_nofixup() macro, accidentaly inserted instead of __FSM_JMP() macro, with the __FSM_JMP() everywhere over a code of HTTP Method parser. However, the problem of zero-length method name requires different method which is now implemented as well.
To detect these bugs (and to be sure they no more exist) the following tests were added to unit tests:

double LF before request line
double CRLF before request line
the request with zero-length method "" /filename HTTP/1.1""
the requests with mangled method name


""\tOST""




""P\tST""




""PO\tT""




""POS\t""


tests for number of leading bytes to strip, which complement pre-existed tests for allowed 0, 1 (LF) and 2 (CRLF) characters before request line (the tests for #1061 issue).

The new chunking procedure based on fixed CHUNK_SIZES list is introduced in this PR insteand of conevntional one
based on PRIMES array and pseudorandomness, because the PRIMES procedure do not detect some of listed errors.
Two additional bugs in the parser were detected on the way:

the #1537 - solved here,
the 1537-bis - solution imported from PR #1546.","The last commit solves the 1537-bis bug.
The solition was imported from PR #1546 commit 075f645 (very selective 1-line pull).",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1539,2021-12-20T15:02:30Z,2022-01-19T22:57:11Z,2022-01-19T22:57:11Z,CLOSED,False,262,80,4,https://github.com/byko3y,Implemented additional validation for Cache-Control for #530,1,[],https://github.com/tempesta-tech/tempesta/pull/1539,https://github.com/byko3y,1,https://github.com/tempesta-tech/tempesta/pull/1539,Also slightly reworked the tests to match the new validation logic.,Also slightly reworked the tests to match the new validation logic.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1539,2021-12-20T15:02:30Z,2022-01-19T22:57:11Z,2022-01-19T22:57:11Z,CLOSED,False,262,80,4,https://github.com/byko3y,Implemented additional validation for Cache-Control for #530,1,[],https://github.com/tempesta-tech/tempesta/pull/1539,https://github.com/byko3y,2,https://github.com/tempesta-tech/tempesta/pull/1539#issuecomment-998443417,Also slightly reworked the tests to match the new validation logic.,"I realized there are some issues with identation, which are easily fixable. Also I did not modify the __h2_req_parse_cache_control (it's not covered by tests anyway), which is similar to __req_parse_cache_control, so the changes can be easily copied.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1539,2021-12-20T15:02:30Z,2022-01-19T22:57:11Z,2022-01-19T22:57:11Z,CLOSED,False,262,80,4,https://github.com/byko3y,Implemented additional validation for Cache-Control for #530,1,[],https://github.com/tempesta-tech/tempesta/pull/1539,https://github.com/krizhanovsky,3,https://github.com/tempesta-tech/tempesta/pull/1539#issuecomment-1016947079,Also slightly reworked the tests to match the new validation logic.,"The most FSM issues are handled in #1550, so I close the PR",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1541,2021-12-24T11:13:33Z,2021-12-29T12:58:00Z,2021-12-29T12:58:08Z,MERGED,True,163,51,5,None,fix alignment & realloc bugs #1540,2,[],https://github.com/tempesta-tech/tempesta/pull/1541,None,1,https://github.com/tempesta-tech/tempesta/pull/1541,"This patch should fix the alignment and realloc() problems described
in issue #1540. It also adds a couple of unit tests.","This patch should fix the alignment and realloc() problems described
in issue #1540. It also adds a couple of unit tests.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1541,2021-12-24T11:13:33Z,2021-12-29T12:58:00Z,2021-12-29T12:58:08Z,MERGED,True,163,51,5,None,fix alignment & realloc bugs #1540,2,[],https://github.com/tempesta-tech/tempesta/pull/1541,None,2,https://github.com/tempesta-tech/tempesta/pull/1541#issuecomment-1002127280,"This patch should fix the alignment and realloc() problems described
in issue #1540. It also adds a couple of unit tests.","OK, I'll add this stuff, but frankly it doesn't make sense to me to branch on align in the ""fast"" path if we care about the performance so much. All callers already know (statically) whether alignment is necessary. So it makes more sense to have three functions: aligned allocation, non-aligned allocation, and move the chunk allocation code to a separate function that accepts the align parameter.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1541,2021-12-24T11:13:33Z,2021-12-29T12:58:00Z,2021-12-29T12:58:08Z,MERGED,True,163,51,5,None,fix alignment & realloc bugs #1540,2,[],https://github.com/tempesta-tech/tempesta/pull/1541,https://github.com/krizhanovsky,3,https://github.com/tempesta-tech/tempesta/pull/1541#issuecomment-1002139190,"This patch should fix the alignment and realloc() problems described
in issue #1540. It also adds a couple of unit tests.","Yes, good point. The aligned and non-aligned fast paths can go to pool.h and on the slow path just call the function, which will implement the slow path only.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1541,2021-12-24T11:13:33Z,2021-12-29T12:58:00Z,2021-12-29T12:58:08Z,MERGED,True,163,51,5,None,fix alignment & realloc bugs #1540,2,[],https://github.com/tempesta-tech/tempesta/pull/1541,None,4,https://github.com/tempesta-tech/tempesta/pull/1541#issuecomment-1002545099,"This patch should fix the alignment and realloc() problems described
in issue #1540. It also adds a couple of unit tests.","@krizhanovsky Please take a look at the updated PR. Since this now touches H2 processing a bit I also tried running the ""h2"" tests from the suite, but half of these doesn't work as usual (even without this patch). If you have suggestions for other testing let me know.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1545,2021-12-29T14:48:09Z,2022-01-16T14:30:15Z,2022-05-07T13:42:07Z,CLOSED,False,680,99,7,https://github.com/byko3y,Pk 530 - Preview of the cache control options,2,[],https://github.com/tempesta-tech/tempesta/pull/1545,https://github.com/byko3y,1,https://github.com/tempesta-tech/tempesta/pull/1545,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1545,2021-12-29T14:48:09Z,2022-01-16T14:30:15Z,2022-05-07T13:42:07Z,CLOSED,False,680,99,7,https://github.com/byko3y,Pk 530 - Preview of the cache control options,2,[],https://github.com/tempesta-tech/tempesta/pull/1545,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/1545#issuecomment-1013886481,,I close the PR since it looks like a duplicate of #1550,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1546,2022-01-11T04:10:49Z,2022-02-08T00:56:12Z,2022-05-07T13:42:44Z,CLOSED,False,141,70,2,https://github.com/byko3y,Incorrect fixups for Accept and Content-Type in request parser,2,[],https://github.com/tempesta-tech/tempesta/pull/1546,https://github.com/byko3y,1,https://github.com/tempesta-tech/tempesta/pull/1546,"I really dislike the idea of ""saveval"" argument in __TFW_HTTP_PARSE_SPECHDR_VAL/__TFW_HTTP_PARSE_RAWHDR_VAL/TFW_H2_PARSE_HDR_VAL macroses, because it spreads a single fixups logic into three remote locations. However, I haven't been able to find an easy solution to avoid a significant refactoring of the parser. So I'm just leaving the saveval problem as is and just repairing the concrete fixup logic, which currently leads to additional 30 assertions in tests.","I really dislike the idea of ""saveval"" argument in __TFW_HTTP_PARSE_SPECHDR_VAL/__TFW_HTTP_PARSE_RAWHDR_VAL/TFW_H2_PARSE_HDR_VAL macroses, because it spreads a single fixups logic into three remote locations. However, I haven't been able to find an easy solution to avoid a significant refactoring of the parser. So I'm just leaving the saveval problem as is and just repairing the concrete fixup logic, which currently leads to additional 30 assertions in tests.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1546,2022-01-11T04:10:49Z,2022-02-08T00:56:12Z,2022-05-07T13:42:44Z,CLOSED,False,141,70,2,https://github.com/byko3y,Incorrect fixups for Accept and Content-Type in request parser,2,[],https://github.com/tempesta-tech/tempesta/pull/1546,https://github.com/byko3y,2,https://github.com/tempesta-tech/tempesta/pull/1546#issuecomment-1014081464,"I really dislike the idea of ""saveval"" argument in __TFW_HTTP_PARSE_SPECHDR_VAL/__TFW_HTTP_PARSE_RAWHDR_VAL/TFW_H2_PARSE_HDR_VAL macroses, because it spreads a single fixups logic into three remote locations. However, I haven't been able to find an easy solution to avoid a significant refactoring of the parser. So I'm just leaving the saveval problem as is and just repairing the concrete fixup logic, which currently leads to additional 30 assertions in tests.","I updated the pull request with a proposal for a more radical fix of the issue: 7811dba. The fundamental problem is the chaining of different parser's functions i.e. one function parsing the header value calls another function for parsing of a date inside the header value. This chaining currently requires the functions to know each others internals, because a single integer result (total amount of bytes processed) is not enough for communication, it tells the callee function (i.e. __TFW_HTTP_PARSE_SPECHDR_VAL) about the last processed byte, but doesn't tell anything about fixups within the called function (i.e. __req_parse_content_type that caused the bug).
So we either need additional global variable or additional integer in the function's result -- the latter is more convenient in terms of performance and code modularity.
The new mechanism for chaining of parser functions via fsm_result as advantage has the ability to lazily fixup string more often, which will overshadow the small overhead of having additional variable ""__fsm_last_fixup"" in the function's stack. At the same time, for functions that don't use the ""__fsm_last_fixup"" this variable will be completely optimized out. My benchmarks show no performance impact (less than precision of my tools, which is approx. 2%) from those changes.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1546,2022-01-11T04:10:49Z,2022-02-08T00:56:12Z,2022-05-07T13:42:44Z,CLOSED,False,141,70,2,https://github.com/byko3y,Incorrect fixups for Accept and Content-Type in request parser,2,[],https://github.com/tempesta-tech/tempesta/pull/1546,https://github.com/keshonok,3,https://github.com/tempesta-tech/tempesta/pull/1546#issuecomment-1014484430,"I really dislike the idea of ""saveval"" argument in __TFW_HTTP_PARSE_SPECHDR_VAL/__TFW_HTTP_PARSE_RAWHDR_VAL/TFW_H2_PARSE_HDR_VAL macroses, because it spreads a single fixups logic into three remote locations. However, I haven't been able to find an easy solution to avoid a significant refactoring of the parser. So I'm just leaving the saveval problem as is and just repairing the concrete fixup logic, which currently leads to additional 30 assertions in tests.","I am not intimately familiar with the parser's internals in its current state, so this may be considered a view of an outsider who was familiar with the parser design before. I would appreciate (benefit from) a clear explanation (comment) of why an additional variable is required, why a subsequent function in a chain needs to know of a fixup that occurred inside an intermediate parsing function (parsing a date?), and so on. The whole idea of a fuxup is to stop a TfwStr{} chunk of data at a specific place semantically, so that there's no need to seek the end of that semantic piece of data later on (i.e. a date or an HTTP header name). Perhaps, a carefully constructed and clear example of a typical processing chain would be sufficient instead of a lengthy theoretical explanation of all possible situations.
Perhaps, __TFW_HTTP_PARSE_SPECHDR_VAL/__TFW_HTTP_PARSE_RAWHDR_VAL/TFW_H2_PARSE_HDR_VAL macros should not be considered as three remote locations because the primary reason there are three different macros is to avoid extra branching where it's unnecessary. Otherwise they serve the same purpose and essentially are ""the same"" semantically, albeit with small variations. The parser uses repetitious code inserts instead of extra branching, be that function calls or if/else branching.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1546,2022-01-11T04:10:49Z,2022-02-08T00:56:12Z,2022-05-07T13:42:44Z,CLOSED,False,141,70,2,https://github.com/byko3y,Incorrect fixups for Accept and Content-Type in request parser,2,[],https://github.com/tempesta-tech/tempesta/pull/1546,https://github.com/Dmitry-Gouriev,4,https://github.com/tempesta-tech/tempesta/pull/1546#issuecomment-1014870558,"I really dislike the idea of ""saveval"" argument in __TFW_HTTP_PARSE_SPECHDR_VAL/__TFW_HTTP_PARSE_RAWHDR_VAL/TFW_H2_PARSE_HDR_VAL macroses, because it spreads a single fixups logic into three remote locations. However, I haven't been able to find an easy solution to avoid a significant refactoring of the parser. So I'm just leaving the saveval problem as is and just repairing the concrete fixup logic, which currently leads to additional 30 assertions in tests.","I'd avoid make so radical changes because they require an exhaustive testing and are about ""a research"".
Probably better to move these changes to some later millestone?
And, again, the code which was complex by the nature becomes even more complex.",True,{'THUMBS_UP': ['https://github.com/krizhanovsky']}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1546,2022-01-11T04:10:49Z,2022-02-08T00:56:12Z,2022-05-07T13:42:44Z,CLOSED,False,141,70,2,https://github.com/byko3y,Incorrect fixups for Accept and Content-Type in request parser,2,[],https://github.com/tempesta-tech/tempesta/pull/1546,https://github.com/byko3y,5,https://github.com/tempesta-tech/tempesta/pull/1546#issuecomment-1015176456,"I really dislike the idea of ""saveval"" argument in __TFW_HTTP_PARSE_SPECHDR_VAL/__TFW_HTTP_PARSE_RAWHDR_VAL/TFW_H2_PARSE_HDR_VAL macroses, because it spreads a single fixups logic into three remote locations. However, I haven't been able to find an easy solution to avoid a significant refactoring of the parser. So I'm just leaving the saveval problem as is and just repairing the concrete fixup logic, which currently leads to additional 30 assertions in tests.","@keshonok wrote:

I would appreciate (benefit from) a clear explanation (comment) of why an additional variable is required, why a subsequent function in a chain needs to know of a fixup that occurred inside an intermediate parsing function (parsing a date?), and so on.

It's not just about a function calling another function, but also about several sequential FSM states i.e. any non-trivial value processing with possible non-standard chunking. Some blocks delegate the fixup of the chunk to a subsequent code and some fixup immediately. The current code base contains sufficient amount of manually applied glue code to just work e.g. __msg_hdr_chunk_fixup calls within a nested function and ""saveval"" parameter for __TFW_HTTP_PARSE_RAWHDR_VAL/__TFW_HTTP_PARSE_SPECHDR_VAL. Failing to apply the glue correctly on any of the sides will result in corruption of parser's result -- that's precisely what caused the two corruptions I reported in the #1547
I do agree TFW_H2_PARSE_HDR_VAL is a distinct macro, however, __TFW_HTTP_PARSE_RAWHDR_VAL and __TFW_HTTP_PARSE_SPECHDR_VAL are not. The only new condition in the merged __TFW_HTTP_PARSE_HDR_VAL is optimized away by GCC even at ""-O0"" level.
Considering the ""added complexity"", I spent like 2 hours rewriting all the request parsing functions and testing them, got zero impact on performance (1% or less). A complete rewrite (h2, responses) would probably take a whole day. Most of the modifications are about replacing return __data_off(p) with __FSM_EXIT(__data_off(p)) and return FSM_RESULT(__data_off(p)), so I don't really see much complexity coming from it and don't feel like that's anything radical.
However, I agree the modification does not bring much to the table right now, so it can be considered of low priority.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1546,2022-01-11T04:10:49Z,2022-02-08T00:56:12Z,2022-05-07T13:42:44Z,CLOSED,False,141,70,2,https://github.com/byko3y,Incorrect fixups for Accept and Content-Type in request parser,2,[],https://github.com/tempesta-tech/tempesta/pull/1546,https://github.com/byko3y,6,https://github.com/tempesta-tech/tempesta/pull/1546#issuecomment-1032101267,"I really dislike the idea of ""saveval"" argument in __TFW_HTTP_PARSE_SPECHDR_VAL/__TFW_HTTP_PARSE_RAWHDR_VAL/TFW_H2_PARSE_HDR_VAL macroses, because it spreads a single fixups logic into three remote locations. However, I haven't been able to find an easy solution to avoid a significant refactoring of the parser. So I'm just leaving the saveval problem as is and just repairing the concrete fixup logic, which currently leads to additional 30 assertions in tests.","The changes are already merged as a part of #1538, so I'm closing this pull request. I'm gonna create a new one with documentation-related changes for #1547.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1548,2022-01-12T00:00:32Z,2022-01-12T00:35:10Z,2022-05-07T13:42:34Z,MERGED,True,2,2,1,https://github.com/byko3y,Incorrect offsets for fast parsing of Accept header in request,1,[],https://github.com/tempesta-tech/tempesta/pull/1548,https://github.com/byko3y,1,https://github.com/tempesta-tech/tempesta/pull/1548,Probably a copy-paste typo.,Probably a copy-paste typo.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1550,2022-01-12T23:55:20Z,2022-02-01T00:14:00Z,2022-05-07T13:42:51Z,MERGED,True,1063,161,12,https://github.com/byko3y,Implemented additional caching features for #530,7,[],https://github.com/tempesta-tech/tempesta/pull/1550,https://github.com/byko3y,1,https://github.com/tempesta-tech/tempesta/pull/1550,"Parsing and application of no-cache and private directives with arguments.
Additional validation of Cache-Control header.
New cache_control_ignore, cache_resp_hdr_del configuration options.
Fixed corruption of cached responses with empty header value.
Fixed all the comments from the #1539 here.","Parsing and application of no-cache and private directives with arguments.
Additional validation of Cache-Control header.
New cache_control_ignore, cache_resp_hdr_del configuration options.
Fixed corruption of cached responses with empty header value.
Fixed all the comments from the #1539 here.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1550,2022-01-12T23:55:20Z,2022-02-01T00:14:00Z,2022-05-07T13:42:51Z,MERGED,True,1063,161,12,https://github.com/byko3y,Implemented additional caching features for #530,7,[],https://github.com/tempesta-tech/tempesta/pull/1550,https://github.com/byko3y,2,https://github.com/tempesta-tech/tempesta/pull/1550#issuecomment-1012688341,"Parsing and application of no-cache and private directives with arguments.
Additional validation of Cache-Control header.
New cache_control_ignore, cache_resp_hdr_del configuration options.
Fixed corruption of cached responses with empty header value.
Fixed all the comments from the #1539 here.",The original version of the pull request is not compilable because of excessive curly brackets. Somehow git brought my working copy 1 commit before the final version so I haven't verified the final version itself. Good news is the last commit had only cosmetic changes so it's not a big deal.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1550,2022-01-12T23:55:20Z,2022-02-01T00:14:00Z,2022-05-07T13:42:51Z,MERGED,True,1063,161,12,https://github.com/byko3y,Implemented additional caching features for #530,7,[],https://github.com/tempesta-tech/tempesta/pull/1550,https://github.com/byko3y,3,https://github.com/tempesta-tech/tempesta/pull/1550#issuecomment-1021420915,"Parsing and application of no-cache and private directives with arguments.
Additional validation of Cache-Control header.
New cache_control_ignore, cache_resp_hdr_del configuration options.
Fixed corruption of cached responses with empty header value.
Fixed all the comments from the #1539 here.","Removed unnecessary conditions and reworked leading comma handling in cache-control parsing functions;
Additional tests for commas in cache-control directives and their arguments;
Reworked tfw_str_array_append_chunk();
Reworked __tfw_strcmpspn() to match strings even if one of them lacks a trailing separator;
Additional tests for both tfw_str_array_append_chunk and __tfw_strcmpspn().

Will update the copyright years once the final list of files is clear.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1550,2022-01-12T23:55:20Z,2022-02-01T00:14:00Z,2022-05-07T13:42:51Z,MERGED,True,1063,161,12,https://github.com/byko3y,Implemented additional caching features for #530,7,[],https://github.com/tempesta-tech/tempesta/pull/1550,https://github.com/byko3y,4,https://github.com/tempesta-tech/tempesta/pull/1550#issuecomment-1024183606,"Parsing and application of no-cache and private directives with arguments.
Additional validation of Cache-Control header.
New cache_control_ignore, cache_resp_hdr_del configuration options.
Fixed corruption of cached responses with empty header value.
Fixed all the comments from the #1539 here.",Hopefully resolved all the comments.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1551,2022-01-17T01:34:29Z,2022-02-08T00:17:01Z,2022-05-07T13:42:58Z,MERGED,True,13,10,1,https://github.com/byko3y,Kernel panic for cached HTTP/2 response with empty header value,2,[],https://github.com/tempesta-tech/tempesta/pull/1551,https://github.com/byko3y,1,https://github.com/tempesta-tech/tempesta/pull/1551,Fixes #1549. Still not sure about tfw_hpack_hdr_add and tfw_hpack_hdr_expand that also use s_val.,Fixes #1549. Still not sure about tfw_hpack_hdr_add and tfw_hpack_hdr_expand that also use s_val.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1552,2022-01-25T23:55:34Z,2022-02-02T16:41:37Z,2022-05-07T13:42:54Z,MERGED,True,120,61,5,https://github.com/Dmitry-Gouriev,Solution for #1535 issue,15,[],https://github.com/tempesta-tech/tempesta/pull/1552,https://github.com/Dmitry-Gouriev,1,https://github.com/tempesta-tech/tempesta/pull/1552,"The PR contains (probably final) proposals for solution for issue #1535 .
The new function ss_skb_list_chop_head_tail() was intoduced.
The function chops given number of bytes from head and tail of skb list, iterating over the list if neccessary.
The function is a wrapper around older function ss_skb_chop_head_tail(), which remains unchanged.
Examples of usage:

the temporary function tfw_h1_chop_leading_crlf() was replaced completely with  ss_skb_list_chop_head_tail()
in the   the tfw_h1_rewrite_purge_to_get function an erroneous call to  ss_skb_chop_head_tail() was replaced with correct call to ss_skb_list_chop_head_tail(). This replacement fixes the bug #1535 (comment) which was the formal reason to open the #1535  isddue.

Correctness is checked by the tests test_malformed_crlfs.py and test_purge_hch.py; both tests passed.
(Both tests reside in #195 tempesta-tech/tempesta-test#195 (comment)  PR for now :( ).
However chopping from the tail of the list and both from the head and the tail is still not tested.","The PR contains (probably final) proposals for solution for issue #1535 .
The new function ss_skb_list_chop_head_tail() was intoduced.
The function chops given number of bytes from head and tail of skb list, iterating over the list if neccessary.
The function is a wrapper around older function ss_skb_chop_head_tail(), which remains unchanged.
Examples of usage:

the temporary function tfw_h1_chop_leading_crlf() was replaced completely with  ss_skb_list_chop_head_tail()
in the   the tfw_h1_rewrite_purge_to_get function an erroneous call to  ss_skb_chop_head_tail() was replaced with correct call to ss_skb_list_chop_head_tail(). This replacement fixes the bug #1535 (comment) which was the formal reason to open the #1535  isddue.

Correctness is checked by the tests test_malformed_crlfs.py and test_purge_hch.py; both tests passed.
(Both tests reside in #195 tempesta-tech/tempesta-test#195 (comment)  PR for now :( ).
However chopping from the tail of the list and both from the head and the tail is still not tested.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1552,2022-01-25T23:55:34Z,2022-02-02T16:41:37Z,2022-05-07T13:42:54Z,MERGED,True,120,61,5,https://github.com/Dmitry-Gouriev,Solution for #1535 issue,15,[],https://github.com/tempesta-tech/tempesta/pull/1552,https://github.com/Dmitry-Gouriev,2,https://github.com/tempesta-tech/tempesta/pull/1552#issuecomment-1022707302,"The PR contains (probably final) proposals for solution for issue #1535 .
The new function ss_skb_list_chop_head_tail() was intoduced.
The function chops given number of bytes from head and tail of skb list, iterating over the list if neccessary.
The function is a wrapper around older function ss_skb_chop_head_tail(), which remains unchanged.
Examples of usage:

the temporary function tfw_h1_chop_leading_crlf() was replaced completely with  ss_skb_list_chop_head_tail()
in the   the tfw_h1_rewrite_purge_to_get function an erroneous call to  ss_skb_chop_head_tail() was replaced with correct call to ss_skb_list_chop_head_tail(). This replacement fixes the bug #1535 (comment) which was the formal reason to open the #1535  isddue.

Correctness is checked by the tests test_malformed_crlfs.py and test_purge_hch.py; both tests passed.
(Both tests reside in #195 tempesta-tech/tempesta-test#195 (comment)  PR for now :( ).
However chopping from the tail of the list and both from the head and the tail is still not tested.","@krizhanovsky
I borrowed an idea from tfw_tls_chop_skb_rec() and in this way have reduced a number of condition checks per loop from 3 to 2. I believe, in can not be smaller.
I decided to keep single_buf: branch as is.",True,{'THUMBS_UP': ['https://github.com/krizhanovsky']}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1552,2022-01-25T23:55:34Z,2022-02-02T16:41:37Z,2022-05-07T13:42:54Z,MERGED,True,120,61,5,https://github.com/Dmitry-Gouriev,Solution for #1535 issue,15,[],https://github.com/tempesta-tech/tempesta/pull/1552,https://github.com/Dmitry-Gouriev,3,https://github.com/tempesta-tech/tempesta/pull/1552#issuecomment-1022709013,"The PR contains (probably final) proposals for solution for issue #1535 .
The new function ss_skb_list_chop_head_tail() was intoduced.
The function chops given number of bytes from head and tail of skb list, iterating over the list if neccessary.
The function is a wrapper around older function ss_skb_chop_head_tail(), which remains unchanged.
Examples of usage:

the temporary function tfw_h1_chop_leading_crlf() was replaced completely with  ss_skb_list_chop_head_tail()
in the   the tfw_h1_rewrite_purge_to_get function an erroneous call to  ss_skb_chop_head_tail() was replaced with correct call to ss_skb_list_chop_head_tail(). This replacement fixes the bug #1535 (comment) which was the formal reason to open the #1535  isddue.

Correctness is checked by the tests test_malformed_crlfs.py and test_purge_hch.py; both tests passed.
(Both tests reside in #195 tempesta-tech/tempesta-test#195 (comment)  PR for now :( ).
However chopping from the tail of the list and both from the head and the tail is still not tested.","@krizhanovsky
Still remains a question to test chopping from tail and both from head and tail.
I still do not understand is this required or not.
And I still have no idea how to.
Probably I should create a kind of unit test?
Anyway the programming itself is near to finish however testing will take additional time.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1552,2022-01-25T23:55:34Z,2022-02-02T16:41:37Z,2022-05-07T13:42:54Z,MERGED,True,120,61,5,https://github.com/Dmitry-Gouriev,Solution for #1535 issue,15,[],https://github.com/tempesta-tech/tempesta/pull/1552,https://github.com/Dmitry-Gouriev,4,https://github.com/tempesta-tech/tempesta/pull/1552#issuecomment-1022720161,"The PR contains (probably final) proposals for solution for issue #1535 .
The new function ss_skb_list_chop_head_tail() was intoduced.
The function chops given number of bytes from head and tail of skb list, iterating over the list if neccessary.
The function is a wrapper around older function ss_skb_chop_head_tail(), which remains unchanged.
Examples of usage:

the temporary function tfw_h1_chop_leading_crlf() was replaced completely with  ss_skb_list_chop_head_tail()
in the   the tfw_h1_rewrite_purge_to_get function an erroneous call to  ss_skb_chop_head_tail() was replaced with correct call to ss_skb_list_chop_head_tail(). This replacement fixes the bug #1535 (comment) which was the formal reason to open the #1535  isddue.

Correctness is checked by the tests test_malformed_crlfs.py and test_purge_hch.py; both tests passed.
(Both tests reside in #195 tempesta-tech/tempesta-test#195 (comment)  PR for now :( ).
However chopping from the tail of the list and both from the head and the tail is still not tested.","The main issue with the PR is that now we have many places, which I enumerated in #1535, with very similar logic. Even worse that the logic isn't just copy & paste, but logically the same. This makes the whole code harder to maintain. This must be fixed. The code should unified among several places, e.g. the new ss_skb_list_chop_head_tail() and tfw_tls_chop_skb_rec().

I think the way could be to debug and test the new ss_skb_list_chop_head_tail() thorously and then replace all similar code parts with calls to the function. However all these replacements must be thorously tested as well (probably it can
be the same tests).
My initial understanding of the #1535 was just like this idea.
However the timing of this work seems to exceed 5 days.
The most time-cost part is, of course, testing rather than programming.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1552,2022-01-25T23:55:34Z,2022-02-02T16:41:37Z,2022-05-07T13:42:54Z,MERGED,True,120,61,5,https://github.com/Dmitry-Gouriev,Solution for #1535 issue,15,[],https://github.com/tempesta-tech/tempesta/pull/1552,https://github.com/Dmitry-Gouriev,5,https://github.com/tempesta-tech/tempesta/pull/1552#issuecomment-1023653286,"The PR contains (probably final) proposals for solution for issue #1535 .
The new function ss_skb_list_chop_head_tail() was intoduced.
The function chops given number of bytes from head and tail of skb list, iterating over the list if neccessary.
The function is a wrapper around older function ss_skb_chop_head_tail(), which remains unchanged.
Examples of usage:

the temporary function tfw_h1_chop_leading_crlf() was replaced completely with  ss_skb_list_chop_head_tail()
in the   the tfw_h1_rewrite_purge_to_get function an erroneous call to  ss_skb_chop_head_tail() was replaced with correct call to ss_skb_list_chop_head_tail(). This replacement fixes the bug #1535 (comment) which was the formal reason to open the #1535  isddue.

Correctness is checked by the tests test_malformed_crlfs.py and test_purge_hch.py; both tests passed.
(Both tests reside in #195 tempesta-tech/tempesta-test#195 (comment)  PR for now :( ).
However chopping from the tail of the list and both from the head and the tail is still not tested.","@krizhanovsky
In reply to #1552 (review)
If I understand correctly,

the ss_tcp_process_skb() should not be patched with ss_skb_list_chop_head_tail() at all,
the patch for tfw_h2_frame_process() is defered until you (with @byko3y ?) fix more serious bugs in it,
and the only patch for tfw_tls_chop_skb_rec() with ss_skb_list_chop_head_tail() is desired for now.

Is this true?
Of course tesing is requred.
I have tested with predesigned tests for patches which I just have done, i.e. for gone tfw_h1_chop_leading_crlf() and for tfw_h1_rewrite_purge_to_get().
What about tests for tfw_tls_chop_skb_rec()...
I guess somewhere the test for it exists.
However I still not know where it is.
Finding it or creating one if not found will require some time.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1552,2022-01-25T23:55:34Z,2022-02-02T16:41:37Z,2022-05-07T13:42:54Z,MERGED,True,120,61,5,https://github.com/Dmitry-Gouriev,Solution for #1535 issue,15,[],https://github.com/tempesta-tech/tempesta/pull/1552,https://github.com/Dmitry-Gouriev,6,https://github.com/tempesta-tech/tempesta/pull/1552#issuecomment-1023665269,"The PR contains (probably final) proposals for solution for issue #1535 .
The new function ss_skb_list_chop_head_tail() was intoduced.
The function chops given number of bytes from head and tail of skb list, iterating over the list if neccessary.
The function is a wrapper around older function ss_skb_chop_head_tail(), which remains unchanged.
Examples of usage:

the temporary function tfw_h1_chop_leading_crlf() was replaced completely with  ss_skb_list_chop_head_tail()
in the   the tfw_h1_rewrite_purge_to_get function an erroneous call to  ss_skb_chop_head_tail() was replaced with correct call to ss_skb_list_chop_head_tail(). This replacement fixes the bug #1535 (comment) which was the formal reason to open the #1535  isddue.

Correctness is checked by the tests test_malformed_crlfs.py and test_purge_hch.py; both tests passed.
(Both tests reside in #195 tempesta-tech/tempesta-test#195 (comment)  PR for now :( ).
However chopping from the tail of the list and both from the head and the tail is still not tested.","tfw_tls_chop_skb_rec() is also very easy to test - any TLS record is truncated at the beginning and end for about 16 bytes. The only possible thing to do extra is to send a TLS record with about 5-byte chunks to make the function firstly delete couple of skbs and next remove the rest of 1 byte. Probably this can be done with existing tempesta-test/tls tests and you even don't need to employ the new features of #115.

Probably...
Thinking on it...",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1552,2022-01-25T23:55:34Z,2022-02-02T16:41:37Z,2022-05-07T13:42:54Z,MERGED,True,120,61,5,https://github.com/Dmitry-Gouriev,Solution for #1535 issue,15,[],https://github.com/tempesta-tech/tempesta/pull/1552,https://github.com/krizhanovsky,7,https://github.com/tempesta-tech/tempesta/pull/1552#issuecomment-1024945406,"The PR contains (probably final) proposals for solution for issue #1535 .
The new function ss_skb_list_chop_head_tail() was intoduced.
The function chops given number of bytes from head and tail of skb list, iterating over the list if neccessary.
The function is a wrapper around older function ss_skb_chop_head_tail(), which remains unchanged.
Examples of usage:

the temporary function tfw_h1_chop_leading_crlf() was replaced completely with  ss_skb_list_chop_head_tail()
in the   the tfw_h1_rewrite_purge_to_get function an erroneous call to  ss_skb_chop_head_tail() was replaced with correct call to ss_skb_list_chop_head_tail(). This replacement fixes the bug #1535 (comment) which was the formal reason to open the #1535  isddue.

Correctness is checked by the tests test_malformed_crlfs.py and test_purge_hch.py; both tests passed.
(Both tests reside in #195 tempesta-tech/tempesta-test#195 (comment)  PR for now :( ).
However chopping from the tail of the list and both from the head and the tail is still not tested.","the ss_tcp_process_skb() should not be patched with ss_skb_list_chop_head_tail() at all,

Yes, because ss_tcp_process_skb() is always called for single skb

the patch for tfw_h2_frame_process() is defered until you (with @byko3y ?) fix more serious bugs in it,

Please call ss_skb_list_chop_head_tail(&h2->skb_head, h2->data_off, 0); in tfw_h2_frame_process() and remove the code, which is currently duplicated with the call. There is no need to test the function, since we'll test and fix h2 code in the near weeks.

and the only patch for tfw_tls_chop_skb_rec() with ss_skb_list_chop_head_tail() is desired for now.

yes, tfw_tls_chop_skb_rec() seems will be just a tiny wrapper for ss_skb_list_chop_head_tail()

What about tests for tfw_tls_chop_skb_rec()...
I guess somewhere the test for it exists.

Just run the tests from tempesta-test/tls - I believe they cover the code. Basically, TLS record with an application data will test the function call. Just to be more confident that the fix is good, I'd just recommend to deploy our web site under Tempesta FW with https:// and browse it a little bit using normal browser.",True,{'THUMBS_UP': ['https://github.com/Dmitry-Gouriev']}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1552,2022-01-25T23:55:34Z,2022-02-02T16:41:37Z,2022-05-07T13:42:54Z,MERGED,True,120,61,5,https://github.com/Dmitry-Gouriev,Solution for #1535 issue,15,[],https://github.com/tempesta-tech/tempesta/pull/1552,https://github.com/Dmitry-Gouriev,8,https://github.com/tempesta-tech/tempesta/pull/1552#issuecomment-1025702773,"The PR contains (probably final) proposals for solution for issue #1535 .
The new function ss_skb_list_chop_head_tail() was intoduced.
The function chops given number of bytes from head and tail of skb list, iterating over the list if neccessary.
The function is a wrapper around older function ss_skb_chop_head_tail(), which remains unchanged.
Examples of usage:

the temporary function tfw_h1_chop_leading_crlf() was replaced completely with  ss_skb_list_chop_head_tail()
in the   the tfw_h1_rewrite_purge_to_get function an erroneous call to  ss_skb_chop_head_tail() was replaced with correct call to ss_skb_list_chop_head_tail(). This replacement fixes the bug #1535 (comment) which was the formal reason to open the #1535  isddue.

Correctness is checked by the tests test_malformed_crlfs.py and test_purge_hch.py; both tests passed.
(Both tests reside in #195 tempesta-tech/tempesta-test#195 (comment)  PR for now :( ).
However chopping from the tail of the list and both from the head and the tail is still not tested.","@krizhanovsky I found that ss_tcp_process_skb() calls ss_skb_unroll() wich converts a single skb into skb list and tnen implements a scenario similar to ss_skb_list_chop_head_tail(skb_list, offset, 0). So there is a reason to replace it's part with ss_skb_list_chop_head_tail() as well as in other places.
However I'd better leave this function untouched because it is more crucial and is more difficult to test than other candidates for replaements.
UPDATE:
Oh. yeaah! It also makes additional checks
		WARN_ON_ONCE(skb->tail_lock);
		WARN_ON_ONCE(skb_has_frag_list(skb));
		WARN_ON_ONCE(skb->sk);

which are not implemented inside ss_skb_list_chop_head_tail().
This is another reason to leave this function untouched.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1552,2022-01-25T23:55:34Z,2022-02-02T16:41:37Z,2022-05-07T13:42:54Z,MERGED,True,120,61,5,https://github.com/Dmitry-Gouriev,Solution for #1535 issue,15,[],https://github.com/tempesta-tech/tempesta/pull/1552,https://github.com/Dmitry-Gouriev,9,https://github.com/tempesta-tech/tempesta/pull/1552#issuecomment-1025746040,"The PR contains (probably final) proposals for solution for issue #1535 .
The new function ss_skb_list_chop_head_tail() was intoduced.
The function chops given number of bytes from head and tail of skb list, iterating over the list if neccessary.
The function is a wrapper around older function ss_skb_chop_head_tail(), which remains unchanged.
Examples of usage:

the temporary function tfw_h1_chop_leading_crlf() was replaced completely with  ss_skb_list_chop_head_tail()
in the   the tfw_h1_rewrite_purge_to_get function an erroneous call to  ss_skb_chop_head_tail() was replaced with correct call to ss_skb_list_chop_head_tail(). This replacement fixes the bug #1535 (comment) which was the formal reason to open the #1535  isddue.

Correctness is checked by the tests test_malformed_crlfs.py and test_purge_hch.py; both tests passed.
(Both tests reside in #195 tempesta-tech/tempesta-test#195 (comment)  PR for now :( ).
However chopping from the tail of the list and both from the head and the tail is still not tested.","@krizhanovsky  on tfw_h2_frame_process()
There is a special check
			/*
			 * Special case when the frame is postponed just
			 * in the beginning of the app data, after all
			 * frame header fields processed.
			 */
			if (!h2->skb_head) {
				WARN_ON_ONCE(h2->data_off);
				return T_OK;
			}
(lines 1777-1785 at master)
With poor knowledge of HTTP2 I can not estimate an importance of this check.
Of course, it is not and should not implemented in more general purpose ss_skb_list_chop_head_tail().
So there are 2 alternatives:

to drop the check at all
to implement it in a separate preprocessing loop.

The 1st lead to semantic changes and the 2nd have negative impact on performace.
And of course there is a way to leave tfw_h2_frame_process() as is.
A suggestion is needed.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1552,2022-01-25T23:55:34Z,2022-02-02T16:41:37Z,2022-05-07T13:42:54Z,MERGED,True,120,61,5,https://github.com/Dmitry-Gouriev,Solution for #1535 issue,15,[],https://github.com/tempesta-tech/tempesta/pull/1552,https://github.com/krizhanovsky,10,https://github.com/tempesta-tech/tempesta/pull/1552#issuecomment-1025794583,"The PR contains (probably final) proposals for solution for issue #1535 .
The new function ss_skb_list_chop_head_tail() was intoduced.
The function chops given number of bytes from head and tail of skb list, iterating over the list if neccessary.
The function is a wrapper around older function ss_skb_chop_head_tail(), which remains unchanged.
Examples of usage:

the temporary function tfw_h1_chop_leading_crlf() was replaced completely with  ss_skb_list_chop_head_tail()
in the   the tfw_h1_rewrite_purge_to_get function an erroneous call to  ss_skb_chop_head_tail() was replaced with correct call to ss_skb_list_chop_head_tail(). This replacement fixes the bug #1535 (comment) which was the formal reason to open the #1535  isddue.

Correctness is checked by the tests test_malformed_crlfs.py and test_purge_hch.py; both tests passed.
(Both tests reside in #195 tempesta-tech/tempesta-test#195 (comment)  PR for now :( ).
However chopping from the tail of the list and both from the head and the tail is still not tested.","I found that ss_tcp_process_skb() calls ss_skb_unroll() wich converts a single skb into skb list and tnen implements a scenario similar to ss_skb_list_chop_head_tail(skb_list, offset, 0).

There are a lot of other things done inside the loop over the skb list and removing the overlapping TCP segment is one of the smallest. Also we call ss_skb_list_chop_head_tail() for the application data and non zero sum is quite likely, form the other hand overlapping TCP segments is quite unlikely. The functions are very different actually.
Regarding tfw_h2_frame_process() let's leave it as is. Maybe just add words why don't we use `ss_skb_list_chop_head_tail() into the comment for the check.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1552,2022-01-25T23:55:34Z,2022-02-02T16:41:37Z,2022-05-07T13:42:54Z,MERGED,True,120,61,5,https://github.com/Dmitry-Gouriev,Solution for #1535 issue,15,[],https://github.com/tempesta-tech/tempesta/pull/1552,https://github.com/Dmitry-Gouriev,11,https://github.com/tempesta-tech/tempesta/pull/1552#issuecomment-1025806973,"The PR contains (probably final) proposals for solution for issue #1535 .
The new function ss_skb_list_chop_head_tail() was intoduced.
The function chops given number of bytes from head and tail of skb list, iterating over the list if neccessary.
The function is a wrapper around older function ss_skb_chop_head_tail(), which remains unchanged.
Examples of usage:

the temporary function tfw_h1_chop_leading_crlf() was replaced completely with  ss_skb_list_chop_head_tail()
in the   the tfw_h1_rewrite_purge_to_get function an erroneous call to  ss_skb_chop_head_tail() was replaced with correct call to ss_skb_list_chop_head_tail(). This replacement fixes the bug #1535 (comment) which was the formal reason to open the #1535  isddue.

Correctness is checked by the tests test_malformed_crlfs.py and test_purge_hch.py; both tests passed.
(Both tests reside in #195 tempesta-tech/tempesta-test#195 (comment)  PR for now :( ).
However chopping from the tail of the list and both from the head and the tail is still not tested.","There is also a way to to extend flexibility of ss_skb_list_chop_head_tail() and cover the cases #1552 (comment) and #1552 (comment) in this way. Two possible approaches

convert the func into macro with substitution of additional code in LAMBDA-way
add a callback function parameter to implement additional check and actions (say, this will be an ss_skb_list_chop_head_tail_ex()

I am afraid of the 1st way, because the function is quite large and still is not fully tested.
The 2nd way is a little more sophisticated in usage and have some negative impact on performance, however, in general seems to me to be more acceptable.
Probably this is an idea for some future.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1553,2022-02-01T15:43:41Z,2022-02-02T06:16:26Z,2022-02-11T15:56:05Z,CLOSED,False,29,6,2,https://github.com/ttaym,"Make adx and bmi2 non-mandatory, disable tls build in absence",1,[],https://github.com/tempesta-tech/tempesta/pull/1553,https://github.com/ttaym,1,https://github.com/tempesta-tech/tempesta/pull/1553,"I have not so ancient, but relatively old hardware.
My processor family is IvyBridge. Wiki says that it is not supported and tempesta build fails.
But it seems that it is strongly requires only for Tempesta TLS. Just made simple PR that render adx and bmi2 feature non-mandatory, but instead of failure disables Tempesta TLS build in hope that Tempesta FW is usable without TLS too.
This PR is WIP. I'll update and finish it if it make sense overall.","I have not so ancient, but relatively old hardware.
My processor family is IvyBridge. Wiki says that it is not supported and tempesta build fails.
But it seems that it is strongly requires only for Tempesta TLS. Just made simple PR that render adx and bmi2 feature non-mandatory, but instead of failure disables Tempesta TLS build in hope that Tempesta FW is usable without TLS too.
This PR is WIP. I'll update and finish it if it make sense overall.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1553,2022-02-01T15:43:41Z,2022-02-02T06:16:26Z,2022-02-11T15:56:05Z,CLOSED,False,29,6,2,https://github.com/ttaym,"Make adx and bmi2 non-mandatory, disable tls build in absence",1,[],https://github.com/tempesta-tech/tempesta/pull/1553,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/1553#issuecomment-1027044905,"I have not so ancient, but relatively old hardware.
My processor family is IvyBridge. Wiki says that it is not supported and tempesta build fails.
But it seems that it is strongly requires only for Tempesta TLS. Just made simple PR that render adx and bmi2 feature non-mandatory, but instead of failure disables Tempesta TLS build in hope that Tempesta FW is usable without TLS too.
This PR is WIP. I'll update and finish it if it make sense overall.","We had requests to support pre-Broadwell hardware, e.g. #1515 . The most modern CPU extensions are required for TLS crypto, so the PR makes sense just to build a Tempesta FW on such hardware. However, since TLS is mandatory nowadays even in microservices communications inside single server, it seems that such build is just a toy.
The most my concern about compatibility issues is that we'll need to support more code or even two versions of mathematics if we go with a proper implementation of cryptography for the pre-Broadwell CPUs.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1554,2022-02-02T07:53:45Z,2022-02-03T06:37:23Z,2022-02-03T06:39:02Z,MERGED,True,2,1,1,https://github.com/ttaym,Ethtool output parsing fix #1542,1,[],https://github.com/tempesta-tech/tempesta/pull/1554,https://github.com/ttaym,1,https://github.com/tempesta-tech/tempesta/pull/1554,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1554,2022-02-02T07:53:45Z,2022-02-03T06:37:23Z,2022-02-03T06:39:02Z,MERGED,True,2,1,1,https://github.com/ttaym,Ethtool output parsing fix #1542,1,[],https://github.com/tempesta-tech/tempesta/pull/1554,https://github.com/ttaym,2,https://github.com/tempesta-tech/tempesta/pull/1554#issuecomment-1028012838,,"@krizhanovsky
This message from printf is not preventing script from functioning. Can be safely redirected to /dev/null (done already).
Printf give 0 if argument seems to be not integer, that is right thing for script logic.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1555,2022-02-02T10:26:22Z,2022-02-04T12:02:57Z,2022-05-07T13:42:57Z,MERGED,True,8,6,3,https://github.com/dmpetroff,Fix #1473,2,[],https://github.com/tempesta-tech/tempesta/pull/1555,https://github.com/dmpetroff,1,https://github.com/tempesta-tech/tempesta/pull/1555,"Fixed ss_getpeername so it uses source IP and port now.
TfwClient is cached across multiple connections and its addr field contains address with port from the first encounter of that client. This means that if we use said address for printing, port part will eventually get outdated. This is why we disabling client port printing from tfw_http_cli_error_resp_and_log().","Fixed ss_getpeername so it uses source IP and port now.
TfwClient is cached across multiple connections and its addr field contains address with port from the first encounter of that client. This means that if we use said address for printing, port part will eventually get outdated. This is why we disabling client port printing from tfw_http_cli_error_resp_and_log().",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1555,2022-02-02T10:26:22Z,2022-02-04T12:02:57Z,2022-05-07T13:42:57Z,MERGED,True,8,6,3,https://github.com/dmpetroff,Fix #1473,2,[],https://github.com/tempesta-tech/tempesta/pull/1555,https://github.com/dmpetroff,2,https://github.com/tempesta-tech/tempesta/pull/1555#issuecomment-1028883029,"Fixed ss_getpeername so it uses source IP and port now.
TfwClient is cached across multiple connections and its addr field contains address with port from the first encounter of that client. This means that if we use said address for printing, port part will eventually get outdated. This is why we disabling client port printing from tfw_http_cli_error_resp_and_log().","Carefully looked through code for TFW_WITH_PORT and replaced it to TFW_WITHOUT_PORT where appropriate.
Finding out how to run tests to make sure that changes haven't broke anything else.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1556,2022-02-02T14:32:46Z,2022-02-04T08:49:06Z,2022-02-04T08:49:19Z,MERGED,True,49,6,2,https://github.com/ttaym,"Add runtime check for not present adx, may be false negative",2,[],https://github.com/tempesta-tech/tempesta/pull/1556,https://github.com/ttaym,1,https://github.com/tempesta-tech/tempesta/pull/1556,"There are some cloud providers that do support adx instructions in their VPS but do not show this support in /proc/cpuinfo.
I suppose there is need for runtime check of supporting theas instruct if their support not present in /proc/cpuinfo by running binary that contain adcx instruction for example emmited by inline asm.","There are some cloud providers that do support adx instructions in their VPS but do not show this support in /proc/cpuinfo.
I suppose there is need for runtime check of supporting theas instruct if their support not present in /proc/cpuinfo by running binary that contain adcx instruction for example emmited by inline asm.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1556,2022-02-02T14:32:46Z,2022-02-04T08:49:06Z,2022-02-04T08:49:19Z,MERGED,True,49,6,2,https://github.com/ttaym,"Add runtime check for not present adx, may be false negative",2,[],https://github.com/tempesta-tech/tempesta/pull/1556,https://github.com/ttaym,2,https://github.com/tempesta-tech/tempesta/pull/1556#issuecomment-1028701917,"There are some cloud providers that do support adx instructions in their VPS but do not show this support in /proc/cpuinfo.
I suppose there is need for runtime check of supporting theas instruct if their support not present in /proc/cpuinfo by running binary that contain adcx instruction for example emmited by inline asm.","@krizhanovsky
I have made all requested changes and resolve all discusstions.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1557,2022-02-02T19:46:24Z,2022-02-03T21:03:09Z,2022-02-03T21:03:51Z,MERGED,True,11,26,1,https://github.com/Dmitry-Gouriev,Fixed memory leak in tfw_tls_msg_process(),2,[],https://github.com/tempesta-tech/tempesta/pull/1557,https://github.com/Dmitry-Gouriev,1,https://github.com/tempesta-tech/tempesta/pull/1557,"It seems there is a memory leak in the function tfw_tls_msg_process() (file fw/tls.c):
		r = tfw_tls_chop_skb_rec(tls, tls->io_in.skb_list, &data_up);
		if (r) {
			spin_unlock(&tls->lock);
			return r;
		}
(lines 189-193 at master).
On error code returned from tfw_tls_chop_skb_rec() neither skbs in tls->io_in.skb_list nor nskb are freed.
The PR contains proposal to fix this bug.
The changes were tested against tempesta-test/tls test suite just like preceding PR #1552","It seems there is a memory leak in the function tfw_tls_msg_process() (file fw/tls.c):
		r = tfw_tls_chop_skb_rec(tls, tls->io_in.skb_list, &data_up);
		if (r) {
			spin_unlock(&tls->lock);
			return r;
		}
(lines 189-193 at master).
On error code returned from tfw_tls_chop_skb_rec() neither skbs in tls->io_in.skb_list nor nskb are freed.
The PR contains proposal to fix this bug.
The changes were tested against tempesta-test/tls test suite just like preceding PR #1552",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1558,2022-02-02T22:33:42Z,2022-02-12T09:19:48Z,2022-05-07T13:43:13Z,MERGED,True,39,7,2,https://github.com/byko3y,Corrections for cache-control directives handling,3,[],https://github.com/tempesta-tech/tempesta/pull/1558,https://github.com/byko3y,1,https://github.com/tempesta-tech/tempesta/pull/1558,"Added max-age and s-maxage support for cache_control_ignore configuration
option.
Fixed interaction of Authorization request with s-maxage, public,
must-revalidate, proxy-revalidate responses.

There still remain some problems with only-if-cached and max-state+max-age, so it's kind of a preview.","Added max-age and s-maxage support for cache_control_ignore configuration
option.
Fixed interaction of Authorization request with s-maxage, public,
must-revalidate, proxy-revalidate responses.

There still remain some problems with only-if-cached and max-state+max-age, so it's kind of a preview.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1558,2022-02-02T22:33:42Z,2022-02-12T09:19:48Z,2022-05-07T13:43:13Z,MERGED,True,39,7,2,https://github.com/byko3y,Corrections for cache-control directives handling,3,[],https://github.com/tempesta-tech/tempesta/pull/1558,https://github.com/byko3y,2,https://github.com/tempesta-tech/tempesta/pull/1558#issuecomment-1031857609,"Added max-age and s-maxage support for cache_control_ignore configuration
option.
Fixed interaction of Authorization request with s-maxage, public,
must-revalidate, proxy-revalidate responses.

There still remain some problems with only-if-cached and max-state+max-age, so it's kind of a preview.","We are to calculate 2 values: current age and the last age when response could be served from the cache, and then compare it. The second value must consolidate requirements from the response and from the subsequent request, if any

It's not that simple. There are conditional handlings caused by cache-control directives, there is a max-state directive that overrides normal lifetimes by allowing stale responses, and there is a default caching policy that is kinda undefined by standard e.g. you might cache or might not cache a response having no ""public"" neither ""private"" directive.

Suppose the server respond with Cache-Control: max-age=120,
and a subsequent client request contains Cache-Control: max-age: 60

tfw_cache_calc_lifetime() calculates the response lifetime, its result is saved into TfwCacheEntry *ce->lifetime. Latter the decision to serve the response is made by tfw_cache_entry_is_live which choses between req->cache_ctl.max_age and ce->lifetime.
There are cache.test_cache_control.RequestMaxAgeNoCached and cache.test_cache_control.RequestMaxAgeCached tests to verify that behaviour.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1558,2022-02-02T22:33:42Z,2022-02-12T09:19:48Z,2022-05-07T13:43:13Z,MERGED,True,39,7,2,https://github.com/byko3y,Corrections for cache-control directives handling,3,[],https://github.com/tempesta-tech/tempesta/pull/1558,https://github.com/Dmitry-Gouriev,3,https://github.com/tempesta-tech/tempesta/pull/1558#issuecomment-1031982842,"Added max-age and s-maxage support for cache_control_ignore configuration
option.
Fixed interaction of Authorization request with s-maxage, public,
must-revalidate, proxy-revalidate responses.

There still remain some problems with only-if-cached and max-state+max-age, so it's kind of a preview.","There are conditional handlings caused by cache-control directives, there is a max-state directive that overrides normal lifetimes by allowing stale responses...

Yeah, I insist, it is overcomplicated :D :D :D However it seems now is a bad time for refactoring.

there is a default caching policy that is kinda undefined by standard

The former version of the HTTP spec was more clear, However the current spec contains necessaey statements
https://datatracker.ietf.org/doc/html/rfc7234#section-3
The ""cacheable"" method and ""cacheable"" response code are sufficient conditions to cache the response
in absense of special headers and directives.

tfw_cache_calc_lifetime() calculates the response lifetime, its result is saved into TfwCacheEntry *ce->lifetime. Latter the decision to serve the response is made by tfw_cache_entry_is_live which choses between req->cache_ctl.max_age and ce->lifetime.

Yes, now I see, thank you!
However now I have another question.
max-stale and min-fresh directives corrects freshness lifetime on a base of server-side set lifetime only.
Should not the cache take in account client-side max-age as well when apply deltas set by max-stale and min-fresh?",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1558,2022-02-02T22:33:42Z,2022-02-12T09:19:48Z,2022-05-07T13:43:13Z,MERGED,True,39,7,2,https://github.com/byko3y,Corrections for cache-control directives handling,3,[],https://github.com/tempesta-tech/tempesta/pull/1558,https://github.com/Dmitry-Gouriev,4,https://github.com/tempesta-tech/tempesta/pull/1558#issuecomment-1031991400,"Added max-age and s-maxage support for cache_control_ignore configuration
option.
Fixed interaction of Authorization request with s-maxage, public,
must-revalidate, proxy-revalidate responses.

There still remain some problems with only-if-cached and max-state+max-age, so it's kind of a preview.","To dream a little...
The simplification could be the following.

max-age, s-maxage, Expires: in response give a server-side demand for freshness lifetime,
with favor of s-maxage (because we are a shared cache) and resolving other ambiguiies (selecting smaller value?).
max-age in request give a client-side demand for freshness lifetime.
We should select smaller one of these two.|
max-stale and min-fresh, if present, give deltas (positive and negative correspondently) to adjust this value once more
after all we have a single value to compare with age of the response in the cache

...However it is not simplification. It is very close to code existing now. At leat, it is not significantly simplier :'(",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1558,2022-02-02T22:33:42Z,2022-02-12T09:19:48Z,2022-05-07T13:43:13Z,MERGED,True,39,7,2,https://github.com/byko3y,Corrections for cache-control directives handling,3,[],https://github.com/tempesta-tech/tempesta/pull/1558,https://github.com/byko3y,5,https://github.com/tempesta-tech/tempesta/pull/1558#issuecomment-1032021889,"Added max-age and s-maxage support for cache_control_ignore configuration
option.
Fixed interaction of Authorization request with s-maxage, public,
must-revalidate, proxy-revalidate responses.

There still remain some problems with only-if-cached and max-state+max-age, so it's kind of a preview.","RFC 7234 uses the wording ""the request method is understood by the cache and defined as being cacheable, and the response status code is understood by the cache"" - which is as vague as it can be. So it basically says ""cache it if you dare, unless caching is explicitly forbidden"".

Should not the cache take in account client-side max-age as well when apply deltas set by max-stale and min-fresh?

Age of what? Of the client's request? Age/lifetime is only meaningfull when applied to a ""response being cached"". Anyway, it's all defined in RFC.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1558,2022-02-02T22:33:42Z,2022-02-12T09:19:48Z,2022-05-07T13:43:13Z,MERGED,True,39,7,2,https://github.com/byko3y,Corrections for cache-control directives handling,3,[],https://github.com/tempesta-tech/tempesta/pull/1558,https://github.com/Dmitry-Gouriev,6,https://github.com/tempesta-tech/tempesta/pull/1558#issuecomment-1032032143,"Added max-age and s-maxage support for cache_control_ignore configuration
option.
Fixed interaction of Authorization request with s-maxage, public,
must-revalidate, proxy-revalidate responses.

There still remain some problems with only-if-cached and max-state+max-age, so it's kind of a preview.","cache it if you dare, unless caching is explicitly forbidden

Exactly, and this seems not to change from times of RFC 2068.

Age of what?

This is a little strange question. Age of what is referenced in all client-side directives, including max-age itself?",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1558,2022-02-02T22:33:42Z,2022-02-12T09:19:48Z,2022-05-07T13:43:13Z,MERGED,True,39,7,2,https://github.com/byko3y,Corrections for cache-control directives handling,3,[],https://github.com/tempesta-tech/tempesta/pull/1558,https://github.com/krizhanovsky,7,https://github.com/tempesta-tech/tempesta/pull/1558#issuecomment-1035322196,"Added max-age and s-maxage support for cache_control_ignore configuration
option.
Fixed interaction of Authorization request with s-maxage, public,
must-revalidate, proxy-revalidate responses.

There still remain some problems with only-if-cached and max-state+max-age, so it's kind of a preview.","@Dmitry-Gouriev client side max-age is used in tfw_cache_entry_is_live() as lt_max_age for lt_fresh calculation, which is then used for ce_lifetime. Does it answer your question?",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1558,2022-02-02T22:33:42Z,2022-02-12T09:19:48Z,2022-05-07T13:43:13Z,MERGED,True,39,7,2,https://github.com/byko3y,Corrections for cache-control directives handling,3,[],https://github.com/tempesta-tech/tempesta/pull/1558,https://github.com/krizhanovsky,8,https://github.com/tempesta-tech/tempesta/pull/1558#issuecomment-1035337452,"Added max-age and s-maxage support for cache_control_ignore configuration
option.
Fixed interaction of Authorization request with s-maxage, public,
must-revalidate, proxy-revalidate responses.

There still remain some problems with only-if-cached and max-state+max-age, so it's kind of a preview.","I agree that the cache logic is quite overcomplicated and this isn't about legacy code: having comprehensive functional tests in #810 this isn't a big deal to rework a less thatn 3KLoC file. I see the problem is in the RFC 7234 with many sophisticated conditions and exceptions along with the real life requirement to ignore/extend the RFC requirements.

max-age, s-maxage, Expires: in response give a server-side demand for freshness lifetime,
with favor of s-maxage (because we are a shared cache) and resolving other ambiguiies (selecting smaller value?).

This is tfw_cache_calc_lifetime().

max-age in request give a client-side demand for freshness lifetime.

Not only. There is also Tempesta FW configuration about returning stale responses and other request fields like min-fresh and max-stale. This is essentially tfw_cache_entry_is_live() - the same cached entry might be live or not for different requests.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1558,2022-02-02T22:33:42Z,2022-02-12T09:19:48Z,2022-05-07T13:43:13Z,MERGED,True,39,7,2,https://github.com/byko3y,Corrections for cache-control directives handling,3,[],https://github.com/tempesta-tech/tempesta/pull/1558,https://github.com/Dmitry-Gouriev,9,https://github.com/tempesta-tech/tempesta/pull/1558#issuecomment-1035393101,"Added max-age and s-maxage support for cache_control_ignore configuration
option.
Fixed interaction of Authorization request with s-maxage, public,
must-revalidate, proxy-revalidate responses.

There still remain some problems with only-if-cached and max-state+max-age, so it's kind of a preview.","@krizhanovsky Yes I saw the influence of client's max-age via variables mentioned.
My questions are inspired by different anderstanding of RFC 7234.
Probably my understanding was not enough correct.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1558,2022-02-02T22:33:42Z,2022-02-12T09:19:48Z,2022-05-07T13:43:13Z,MERGED,True,39,7,2,https://github.com/byko3y,Corrections for cache-control directives handling,3,[],https://github.com/tempesta-tech/tempesta/pull/1558,https://github.com/krizhanovsky,10,https://github.com/tempesta-tech/tempesta/pull/1558#issuecomment-1035430062,"Added max-age and s-maxage support for cache_control_ignore configuration
option.
Fixed interaction of Authorization request with s-maxage, public,
must-revalidate, proxy-revalidate responses.

There still remain some problems with only-if-cached and max-state+max-age, so it's kind of a preview.",Then let's merge it and finally close #530,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1560,2022-02-04T14:20:22Z,2022-02-12T21:36:30Z,2022-02-12T21:36:38Z,MERGED,True,301,69,5,https://github.com/ttaym,"Handle Content-Type in GET requests, fixes #1296",12,[],https://github.com/tempesta-tech/tempesta/pull/1560,https://github.com/ttaym,1,https://github.com/tempesta-tech/tempesta/pull/1560,"Fixes #1296
Considerations. For methods: GET, HEAD, DELETE, CONNECT, TRACE requests with payload to be dropped.
CONNECT method not supported now and need considerably more work to support.
For HTTP/1.1 payload indicated by presence of Content-Length or Transfer-Encoding headers. Even if Content-Length is zero message to be dropped, because Content-Length header may change semantics for recipient.
For HTTP/2.0 payload indicated by underlying framing protocol, but content-length header may be present and must be consistent with it. So message to be dropped once content-length header is seen or data frame for message is seen.
One more consideration is X-Http-Method-Override header, that used for method tunnelling. It to be respected when do the filtering. It is reasonable to expect that non-safe override methods can not be hidden behind safe method.
The same to be done for Content-Type header as it can change semantics for back-end server and its presence in request message with no payload have no meaningful reason.
For further discussions go to linked issue.","Fixes #1296
Considerations. For methods: GET, HEAD, DELETE, CONNECT, TRACE requests with payload to be dropped.
CONNECT method not supported now and need considerably more work to support.
For HTTP/1.1 payload indicated by presence of Content-Length or Transfer-Encoding headers. Even if Content-Length is zero message to be dropped, because Content-Length header may change semantics for recipient.
For HTTP/2.0 payload indicated by underlying framing protocol, but content-length header may be present and must be consistent with it. So message to be dropped once content-length header is seen or data frame for message is seen.
One more consideration is X-Http-Method-Override header, that used for method tunnelling. It to be respected when do the filtering. It is reasonable to expect that non-safe override methods can not be hidden behind safe method.
The same to be done for Content-Type header as it can change semantics for back-end server and its presence in request message with no payload have no meaningful reason.
For further discussions go to linked issue.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1560,2022-02-04T14:20:22Z,2022-02-12T21:36:30Z,2022-02-12T21:36:38Z,MERGED,True,301,69,5,https://github.com/ttaym,"Handle Content-Type in GET requests, fixes #1296",12,[],https://github.com/tempesta-tech/tempesta/pull/1560,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/1560#issuecomment-1035695049,"Fixes #1296
Considerations. For methods: GET, HEAD, DELETE, CONNECT, TRACE requests with payload to be dropped.
CONNECT method not supported now and need considerably more work to support.
For HTTP/1.1 payload indicated by presence of Content-Length or Transfer-Encoding headers. Even if Content-Length is zero message to be dropped, because Content-Length header may change semantics for recipient.
For HTTP/2.0 payload indicated by underlying framing protocol, but content-length header may be present and must be consistent with it. So message to be dropped once content-length header is seen or data frame for message is seen.
One more consideration is X-Http-Method-Override header, that used for method tunnelling. It to be respected when do the filtering. It is reasonable to expect that non-safe override methods can not be hidden behind safe method.
The same to be done for Content-Type header as it can change semantics for back-end server and its presence in request message with no payload have no meaningful reason.
For further discussions go to linked issue.","Also there are several several statements in https://github.com/tempesta-tech/tempesta/wiki/Web-security#http-request-smuggling , which must be fixed:

 ""Tempesta FW should reject it, but that not implemented yet."" -> ""Tempesta FW rejects such messages.""
 "" Tempesta FW should overall reject message with such headers"" - please test the case and remove ""should""",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1560,2022-02-04T14:20:22Z,2022-02-12T21:36:30Z,2022-02-12T21:36:38Z,MERGED,True,301,69,5,https://github.com/ttaym,"Handle Content-Type in GET requests, fixes #1296",12,[],https://github.com/tempesta-tech/tempesta/pull/1560,https://github.com/ttaym,3,https://github.com/tempesta-tech/tempesta/pull/1560#issuecomment-1036222104,"Fixes #1296
Considerations. For methods: GET, HEAD, DELETE, CONNECT, TRACE requests with payload to be dropped.
CONNECT method not supported now and need considerably more work to support.
For HTTP/1.1 payload indicated by presence of Content-Length or Transfer-Encoding headers. Even if Content-Length is zero message to be dropped, because Content-Length header may change semantics for recipient.
For HTTP/2.0 payload indicated by underlying framing protocol, but content-length header may be present and must be consistent with it. So message to be dropped once content-length header is seen or data frame for message is seen.
One more consideration is X-Http-Method-Override header, that used for method tunnelling. It to be respected when do the filtering. It is reasonable to expect that non-safe override methods can not be hidden behind safe method.
The same to be done for Content-Type header as it can change semantics for back-end server and its presence in request message with no payload have no meaningful reason.
For further discussions go to linked issue.","@krizhanovsky
Give here reason behind touching existing tests. I touched only those tests that become broken with new content-length and content-type logic.
FOR_REQ_SIMPLE() only set GET method and that fail with any content-length or content-type headers.
For broken tests there are two way to fix it. First one to remove the headers that render it invalid or change method to POST for instance. I prefer later for where we not test method parsing logic.
I'll leave comments for all of your started discuusions.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1561,2022-02-08T22:50:38Z,2022-02-10T19:35:27Z,2022-02-10T19:35:39Z,MERGED,True,2,4,1,https://github.com/Dmitry-Gouriev,Fixed buggy ss_skb_chop_head_tail() in tfw_h1_purge_resp_clean(),1,[],https://github.com/tempesta-tech/tempesta/pull/1561,https://github.com/Dmitry-Gouriev,1,https://github.com/tempesta-tech/tempesta/pull/1561,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1562,2022-02-10T02:15:01Z,2022-02-16T06:50:24Z,2022-02-16T16:37:07Z,MERGED,True,128,19,1,https://github.com/byko3y,Comments and small refactoring of fixup macroses,5,[],https://github.com/tempesta-tech/tempesta/pull/1562,https://github.com/byko3y,1,https://github.com/tempesta-tech/tempesta/pull/1562,"As a part of #1547

Commented FSM variables, fixup macroses and their naming convention.
Marked with a comment all nested FSM-s that use explicit chunking.
Verified they actually use explicit chunking macroses only.
Removed some unused macroses.
Corrected excessive fixup in __req_parse_cache_control() and missing
fixup in __h2_req_parse_authority().
Wrote additional tests for response chunking.","As a part of #1547

Commented FSM variables, fixup macroses and their naming convention.
Marked with a comment all nested FSM-s that use explicit chunking.
Verified they actually use explicit chunking macroses only.
Removed some unused macroses.
Corrected excessive fixup in __req_parse_cache_control() and missing
fixup in __h2_req_parse_authority().
Wrote additional tests for response chunking.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1562,2022-02-10T02:15:01Z,2022-02-16T06:50:24Z,2022-02-16T16:37:07Z,MERGED,True,128,19,1,https://github.com/byko3y,Comments and small refactoring of fixup macroses,5,[],https://github.com/tempesta-tech/tempesta/pull/1562,https://github.com/byko3y,2,https://github.com/tempesta-tech/tempesta/pull/1562#issuecomment-1038886645,"As a part of #1547

Commented FSM variables, fixup macroses and their naming convention.
Marked with a comment all nested FSM-s that use explicit chunking.
Verified they actually use explicit chunking macroses only.
Removed some unused macroses.
Corrected excessive fixup in __req_parse_cache_control() and missing
fixup in __h2_req_parse_authority().
Wrote additional tests for response chunking.",Rolled back the mentioned macros.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1563,2022-02-10T07:17:36Z,2022-02-11T15:18:27Z,2022-02-11T15:18:36Z,MERGED,True,2,0,2,https://github.com/ttaym,Fixes build when dbg_hpack defined,2,[],https://github.com/tempesta-tech/tempesta/pull/1563,https://github.com/ttaym,1,https://github.com/tempesta-tech/tempesta/pull/1563,"No linked issue.
I ran into an issue when building unit tests with command:
> DEBUG=3 DBG_HTTP_PARSE=3 DBG_HPACK=3 make test

Build failed with error:

In file included from ./include/linux/export.h:43,
from ./include/linux/linkage.h:7,
from ./arch/x86/include/asm/cache.h:5,
from ./include/linux/cache.h:6,
from /root/workspace/tempesta/fw/pool.h:26,
from /root/workspace/tempesta/fw/hpack.c:26:
/root/workspace/tempesta/fw/pool.h: In function 'tfw_pool_alloc_np':
/root/workspace/tempesta/fw/pool.h:31:31: error: 'PAGE_SIZE' undeclared (first use in this function)
31 | #define TFW_POOL_CHUNK_SZ(p) (PAGE_SIZE << (p)->order)
|                               ^~~~~~~~~
./include/linux/compiler.h:78:42: note: in definition of macro 'unlikely'
78 | # define unlikely(x) __builtin_expect(!!(x), 0)
|                                          ^
/root/workspace/tempesta/fw/pool.h:94:21: note: in expansion of macro 'TFW_POOL_CHUNK_SZ'
94 |  if (unlikely(off > TFW_POOL_CHUNK_SZ(p))) {
|                     ^~~~~~~~~~~~~~~~~
/root/workspace/tempesta/fw/pool.h:31:31: note: each undeclared identifier is reported only once for each function it appears in
31 | #define TFW_POOL_CHUNK_SZ(p) (PAGE_SIZE << (p)->order)
|                               ^~~~~~~~~
./include/linux/compiler.h:78:42: note: in definition of macro 'unlikely'
78 | # define unlikely(x) __builtin_expect(!!(x), 0)
|                                          ^
/root/workspace/tempesta/fw/pool.h:94:21: note: in expansion of macro 'TFW_POOL_CHUNK_SZ'
94 |  if (unlikely(off > TFW_POOL_CHUNK_SZ(p))) {

This PR fixes issue.","No linked issue.
I ran into an issue when building unit tests with command:
> DEBUG=3 DBG_HTTP_PARSE=3 DBG_HPACK=3 make test

Build failed with error:

In file included from ./include/linux/export.h:43,
from ./include/linux/linkage.h:7,
from ./arch/x86/include/asm/cache.h:5,
from ./include/linux/cache.h:6,
from /root/workspace/tempesta/fw/pool.h:26,
from /root/workspace/tempesta/fw/hpack.c:26:
/root/workspace/tempesta/fw/pool.h: In function 'tfw_pool_alloc_np':
/root/workspace/tempesta/fw/pool.h:31:31: error: 'PAGE_SIZE' undeclared (first use in this function)
31 | #define TFW_POOL_CHUNK_SZ(p) (PAGE_SIZE << (p)->order)
|                               ^~~~~~~~~
./include/linux/compiler.h:78:42: note: in definition of macro 'unlikely'
78 | # define unlikely(x) __builtin_expect(!!(x), 0)
|                                          ^
/root/workspace/tempesta/fw/pool.h:94:21: note: in expansion of macro 'TFW_POOL_CHUNK_SZ'
94 |  if (unlikely(off > TFW_POOL_CHUNK_SZ(p))) {
|                     ^~~~~~~~~~~~~~~~~
/root/workspace/tempesta/fw/pool.h:31:31: note: each undeclared identifier is reported only once for each function it appears in
31 | #define TFW_POOL_CHUNK_SZ(p) (PAGE_SIZE << (p)->order)
|                               ^~~~~~~~~
./include/linux/compiler.h:78:42: note: in definition of macro 'unlikely'
78 | # define unlikely(x) __builtin_expect(!!(x), 0)
|                                          ^
/root/workspace/tempesta/fw/pool.h:94:21: note: in expansion of macro 'TFW_POOL_CHUNK_SZ'
94 |  if (unlikely(off > TFW_POOL_CHUNK_SZ(p))) {

This PR fixes issue.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1564,2022-02-10T12:21:20Z,2022-02-18T15:25:48Z,2022-02-18T15:26:50Z,MERGED,True,606,134,10,https://github.com/ttaym,Add option for set cache policy based on cookie name or pattern,5,[],https://github.com/tempesta-tech/tempesta/pull/1564,https://github.com/ttaym,1,https://github.com/tempesta-tech/tempesta/pull/1564,"Fixes #1544
PR adds new rule to http chains. Field 'cookie', field value string with prefix or postfix wildcard, forced (for now) equality sign, field argument string with prefix or postfix wildcard, action that typically should set new flag '$cache'.
The PR contains feature implementation and unit tests for http chains cookie rule. No functional tests.
Please note, that cookie field value string in TfwHttpMatchRule for cookie name matching is allocated string.
Implemented logic works only for requests. Header Set-Cookie not consulted.
In fact only setting $cache variable to zero works as expected. Setting it to 1 is just leaving Tempesta FW caching logic intact.
Currently in implemented logic setting $cache to 1 after some previous cookie rules set it to 0 will effectivelly reset it, as if it never set to zero.
As side-effect $cache setting action is usable in other rules as well.
Cookie name and value matching are case-sensitive. As i can see RFC6265#section-4.2 has no mention of case-insensitive matching (as it does for cookie attributes).
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com","Fixes #1544
PR adds new rule to http chains. Field 'cookie', field value string with prefix or postfix wildcard, forced (for now) equality sign, field argument string with prefix or postfix wildcard, action that typically should set new flag '$cache'.
The PR contains feature implementation and unit tests for http chains cookie rule. No functional tests.
Please note, that cookie field value string in TfwHttpMatchRule for cookie name matching is allocated string.
Implemented logic works only for requests. Header Set-Cookie not consulted.
In fact only setting $cache variable to zero works as expected. Setting it to 1 is just leaving Tempesta FW caching logic intact.
Currently in implemented logic setting $cache to 1 after some previous cookie rules set it to 0 will effectivelly reset it, as if it never set to zero.
As side-effect $cache setting action is usable in other rules as well.
Cookie name and value matching are case-sensitive. As i can see RFC6265#section-4.2 has no mention of case-insensitive matching (as it does for cookie attributes).
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1564,2022-02-10T12:21:20Z,2022-02-18T15:25:48Z,2022-02-18T15:26:50Z,MERGED,True,606,134,10,https://github.com/ttaym,Add option for set cache policy based on cookie name or pattern,5,[],https://github.com/tempesta-tech/tempesta/pull/1564,https://github.com/ttaym,2,https://github.com/tempesta-tech/tempesta/pull/1564#issuecomment-1044217677,"Fixes #1544
PR adds new rule to http chains. Field 'cookie', field value string with prefix or postfix wildcard, forced (for now) equality sign, field argument string with prefix or postfix wildcard, action that typically should set new flag '$cache'.
The PR contains feature implementation and unit tests for http chains cookie rule. No functional tests.
Please note, that cookie field value string in TfwHttpMatchRule for cookie name matching is allocated string.
Implemented logic works only for requests. Header Set-Cookie not consulted.
In fact only setting $cache variable to zero works as expected. Setting it to 1 is just leaving Tempesta FW caching logic intact.
Currently in implemented logic setting $cache to 1 after some previous cookie rules set it to 0 will effectivelly reset it, as if it never set to zero.
As side-effect $cache setting action is usable in other rules as well.
Cookie name and value matching are case-sensitive. As i can see RFC6265#section-4.2 has no mention of case-insensitive matching (as it does for cookie attributes).
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com",Updated PR. Please look at not resolved comments.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1566,2022-02-15T12:02:47Z,2022-02-16T08:37:31Z,2022-02-16T16:37:15Z,MERGED,True,34,11,2,https://github.com/byko3y,Corrected fixups for cache-control and authority,2,[],https://github.com/tempesta-tech/tempesta/pull/1566,https://github.com/byko3y,1,https://github.com/tempesta-tech/tempesta/pull/1566,"Extracted from #1562
Also added more headers into fills_hdr_tbl_for_resp test
__req_parse_cache_control() bug:
__FSM_I_MATCH_MOVE and __FSM_I_MATCH_MOVE_fixup only differ in calling
__msg_hdr_chunk_fixup() with data + len and p + __fsm_size
correspondingly. This creates a problem when p != data e.g. we are
parsing multiple tokens.
The whole __req_parse_cache_control() function normally uses
__FSM_I_MATCH_MOVE, thus doing lazy fixups over complete chunks with
TFW_POSTPONE return value and the final fixup is performed by parent
TFW_HTTP_PARSE_RAWHDR_VAL with return value greater or equal 0.
The fills_hdr_tbl_for_req test shows a mishandling of Cache-Control
header value when it's equal to
Cache-Control: max-age=1, dummy, no-store, min-fresh=30
Let's suppose the string is chunked into
max-age=1, dum
my, no-store, min-fresh=30
blocks. The first chunk will be processed via labels
m  -> Req_I_CC_start, Req_I_CC
max-age=  -> Req_I_CC_m, Req_I_CC_MaxAgeVBeg
1  -> Req_I_CC_MaxAgeVBeg, Req_I_CC_MaxAgeV
,  -> Req_I_EoT
"" "" -> Req_I_After_Comma
d  -> Req_I_CC
dum -> Req_I_CC_Ext (returns TFW_POSTPONE)
When the wrong fixup macro is used, the parsing of the first chunk
will reach the Req_I_CC_Ext label and trigger the __fsm_sz == __fsm_n
condition (chunk exhaustion) in the __FSM_I_MATCH_MOVE_fixup, thus
doing a __msg_hdr_chunk_fixup(""dum"", 3) fixup and returning
TFW_POSTPONE. This way the starting portion of the first chunk will
never be fixed up. Parsing of the second chunk, will be resumed on
the same __FSM_I_MATCH_MOVE_fixup, which will effectively return a
__fsm_sz value and continue normal processing in the
__req_parse_cache_control().
This way the final value for msg->stream->parser.hdr string will be
Cache-Control: dummy, no-store, min-fresh=30
Which might look fine, aprat from the missing starting portion.
__h2_req_parse_authority() bug:
This function has an inverse problem: a lazy __FSM_H2_I_MOVE_n_flag
fixup is used instead of explicit __FSM_H2_I_MOVE_fixup.
Suppose the header is
Authority: [::1]:5001
and its value is chunked as
The processing will go through the following FSM states:
""["" -> Req_I_A_Start (fixups ""["")
"":"" -> Req_I_A_v6 (fixups ???, returns TFW_POSTPONE \ CSTR_NEQ)
"":"" -> Req_I_A_v6 (fixups "":"")
""1"" -> Req_I_A_v6 (fixups ""1"")
""]"" -> Req_I_A_v6 (fixups ""]"")
"":"" -> Req_I_A_End (fixups "":"")
5000 -> Req_I_A_Port (fixups ""5000"", returns 0 \ CSTR_EQ)
The use of __FSM_H2_I_MOVE_n_flag macro inside Req_I_A_v6 leads to
a __msg_hdr_chunk_fixup(""[:"", 2) call instead of a correct
__msg_hdr_chunk_fixup("":"", 1). Thus the final parsed string will look
like
Authority: [[::1]:5001","Extracted from #1562
Also added more headers into fills_hdr_tbl_for_resp test
__req_parse_cache_control() bug:
__FSM_I_MATCH_MOVE and __FSM_I_MATCH_MOVE_fixup only differ in calling
__msg_hdr_chunk_fixup() with data + len and p + __fsm_size
correspondingly. This creates a problem when p != data e.g. we are
parsing multiple tokens.
The whole __req_parse_cache_control() function normally uses
__FSM_I_MATCH_MOVE, thus doing lazy fixups over complete chunks with
TFW_POSTPONE return value and the final fixup is performed by parent
TFW_HTTP_PARSE_RAWHDR_VAL with return value greater or equal 0.
The fills_hdr_tbl_for_req test shows a mishandling of Cache-Control
header value when it's equal to
Cache-Control: max-age=1, dummy, no-store, min-fresh=30
Let's suppose the string is chunked into
max-age=1, dum
my, no-store, min-fresh=30
blocks. The first chunk will be processed via labels
m  -> Req_I_CC_start, Req_I_CC
max-age=  -> Req_I_CC_m, Req_I_CC_MaxAgeVBeg
1  -> Req_I_CC_MaxAgeVBeg, Req_I_CC_MaxAgeV
,  -> Req_I_EoT
"" "" -> Req_I_After_Comma
d  -> Req_I_CC
dum -> Req_I_CC_Ext (returns TFW_POSTPONE)
When the wrong fixup macro is used, the parsing of the first chunk
will reach the Req_I_CC_Ext label and trigger the __fsm_sz == __fsm_n
condition (chunk exhaustion) in the __FSM_I_MATCH_MOVE_fixup, thus
doing a __msg_hdr_chunk_fixup(""dum"", 3) fixup and returning
TFW_POSTPONE. This way the starting portion of the first chunk will
never be fixed up. Parsing of the second chunk, will be resumed on
the same __FSM_I_MATCH_MOVE_fixup, which will effectively return a
__fsm_sz value and continue normal processing in the
__req_parse_cache_control().
This way the final value for msg->stream->parser.hdr string will be
Cache-Control: dummy, no-store, min-fresh=30
Which might look fine, aprat from the missing starting portion.
__h2_req_parse_authority() bug:
This function has an inverse problem: a lazy __FSM_H2_I_MOVE_n_flag
fixup is used instead of explicit __FSM_H2_I_MOVE_fixup.
Suppose the header is
Authority: [::1]:5001
and its value is chunked as
The processing will go through the following FSM states:
""["" -> Req_I_A_Start (fixups ""["")
"":"" -> Req_I_A_v6 (fixups ???, returns TFW_POSTPONE \ CSTR_NEQ)
"":"" -> Req_I_A_v6 (fixups "":"")
""1"" -> Req_I_A_v6 (fixups ""1"")
""]"" -> Req_I_A_v6 (fixups ""]"")
"":"" -> Req_I_A_End (fixups "":"")
5000 -> Req_I_A_Port (fixups ""5000"", returns 0 \ CSTR_EQ)
The use of __FSM_H2_I_MOVE_n_flag macro inside Req_I_A_v6 leads to
a __msg_hdr_chunk_fixup(""[:"", 2) call instead of a correct
__msg_hdr_chunk_fixup("":"", 1). Thus the final parsed string will look
like
Authority: [[::1]:5001",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1567,2022-02-15T12:13:36Z,2022-02-18T08:48:42Z,2022-05-07T13:43:11Z,MERGED,True,505,3,5,https://github.com/dmpetroff,Simple access log,10,[],https://github.com/tempesta-tech/tempesta/pull/1567,https://github.com/dmpetroff,1,https://github.com/tempesta-tech/tempesta/pull/1567,"Add simple access logging (see #1154)
Access logging is enabled/disabled globally via config option
access_log on;

Messages are being printed to klog with printk and truncated to 990 bytes with about ~300 bytes limit per uri/referer/user-agent.
Missing entries are replaced with -. In case of parser errors request method, uri, and version may be ""missing separately"" and resulting request line could look like ""GET /some-uri -"" or even ""- - -"".
Access logging works for http/1.x and http/2 for frang-rejected requests too (though I fake http response status in tfw_h2_error_resp).","Add simple access logging (see #1154)
Access logging is enabled/disabled globally via config option
access_log on;

Messages are being printed to klog with printk and truncated to 990 bytes with about ~300 bytes limit per uri/referer/user-agent.
Missing entries are replaced with -. In case of parser errors request method, uri, and version may be ""missing separately"" and resulting request line could look like ""GET /some-uri -"" or even ""- - -"".
Access logging works for http/1.x and http/2 for frang-rejected requests too (though I fake http response status in tfw_h2_error_resp).",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1567,2022-02-15T12:13:36Z,2022-02-18T08:48:42Z,2022-05-07T13:43:11Z,MERGED,True,505,3,5,https://github.com/dmpetroff,Simple access log,10,[],https://github.com/tempesta-tech/tempesta/pull/1567,https://github.com/dmpetroff,2,https://github.com/tempesta-tech/tempesta/pull/1567#issuecomment-1041852786,"Add simple access logging (see #1154)
Access logging is enabled/disabled globally via config option
access_log on;

Messages are being printed to klog with printk and truncated to 990 bytes with about ~300 bytes limit per uri/referer/user-agent.
Missing entries are replaced with -. In case of parser errors request method, uri, and version may be ""missing separately"" and resulting request line could look like ""GET /some-uri -"" or even ""- - -"".
Access logging works for http/1.x and http/2 for frang-rejected requests too (though I fake http response status in tfw_h2_error_resp).","I've addressed all problems mentioned and re-implemented access logging with some metaprogramming.
Now log line structure is set within ACCESS_LOG_LINE and require some minor code adjustments (to serialze new field to the string).
Also as a side-effect now there's a bit of ""zero-copying"" things (like plain strings are sent unmodified to printk) and this would make this code more suitable for proper logging in the future.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1567,2022-02-15T12:13:36Z,2022-02-18T08:48:42Z,2022-05-07T13:43:11Z,MERGED,True,505,3,5,https://github.com/dmpetroff,Simple access log,10,[],https://github.com/tempesta-tech/tempesta/pull/1567,https://github.com/dmpetroff,3,https://github.com/tempesta-tech/tempesta/pull/1567#issuecomment-1042968460,"Add simple access logging (see #1154)
Access logging is enabled/disabled globally via config option
access_log on;

Messages are being printed to klog with printk and truncated to 990 bytes with about ~300 bytes limit per uri/referer/user-agent.
Missing entries are replaced with -. In case of parser errors request method, uri, and version may be ""missing separately"" and resulting request line could look like ""GET /some-uri -"" or even ""- - -"".
Access logging works for http/1.x and http/2 for frang-rejected requests too (though I fake http response status in tfw_h2_error_resp).","I've addressed mentioned problems and found one small bug, where vhost field wasn't enclosed into double quotes on the right side.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1568,2022-02-21T11:56:27Z,2022-02-24T12:39:02Z,2022-02-24T12:39:33Z,MERGED,True,84,145,14,https://github.com/ttaym,Replace GFSM calls with direct calls to TLS and HTTP,1,[],https://github.com/tempesta-tech/tempesta/pull/1568,https://github.com/ttaym,1,https://github.com/tempesta-tech/tempesta/pull/1568,"Contributes to #755
Porting of 2eae1da

Replace GFSM calls with direct calls to TLS and HTTP handlers
 on low level networking layers.

GFSM was designed to build graphs of network protocols FSMs (this
design was inspired by FreeBSD netgraph). However, during the years
neither we nor external users have any requirements to introduce
any modules which use GFSM to hook TLS or HTTP entry code. There
are only 2 users of the mechanism for TLS and HTTP for now:
1. TLS -> HTTP protocols handling
2. HTTP limits (the frang module)

This patch replaces GFSM calls with direct calls to
tfw_http_req_process(), tfw_tls_msg_process() and frang_tls_handler()
in following paths:
1. sync sockets -> TLS
2. sync sockets -> HTTP
3. TLS -> HTTP
4. TLS -> Frang

As the result the function tfw_connection_recv() was eliminated.
Now the code is simpler and has lower overhead.

We still might need GFSM for the user-space requests handling (#77)
and Tempesta Language (#102).


Based-on-patch-by: Alexander K ak@tempesta-tech.com
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com","Contributes to #755
Porting of 2eae1da

Replace GFSM calls with direct calls to TLS and HTTP handlers
 on low level networking layers.

GFSM was designed to build graphs of network protocols FSMs (this
design was inspired by FreeBSD netgraph). However, during the years
neither we nor external users have any requirements to introduce
any modules which use GFSM to hook TLS or HTTP entry code. There
are only 2 users of the mechanism for TLS and HTTP for now:
1. TLS -> HTTP protocols handling
2. HTTP limits (the frang module)

This patch replaces GFSM calls with direct calls to
tfw_http_req_process(), tfw_tls_msg_process() and frang_tls_handler()
in following paths:
1. sync sockets -> TLS
2. sync sockets -> HTTP
3. TLS -> HTTP
4. TLS -> Frang

As the result the function tfw_connection_recv() was eliminated.
Now the code is simpler and has lower overhead.

We still might need GFSM for the user-space requests handling (#77)
and Tempesta Language (#102).


Based-on-patch-by: Alexander K ak@tempesta-tech.com
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1568,2022-02-21T11:56:27Z,2022-02-24T12:39:02Z,2022-02-24T12:39:33Z,MERGED,True,84,145,14,https://github.com/ttaym,Replace GFSM calls with direct calls to TLS and HTTP,1,[],https://github.com/tempesta-tech/tempesta/pull/1568,https://github.com/ttaym,2,https://github.com/tempesta-tech/tempesta/pull/1568#issuecomment-1049818285,"Contributes to #755
Porting of 2eae1da

Replace GFSM calls with direct calls to TLS and HTTP handlers
 on low level networking layers.

GFSM was designed to build graphs of network protocols FSMs (this
design was inspired by FreeBSD netgraph). However, during the years
neither we nor external users have any requirements to introduce
any modules which use GFSM to hook TLS or HTTP entry code. There
are only 2 users of the mechanism for TLS and HTTP for now:
1. TLS -> HTTP protocols handling
2. HTTP limits (the frang module)

This patch replaces GFSM calls with direct calls to
tfw_http_req_process(), tfw_tls_msg_process() and frang_tls_handler()
in following paths:
1. sync sockets -> TLS
2. sync sockets -> HTTP
3. TLS -> HTTP
4. TLS -> Frang

As the result the function tfw_connection_recv() was eliminated.
Now the code is simpler and has lower overhead.

We still might need GFSM for the user-space requests handling (#77)
and Tempesta Language (#102).


Based-on-patch-by: Alexander K ak@tempesta-tech.com
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com","I manually test patch on VPS instance with:
~$ curl -vik --resolve debian.tempesta:443:44.93.154.134 https://debian.tempesta/

And config:
listen 443 proto=https;

srv_group default {
    server 127.0.0.1:8000 conns_n=4;
}

vhost debian.tempesta {
    proxy_pass default;
    tls_certificate     /root/cert.pem;
    tls_certificate_key /root/privkey.pem;
}

cache 1;
cache_fulfill * *;

block_action attack reply;

http_chain {
    -> debian.tempesta;
}

Connection established and https request served.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1570,2022-02-22T12:16:45Z,2022-02-25T06:58:25Z,2022-02-25T06:59:06Z,MERGED,True,201,133,2,https://github.com/ttaym,"Scheme parsing fix (https) and extending (ws, wss)",6,[],https://github.com/tempesta-tech/tempesta/pull/1570,https://github.com/ttaym,1,https://github.com/tempesta-tech/tempesta/pull/1570,"Contributes to #755
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com","Contributes to #755
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1571,2022-02-24T13:40:00Z,2022-03-16T13:44:44Z,2022-03-16T14:00:39Z,MERGED,True,311,22,5,https://github.com/ttaym,Websocket upgrade directive implementation,2,[],https://github.com/tempesta-tech/tempesta/pull/1571,https://github.com/ttaym,1,https://github.com/tempesta-tech/tempesta/pull/1571,"Contributes to #755
Considerations.
It seems that to confrom to RFC7230#section-6.6 we have to be prepared to process requests with Connection: upgrade and Expect: 100-continue set at the same time and respond with 100 before going further with the request. But for websocket upgrade case it is obscure and rare (if ever) seen. For now implemented logic does not have that.
It seems that standard does not explicitly forbid Upgrade header in request trailer field. But for now implementation does not support that scenario.
Tempesta FW MUST block requests with Upgrade header but without upgrade option in Connection header. Tempesta FW MUST ignore Upgrade header for HTTP version less then HTTP/1.1. See RFC7230#section-6.1:

When Upgrade is sent, the sender MUST also send a Connection header
field (Section 6.1) that contains an ""upgrade"" connection option, in
order to prevent Upgrade from being accidentally forwarded by
intermediaries that might not implement the listed protocols.  A
server MUST ignore an Upgrade header field that is received in an
HTTP/1.0 request.

Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com","Contributes to #755
Considerations.
It seems that to confrom to RFC7230#section-6.6 we have to be prepared to process requests with Connection: upgrade and Expect: 100-continue set at the same time and respond with 100 before going further with the request. But for websocket upgrade case it is obscure and rare (if ever) seen. For now implemented logic does not have that.
It seems that standard does not explicitly forbid Upgrade header in request trailer field. But for now implementation does not support that scenario.
Tempesta FW MUST block requests with Upgrade header but without upgrade option in Connection header. Tempesta FW MUST ignore Upgrade header for HTTP version less then HTTP/1.1. See RFC7230#section-6.1:

When Upgrade is sent, the sender MUST also send a Connection header
field (Section 6.1) that contains an ""upgrade"" connection option, in
order to prevent Upgrade from being accidentally forwarded by
intermediaries that might not implement the listed protocols.  A
server MUST ignore an Upgrade header field that is received in an
HTTP/1.0 request.

Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1574,2022-03-01T15:57:14Z,2022-03-02T13:40:34Z,2022-03-02T16:05:57Z,MERGED,True,1,1,1,https://github.com/ttaym,Fix build on ubuntu 20.04,2,[],https://github.com/tempesta-tech/tempesta/pull/1574,https://github.com/ttaym,1,https://github.com/tempesta-tech/tempesta/pull/1574,Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com,Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1575,2022-03-01T16:13:28Z,2022-03-01T18:50:48Z,2022-03-01T18:50:53Z,MERGED,True,3,3,2,https://github.com/pale-emperor,Build for kernel 5.10.35+,1,[],https://github.com/tempesta-tech/tempesta/pull/1575,https://github.com/pale-emperor,1,https://github.com/tempesta-tech/tempesta/pull/1575,"BUILD_EXCLUSIVE_KERNEL=5.10.35*
dh_install db
dh_install fw","BUILD_EXCLUSIVE_KERNEL=5.10.35*
dh_install db
dh_install fw",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1576,2022-03-02T11:15:35Z,,2022-03-03T17:16:02Z,OPEN,False,47,15,2,https://github.com/ttaym,Connection header parsing fix for well-known prefixed headers,2,[],https://github.com/tempesta-tech/tempesta/pull/1576,https://github.com/ttaym,1,https://github.com/tempesta-tech/tempesta/pull/1576,"Fixes #1579
Fix of Connection header parsing bug discovered.
Bug emerges when token name starts exactly with name of well-known option (close) or specially processed header (keep-alive).
PR includes fix and new unit test to cover this case.
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com","Fixes #1579
Fix of Connection header parsing bug discovered.
Bug emerges when token name starts exactly with name of well-known option (close) or specially processed header (keep-alive).
PR includes fix and new unit test to cover this case.
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1576,2022-03-02T11:15:35Z,,2022-03-03T17:16:02Z,OPEN,False,47,15,2,https://github.com/ttaym,Connection header parsing fix for well-known prefixed headers,2,[],https://github.com/tempesta-tech/tempesta/pull/1576,https://github.com/ttaym,2,https://github.com/tempesta-tech/tempesta/pull/1576#issuecomment-1057745578,"Fixes #1579
Fix of Connection header parsing bug discovered.
Bug emerges when token name starts exactly with name of well-known option (close) or specially processed header (keep-alive).
PR includes fix and new unit test to cover this case.
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com","I appreciate your reviews. With all your help my standing now is that:

The code is correct in a sense that it works as expected due to its relatively rich unit test coverage.
The code is chunk safe because unit tests chunk-fuzzed for each test case.

But there are legit concerns:

Introduction of _saved_p is go against parser conceptional ideas and should be avoided if possible.
Not optimal and semantically inaccurate overall structure of parser and parser state design in the function. While refactor of function is not directly in scope of this PR it can be fixed if it helps point 1).

@krizhanovsky As i can see __hbh_parser_add_data() not called twice, because it is not called on full match of Keep-Alive (call to it is in finish callback that is called on partial matches only).
@byko3y Old TRY_CONN_TOKEN worked as long as only one special token or its fully matched prefix (close, keep-alive) seen on single __parse_connection call. Multiple tokens rarely present in connection options because close and keep-alive semantics antipodes, yet cases when connection option is not exactly equal but start with the token was not covered.
@byko3y Saving chunk start in __FSM_DECLARE_VARS may be not an option, because invocation of __parse_connection may be awakening from TFW_POSTPONE and token start will be lost.
With all said, I'll try to fix the bug while not introducing _saved_p to be consistent with parser internals and fundamentals.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1576,2022-03-02T11:15:35Z,,2022-03-03T17:16:02Z,OPEN,False,47,15,2,https://github.com/ttaym,Connection header parsing fix for well-known prefixed headers,2,[],https://github.com/tempesta-tech/tempesta/pull/1576,https://github.com/krizhanovsky,3,https://github.com/tempesta-tech/tempesta/pull/1576#issuecomment-1057878436,"Fixes #1579
Fix of Connection header parsing bug discovered.
Bug emerges when token name starts exactly with name of well-known option (close) or specially processed header (keep-alive).
PR includes fix and new unit test to cover this case.
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com","As i can see __hbh_parser_add_data() not called twice, because it is not called on full match of Keep-Alive (call to it is in finish callback that is called on partial matches only).

Yeah, agree

The code is correct in a sense that it works as expected due to its relatively rich unit test coverage.

No since your test shows that the code has the problem

The code is chunk safe because unit tests chunk-fuzzed for each test case.
Not necessary. Pavel and Dmitry recently found bugs the tests and the parser itself - we were living with all the code for a long time.

The answer for this question would be testing coverage, but we didn't integrate it yet.
For now I'd suggest to run the test and make sure (e.g. with instrumentation and/or parser debugging facilities) that it actually runs chunking test.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1576,2022-03-02T11:15:35Z,,2022-03-03T17:16:02Z,OPEN,False,47,15,2,https://github.com/ttaym,Connection header parsing fix for well-known prefixed headers,2,[],https://github.com/tempesta-tech/tempesta/pull/1576,https://github.com/ttaym,4,https://github.com/tempesta-tech/tempesta/pull/1576#issuecomment-1057919741,"Fixes #1579
Fix of Connection header parsing bug discovered.
Bug emerges when token name starts exactly with name of well-known option (close) or specially processed header (keep-alive).
PR includes fix and new unit test to cover this case.
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com","I suppose that trick with _saved_p will not always work if chunks reside not in continious memory block. This cases not covered in unit tests at all, because it emulate chunks with TfWStr delimitation not with real detached chunks. But parser should be prepared for unrelated chunks.
Definitely saved position must not be introduced. It will break parser on high load for sure.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1576,2022-03-02T11:15:35Z,,2022-03-03T17:16:02Z,OPEN,False,47,15,2,https://github.com/ttaym,Connection header parsing fix for well-known prefixed headers,2,[],https://github.com/tempesta-tech/tempesta/pull/1576,https://github.com/Dmitry-Gouriev,5,https://github.com/tempesta-tech/tempesta/pull/1576#issuecomment-1057960088,"Fixes #1579
Fix of Connection header parsing bug discovered.
Bug emerges when token name starts exactly with name of well-known option (close) or specially processed header (keep-alive).
PR includes fix and new unit test to cover this case.
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com","__hbh_parser_add_data() includes check for headers denied in Connection:, comparing with list of denied headers. On heavy chunked input this comparison will always fail. All other things will work and unit tests should not manifest any errors.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1576,2022-03-02T11:15:35Z,,2022-03-03T17:16:02Z,OPEN,False,47,15,2,https://github.com/ttaym,Connection header parsing fix for well-known prefixed headers,2,[],https://github.com/tempesta-tech/tempesta/pull/1576,https://github.com/Dmitry-Gouriev,6,https://github.com/tempesta-tech/tempesta/pull/1576#issuecomment-1057965549,"Fixes #1579
Fix of Connection header parsing bug discovered.
Bug emerges when token name starts exactly with name of well-known option (close) or specially processed header (keep-alive).
PR includes fix and new unit test to cover this case.
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com","@krizhanovsky @ttaym @byko3y
I have a crasy proposal to extend parser state with once more TfwStr which will accumulate a current token of the header parsed, and update xxx_fuxup macro correspondently. This will simplify many problems when parsing headers which the TFW must understand. In this case functions like __hbh_parser_add_data() could be called when we know the token is finished.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1577,2022-03-02T17:10:57Z,2022-03-02T18:12:32Z,2022-03-02T18:12:37Z,MERGED,True,14,2,2,https://github.com/pale-emperor,dkms_build modules path fix,2,[],https://github.com/tempesta-tech/tempesta/pull/1577,https://github.com/pale-emperor,1,https://github.com/tempesta-tech/tempesta/pull/1577,fix dkms paths,fix dkms paths,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1578,2022-03-03T08:57:07Z,2022-03-10T09:17:34Z,2022-03-25T13:55:43Z,MERGED,True,128,112,1,https://github.com/alegz-filomaphitskay,Http/2 parser chunks tests,7,[],https://github.com/tempesta-tech/tempesta/pull/1578,https://github.com/alegz-filomaphitskay,1,https://github.com/tempesta-tech/tempesta/pull/1578,Contributes to #1297,Contributes to #1297,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1578,2022-03-03T08:57:07Z,2022-03-10T09:17:34Z,2022-03-25T13:55:43Z,MERGED,True,128,112,1,https://github.com/alegz-filomaphitskay,Http/2 parser chunks tests,7,[],https://github.com/tempesta-tech/tempesta/pull/1578,https://github.com/alegz-filomaphitskay,2,https://github.com/tempesta-tech/tempesta/pull/1578#issuecomment-1063831783,Contributes to #1297,"It surprises me alot that chunked h2 parser tests pass. So please see my comment on the issue #1297 (comment) and ensure that there are no problems in tfw_hpack_decode() left undiscovered by tests.

I took a closer look at the logs and came to the conclusion that the code is work.
Unfortunately I couldn't make the logs more informative for this task.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1581,2022-03-03T17:54:16Z,2022-03-09T19:25:22Z,2022-03-09T19:25:29Z,MERGED,True,49,35,2,https://github.com/pale-emperor,Update tempesta_installer.sh to ubuntu-20 release,2,[],https://github.com/tempesta-tech/tempesta/pull/1581,https://github.com/pale-emperor,1,https://github.com/tempesta-tech/tempesta/pull/1581,"Script tested on fresh Ubuntu 20.04.4 installation - works fine
Fix ubuntu version 20.4 or 20.3 case statement
Fix  _PATH tempesta-fw.service
Fix intends","Script tested on fresh Ubuntu 20.04.4 installation - works fine
Fix ubuntu version 20.4 or 20.3 case statement
Fix  _PATH tempesta-fw.service
Fix intends",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1582,2022-03-05T07:36:33Z,2022-03-16T13:47:12Z,2022-03-16T13:52:08Z,CLOSED,False,88,9,3,https://github.com/ttaym,Recreate upgrade headers for websocket request,1,[],https://github.com/tempesta-tech/tempesta/pull/1582,https://github.com/ttaym,1,https://github.com/tempesta-tech/tempesta/pull/1582,"Contributes to #755
Stacked PR on top of #1571
May be merged in any order.
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com","Contributes to #755
Stacked PR on top of #1571
May be merged in any order.
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1584,2022-03-09T11:55:12Z,2022-03-17T16:06:10Z,2022-03-17T16:06:18Z,CLOSED,False,1368,54,19,https://github.com/ttaym,Upgrade connection to websocket and provision new connection,10,[],https://github.com/tempesta-tech/tempesta/pull/1584,https://github.com/ttaym,1,https://github.com/tempesta-tech/tempesta/pull/1584,"Contributes to #755
Stacked PR on top of #1582
May be merged in any order.
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com","Contributes to #755
Stacked PR on top of #1582
May be merged in any order.
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1586,2022-03-10T08:53:08Z,2022-03-10T13:26:27Z,2022-03-10T13:27:22Z,MERGED,True,1,1,1,https://github.com/pale-emperor,Fix Case in tfw_try_distro(),1,[],https://github.com/tempesta-tech/tempesta/pull/1586,https://github.com/pale-emperor,1,https://github.com/tempesta-tech/tempesta/pull/1586,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1588,2022-03-10T15:03:44Z,2022-03-10T16:34:05Z,2022-05-07T13:41:19Z,MERGED,True,1,7,1,https://github.com/alegz-filomaphitskay,Fix HTTP/2 test warning (#1297),1,[],https://github.com/tempesta-tech/tempesta/pull/1588,https://github.com/alegz-filomaphitskay,1,https://github.com/tempesta-tech/tempesta/pull/1588,Contributes to #1297,Contributes to #1297,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1590,2022-03-15T07:57:35Z,2022-03-15T08:23:45Z,2022-03-15T08:25:42Z,MERGED,True,10,1,2,https://github.com/ttaym,Content length zero in h2 get request fix,1,[],https://github.com/tempesta-tech/tempesta/pull/1590,https://github.com/ttaym,1,https://github.com/tempesta-tech/tempesta/pull/1590,"Fixes discovered false-pass unit test.
	/* But with content-length will be block for http2 too */
	EXPECT_BLOCK_REQ_H2("":authority: debian\n""
			    "":method: GET\n""
-			    "":scheme: http\n""
+			    "":scheme: https\n""
			    "":path: /\n""
			    ""content-length: 0"");
Http2 only viable when https scheme, so was block, but not on content-length bot on scheme. PR fixes that and content-legnth h2 parsing code.
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com","Fixes discovered false-pass unit test.
	/* But with content-length will be block for http2 too */
	EXPECT_BLOCK_REQ_H2("":authority: debian\n""
			    "":method: GET\n""
-			    "":scheme: http\n""
+			    "":scheme: https\n""
			    "":path: /\n""
			    ""content-length: 0"");
Http2 only viable when https scheme, so was block, but not on content-length bot on scheme. PR fixes that and content-legnth h2 parsing code.
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1590,2022-03-15T07:57:35Z,2022-03-15T08:23:45Z,2022-03-15T08:25:42Z,MERGED,True,10,1,2,https://github.com/ttaym,Content length zero in h2 get request fix,1,[],https://github.com/tempesta-tech/tempesta/pull/1590,https://github.com/ttaym,2,https://github.com/tempesta-tech/tempesta/pull/1590#issuecomment-1067694650,"Fixes discovered false-pass unit test.
	/* But with content-length will be block for http2 too */
	EXPECT_BLOCK_REQ_H2("":authority: debian\n""
			    "":method: GET\n""
-			    "":scheme: http\n""
+			    "":scheme: https\n""
			    "":path: /\n""
			    ""content-length: 0"");
Http2 only viable when https scheme, so was block, but not on content-length bot on scheme. PR fixes that and content-legnth h2 parsing code.
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com",Merge now as is. Method overrides will be handled in separate PR.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1591,2022-03-15T14:04:43Z,2022-03-25T14:00:39Z,2022-03-25T14:00:45Z,MERGED,True,259,88,5,https://github.com/alegz-filomaphitskay,Made correct block for requests with content-type and content-length headers in case with bodyless’s methods,14,[],https://github.com/tempesta-tech/tempesta/pull/1591,https://github.com/alegz-filomaphitskay,1,https://github.com/tempesta-tech/tempesta/pull/1591,Contributes to #1297,Contributes to #1297,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1591,2022-03-15T14:04:43Z,2022-03-25T14:00:39Z,2022-03-25T14:00:45Z,MERGED,True,259,88,5,https://github.com/alegz-filomaphitskay,Made correct block for requests with content-type and content-length headers in case with bodyless’s methods,14,[],https://github.com/tempesta-tech/tempesta/pull/1591,https://github.com/ttaym,2,https://github.com/tempesta-tech/tempesta/pull/1591#issuecomment-1069307582,Contributes to #1297,One general comment. I have not found any resources about a prevalence of http override headers in http2. Do you have some links on it? May be that functionality not needed in http2?,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1591,2022-03-15T14:04:43Z,2022-03-25T14:00:39Z,2022-03-25T14:00:45Z,MERGED,True,259,88,5,https://github.com/alegz-filomaphitskay,Made correct block for requests with content-type and content-length headers in case with bodyless’s methods,14,[],https://github.com/tempesta-tech/tempesta/pull/1591,https://github.com/alegz-filomaphitskay,3,https://github.com/tempesta-tech/tempesta/pull/1591#issuecomment-1069397832,Contributes to #1297,"One general comment. I have not found any resources about a prevalence of http override headers in http2. Do you have some links on it?

No, I haven't. But also I don't have any references confirming that the override mechanism is not exist.
I can only quote the RFC:

HTTP/2 is intended to be as compatible as possible with current uses
of HTTP.  This means that, from the application perspective, the
features of the protocol are largely unchanged.  To achieve this, all
request and response semantics are preserved, although the syntax of
conveying those semantics has changed.

Can this serve as proof that the override exists?",True,{'THUMBS_UP': ['https://github.com/ttaym']}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1592,2022-03-16T14:02:19Z,2022-03-18T07:50:04Z,2022-03-18T07:53:06Z,MERGED,True,120,14,3,https://github.com/ttaym,Recreate upgrade headers for websocket request,4,[],https://github.com/tempesta-tech/tempesta/pull/1592,https://github.com/ttaym,1,https://github.com/tempesta-tech/tempesta/pull/1592,"Contributes to #755
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com","Contributes to #755
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1593,2022-03-16T20:06:51Z,2022-03-17T15:07:40Z,2022-03-17T18:17:58Z,MERGED,True,47,3,2,https://github.com/pale-emperor,1589 include directive in the configuration file,5,[],https://github.com/tempesta-tech/tempesta/pull/1593,https://github.com/pale-emperor,1,https://github.com/tempesta-tech/tempesta/pull/1593,From now - config generated from template,From now - config generated from template,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1594,2022-03-17T15:52:13Z,2022-04-03T19:52:39Z,2022-04-08T09:08:43Z,CLOSED,False,221,55,12,https://github.com/ttaym,Upgrade connection to websocket and provision new connection,5,[],https://github.com/tempesta-tech/tempesta/pull/1594,https://github.com/ttaym,1,https://github.com/tempesta-tech/tempesta/pull/1594,"Contributes to #755
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com","Contributes to #755
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1594,2022-03-17T15:52:13Z,2022-04-03T19:52:39Z,2022-04-08T09:08:43Z,CLOSED,False,221,55,12,https://github.com/ttaym,Upgrade connection to websocket and provision new connection,5,[],https://github.com/tempesta-tech/tempesta/pull/1594,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/1594#issuecomment-1086937072,"Contributes to #755
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com","The code and the only one not-addressed comment were moved to #1595 . Please don't forget to remove the branch, when it's not needed",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1595,2022-03-18T11:33:22Z,2022-05-05T12:26:25Z,2022-05-09T08:50:43Z,MERGED,True,649,120,33,https://github.com/ttaym,Websocket simple proxy protocol implementation,11,[],https://github.com/tempesta-tech/tempesta/pull/1595,https://github.com/ttaym,1,https://github.com/tempesta-tech/tempesta/pull/1595,"Contributes to #755
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com","Contributes to #755
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1595,2022-03-18T11:33:22Z,2022-05-05T12:26:25Z,2022-05-09T08:50:43Z,MERGED,True,649,120,33,https://github.com/ttaym,Websocket simple proxy protocol implementation,11,[],https://github.com/tempesta-tech/tempesta/pull/1595,https://github.com/ttaym,2,https://github.com/tempesta-tech/tempesta/pull/1595#issuecomment-1091437259,"Contributes to #755
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com","This answers #1595 (comment)
While for backend connection state field not needed, but we use client connection as is with adapted websocket type. And we call for it for example tfw_http_conn_drop() -> tfw_http_resp_terminate() -> tfw_http_resp_cache() -> tfw_gfsm_move() that use state. I think here not safe to union with it.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1596,2022-03-21T09:46:24Z,2022-03-28T02:57:53Z,2022-03-28T02:58:05Z,MERGED,True,1,0,1,https://github.com/pale-emperor,Update tempesta.sh,1,[],https://github.com/tempesta-tech/tempesta/pull/1596,https://github.com/pale-emperor,1,https://github.com/tempesta-tech/tempesta/pull/1596,Fix deb-package - cant reach default template path at first start,Fix deb-package - cant reach default template path at first start,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1597,2022-03-21T13:44:48Z,2022-05-04T09:15:00Z,2022-05-04T09:15:11Z,MERGED,True,3762,875,8,https://github.com/alegz-filomaphitskay,Split HTTP1 and HTTP2 parser tests,53,[],https://github.com/tempesta-tech/tempesta/pull/1597,https://github.com/alegz-filomaphitskay,1,https://github.com/tempesta-tech/tempesta/pull/1597,"Contributes to #1297
What has been done:

h1/h2 parser tests were splitted in different files;
added little framework for building h2 tests requests;
added many new tests for h2 that duplicated h1 tests;
some h2 parser implementation fixes.","Contributes to #1297
What has been done:

h1/h2 parser tests were splitted in different files;
added little framework for building h2 tests requests;
added many new tests for h2 that duplicated h1 tests;
some h2 parser implementation fixes.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1599,2022-03-24T22:13:57Z,2022-03-24T22:29:13Z,2022-03-24T22:30:23Z,CLOSED,False,7,3,2,https://github.com/pale-emperor,Fix tempesta sh,1,[],https://github.com/tempesta-tech/tempesta/pull/1599,https://github.com/pale-emperor,1,https://github.com/tempesta-tech/tempesta/pull/1599,Fix include pattern logic to use only *.conf files,Fix include pattern logic to use only *.conf files,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1600,2022-03-24T22:42:47Z,2022-03-25T15:10:02Z,2022-03-25T15:10:07Z,MERGED,True,7,2,2,https://github.com/pale-emperor,Fix tempesta.sh and tempesta_installer.sh,1,[],https://github.com/tempesta-tech/tempesta/pull/1600,https://github.com/pale-emperor,1,https://github.com/tempesta-tech/tempesta/pull/1600,"Fix install script with right default grub option
Fix !include pattern to get only *.conf files","Fix install script with right default grub option
Fix !include pattern to get only *.conf files",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1602,2022-03-28T14:38:28Z,2022-03-31T07:03:39Z,2022-04-04T14:53:32Z,MERGED,True,1,1,1,https://github.com/pale-emperor,Update tempesta.sh,1,[],https://github.com/tempesta-tech/tempesta/pull/1602,https://github.com/pale-emperor,1,https://github.com/tempesta-tech/tempesta/pull/1602,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1603,2022-04-08T08:59:26Z,2022-05-04T09:43:00Z,2022-05-05T14:46:14Z,MERGED,True,419,121,6,https://github.com/alegz-filomaphitskay,Implementation of HTTP/2 fuzzer,62,[],https://github.com/tempesta-tech/tempesta/pull/1603,https://github.com/alegz-filomaphitskay,1,https://github.com/tempesta-tech/tempesta/pull/1603,"Contributes to #1297
What was done here:

added implementation of HTTP/2 fuzzer;
added more explicit definition of buffer overflow that is storing generated message.","Contributes to #1297
What was done here:

added implementation of HTTP/2 fuzzer;
added more explicit definition of buffer overflow that is storing generated message.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1604,2022-04-08T09:14:16Z,2022-05-09T08:50:42Z,2022-05-09T08:50:42Z,CLOSED,False,602,116,20,https://github.com/ttaym,Implement websocket boostrapping for http2,6,[],https://github.com/tempesta-tech/tempesta/pull/1604,https://github.com/ttaym,1,https://github.com/tempesta-tech/tempesta/pull/1604,"Contributes to #755

 HTTP/2 -> HTTP/1.1
 HTTP/2 stream FSM amendments
 Sec-WebSocket-Key insert
 HTTP/1.1 -> HTTP/2
 Sec-WebSocket-Accept strip
 Pairing server connection to client stream
 Websocket protocol amendments
 Gracefull shutting down stream

This PR adds CONNECT method and :protocol header field for HTTP/2 parsing.
CONNECT HTTP/2 messages with :protocol equals to websocket transformed to HTTP/1.1 messages for backend with method GET, headers Connection: upgrade and Upgrade: websocket.
Responses from backend with headers Connection: upgrade, Upgrade: websocket and status 101 transformed to :status 200 HTTP/2 responses to client.
When sending 200-success to CONNECT request with websocket :protocol we need not to send END_STREAM frame flag. So to gracefully shutting down stream we need to detect Close websocket control frame or rely on closing tcp connection from backend or closing stream from client.
Note that Sec-WebSocket-Accept stripped from HTTP/1.1 responses and Sec-WebSocket-Key added to HTTP/1.1 request to backend.
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com","Contributes to #755

 HTTP/2 -> HTTP/1.1
 HTTP/2 stream FSM amendments
 Sec-WebSocket-Key insert
 HTTP/1.1 -> HTTP/2
 Sec-WebSocket-Accept strip
 Pairing server connection to client stream
 Websocket protocol amendments
 Gracefull shutting down stream

This PR adds CONNECT method and :protocol header field for HTTP/2 parsing.
CONNECT HTTP/2 messages with :protocol equals to websocket transformed to HTTP/1.1 messages for backend with method GET, headers Connection: upgrade and Upgrade: websocket.
Responses from backend with headers Connection: upgrade, Upgrade: websocket and status 101 transformed to :status 200 HTTP/2 responses to client.
When sending 200-success to CONNECT request with websocket :protocol we need not to send END_STREAM frame flag. So to gracefully shutting down stream we need to detect Close websocket control frame or rely on closing tcp connection from backend or closing stream from client.
Note that Sec-WebSocket-Accept stripped from HTTP/1.1 responses and Sec-WebSocket-Key added to HTTP/1.1 request to backend.
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1605,2022-04-08T10:22:29Z,2022-04-08T19:47:16Z,2022-04-08T19:47:19Z,MERGED,True,17,15,1,https://github.com/avbelov23,Fixed use after destroy,1,[],https://github.com/tempesta-tech/tempesta/pull/1605,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1605,"An array of chunks was created on the stack in the block, and when
the block exits, it was destroyed","An array of chunks was created on the stack in the block, and when
the block exits, it was destroyed",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1605,2022-04-08T10:22:29Z,2022-04-08T19:47:16Z,2022-04-08T19:47:19Z,MERGED,True,17,15,1,https://github.com/avbelov23,Fixed use after destroy,1,[],https://github.com/tempesta-tech/tempesta/pull/1605,https://github.com/avbelov23,2,https://github.com/tempesta-tech/tempesta/pull/1605#issuecomment-1092980255,"An array of chunks was created on the stack in the block, and when
the block exits, it was destroyed",DONE,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1605,2022-04-08T10:22:29Z,2022-04-08T19:47:16Z,2022-04-08T19:47:19Z,MERGED,True,17,15,1,https://github.com/avbelov23,Fixed use after destroy,1,[],https://github.com/tempesta-tech/tempesta/pull/1605,https://github.com/avbelov23,3,https://github.com/tempesta-tech/tempesta/pull/1605#issuecomment-1093039955,"An array of chunks was created on the stack in the block, and when
the block exits, it was destroyed",DONE,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1606,2022-04-08T10:44:11Z,2022-04-08T11:28:30Z,2022-04-08T11:28:33Z,MERGED,True,5,0,1,https://github.com/pale-emperor,kernel panic tempesta.sh,4,[],https://github.com/tempesta-tech/tempesta/pull/1606,https://github.com/pale-emperor,1,https://github.com/tempesta-tech/tempesta/pull/1606,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1609,2022-04-10T23:43:48Z,2022-04-11T13:07:53Z,2022-04-11T13:07:57Z,MERGED,True,428,147,20,https://github.com/krizhanovsky,Handle SAN certificates,4,['crucial'],https://github.com/tempesta-tech/tempesta/pull/1609,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1609,See commit messages. Fixes #1608.,See commit messages. Fixes #1608.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1610,2022-04-11T15:41:09Z,2022-04-11T15:44:00Z,2022-04-11T15:44:03Z,MERGED,True,3,0,1,https://github.com/pale-emperor,Enable sysrq issue-9,1,[],https://github.com/tempesta-tech/tempesta/pull/1610,https://github.com/pale-emperor,1,https://github.com/tempesta-tech/tempesta/pull/1610,Enable sysrq for echo 1 > /proc/sys/kernel/sysrq,Enable sysrq for echo 1 > /proc/sys/kernel/sysrq,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1611,2022-04-11T16:13:17Z,2022-04-11T16:13:27Z,2022-04-11T16:13:30Z,MERGED,True,9,5,1,https://github.com/krizhanovsky,Fix minor bug with SAN certificates processing,1,[],https://github.com/tempesta-tech/tempesta/pull/1611,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1611,"Add SAN/CN wildcard to the SNI mapping regardless whether it matches to the current vhost. Also add the chopped CN, not the vhost name.","Add SAN/CN wildcard to the SNI mapping regardless whether it matches to the current vhost. Also add the chopped CN, not the vhost name.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1612,2022-04-12T07:23:47Z,2022-05-05T14:46:06Z,2022-05-05T20:32:56Z,MERGED,True,1205,600,3,https://github.com/alegz-filomaphitskay,HPACK static table tests,82,[],https://github.com/tempesta-tech/tempesta/pull/1612,https://github.com/alegz-filomaphitskay,1,https://github.com/tempesta-tech/tempesta/pull/1612,"Contributes to #1297
What was done here:

ability to set indexed and literal header field representation;
little refactoring of test's message builder;
tests for HPACK static table (only request entries).","Contributes to #1297
What was done here:

ability to set indexed and literal header field representation;
little refactoring of test's message builder;
tests for HPACK static table (only request entries).",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1613,2022-04-15T09:54:43Z,2022-04-29T09:53:18Z,2022-04-29T09:53:21Z,MERGED,True,103,30,3,https://github.com/avbelov23,Listeners reconfig,3,[],https://github.com/tempesta-tech/tempesta/pull/1613,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1613,#1105,#1105,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1615,2022-04-19T08:45:52Z,2022-05-06T06:49:10Z,2022-05-06T16:20:23Z,MERGED,True,1505,11,2,https://github.com/alegz-filomaphitskay,HPACK dynamic table tests in http/2 parser,10,[],https://github.com/tempesta-tech/tempesta/pull/1615,https://github.com/alegz-filomaphitskay,1,https://github.com/tempesta-tech/tempesta/pull/1615,"Contributes to #1297.
What was done here:

added tests for hpack dynamic table;
in do_split_and_parse() HPACK context is saved before running request's parsing and it is restored before using next chunk size.","Contributes to #1297.
What was done here:

added tests for hpack dynamic table;
in do_split_and_parse() HPACK context is saved before running request's parsing and it is restored before using next chunk size.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1616,2022-04-19T10:40:12Z,2022-05-05T20:32:28Z,2022-05-06T16:20:10Z,MERGED,True,333,299,5,https://github.com/alegz-filomaphitskay,Separate hpack parser tests,89,[],https://github.com/tempesta-tech/tempesta/pull/1616,https://github.com/alegz-filomaphitskay,1,https://github.com/tempesta-tech/tempesta/pull/1616,"Contributes to #1297
What was done here:

move hpack_static_table tests to individual file;
loop that used for iterating chunks for TRY_PARSE_EXPECT_PASS/TRY_PARSE_EXPECT_BLOCK was moved inside defines;

after that fuzzer's tests became use chunks for requests. Before that, all  fuzzer's requests were run on the size of the first chunk;


now validate_data_fully_parsed() doesn't use static variable hm_exp_len (it became local);
added FOR_REQ_H2_HPACK/EXPECT_BLOCK_REQ_H2_HPACK that not call test_case_parse_prepare_h2 (this will be needed for dynamic table tests).","Contributes to #1297
What was done here:

move hpack_static_table tests to individual file;
loop that used for iterating chunks for TRY_PARSE_EXPECT_PASS/TRY_PARSE_EXPECT_BLOCK was moved inside defines;

after that fuzzer's tests became use chunks for requests. Before that, all  fuzzer's requests were run on the size of the first chunk;


now validate_data_fully_parsed() doesn't use static variable hm_exp_len (it became local);
added FOR_REQ_H2_HPACK/EXPECT_BLOCK_REQ_H2_HPACK that not call test_case_parse_prepare_h2 (this will be needed for dynamic table tests).",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1618,2022-04-22T12:24:25Z,2022-05-06T17:52:29Z,2022-05-31T19:15:21Z,MERGED,True,520,54,7,https://github.com/avbelov23,Custom HTTP redirects,3,[],https://github.com/tempesta-tech/tempesta/pull/1618,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1618,#856,#856,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1618,2022-04-22T12:24:25Z,2022-05-06T17:52:29Z,2022-05-31T19:15:21Z,MERGED,True,520,54,7,https://github.com/avbelov23,Custom HTTP redirects,3,[],https://github.com/tempesta-tech/tempesta/pull/1618,https://github.com/avbelov23,2,https://github.com/tempesta-tech/tempesta/pull/1618#issuecomment-1106587020,#856,"Perhaps it would be convenient for ease of inserting variable values into placeholders ($host, $request_uri) at the config stage to break the redir url into chunks",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1620,2022-04-28T19:53:40Z,2022-05-06T11:56:03Z,2022-05-06T16:20:33Z,MERGED,True,17,17,8,https://github.com/alegz-filomaphitskay,Use unsigned_int instead of size_t in ss_skb_actor_t,1,[],https://github.com/tempesta-tech/tempesta/pull/1620,https://github.com/alegz-filomaphitskay,1,https://github.com/tempesta-tech/tempesta/pull/1620,"Contributes to #1297.
@krizhanovsky said very well:

len in ss_skb_actor_t() comes from skb_headlen(), which is unsigned int. unsigned int headlen also makes the code more robust.

What was done here:

used unsigned int instead of size_t in ss_skb_actor_t;
also unsigned int is used instead of size_t at major network data processing points.","Contributes to #1297.
@krizhanovsky said very well:

len in ss_skb_actor_t() comes from skb_headlen(), which is unsigned int. unsigned int headlen also makes the code more robust.

What was done here:

used unsigned int instead of size_t in ss_skb_actor_t;
also unsigned int is used instead of size_t at major network data processing points.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1620,2022-04-28T19:53:40Z,2022-05-06T11:56:03Z,2022-05-06T16:20:33Z,MERGED,True,17,17,8,https://github.com/alegz-filomaphitskay,Use unsigned_int instead of size_t in ss_skb_actor_t,1,[],https://github.com/tempesta-tech/tempesta/pull/1620,https://github.com/keshonok,2,https://github.com/tempesta-tech/tempesta/pull/1620#issuecomment-1112611977,"Contributes to #1297.
@krizhanovsky said very well:

len in ss_skb_actor_t() comes from skb_headlen(), which is unsigned int. unsigned int headlen also makes the code more robust.

What was done here:

used unsigned int instead of size_t in ss_skb_actor_t;
also unsigned int is used instead of size_t at major network data processing points.","Frankly, I would have added an explanatory text to the commit message to explain why the change was necessary. Otherwise it would be totally obscure to anyone tracking the changes in the code (including any future contributors).",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1620,2022-04-28T19:53:40Z,2022-05-06T11:56:03Z,2022-05-06T16:20:33Z,MERGED,True,17,17,8,https://github.com/alegz-filomaphitskay,Use unsigned_int instead of size_t in ss_skb_actor_t,1,[],https://github.com/tempesta-tech/tempesta/pull/1620,https://github.com/alegz-filomaphitskay,3,https://github.com/tempesta-tech/tempesta/pull/1620#issuecomment-1112620072,"Contributes to #1297.
@krizhanovsky said very well:

len in ss_skb_actor_t() comes from skb_headlen(), which is unsigned int. unsigned int headlen also makes the code more robust.

What was done here:

used unsigned int instead of size_t in ss_skb_actor_t;
also unsigned int is used instead of size_t at major network data processing points.","Frankly, I would have added an explanatory text to the commit message to explain why the change was necessary. Otherwise it would be totally obscure to anyone tracking the changes in the code (including any future contributors).

Thanks for the advice. But it is just only draft for view files changes.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1621,2022-04-29T18:01:42Z,2022-05-07T13:38:06Z,2022-05-07T13:38:09Z,MERGED,True,76,56,2,https://github.com/alegz-filomaphitskay,Pretty print for H2 requests in log,8,[],https://github.com/tempesta-tech/tempesta/pull/1621,https://github.com/alegz-filomaphitskay,1,https://github.com/tempesta-tech/tempesta/pull/1621,"Contributes to #1297.
What was done here:

added pretty print for H2 requests;
the historical usage of the __FOR_REQ macro is redundant for macros of the FOR_REQ_H2-family. It is more correct to use the __FOR_REQ macro only for HTTP/1 requests;
removed unused FOR_REQ_H2_CHUNK_OFF and EXPECT_BLOCK_REQ_H2_CHUNK_OFF macros;
some cosmetic changes.","Contributes to #1297.
What was done here:

added pretty print for H2 requests;
the historical usage of the __FOR_REQ macro is redundant for macros of the FOR_REQ_H2-family. It is more correct to use the __FOR_REQ macro only for HTTP/1 requests;
removed unused FOR_REQ_H2_CHUNK_OFF and EXPECT_BLOCK_REQ_H2_CHUNK_OFF macros;
some cosmetic changes.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1622,2022-05-02T09:40:41Z,2022-05-07T13:40:17Z,2022-05-07T13:40:20Z,MERGED,True,20,28,3,https://github.com/alegz-filomaphitskay,EXPECT_BLOCK-macro post-checks,1,[],https://github.com/tempesta-tech/tempesta/pull/1622,https://github.com/alegz-filomaphitskay,1,https://github.com/tempesta-tech/tempesta/pull/1622,Thus we can use post-checks inside while-body related to EXPECT_BLOCK-macro for every chunk size but not only for the last.,Thus we can use post-checks inside while-body related to EXPECT_BLOCK-macro for every chunk size but not only for the last.,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1623,2022-05-02T23:15:10Z,2022-05-04T20:00:08Z,2022-05-04T20:00:22Z,MERGED,True,77,78,2,https://github.com/krizhanovsky,Additional fix and the code documentation improvements for #1597,69,[],https://github.com/tempesta-tech/tempesta/pull/1623,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1623,Please see commit messages and code comments for the details,Please see commit messages and code comments for the details,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1625,2022-05-09T14:19:34Z,,2022-05-31T15:25:50Z,OPEN,False,572,114,19,https://github.com/ttaym,Bootstrap websocket connection with http2 CONNECT,1,[],https://github.com/tempesta-tech/tempesta/pull/1625,https://github.com/ttaym,1,https://github.com/tempesta-tech/tempesta/pull/1625,"Contributes to #755
This PR adds CONNECT method and :protocol header field for HTTP/2 parsing.
CONNECT HTTP/2 messages with :protocol equals to websocket transformed to HTTP/1.1 messages for backend with method GET, headers Connection: upgrade and Upgrade: websocket.
Responses from backend with headers Connection: upgrade, Upgrade: websocket and status 101 transformed to :status 200 HTTP/2 responses to client.
When sending 200-success to CONNECT request with websocket :protocol we need not to send END_STREAM frame flag. So to gracefully shutting down stream we need to detect Close websocket control frame or rely on closing tcp connection from backend or closing stream from client.
Note that Sec-WebSocket-Accept stripped from HTTP/1.1 responses and Sec-WebSocket-Key added to HTTP/1.1 request to backend.
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com","Contributes to #755
This PR adds CONNECT method and :protocol header field for HTTP/2 parsing.
CONNECT HTTP/2 messages with :protocol equals to websocket transformed to HTTP/1.1 messages for backend with method GET, headers Connection: upgrade and Upgrade: websocket.
Responses from backend with headers Connection: upgrade, Upgrade: websocket and status 101 transformed to :status 200 HTTP/2 responses to client.
When sending 200-success to CONNECT request with websocket :protocol we need not to send END_STREAM frame flag. So to gracefully shutting down stream we need to detect Close websocket control frame or rely on closing tcp connection from backend or closing stream from client.
Note that Sec-WebSocket-Accept stripped from HTTP/1.1 responses and Sec-WebSocket-Key added to HTTP/1.1 request to backend.
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1625,2022-05-09T14:19:34Z,,2022-05-31T15:25:50Z,OPEN,False,572,114,19,https://github.com/ttaym,Bootstrap websocket connection with http2 CONNECT,1,[],https://github.com/tempesta-tech/tempesta/pull/1625,https://github.com/ttaym,2,https://github.com/tempesta-tech/tempesta/pull/1625#issuecomment-1140925757,"Contributes to #755
This PR adds CONNECT method and :protocol header field for HTTP/2 parsing.
CONNECT HTTP/2 messages with :protocol equals to websocket transformed to HTTP/1.1 messages for backend with method GET, headers Connection: upgrade and Upgrade: websocket.
Responses from backend with headers Connection: upgrade, Upgrade: websocket and status 101 transformed to :status 200 HTTP/2 responses to client.
When sending 200-success to CONNECT request with websocket :protocol we need not to send END_STREAM frame flag. So to gracefully shutting down stream we need to detect Close websocket control frame or rely on closing tcp connection from backend or closing stream from client.
Note that Sec-WebSocket-Accept stripped from HTTP/1.1 responses and Sec-WebSocket-Key added to HTTP/1.1 request to backend.
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com","In response to #1625 (review)
I have applied suggested style amendments.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1625,2022-05-09T14:19:34Z,,2022-05-31T15:25:50Z,OPEN,False,572,114,19,https://github.com/ttaym,Bootstrap websocket connection with http2 CONNECT,1,[],https://github.com/tempesta-tech/tempesta/pull/1625,https://github.com/ttaym,3,https://github.com/tempesta-tech/tempesta/pull/1625#issuecomment-1142176349,"Contributes to #755
This PR adds CONNECT method and :protocol header field for HTTP/2 parsing.
CONNECT HTTP/2 messages with :protocol equals to websocket transformed to HTTP/1.1 messages for backend with method GET, headers Connection: upgrade and Upgrade: websocket.
Responses from backend with headers Connection: upgrade, Upgrade: websocket and status 101 transformed to :status 200 HTTP/2 responses to client.
When sending 200-success to CONNECT request with websocket :protocol we need not to send END_STREAM frame flag. So to gracefully shutting down stream we need to detect Close websocket control frame or rely on closing tcp connection from backend or closing stream from client.
Note that Sec-WebSocket-Accept stripped from HTTP/1.1 responses and Sec-WebSocket-Key added to HTTP/1.1 request to backend.
Signed-off-by: Aleksey Mikhaylov aym@tempesta-tech.com","In response to #1625 (comment)
My idea is that in connection drop requests that linked to stream will be freed.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1627,2022-05-15T23:17:19Z,2022-05-31T14:00:50Z,2022-05-31T14:00:50Z,MERGED,True,3,7,1,https://github.com/s0nx,Fix kernel hang on boot using patched vanilla linux-5.10.35,3,"['bug', 'crucial']",https://github.com/tempesta-tech/tempesta/pull/1627,https://github.com/s0nx,1,https://github.com/tempesta-tech/tempesta/pull/1627,"Fixes #1626


Remove duplicate call to prep_compound_page()","Fixes #1626


Remove duplicate call to prep_compound_page()",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1627,2022-05-15T23:17:19Z,2022-05-31T14:00:50Z,2022-05-31T14:00:50Z,MERGED,True,3,7,1,https://github.com/s0nx,Fix kernel hang on boot using patched vanilla linux-5.10.35,3,"['bug', 'crucial']",https://github.com/tempesta-tech/tempesta/pull/1627,https://github.com/krizhanovsky,2,https://github.com/tempesta-tech/tempesta/pull/1627#issuecomment-1128039145,"Fixes #1626


Remove duplicate call to prep_compound_page()","I didn't review the path yet, but may I ask you to make corresponding pull request for https://github.com/tempesta-tech/linux-5.10.35-tfw",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1627,2022-05-15T23:17:19Z,2022-05-31T14:00:50Z,2022-05-31T14:00:50Z,MERGED,True,3,7,1,https://github.com/s0nx,Fix kernel hang on boot using patched vanilla linux-5.10.35,3,"['bug', 'crucial']",https://github.com/tempesta-tech/tempesta/pull/1627,https://github.com/s0nx,3,https://github.com/tempesta-tech/tempesta/pull/1627#issuecomment-1129035118,"Fixes #1626


Remove duplicate call to prep_compound_page()","I didn't review the path yet, but may I ask you to make corresponding pull request for https://github.com/tempesta-tech/linux-5.10.35-tfw

Done. PR #2",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1628,2022-05-16T21:47:20Z,2022-05-31T20:19:58Z,2022-05-31T20:20:01Z,MERGED,True,602,744,7,https://github.com/avbelov23,Custom HTTP redirects (Unification),2,[],https://github.com/tempesta-tech/tempesta/pull/1628,https://github.com/avbelov23,1,https://github.com/tempesta-tech/tempesta/pull/1628,"#856
Remark:
The body of the js challenge redirect can consist of chunks (tfw_http_sticky_build_redirect()), but tfw_h2_frame_local_resp() is not ready to work with such a body, therefore, to avoid problems, it was temporarily decided to expand such a body into a plain tfw string","#856
Remark:
The body of the js challenge redirect can consist of chunks (tfw_http_sticky_build_redirect()), but tfw_h2_frame_local_resp() is not ready to work with such a body, therefore, to avoid problems, it was temporarily decided to expand such a body into a plain tfw string",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1629,2022-05-17T13:15:10Z,,2022-05-31T12:20:14Z,OPEN,False,1873,19,10,https://github.com/const-t,Forwarded HTTP header #1350,3,[],https://github.com/tempesta-tech/tempesta/pull/1629,https://github.com/const-t,1,https://github.com/tempesta-tech/tempesta/pull/1629,"What has been implemented:

Parsing of ""Forwarded"" header. ""for="" parameter parsed, but
not used now. Only xff continues to be used. Also ""Forwarded""
not modified when forwarding to backend.
Choosing the right host by using keyword ""host"" in HTTPTables.

Highest priority has ""URI"", then ""Host"" and ""Forwarded""


Added tests for validity of parsing and choosing host.","What has been implemented:

Parsing of ""Forwarded"" header. ""for="" parameter parsed, but
not used now. Only xff continues to be used. Also ""Forwarded""
not modified when forwarding to backend.
Choosing the right host by using keyword ""host"" in HTTPTables.

Highest priority has ""URI"", then ""Host"" and ""Forwarded""


Added tests for validity of parsing and choosing host.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1631,2022-05-25T16:07:22Z,2022-05-25T16:14:21Z,2022-05-25T16:14:21Z,MERGED,True,0,14,1,https://github.com/s0nx,"h2 hpack: do not expect request to be dropped if ""scheme:"" == ""http""",1,[],https://github.com/tempesta-tech/tempesta/pull/1631,https://github.com/s0nx,1,https://github.com/tempesta-tech/tempesta/pull/1631,Fixes #1614,Fixes #1614,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1632,2022-05-29T20:03:06Z,2022-06-02T14:58:34Z,2022-06-02T14:58:40Z,MERGED,True,30,35,1,https://github.com/krizhanovsky,Fix minor warning for #1377,1,[],https://github.com/tempesta-tech/tempesta/pull/1632,https://github.com/krizhanovsky,1,https://github.com/tempesta-tech/tempesta/pull/1632,"If a server sends empty header (e.g. add_header X-Crash-1377 ' '; for Nginx), then tfw_hpack_node_compare() may raise WARN_ON_ONCE(state != HPACK_HDR_VALUE_FOUND).
In case of empty header tfw_hpack_add_node() -> tfw_http_hdr_split() strips spaces and ':' so we may fall to the warning statement with matching the header name only, but HPACK_HDR_OWS_PROCESS() didn't move state to HPACK_HDR_NAME_FOUND (beacuse no spaces and no ':').
The patch moves the hdr processing tail out of the loop, so hlen might be non-zero after the main loop and WARN_ON_ONCE(hlen) is also eliminated.","If a server sends empty header (e.g. add_header X-Crash-1377 ' '; for Nginx), then tfw_hpack_node_compare() may raise WARN_ON_ONCE(state != HPACK_HDR_VALUE_FOUND).
In case of empty header tfw_hpack_add_node() -> tfw_http_hdr_split() strips spaces and ':' so we may fall to the warning statement with matching the header name only, but HPACK_HDR_OWS_PROCESS() didn't move state to HPACK_HDR_NAME_FOUND (beacuse no spaces and no ':').
The patch moves the hdr processing tail out of the loop, so hlen might be non-zero after the main loop and WARN_ON_ONCE(hlen) is also eliminated.",True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1632,2022-05-29T20:03:06Z,2022-06-02T14:58:34Z,2022-06-02T14:58:40Z,MERGED,True,30,35,1,https://github.com/krizhanovsky,Fix minor warning for #1377,1,[],https://github.com/tempesta-tech/tempesta/pull/1632,https://github.com/HDR,2,https://github.com/tempesta-tech/tempesta/pull/1632#issuecomment-1140644087,"If a server sends empty header (e.g. add_header X-Crash-1377 ' '; for Nginx), then tfw_hpack_node_compare() may raise WARN_ON_ONCE(state != HPACK_HDR_VALUE_FOUND).
In case of empty header tfw_hpack_add_node() -> tfw_http_hdr_split() strips spaces and ':' so we may fall to the warning statement with matching the header name only, but HPACK_HDR_OWS_PROCESS() didn't move state to HPACK_HDR_NAME_FOUND (beacuse no spaces and no ':').
The patch moves the hdr processing tail out of the loop, so hlen might be non-zero after the main loop and WARN_ON_ONCE(hlen) is also eliminated.",Going to assume the mention was unintentional 😄,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1632,2022-05-29T20:03:06Z,2022-06-02T14:58:34Z,2022-06-02T14:58:40Z,MERGED,True,30,35,1,https://github.com/krizhanovsky,Fix minor warning for #1377,1,[],https://github.com/tempesta-tech/tempesta/pull/1632,https://github.com/krizhanovsky,3,https://github.com/tempesta-tech/tempesta/pull/1632#issuecomment-1140960874,"If a server sends empty header (e.g. add_header X-Crash-1377 ' '; for Nginx), then tfw_hpack_node_compare() may raise WARN_ON_ONCE(state != HPACK_HDR_VALUE_FOUND).
In case of empty header tfw_hpack_add_node() -> tfw_http_hdr_split() strips spaces and ':' so we may fall to the warning statement with matching the header name only, but HPACK_HDR_OWS_PROCESS() didn't move state to HPACK_HDR_NAME_FOUND (beacuse no spaces and no ':').
The patch moves the hdr processing tail out of the loop, so hlen might be non-zero after the main loop and WARN_ON_ONCE(hlen) is also eliminated.","Going to assume the mention was unintentional smile

@HDR, Yes, sorry - just copy & pasted comment with doxygen's @.",True,{'HEART': ['https://github.com/HDR']}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1634,2022-05-31T15:33:04Z,2022-05-31T16:19:44Z,2022-05-31T16:19:47Z,MERGED,True,35,0,1,https://github.com/pale-emperor,Jenkinsfile added,4,[],https://github.com/tempesta-tech/tempesta/pull/1634,https://github.com/pale-emperor,1,https://github.com/tempesta-tech/tempesta/pull/1634,,,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1635,2022-06-03T09:27:17Z,,2022-06-03T14:10:01Z,OPEN,False,28,0,3,https://github.com/s0nx,WIP: HPACK dyn tables do not update special fields in request,1,[],https://github.com/tempesta-tech/tempesta/pull/1635,https://github.com/s0nx,1,https://github.com/tempesta-tech/tempesta/pull/1635,Signed-off-by: Petr Vyazovik xen@f-m.fm,Signed-off-by: Petr Vyazovik xen@f-m.fm,True,{}
tempesta-tech/tempesta,https://github.com/tempesta-tech/tempesta,1635,2022-06-03T09:27:17Z,,2022-06-03T14:10:01Z,OPEN,False,28,0,3,https://github.com/s0nx,WIP: HPACK dyn tables do not update special fields in request,1,[],https://github.com/tempesta-tech/tempesta/pull/1635,https://github.com/s0nx,2,https://github.com/tempesta-tech/tempesta/pull/1635#issuecomment-1145777500,Signed-off-by: Petr Vyazovik xen@f-m.fm,Fix to the issues mentioned in #1617,True,{}
