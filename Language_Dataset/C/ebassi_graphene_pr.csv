ebassi/graphene,https://github.com/ebassi/graphene,53,2016-02-10T09:27:13Z,2016-02-10T09:30:41Z,2016-02-10T10:21:52Z,MERGED,True,2,2,1,None,docs: improve doc of graphene_sphere_translate(),1,[],https://github.com/ebassi/graphene/pull/53,None,1,https://github.com/ebassi/graphene/pull/53,"I know what is a translation, but it was not clear to me whether @point
referred to the new center coordinates, or the delta. It turns out that
it's the delta, as expected for a translation, but it's better to
explain it in the docs.","I know what is a translation, but it was not clear to me whether @point
referred to the new center coordinates, or the delta. It turns out that
it's the delta, as expected for a translation, but it's better to
explain it in the docs.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,53,2016-02-10T09:27:13Z,2016-02-10T09:30:41Z,2016-02-10T10:21:52Z,MERGED,True,2,2,1,None,docs: improve doc of graphene_sphere_translate(),1,[],https://github.com/ebassi/graphene/pull/53,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/53#issuecomment-182276057,"I know what is a translation, but it was not clear to me whether @point
referred to the new center coordinates, or the delta. It turns out that
it's the delta, as expected for a translation, but it's better to
explain it in the docs.","Looks good, thanks!",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,57,2016-03-30T21:55:16Z,2016-03-31T07:34:57Z,2016-03-31T07:35:01Z,MERGED,True,8,10,1,https://github.com/cubicool,Fix compile warnings when debug is disabled,1,[],https://github.com/ebassi/graphene/pull/57,https://github.com/cubicool,1,https://github.com/ebassi/graphene/pull/57,"Initialize the 'res' pointer to NULL.
Borrow the 'errno' variable rather than using an 'err' variable local
to graphene_aligned_alloc. There is some precedent for this, as the
existing code also set 'errno = 0' before calling the corresponding
alloc routine.","Initialize the 'res' pointer to NULL.
Borrow the 'errno' variable rather than using an 'err' variable local
to graphene_aligned_alloc. There is some precedent for this, as the
existing code also set 'errno = 0' before calling the corresponding
alloc routine.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,57,2016-03-30T21:55:16Z,2016-03-31T07:34:57Z,2016-03-31T07:35:01Z,MERGED,True,8,10,1,https://github.com/cubicool,Fix compile warnings when debug is disabled,1,[],https://github.com/ebassi/graphene/pull/57,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/57#issuecomment-203798248,"Initialize the 'res' pointer to NULL.
Borrow the 'errno' variable rather than using an 'err' variable local
to graphene_aligned_alloc. There is some precedent for this, as the
existing code also set 'errno = 0' before calling the corresponding
alloc routine.",Looks like a worthy simplification as well. Thanks!,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,58,2016-04-08T04:21:03Z,2016-04-08T12:04:12Z,2016-04-08T12:04:22Z,MERGED,True,1,2,1,https://github.com/fanc999,graphene-simd4x4f.h: Fix x86 Builds on MSVC 2013 and Later,1,[],https://github.com/ebassi/graphene/pull/58,https://github.com/fanc999,1,https://github.com/ebassi/graphene/pull/58,"Hi,
(Sorry, I forgot to post about this, which was an issue for a while...)
The current placement of GRAPHENE_VECTORCALL, which is expanded to __vectorcall on Visual Studio 2013 and later (for 32-bit builds) is actually breaking the build there.  That needs to be done after the return type.
With blessings, thank you!","Hi,
(Sorry, I forgot to post about this, which was an issue for a while...)
The current placement of GRAPHENE_VECTORCALL, which is expanded to __vectorcall on Visual Studio 2013 and later (for 32-bit builds) is actually breaking the build there.  That needs to be done after the return type.
With blessings, thank you!",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,58,2016-04-08T04:21:03Z,2016-04-08T12:04:12Z,2016-04-08T12:04:22Z,MERGED,True,1,2,1,https://github.com/fanc999,graphene-simd4x4f.h: Fix x86 Builds on MSVC 2013 and Later,1,[],https://github.com/ebassi/graphene/pull/58,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/58#issuecomment-207401063,"Hi,
(Sorry, I forgot to post about this, which was an issue for a while...)
The current placement of GRAPHENE_VECTORCALL, which is expanded to __vectorcall on Visual Studio 2013 and later (for 32-bit builds) is actually breaking the build there.  That needs to be done after the return type.
With blessings, thank you!","Cool, thanks for the patch!",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,60,2016-04-14T08:23:21Z,2016-04-21T09:01:52Z,2016-04-21T09:01:52Z,CLOSED,False,135,39,2,https://github.com/fanc999,Enable SSE codepath on older 32-bit compilers,1,[],https://github.com/ebassi/graphene/pull/60,https://github.com/fanc999,1,https://github.com/ebassi/graphene/pull/60,"Hi,
I understand that this may be a rather controversial pull request here.
For doing graphene_simd4x4f_init() on SSE codepaths, we are passing in 4 __m128's, which is fine on x64 builds as well as newer 32-bit compilers that have special considerations to allow such usage in the ABI, but will fail to build on older 32-bit compilers as a limit of passing 3 __m128's by value is imposed.  This is the case for pre-2012 Visual Studio builds, and possibly older GCC releases, which I unfortunately am not that well acquainted with.
In order to keep ABI disruption to the minimum, we use a check macro to enable such codepaths on 32-bit compilers, and use another macro to get the address of the __m128's if necessary.
I am, by the way, currently only able to deduce the conditions of activating the check macro on Visual Studio builds, not the GCC builds, which I think I might need pointers on, which is not in this PR as of yet.
With blessings, thank you!","Hi,
I understand that this may be a rather controversial pull request here.
For doing graphene_simd4x4f_init() on SSE codepaths, we are passing in 4 __m128's, which is fine on x64 builds as well as newer 32-bit compilers that have special considerations to allow such usage in the ABI, but will fail to build on older 32-bit compilers as a limit of passing 3 __m128's by value is imposed.  This is the case for pre-2012 Visual Studio builds, and possibly older GCC releases, which I unfortunately am not that well acquainted with.
In order to keep ABI disruption to the minimum, we use a check macro to enable such codepaths on 32-bit compilers, and use another macro to get the address of the __m128's if necessary.
I am, by the way, currently only able to deduce the conditions of activating the check macro on Visual Studio builds, not the GCC builds, which I think I might need pointers on, which is not in this PR as of yet.
With blessings, thank you!",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,60,2016-04-14T08:23:21Z,2016-04-21T09:01:52Z,2016-04-21T09:01:52Z,CLOSED,False,135,39,2,https://github.com/fanc999,Enable SSE codepath on older 32-bit compilers,1,[],https://github.com/ebassi/graphene/pull/60,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/60#issuecomment-212428812,"Hi,
I understand that this may be a rather controversial pull request here.
For doing graphene_simd4x4f_init() on SSE codepaths, we are passing in 4 __m128's, which is fine on x64 builds as well as newer 32-bit compilers that have special considerations to allow such usage in the ABI, but will fail to build on older 32-bit compilers as a limit of passing 3 __m128's by value is imposed.  This is the case for pre-2012 Visual Studio builds, and possibly older GCC releases, which I unfortunately am not that well acquainted with.
In order to keep ABI disruption to the minimum, we use a check macro to enable such codepaths on 32-bit compilers, and use another macro to get the address of the __m128's if necessary.
I am, by the way, currently only able to deduce the conditions of activating the check macro on Visual Studio builds, not the GCC builds, which I think I might need pointers on, which is not in this PR as of yet.
With blessings, thank you!","I'm not really fond of this, especially because I'm not entirely sure I want to support pre-2012 MSVC compilers on 32 bit architectures, if it comes at the expense of maintainability, and at the cost of breaking the API. I guess it's too late, now.
To be fair, I'm perfectly comfortable with the idea of requiring MSVC 2015 or newer on 64 and 32 bit platforms.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,60,2016-04-14T08:23:21Z,2016-04-21T09:01:52Z,2016-04-21T09:01:52Z,CLOSED,False,135,39,2,https://github.com/fanc999,Enable SSE codepath on older 32-bit compilers,1,[],https://github.com/ebassi/graphene/pull/60,https://github.com/fanc999,3,https://github.com/ebassi/graphene/pull/60#issuecomment-212820971,"Hi,
I understand that this may be a rather controversial pull request here.
For doing graphene_simd4x4f_init() on SSE codepaths, we are passing in 4 __m128's, which is fine on x64 builds as well as newer 32-bit compilers that have special considerations to allow such usage in the ABI, but will fail to build on older 32-bit compilers as a limit of passing 3 __m128's by value is imposed.  This is the case for pre-2012 Visual Studio builds, and possibly older GCC releases, which I unfortunately am not that well acquainted with.
In order to keep ABI disruption to the minimum, we use a check macro to enable such codepaths on 32-bit compilers, and use another macro to get the address of the __m128's if necessary.
I am, by the way, currently only able to deduce the conditions of activating the check macro on Visual Studio builds, not the GCC builds, which I think I might need pointers on, which is not in this PR as of yet.
With blessings, thank you!","Hi Emmanuele,
I see.  Thanks though.
With blessings.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,64,2016-06-10T22:24:45Z,2016-09-26T09:51:28Z,2016-09-26T09:55:05Z,CLOSED,False,40,10,3,https://github.com/zdydek,Fixing build errors on ARM NEON.,1,[],https://github.com/ebassi/graphene/pull/64,https://github.com/zdydek,1,https://github.com/ebassi/graphene/pull/64,"I was trying to build this for an ARM platform, but ran into some problems.  Not sure if my changes are the best way to resolve them, but the code does compile now.","I was trying to build this for an ARM platform, but ran into some problems.  Not sure if my changes are the best way to resolve them, but the code does compile now.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,64,2016-06-10T22:24:45Z,2016-09-26T09:51:28Z,2016-09-26T09:55:05Z,CLOSED,False,40,10,3,https://github.com/zdydek,Fixing build errors on ARM NEON.,1,[],https://github.com/ebassi/graphene/pull/64,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/64#issuecomment-226186413,"I was trying to build this for an ARM platform, but ran into some problems.  Not sure if my changes are the best way to resolve them, but the code does compile now.","Thanks! I'm setting up an ARM device to test out the changes (and maybe have some sort of automated regression testing), but in principle they look good to meâ€¦",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,64,2016-06-10T22:24:45Z,2016-09-26T09:51:28Z,2016-09-26T09:55:05Z,CLOSED,False,40,10,3,https://github.com/zdydek,Fixing build errors on ARM NEON.,1,[],https://github.com/ebassi/graphene/pull/64,https://github.com/james-huang,3,https://github.com/ebassi/graphene/pull/64#issuecomment-230069649,"I was trying to build this for an ARM platform, but ran into some problems.  Not sure if my changes are the best way to resolve them, but the code does compile now.","hi guys, I've independently some across several of the same issues trying to build graphene on an imx6.
commit
although instead of vreinterpretq_u8_u32 i went with vcgeq_u8.
is vreinterpretq_u8_u32 android specific?
ARM Compiler toolchain Compiler Reference
basically I found a couple issues:

data structure mismatches
variable misdefinitions
error: argument must be a constant against vgetq_lane_f32, which meant manual loop unrolling and also removing some redefinition for me.  This was just something I did to get a build out the door, no idea how dropping the function definition would affect other platforms.

I can chop up the commits if you guys want to incorporate some of the safer fixes for 1 and 2.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,64,2016-06-10T22:24:45Z,2016-09-26T09:51:28Z,2016-09-26T09:55:05Z,CLOSED,False,40,10,3,https://github.com/zdydek,Fixing build errors on ARM NEON.,1,[],https://github.com/ebassi/graphene/pull/64,https://github.com/ebassi,4,https://github.com/ebassi/graphene/pull/64#issuecomment-249527052,"I was trying to build this for an ARM platform, but ran into some problems.  Not sure if my changes are the best way to resolve them, but the code does compile now.",I guess we can close this.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,64,2016-06-10T22:24:45Z,2016-09-26T09:51:28Z,2016-09-26T09:55:05Z,CLOSED,False,40,10,3,https://github.com/zdydek,Fixing build errors on ARM NEON.,1,[],https://github.com/ebassi/graphene/pull/64,https://github.com/ebassi,5,https://github.com/ebassi/graphene/pull/64#issuecomment-249527780,"I was trying to build this for an ARM platform, but ran into some problems.  Not sure if my changes are the best way to resolve them, but the code does compile now.","@james-huang I've commented on #65. Looking for vreinterpretq_u8_u32, I seem to find it in various toolchains for the NEON set in the arm-eabi, so I'm not sure it's Android specific.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,65,2016-07-02T00:04:18Z,2017-01-04T13:58:25Z,2017-01-04T13:58:25Z,CLOSED,False,10,10,2,https://github.com/james-huang,Fixing build errors on ARM NEON pt2.,4,[],https://github.com/ebassi/graphene/pull/65,https://github.com/james-huang,1,https://github.com/ebassi/graphene/pull/65,Similar to #64.,Similar to #64.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,65,2016-07-02T00:04:18Z,2017-01-04T13:58:25Z,2017-01-04T13:58:25Z,CLOSED,False,10,10,2,https://github.com/james-huang,Fixing build errors on ARM NEON pt2.,4,[],https://github.com/ebassi/graphene/pull/65,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/65#issuecomment-249527316,Similar to #64.,"Hi; thanks for your PR.
Would it be possible to rebase your branch now that #71 and #72 were merged?",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,65,2016-07-02T00:04:18Z,2017-01-04T13:58:25Z,2017-01-04T13:58:25Z,CLOSED,False,10,10,2,https://github.com/james-huang,Fixing build errors on ARM NEON pt2.,4,[],https://github.com/ebassi/graphene/pull/65,https://github.com/ebassi,3,https://github.com/ebassi/graphene/pull/65#issuecomment-270376179,Similar to #64.,"I've merged the whitespace commit; everything else was already fixed by PR #64.
Thanks again for your patches!",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,68,2016-08-16T10:30:31Z,2016-08-16T14:19:05Z,2016-08-16T14:19:05Z,MERGED,True,49,4,3,https://github.com/matthiasclasen,A test showing breakage,5,[],https://github.com/ebassi/graphene/pull/68,https://github.com/matthiasclasen,1,https://github.com/ebassi/graphene/pull/68,,,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,69,2016-09-01T04:05:19Z,2016-09-01T12:13:59Z,2016-09-01T12:14:07Z,MERGED,True,1,1,1,https://github.com/ford-prefect,simd4f: Fix a compilation error,1,[],https://github.com/ebassi/graphene/pull/69,https://github.com/ford-prefect,1,https://github.com/ebassi/graphene/pull/69,Not sure why the missing semicolon didn't get caught before.,Not sure why the missing semicolon didn't get caught before.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,69,2016-09-01T04:05:19Z,2016-09-01T12:13:59Z,2016-09-01T12:14:07Z,MERGED,True,1,1,1,https://github.com/ford-prefect,simd4f: Fix a compilation error,1,[],https://github.com/ebassi/graphene/pull/69,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/69#issuecomment-244039487,Not sure why the missing semicolon didn't get caught before.,"Thanks for the patch! It looks good, but would it be possible to update the commit message to list:

the compiler and version that generated the warning
the actual warning

?
I haven't had any warning on my GCC 6.1.1 and Travis didn't find any issue with GCC 4.8 and Clang 3.4, but I don't doubt that there may be combinations that trip the issue. It would be nice to document those.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,69,2016-09-01T04:05:19Z,2016-09-01T12:13:59Z,2016-09-01T12:14:07Z,MERGED,True,1,1,1,https://github.com/ford-prefect,simd4f: Fix a compilation error,1,[],https://github.com/ebassi/graphene/pull/69,https://github.com/ford-prefect,3,https://github.com/ebassi/graphene/pull/69#issuecomment-244052917,Not sure why the missing semicolon didn't get caught before.,Done now. This was an ARM64 build for Android.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,69,2016-09-01T04:05:19Z,2016-09-01T12:13:59Z,2016-09-01T12:14:07Z,MERGED,True,1,1,1,https://github.com/ford-prefect,simd4f: Fix a compilation error,1,[],https://github.com/ebassi/graphene/pull/69,https://github.com/ebassi,4,https://github.com/ebassi/graphene/pull/69#issuecomment-244060373,Not sure why the missing semicolon didn't get caught before.,"Awesome, thanks!",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,70,2016-09-20T23:57:24Z,2016-09-21T09:57:20Z,2016-09-21T09:57:20Z,MERGED,True,20,14,2,https://github.com/thiblahute,Fix building graphene as a meson submodule,3,[],https://github.com/ebassi/graphene/pull/70,https://github.com/thiblahute,1,https://github.com/ebassi/graphene/pull/70,"Fixes building graphene as a meson submodule
Proposed changes:

meson: Fix library version and soversion
meson: Do not use add_global_arguments but instead pass the args ourself","Fixes building graphene as a meson submodule
Proposed changes:

meson: Fix library version and soversion
meson: Do not use add_global_arguments but instead pass the args ourself",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,70,2016-09-20T23:57:24Z,2016-09-21T09:57:20Z,2016-09-21T09:57:20Z,MERGED,True,20,14,2,https://github.com/thiblahute,Fix building graphene as a meson submodule,3,[],https://github.com/ebassi/graphene/pull/70,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/70#issuecomment-248565553,"Fixes building graphene as a meson submodule
Proposed changes:

meson: Fix library version and soversion
meson: Do not use add_global_arguments but instead pass the args ourself",Looks good.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,71,2016-09-26T01:34:12Z,2016-09-26T09:49:32Z,2016-09-26T09:49:32Z,MERGED,True,8,8,1,https://github.com/fheger,Fixing build errors on ARM NEON.,1,[],https://github.com/ebassi/graphene/pull/71,https://github.com/fheger,1,https://github.com/ebassi/graphene/pull/71,Part 1 of splitting PR #64 into two separate PRs.,Part 1 of splitting PR #64 into two separate PRs.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,72,2016-09-26T01:35:05Z,2016-09-26T09:50:35Z,2016-09-26T09:50:35Z,MERGED,True,36,2,2,https://github.com/fheger,Fixing build errors on ARM NEON.,1,[],https://github.com/ebassi/graphene/pull/72,https://github.com/fheger,1,https://github.com/ebassi/graphene/pull/72,"Part 2 of splitting PR #64 into two separate PRs.
The underlying ARM fast type that graphene_simd4f_get calls into requires
its inputs to be compile time constants. Passing the ""col"" argument in was
causing the build to fail.","Part 2 of splitting PR #64 into two separate PRs.
The underlying ARM fast type that graphene_simd4f_get calls into requires
its inputs to be compile time constants. Passing the ""col"" argument in was
causing the build to fail.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,73,2016-10-20T09:10:50Z,2016-11-08T10:28:14Z,2016-11-08T10:28:14Z,MERGED,True,87,34,3,https://github.com/fanc999,build: Allow proper build with Visual Studio out-of-the-box,1,[],https://github.com/ebassi/graphene/pull/73,https://github.com/fanc999,1,https://github.com/ebassi/graphene/pull/73,"Hi,
This attempts to add proper support out-of-the box for building Graphene using Visual Studio, so that we can make use of it with Visual Studio builds of the upcoming GTK+-4.x (for GSK), as most of the code is ready for building and usage under Visual Studio 2008+ (!), but a build system that would support the MSVC toolchain is not yet in place.
As a result, updates are needed for the meson build files to support the toolchain properly, and a few minor changes are needed for the code so that things will work in the Visual Studio versions that we support for GTK+ (the code changes I will post later).  Note that on 32-bit builds, Visual Studio 2013 or later is required to enable SSE2 support due to x86/32-bit ABI limitations.
With blessings, thank you!","Hi,
This attempts to add proper support out-of-the box for building Graphene using Visual Studio, so that we can make use of it with Visual Studio builds of the upcoming GTK+-4.x (for GSK), as most of the code is ready for building and usage under Visual Studio 2008+ (!), but a build system that would support the MSVC toolchain is not yet in place.
As a result, updates are needed for the meson build files to support the toolchain properly, and a few minor changes are needed for the code so that things will work in the Visual Studio versions that we support for GTK+ (the code changes I will post later).  Note that on 32-bit builds, Visual Studio 2013 or later is required to enable SSE2 support due to x86/32-bit ABI limitations.
With blessings, thank you!",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,73,2016-10-20T09:10:50Z,2016-11-08T10:28:14Z,2016-11-08T10:28:14Z,MERGED,True,87,34,3,https://github.com/fanc999,build: Allow proper build with Visual Studio out-of-the-box,1,[],https://github.com/ebassi/graphene/pull/73,https://github.com/fanc999,2,https://github.com/ebassi/graphene/pull/73#issuecomment-256870983,"Hi,
This attempts to add proper support out-of-the box for building Graphene using Visual Studio, so that we can make use of it with Visual Studio builds of the upcoming GTK+-4.x (for GSK), as most of the code is ready for building and usage under Visual Studio 2008+ (!), but a build system that would support the MSVC toolchain is not yet in place.
As a result, updates are needed for the meson build files to support the toolchain properly, and a few minor changes are needed for the code so that things will work in the Visual Studio versions that we support for GTK+ (the code changes I will post later).  Note that on 32-bit builds, Visual Studio 2013 or later is required to enable SSE2 support due to x86/32-bit ABI limitations.
With blessings, thank you!","Hi,
Updated the files to go back to using pkg-config for all builds, plus some small changes for pre-2015 Visual Studio.
With blessings, thank you!",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,77,2016-11-21T23:38:17Z,2016-11-22T00:04:09Z,2016-11-22T01:23:53Z,MERGED,True,13,23,4,https://github.com/ignatenkobrain,build: use join_paths(),1,[],https://github.com/ebassi/graphene/pull/77,https://github.com/ignatenkobrain,1,https://github.com/ebassi/graphene/pull/77,,,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,77,2016-11-21T23:38:17Z,2016-11-22T00:04:09Z,2016-11-22T01:23:53Z,MERGED,True,13,23,4,https://github.com/ignatenkobrain,build: use join_paths(),1,[],https://github.com/ebassi/graphene/pull/77,https://github.com/ignatenkobrain,2,https://github.com/ebassi/graphene/pull/77#issuecomment-262105061,,@ebassi Fixed!,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,77,2016-11-21T23:38:17Z,2016-11-22T00:04:09Z,2016-11-22T01:23:53Z,MERGED,True,13,23,4,https://github.com/ignatenkobrain,build: use join_paths(),1,[],https://github.com/ebassi/graphene/pull/77,https://github.com/ignatenkobrain,3,https://github.com/ebassi/graphene/pull/77#issuecomment-262105690,,"@ebassi I also fixed libdir abspath, because pkgconfig had relative.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,77,2016-11-21T23:38:17Z,2016-11-22T00:04:09Z,2016-11-22T01:23:53Z,MERGED,True,13,23,4,https://github.com/ignatenkobrain,build: use join_paths(),1,[],https://github.com/ebassi/graphene/pull/77,https://github.com/ignatenkobrain,4,https://github.com/ebassi/graphene/pull/77#issuecomment-262107130,,"argh, fixed 3 errors from review",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,78,2016-11-22T01:46:32Z,2016-11-22T14:07:46Z,2016-11-22T14:07:47Z,CLOSED,False,1,1,1,https://github.com/ignatenkobrain,build: install tests into libexecdir,1,[],https://github.com/ebassi/graphene/pull/78,https://github.com/ignatenkobrain,1,https://github.com/ebassi/graphene/pull/78,"Tests are ELF files, so in case of multilib they will conflict. Using libexecdir will tell that this package is not multilib.
@ebassi though I'm not sure if we should use $libdir instead of $libexecdir.","Tests are ELF files, so in case of multilib they will conflict. Using libexecdir will tell that this package is not multilib.
@ebassi though I'm not sure if we should use $libdir instead of $libexecdir.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,78,2016-11-22T01:46:32Z,2016-11-22T14:07:46Z,2016-11-22T14:07:47Z,CLOSED,False,1,1,1,https://github.com/ignatenkobrain,build: install tests into libexecdir,1,[],https://github.com/ebassi/graphene/pull/78,https://github.com/ignatenkobrain,2,https://github.com/ebassi/graphene/pull/78#issuecomment-262124330,"Tests are ELF files, so in case of multilib they will conflict. Using libexecdir will tell that this package is not multilib.
@ebassi though I'm not sure if we should use $libdir instead of $libexecdir.","eog, glib2, gjs are installing elfs into libexecdir",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,78,2016-11-22T01:46:32Z,2016-11-22T14:07:46Z,2016-11-22T14:07:47Z,CLOSED,False,1,1,1,https://github.com/ignatenkobrain,build: install tests into libexecdir,1,[],https://github.com/ebassi/graphene/pull/78,https://github.com/ebassi,3,https://github.com/ebassi/graphene/pull/78#issuecomment-262249200,"Tests are ELF files, so in case of multilib they will conflict. Using libexecdir will tell that this package is not multilib.
@ebassi though I'm not sure if we should use $libdir instead of $libexecdir.","I've merged manually, and fixed @TingPing's comment as well.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,79,2016-11-22T06:23:53Z,2016-11-22T13:43:43Z,2016-11-22T13:43:44Z,MERGED,True,21,0,5,https://github.com/fanc999,Fix build of 1.5.1 on Visual Studio,2,[],https://github.com/ebassi/graphene/pull/79,https://github.com/fanc999,1,https://github.com/ebassi/graphene/pull/79,"Hi,
We have started to use C99-style struct initializers, which is support by Visual Studio 2013/2015, with one exception, that is, using them in initializing static variables and global constants, which will cause C2099 to be raised (initializer not a constant).  This might also affect other compilers as well.
Also, we need to update config.h.meson to define inline as __inline for pre-2013 Visual Studio as well, in addition to graphene-config.h.meson.  I am not sure whether meson has a mechanism for detecting the 'inline' definition for the compiler, so this is what I have for now.
With bessings, thank you!","Hi,
We have started to use C99-style struct initializers, which is support by Visual Studio 2013/2015, with one exception, that is, using them in initializing static variables and global constants, which will cause C2099 to be raised (initializer not a constant).  This might also affect other compilers as well.
Also, we need to update config.h.meson to define inline as __inline for pre-2013 Visual Studio as well, in addition to graphene-config.h.meson.  I am not sure whether meson has a mechanism for detecting the 'inline' definition for the compiler, so this is what I have for now.
With bessings, thank you!",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,81,2016-11-22T15:23:03Z,2016-11-22T15:31:50Z,2016-11-22T15:31:50Z,MERGED,True,4,3,1,https://github.com/TingPing,build: Fix gtk-doc references to glib,1,[],https://github.com/ebassi/graphene/pull/81,https://github.com/TingPing,1,https://github.com/ebassi/graphene/pull/81,,,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,84,2016-12-02T21:26:23Z,2016-12-05T10:01:51Z,2016-12-05T15:08:41Z,MERGED,True,13,7,4,https://github.com/nirbheek,meson: Detect and use _aligned_malloc on MinGW,2,[],https://github.com/ebassi/graphene/pull/84,https://github.com/nirbheek,1,https://github.com/ebassi/graphene/pull/84,"Fixes #83
MinGW also uses _aligned_malloc(), not just MSVC. Without this, we were just returning uninitialized memory since no other aligned allocator was available.
Also, use G_GINT64_FORMAT for printing gint64 otherwise we get a segfault while printing.","Fixes #83
MinGW also uses _aligned_malloc(), not just MSVC. Without this, we were just returning uninitialized memory since no other aligned allocator was available.
Also, use G_GINT64_FORMAT for printing gint64 otherwise we get a segfault while printing.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,84,2016-12-02T21:26:23Z,2016-12-05T10:01:51Z,2016-12-05T15:08:41Z,MERGED,True,13,7,4,https://github.com/nirbheek,meson: Detect and use _aligned_malloc on MinGW,2,[],https://github.com/ebassi/graphene/pull/84,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/84#issuecomment-264812907,"Fixes #83
MinGW also uses _aligned_malloc(), not just MSVC. Without this, we were just returning uninitialized memory since no other aligned allocator was available.
Also, use G_GINT64_FORMAT for printing gint64 otherwise we get a segfault while printing.","Looks good, thanks.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,86,2016-12-05T15:00:43Z,2016-12-05T17:39:49Z,2016-12-05T18:01:55Z,MERGED,True,11,6,3,https://github.com/nirbheek,Use malloc.h for _aligned_malloc instead of stdlib.h,2,[],https://github.com/ebassi/graphene/pull/86,https://github.com/nirbheek,1,https://github.com/ebassi/graphene/pull/86,"Fixes #84 (comment)
Both stdlib.h and malloc.h define it on MinGW but it's only defined by malloc.h on MSVC, so just use malloc.h.
There are more issues needed for MSVC support, but this should help.","Fixes #84 (comment)
Both stdlib.h and malloc.h define it on MinGW but it's only defined by malloc.h on MSVC, so just use malloc.h.
There are more issues needed for MSVC support, but this should help.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,86,2016-12-05T15:00:43Z,2016-12-05T17:39:49Z,2016-12-05T18:01:55Z,MERGED,True,11,6,3,https://github.com/nirbheek,Use malloc.h for _aligned_malloc instead of stdlib.h,2,[],https://github.com/ebassi/graphene/pull/86,https://github.com/achadwick,2,https://github.com/ebassi/graphene/pull/86#issuecomment-264880290,"Fixes #84 (comment)
Both stdlib.h and malloc.h define it on MinGW but it's only defined by malloc.h on MSVC, so just use malloc.h.
There are more issues needed for MSVC support, but this should help.","Conflicts with #87, which also makes graphene use _aligned_malloc. You cannot assume aligned_alloc() exists if _aligned_malloc is defined.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,86,2016-12-05T15:00:43Z,2016-12-05T17:39:49Z,2016-12-05T18:01:55Z,MERGED,True,11,6,3,https://github.com/nirbheek,Use malloc.h for _aligned_malloc instead of stdlib.h,2,[],https://github.com/ebassi/graphene/pull/86,https://github.com/nirbheek,3,https://github.com/ebassi/graphene/pull/86#issuecomment-264881557,"Fixes #84 (comment)
Both stdlib.h and malloc.h define it on MinGW but it's only defined by malloc.h on MSVC, so just use malloc.h.
There are more issues needed for MSVC support, but this should help.","Conflicts with #87, which also makes graphene use _aligned_malloc. You cannot assume aligned_alloc() exists if _aligned_malloc is defined.

I'm confused, did you miss this piece of code in bench/matrix.c?
#ifdef HAVE__ALIGNED_MALLOC
/* On Window, we have to use _aligned_malloc() which takes in parameters in
 * inverted order from aligned_alloc(), but things are more or less the same
 * there otherwise
 */
#define aligned_alloc(alignment,size) _aligned_malloc (size, alignment)

/* if we _aligned_malloc()'ed, then we must do _align_free() on MSVC */
#define free_aligned(x) _aligned_free (x)
#else
#define free_aligned(x) free (x)
#endif

Graphene defines aligned_alloc() as a macro that switches the arguments and calls _aligned_malloc() if the latter is being used.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,86,2016-12-05T15:00:43Z,2016-12-05T17:39:49Z,2016-12-05T18:01:55Z,MERGED,True,11,6,3,https://github.com/nirbheek,Use malloc.h for _aligned_malloc instead of stdlib.h,2,[],https://github.com/ebassi/graphene/pull/86,https://github.com/achadwick,4,https://github.com/ebassi/graphene/pull/86#issuecomment-264884059,"Fixes #84 (comment)
Both stdlib.h and malloc.h define it on MinGW but it's only defined by malloc.h on MSVC, so just use malloc.h.
There are more issues needed for MSVC support, but this should help.","Yes I did, it wasn't there on master. The test in graphene-alloc.c will need to be changed too. Ah, you just added that. nvm.
It looks like your PR is more complete, but the order of the #ifdefs will still need to be changed because posix_memalign is still incorrectly detected.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,86,2016-12-05T15:00:43Z,2016-12-05T17:39:49Z,2016-12-05T18:01:55Z,MERGED,True,11,6,3,https://github.com/nirbheek,Use malloc.h for _aligned_malloc instead of stdlib.h,2,[],https://github.com/ebassi/graphene/pull/86,https://github.com/nirbheek,5,https://github.com/ebassi/graphene/pull/86#issuecomment-264900534,"Fixes #84 (comment)
Both stdlib.h and malloc.h define it on MinGW but it's only defined by malloc.h on MSVC, so just use malloc.h.
There are more issues needed for MSVC support, but this should help.","I don't think the order of the ifdefs is what the issue is. I think the configure/meson checks should only select and define one aligned memory allocator. Right now it tests for all of them and defines everything it finds.
At the same time, the posix_memalign test should just be disabled on Windows since nothing provides it there yet. It looks like MinGW wants to (going by your bug report), but it doesn't yet and it's shipping with a half-finished implementation (fwict) which is why Meson detects it even though it's not fully implemented.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,86,2016-12-05T15:00:43Z,2016-12-05T17:39:49Z,2016-12-05T18:01:55Z,MERGED,True,11,6,3,https://github.com/nirbheek,Use malloc.h for _aligned_malloc instead of stdlib.h,2,[],https://github.com/ebassi/graphene/pull/86,https://github.com/ebassi,6,https://github.com/ebassi/graphene/pull/86#issuecomment-264921712,"Fixes #84 (comment)
Both stdlib.h and malloc.h define it on MinGW but it's only defined by malloc.h on MSVC, so just use malloc.h.
There are more issues needed for MSVC support, but this should help.","Let's go with this, then.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,87,2016-12-05T15:14:40Z,2016-12-05T15:31:43Z,2016-12-05T15:31:43Z,CLOSED,False,9,4,3,https://github.com/achadwick,Use _aligned_malloc,2,[],https://github.com/ebassi/graphene/pull/87,https://github.com/achadwick,1,https://github.com/ebassi/graphene/pull/87,"This appears to be needed to get the build a little further on in MSYS2. It is entirely untested.
Proposed changes:

Look for _aligned_malloc in the correct place for MSVC and MSYS2 (see ref)
Actually use _aligned_malloc().

used in preference to posix_memalign() because posix_memalign is still incorrectly detected on this system possibly as the result of an incorrectly exposed __builtin_posix_memalign.



Benchmark results:

Cannot build yet, sorry. Next hurdle for me is the g-ir-scanner line, which may be too long for meson to handle.

Test suite changes:

Amended src/bench/matrix.c","This appears to be needed to get the build a little further on in MSYS2. It is entirely untested.
Proposed changes:

Look for _aligned_malloc in the correct place for MSVC and MSYS2 (see ref)
Actually use _aligned_malloc().

used in preference to posix_memalign() because posix_memalign is still incorrectly detected on this system possibly as the result of an incorrectly exposed __builtin_posix_memalign.



Benchmark results:

Cannot build yet, sorry. Next hurdle for me is the g-ir-scanner line, which may be too long for meson to handle.

Test suite changes:

Amended src/bench/matrix.c",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,87,2016-12-05T15:14:40Z,2016-12-05T15:31:43Z,2016-12-05T15:31:43Z,CLOSED,False,9,4,3,https://github.com/achadwick,Use _aligned_malloc,2,[],https://github.com/ebassi/graphene/pull/87,https://github.com/achadwick,2,https://github.com/ebassi/graphene/pull/87#issuecomment-264884495,"This appears to be needed to get the build a little further on in MSYS2. It is entirely untested.
Proposed changes:

Look for _aligned_malloc in the correct place for MSVC and MSYS2 (see ref)
Actually use _aligned_malloc().

used in preference to posix_memalign() because posix_memalign is still incorrectly detected on this system possibly as the result of an incorrectly exposed __builtin_posix_memalign.



Benchmark results:

Cannot build yet, sorry. Next hurdle for me is the g-ir-scanner line, which may be too long for meson to handle.

Test suite changes:

Amended src/bench/matrix.c",Withdrawing this one in favour of #86.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,89,2016-12-05T18:34:45Z,2017-01-04T13:45:47Z,2017-01-04T14:24:41Z,MERGED,True,15,4,1,https://github.com/achadwick,"Use only one aligned alloc func, work around msys2",1,[],https://github.com/ebassi/graphene/pull/89,https://github.com/achadwick,1,https://github.com/ebassi/graphene/pull/89,"Fixes #76.
Proposed changes:

Cascading tests for the aligned malloc func as recommended by @nirbheek
Workaround for compilation on MSYS2: a hopefully temporary platform check

Benchmark results:

Still cannot compile on Win32 (blocked by #88)

Test suite changes:

None


As recommended by @nirbheek, only search for a single aligned memory
allocation function: #86 (comment)
The cascade of tests means we can exclude the ones for which MSYS2's
native mingw-w64 builtins and headers conspire to provide meson with a
dud test. Although it is still not clear that meson is doing the right
thing in this case (mesonbuild/meson#1083), we can work around the
failed build in graphene by excluding certain POSIXy cases on Windows.
Closes #76, leaving #88 unsolved.","Fixes #76.
Proposed changes:

Cascading tests for the aligned malloc func as recommended by @nirbheek
Workaround for compilation on MSYS2: a hopefully temporary platform check

Benchmark results:

Still cannot compile on Win32 (blocked by #88)

Test suite changes:

None


As recommended by @nirbheek, only search for a single aligned memory
allocation function: #86 (comment)
The cascade of tests means we can exclude the ones for which MSYS2's
native mingw-w64 builtins and headers conspire to provide meson with a
dud test. Although it is still not clear that meson is doing the right
thing in this case (mesonbuild/meson#1083), we can work around the
failed build in graphene by excluding certain POSIXy cases on Windows.
Closes #76, leaving #88 unsolved.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,89,2016-12-05T18:34:45Z,2017-01-04T13:45:47Z,2017-01-04T14:24:41Z,MERGED,True,15,4,1,https://github.com/achadwick,"Use only one aligned alloc func, work around msys2",1,[],https://github.com/ebassi/graphene/pull/89,https://github.com/achadwick,2,https://github.com/ebassi/graphene/pull/89#issuecomment-270167257,"Fixes #76.
Proposed changes:

Cascading tests for the aligned malloc func as recommended by @nirbheek
Workaround for compilation on MSYS2: a hopefully temporary platform check

Benchmark results:

Still cannot compile on Win32 (blocked by #88)

Test suite changes:

None


As recommended by @nirbheek, only search for a single aligned memory
allocation function: #86 (comment)
The cascade of tests means we can exclude the ones for which MSYS2's
native mingw-w64 builtins and headers conspire to provide meson with a
dud test. Although it is still not clear that meson is doing the right
thing in this case (mesonbuild/meson#1083), we can work around the
failed build in graphene by excluding certain POSIXy cases on Windows.
Closes #76, leaving #88 unsolved.","@ebassi @nirbheek
I've incorporated your suggested changes. I hope the comment is now acceptably free of any github-isms.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,89,2016-12-05T18:34:45Z,2017-01-04T13:45:47Z,2017-01-04T14:24:41Z,MERGED,True,15,4,1,https://github.com/achadwick,"Use only one aligned alloc func, work around msys2",1,[],https://github.com/ebassi/graphene/pull/89,https://github.com/achadwick,3,https://github.com/ebassi/graphene/pull/89#issuecomment-270183627,"Fixes #76.
Proposed changes:

Cascading tests for the aligned malloc func as recommended by @nirbheek
Workaround for compilation on MSYS2: a hopefully temporary platform check

Benchmark results:

Still cannot compile on Win32 (blocked by #88)

Test suite changes:

None


As recommended by @nirbheek, only search for a single aligned memory
allocation function: #86 (comment)
The cascade of tests means we can exclude the ones for which MSYS2's
native mingw-w64 builtins and headers conspire to provide meson with a
dud test. Although it is still not clear that meson is doing the right
thing in this case (mesonbuild/meson#1083), we can work around the
failed build in graphene by excluding certain POSIXy cases on Windows.
Closes #76, leaving #88 unsolved.",@nirbheek Fixed ðŸ˜„,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,89,2016-12-05T18:34:45Z,2017-01-04T13:45:47Z,2017-01-04T14:24:41Z,MERGED,True,15,4,1,https://github.com/achadwick,"Use only one aligned alloc func, work around msys2",1,[],https://github.com/ebassi/graphene/pull/89,https://github.com/achadwick,4,https://github.com/ebassi/graphene/pull/89#issuecomment-270183945,"Fixes #76.
Proposed changes:

Cascading tests for the aligned malloc func as recommended by @nirbheek
Workaround for compilation on MSYS2: a hopefully temporary platform check

Benchmark results:

Still cannot compile on Win32 (blocked by #88)

Test suite changes:

None


As recommended by @nirbheek, only search for a single aligned memory
allocation function: #86 (comment)
The cascade of tests means we can exclude the ones for which MSYS2's
native mingw-w64 builtins and headers conspire to provide meson with a
dud test. Although it is still not clear that meson is doing the right
thing in this case (mesonbuild/meson#1083), we can work around the
failed build in graphene by excluding certain POSIXy cases on Windows.
Closes #76, leaving #88 unsolved.","Please note that although I have used URIs in the commit messages, github is aware of this and has corrected them to the shorter # form.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,90,2016-12-13T07:24:19Z,2016-12-13T11:33:12Z,2016-12-13T11:33:12Z,MERGED,True,1,1,1,https://github.com/benjamin-otte,rect: Fix typo in graphene_rect_intersection(),1,[],https://github.com/ebassi/graphene/pull/90,https://github.com/benjamin-otte,1,https://github.com/ebassi/graphene/pull/90,,,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,93,2017-01-03T17:54:47Z,2017-01-04T13:44:35Z,2017-01-05T13:24:42Z,MERGED,True,31,15,1,https://github.com/achadwick,Update build docs for MSYS2,1,[],https://github.com/ebassi/graphene/pull/93,https://github.com/achadwick,1,https://github.com/ebassi/graphene/pull/93,"This commit updates README.py with better tested documentation for the
MSYS2 platform on Windows. Previously the instructions would fail because
""automake"" is not a package.
This commit also gets the user to select packages based on their intended
target platform, a concept that matters on MSYS2 because each target
has its own $PREFIX.
The docs were also out of date in that they did not cover meson.


Proposed changes:

Update README.md as described in the commit message, quoted above.

Benchmark results:

I have not been able to get it to build yet, so I have not investigated this.
No change is expected because this is a docs-only commit.

Test suite changes:

None proposed.","This commit updates README.py with better tested documentation for the
MSYS2 platform on Windows. Previously the instructions would fail because
""automake"" is not a package.
This commit also gets the user to select packages based on their intended
target platform, a concept that matters on MSYS2 because each target
has its own $PREFIX.
The docs were also out of date in that they did not cover meson.


Proposed changes:

Update README.md as described in the commit message, quoted above.

Benchmark results:

I have not been able to get it to build yet, so I have not investigated this.
No change is expected because this is a docs-only commit.

Test suite changes:

None proposed.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,94,2017-01-03T18:13:39Z,2017-01-04T13:42:56Z,2017-01-04T14:26:04Z,MERGED,True,5,1,3,https://github.com/achadwick,autotools: Use Python to invoke identfilter.py,2,[],https://github.com/ebassi/graphene/pull/94,https://github.com/achadwick,1,https://github.com/ebassi/graphene/pull/94,"We cannot rely on a shebang line on different platforms.
Fixes #88 for autotools.

Addresses #88 again for autotools.
Proposed changes:

invoke Python directly just like a3a959b

Benchmark results:

I cannot get graphene to build with either autotools or meson yet, so I was not able to run the tests.

Test suite changes:

None. The build will fail in the absence of Python however (perhaps with a meaningful error message, even)","We cannot rely on a shebang line on different platforms.
Fixes #88 for autotools.

Addresses #88 again for autotools.
Proposed changes:

invoke Python directly just like a3a959b

Benchmark results:

I cannot get graphene to build with either autotools or meson yet, so I was not able to run the tests.

Test suite changes:

None. The build will fail in the absence of Python however (perhaps with a meaningful error message, even)",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,102,2017-04-07T11:19:59Z,2017-04-07T14:14:43Z,2017-04-07T14:15:35Z,MERGED,True,13,10,3,https://github.com/inigomartinez,Updated meson build files to ease API version change.,5,"['enhancement', 'build']",https://github.com/ebassi/graphene/pull/102,https://github.com/inigomartinez,1,https://github.com/ebassi/graphene/pull/102,"meson build files have been changed to include a variable with graphene string to be used instead of hard coded strings.
Fixes #101
Proposed changes:

Changed the version number handling for generated files and directories in the meson build files.

Benchmark results:

Before: ...
After: ...

Test suite changes:

...","meson build files have been changed to include a variable with graphene string to be used instead of hard coded strings.
Fixes #101
Proposed changes:

Changed the version number handling for generated files and directories in the meson build files.

Benchmark results:

Before: ...
After: ...

Test suite changes:

...",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,102,2017-04-07T11:19:59Z,2017-04-07T14:14:43Z,2017-04-07T14:15:35Z,MERGED,True,13,10,3,https://github.com/inigomartinez,Updated meson build files to ease API version change.,5,"['enhancement', 'build']",https://github.com/ebassi/graphene/pull/102,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/102#issuecomment-292520100,"meson build files have been changed to include a variable with graphene string to be used instead of hard coded strings.
Fixes #101
Proposed changes:

Changed the version number handling for generated files and directories in the meson build files.

Benchmark results:

Before: ...
After: ...

Test suite changes:

...","Thanks for the patch, it looks good and simplifies a bunch of redundant bits.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,102,2017-04-07T11:19:59Z,2017-04-07T14:14:43Z,2017-04-07T14:15:35Z,MERGED,True,13,10,3,https://github.com/inigomartinez,Updated meson build files to ease API version change.,5,"['enhancement', 'build']",https://github.com/ebassi/graphene/pull/102,https://github.com/inigomartinez,3,https://github.com/ebassi/graphene/pull/102#issuecomment-292547574,"meson build files have been changed to include a variable with graphene string to be used instead of hard coded strings.
Fixes #101
Proposed changes:

Changed the version number handling for generated files and directories in the meson build files.

Benchmark results:

Before: ...
After: ...

Test suite changes:

...","I'm very sorry about the update regarding your comments. I tried to update them using the edit option, but I haven't found any way to edit multiple files at the same time, so I had to edit them one by one. Also, the web editor search option doesn't work very well here, and I missed some of the variables when updating one of the files :(.
I expect the files to be properly updated now.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,102,2017-04-07T11:19:59Z,2017-04-07T14:14:43Z,2017-04-07T14:15:35Z,MERGED,True,13,10,3,https://github.com/inigomartinez,Updated meson build files to ease API version change.,5,"['enhancement', 'build']",https://github.com/ebassi/graphene/pull/102,https://github.com/ebassi,4,https://github.com/ebassi/graphene/pull/102#issuecomment-292548264,"meson build files have been changed to include a variable with graphene string to be used instead of hard coded strings.
Fixes #101
Proposed changes:

Changed the version number handling for generated files and directories in the meson build files.

Benchmark results:

Before: ...
After: ...

Test suite changes:

...","@inigomartinez No worries; I've squashed the commits on merge, it's perfectly fine.
Thanks again for your contribution!",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,105,2017-05-05T11:05:10Z,2018-02-24T13:30:06Z,2018-02-24T13:30:06Z,CLOSED,False,93,73,1,https://github.com/inigomartinez,build: Simplified option handling in configure script (#104),2,[],https://github.com/ebassi/graphene/pull/105,https://github.com/inigomartinez,1,https://github.com/ebassi/graphene/pull/105,"Option handling has been simplified by using associative arrays, where all the options are defined along their default options. Then passed options are analyzed using the ""action-option"" pattern and added accordingly to the meson command.
Fixes #...
Option handling in configure file.
Proposed changes:
Use of associative arrays and analyze options with the ""action-option"" pattern.

...

Benchmark results:

Before: ...
After: ...

Test suite changes:

...","Option handling has been simplified by using associative arrays, where all the options are defined along their default options. Then passed options are analyzed using the ""action-option"" pattern and added accordingly to the meson command.
Fixes #...
Option handling in configure file.
Proposed changes:
Use of associative arrays and analyze options with the ""action-option"" pattern.

...

Benchmark results:

Before: ...
After: ...

Test suite changes:

...",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,105,2017-05-05T11:05:10Z,2018-02-24T13:30:06Z,2018-02-24T13:30:06Z,CLOSED,False,93,73,1,https://github.com/inigomartinez,build: Simplified option handling in configure script (#104),2,[],https://github.com/ebassi/graphene/pull/105,https://github.com/TingPing,2,https://github.com/ebassi/graphene/pull/105#issuecomment-299477040,"Option handling has been simplified by using associative arrays, where all the options are defined along their default options. Then passed options are analyzed using the ""action-option"" pattern and added accordingly to the meson command.
Fixes #...
Option handling in configure file.
Proposed changes:
Use of associative arrays and analyze options with the ""action-option"" pattern.

...

Benchmark results:

Before: ...
After: ...

Test suite changes:

...",Might be worth noting that Meson might at some point error on invalid options (mesonbuild/meson#932) and that other projects copy paste this configure file using their own naming conventions so automatic mapping could end poorly.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,105,2017-05-05T11:05:10Z,2018-02-24T13:30:06Z,2018-02-24T13:30:06Z,CLOSED,False,93,73,1,https://github.com/inigomartinez,build: Simplified option handling in configure script (#104),2,[],https://github.com/ebassi/graphene/pull/105,https://github.com/inigomartinez,3,https://github.com/ebassi/graphene/pull/105#issuecomment-299490904,"Option handling has been simplified by using associative arrays, where all the options are defined along their default options. Then passed options are analyzed using the ""action-option"" pattern and added accordingly to the meson command.
Fixes #...
Option handling in configure file.
Proposed changes:
Use of associative arrays and analyze options with the ""action-option"" pattern.

...

Benchmark results:

Before: ...
After: ...

Test suite changes:

...","While this patch does not point error on invalid options, it shows a warning. It should be rather easy to change the warning for an error and stop the script.
Regarding the use of the configure file in other projects, I've used this script in another project[0], which I've slightly modified with the changes in this pull request. While those changes are related only to the build system and not really significant, I though about them as a minor improvement.
[0] https://bugzilla.gnome.org/show_bug.cgi?id=781908#c10",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,105,2017-05-05T11:05:10Z,2018-02-24T13:30:06Z,2018-02-24T13:30:06Z,CLOSED,False,93,73,1,https://github.com/inigomartinez,build: Simplified option handling in configure script (#104),2,[],https://github.com/ebassi/graphene/pull/105,https://github.com/TingPing,4,https://github.com/ebassi/graphene/pull/105#issuecomment-299511001,"Option handling has been simplified by using associative arrays, where all the options are defined along their default options. Then passed options are analyzed using the ""action-option"" pattern and added accordingly to the meson command.
Fixes #...
Option handling in configure file.
Proposed changes:
Use of associative arrays and analyze options with the ""action-option"" pattern.

...

Benchmark results:

Before: ...
After: ...

Test suite changes:

...","While this patch does not point error on invalid options, it shows a warning. It should be rather easy to change the warning for an error and stop the script.

Sorry I was referring to it mapping to Meson options that may not exist and Meson erroring could be a problem.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,105,2017-05-05T11:05:10Z,2018-02-24T13:30:06Z,2018-02-24T13:30:06Z,CLOSED,False,93,73,1,https://github.com/inigomartinez,build: Simplified option handling in configure script (#104),2,[],https://github.com/ebassi/graphene/pull/105,https://github.com/inigomartinez,5,https://github.com/ebassi/graphene/pull/105#issuecomment-299563689,"Option handling has been simplified by using associative arrays, where all the options are defined along their default options. Then passed options are analyzed using the ""action-option"" pattern and added accordingly to the meson command.
Fixes #...
Option handling in configure file.
Proposed changes:
Use of associative arrays and analyze options with the ""action-option"" pattern.

...

Benchmark results:

Before: ...
After: ...

Test suite changes:

...","Oh, it's fine, don't worry. There is an associative array which holds the meson options with their default values, and every option used with configure are checked against those values. If the option does exist, it's added as an argument to the meson's command line, but if it doesn't exist it shows a warning (the one I pointed before that could be easily replaced by an error and a stop).",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,105,2017-05-05T11:05:10Z,2018-02-24T13:30:06Z,2018-02-24T13:30:06Z,CLOSED,False,93,73,1,https://github.com/inigomartinez,build: Simplified option handling in configure script (#104),2,[],https://github.com/ebassi/graphene/pull/105,https://github.com/inigomartinez,6,https://github.com/ebassi/graphene/pull/105#issuecomment-301155362,"Option handling has been simplified by using associative arrays, where all the options are defined along their default options. Then passed options are analyzed using the ""action-option"" pattern and added accordingly to the meson command.
Fixes #...
Option handling in configure file.
Proposed changes:
Use of associative arrays and analyze options with the ""action-option"" pattern.

...

Benchmark results:

Before: ...
After: ...

Test suite changes:

...","You comment has made me rethink the option handling. The last commit presents, more or less, these new ideas.
The option hadling presented in the PR only worked with boolean options by using the {enable|disable}-{option} pattern. It wasn't thought to work with other than boolean options.
I have extended that work to also support other kind of options, as you asked for. That work has led me think about dir options, that could be handled in a similar, but not exactly the same, way.
For example, their default values. I haven't be able to declare their default value in the associative array, because of the relationship between them. For example I can define bindir as ""${dir_options['prefix']}/bin"", which will be resolved when the array is defined, but will not be updated if the value at the 'prefix' key is updated.
Another issue was related to the array where they are defined. Meson handles in a different way the directory options, so they must be stored in a different array. That is the reason behin set_option and set_bool_option. set_option alone does handle both cases at the expense of an extra if statement.
Finally, I tried to use an unified regex to handle all the options, but I have only been able to do so by using two separate regex expression.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,105,2017-05-05T11:05:10Z,2018-02-24T13:30:06Z,2018-02-24T13:30:06Z,CLOSED,False,93,73,1,https://github.com/inigomartinez,build: Simplified option handling in configure script (#104),2,[],https://github.com/ebassi/graphene/pull/105,https://github.com/ebassi,7,https://github.com/ebassi/graphene/pull/105#issuecomment-368228609,"Option handling has been simplified by using associative arrays, where all the options are defined along their default options. Then passed options are analyzed using the ""action-option"" pattern and added accordingly to the meson command.
Fixes #...
Option handling in configure file.
Proposed changes:
Use of associative arrays and analyze options with the ""action-option"" pattern.

...

Benchmark results:

Before: ...
After: ...

Test suite changes:

...",The configure script is now gone.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,108,2017-07-19T03:42:04Z,2017-07-19T15:52:16Z,2017-07-19T15:52:16Z,MERGED,True,1,1,1,https://github.com/jralls,Fix Xcode-9 compile error,1,[],https://github.com/ebassi/graphene/pull/108,https://github.com/jralls,1,https://github.com/ebassi/graphene/pull/108,"Apple's clang-9 (no idea what that maps to in clang's normal version) doesn't like an '=' in the version flags.
Fixes #...
Proposed changes:

...

Benchmark results:

Before: ...
After: ...

Test suite changes:

...","Apple's clang-9 (no idea what that maps to in clang's normal version) doesn't like an '=' in the version flags.
Fixes #...
Proposed changes:

...

Benchmark results:

Before: ...
After: ...

Test suite changes:

...",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,108,2017-07-19T03:42:04Z,2017-07-19T15:52:16Z,2017-07-19T15:52:16Z,MERGED,True,1,1,1,https://github.com/jralls,Fix Xcode-9 compile error,1,[],https://github.com/ebassi/graphene/pull/108,https://github.com/jralls,2,https://github.com/ebassi/graphene/pull/108#issuecomment-316264208,"Apple's clang-9 (no idea what that maps to in clang's normal version) doesn't like an '=' in the version flags.
Fixes #...
Proposed changes:

...

Benchmark results:

Before: ...
After: ...

Test suite changes:

...",The error it emits is: ld: malformed 32-bit x.y.z version number: =1,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,109,2017-09-07T16:57:44Z,2017-09-07T17:02:36Z,2017-09-07T17:02:51Z,MERGED,True,20,16,1,https://github.com/nirbheek,Add gir and typelib to declare_dependency for subproject use,1,[],https://github.com/ebassi/graphene/pull/109,https://github.com/nirbheek,1,https://github.com/ebassi/graphene/pull/109,This is required for using graphene as a subproject inside gtk+,This is required for using graphene as a subproject inside gtk+,True,{'THUMBS_UP': ['https://github.com/ebassi']}
ebassi/graphene,https://github.com/ebassi/graphene,113,2018-03-06T09:38:42Z,2018-03-06T10:01:29Z,2018-03-06T10:04:14Z,MERGED,True,1,1,1,https://github.com/ricotz,Fix header reference in GIR,1,[],https://github.com/ebassi/graphene/pull/113,https://github.com/ricotz,1,https://github.com/ebassi/graphene/pull/113,,,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,113,2018-03-06T09:38:42Z,2018-03-06T10:01:29Z,2018-03-06T10:04:14Z,MERGED,True,1,1,1,https://github.com/ricotz,Fix header reference in GIR,1,[],https://github.com/ebassi/graphene/pull/113,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/113#issuecomment-370728235,,Thanks! That'll teach me about doing releases while travelling.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,115,2018-04-09T09:19:35Z,2018-04-09T19:17:41Z,2018-04-09T19:17:45Z,MERGED,True,18,14,5,https://github.com/ebassi,Check pre-processor symbols,3,[],https://github.com/ebassi/graphene/pull/115,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/115,"We're using a bunch of pre-processor symbols before checking if they are defined, which makes it hard to build Graphene if compiler flags like -Wundef are used.
Fixes #114","We're using a bunch of pre-processor symbols before checking if they are defined, which makes it hard to build Graphene if compiler flags like -Wundef are used.
Fixes #114",True,{'HOORAY': ['https://github.com/lazka']}
ebassi/graphene,https://github.com/ebassi/graphene,116,2018-04-09T19:20:51Z,2018-06-11T22:23:25Z,2018-06-11T22:23:29Z,MERGED,True,44,42,9,https://github.com/ebassi,Various build fixes,8,[],https://github.com/ebassi/graphene/pull/116,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/116,"Our build system hasn't been touched in a while, and so it fell a bit out of date with what we ought to consider ""safe"".
Let's amp up the compiler warnings and errors, and improve our chances at finding issues before they become problems.","Our build system hasn't been touched in a while, and so it fell a bit out of date with what we ought to consider ""safe"".
Let's amp up the compiler warnings and errors, and improve our chances at finding issues before they become problems.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,117,2018-04-09T21:41:31Z,2018-06-11T22:22:24Z,2018-06-11T22:22:24Z,MERGED,True,89,40,4,https://github.com/lazka,appveyor: Add MSYS2 jobs,2,[],https://github.com/ebassi/graphene/pull/117,https://github.com/lazka,1,https://github.com/ebassi/graphene/pull/117,"Context: #114 (comment)
The first commit moves the MSVC commands into a separate file, the second one adds MSYS2 support.
Sadly every build goes through all commands so you either have to do lots of ifs everywhere or move things to batch/shell files. And with batch files you have to do that goto stuff to get it to fail properly. But it seemed like less of a mess all in all.","Context: #114 (comment)
The first commit moves the MSVC commands into a separate file, the second one adds MSYS2 support.
Sadly every build goes through all commands so you either have to do lots of ifs everywhere or move things to batch/shell files. And with batch files you have to do that goto stuff to get it to fail properly. But it seemed like less of a mess all in all.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,119,2018-04-13T10:04:21Z,2018-05-23T15:56:03Z,2018-05-23T15:56:04Z,MERGED,True,8,14,3,https://github.com/lazka,Fix some MinGW warnings,2,[],https://github.com/ebassi/graphene/pull/119,https://github.com/lazka,1,https://github.com/ebassi/graphene/pull/119,"partly fixes #118
I haven't figured out the SSE related warning (seems to be a real warning, enabling SSE on 32bit seems to change ABI and things crash until rebuild)","partly fixes #118
I haven't figured out the SSE related warning (seems to be a real warning, enabling SSE on 32bit seems to change ABI and things crash until rebuild)",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,120,2018-04-13T10:13:26Z,2018-06-11T22:22:50Z,2018-06-11T22:22:50Z,MERGED,True,9,11,2,https://github.com/lazka,meson: make sure simd related cflags are used for tests/benchmarks,1,[],https://github.com/ebassi/graphene/pull/120,https://github.com/lazka,1,https://github.com/ebassi/graphene/pull/120,"They were only added to extra_args which isn't used to build tests/benchmarks.
Add them to common_cflags instead.","They were only added to extra_args which isn't used to build tests/benchmarks.
Add them to common_cflags instead.",True,{'THUMBS_UP': ['https://github.com/ebassi']}
ebassi/graphene,https://github.com/ebassi/graphene,122,2018-06-11T22:09:44Z,2018-06-11T22:53:00Z,2018-06-11T22:53:03Z,MERGED,True,5,4,2,https://github.com/ebassi,Disable SIMD optimizations on 32bit Intel Architectures,1,[],https://github.com/ebassi/graphene/pull/122,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/122,"SIMD implementations are terrible on 32bit IA for a variety of reasons:

SSE2+ intrinsics are generally unsupported except on very old CPU
packages, and compilers are poorly optimized for those
GCC vectorization builtins require a decent version of GCC to begin
with, and will likely work badly on 32 bit builds
allocators on 32bit are not capable of aligning SIMD-based
structures, and no amount of trickery will allow them to work
properly.

If you're building Graphene for 32 bit you're much better served by
using the scalar fallback code; it may be slow, but at least it'll work
as expected.","SIMD implementations are terrible on 32bit IA for a variety of reasons:

SSE2+ intrinsics are generally unsupported except on very old CPU
packages, and compilers are poorly optimized for those
GCC vectorization builtins require a decent version of GCC to begin
with, and will likely work badly on 32 bit builds
allocators on 32bit are not capable of aligning SIMD-based
structures, and no amount of trickery will allow them to work
properly.

If you're building Graphene for 32 bit you're much better served by
using the scalar fallback code; it may be slow, but at least it'll work
as expected.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,123,2018-06-11T22:30:29Z,2018-06-11T22:52:47Z,2018-06-11T22:52:50Z,MERGED,True,8,18,1,https://github.com/ebassi,Updates for the README file,3,[],https://github.com/ebassi/graphene/pull/123,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/123,Closes #111,Closes #111,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,124,2018-06-13T16:02:44Z,2018-06-13T16:35:48Z,2018-06-13T16:35:51Z,MERGED,True,81,93,10,https://github.com/ebassi,Ensure alignment of SIMD types,7,[],https://github.com/ebassi/graphene/pull/124,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/124,"Since graphene_simd4f_t can have different implementations, we need to ensure that structures including a field with that type are appropriately aligned. For instance, the scalar implementation is smaller than the SSE2 and GCC vector ones, as float[4] is packed differently than a __m128. The alignment difference creates the potential for ABI breaks in code using Graphene that embeds a Graphene type with a graphene_simd4f_t field, if Graphene was built with different SIMD backends.
We already have GRAPHENE_ALIGN16 for this job, but instead of relying on caller code doing the right thing, we can ensure that our types are already correctly aligned.","Since graphene_simd4f_t can have different implementations, we need to ensure that structures including a field with that type are appropriately aligned. For instance, the scalar implementation is smaller than the SSE2 and GCC vector ones, as float[4] is packed differently than a __m128. The alignment difference creates the potential for ABI breaks in code using Graphene that embeds a Graphene type with a graphene_simd4f_t field, if Graphene was built with different SIMD backends.
We already have GRAPHENE_ALIGN16 for this job, but instead of relying on caller code doing the right thing, we can ensure that our types are already correctly aligned.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,125,2018-08-05T18:49:58Z,2018-08-05T19:41:33Z,2018-08-05T19:41:36Z,MERGED,True,53,5,4,https://github.com/ebassi,Fix point transformation,5,[],https://github.com/ebassi/graphene/pull/125,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/125,"The transformation of 2D and 3D points should take into account the W row of the matrix, unlike transformations of vec3 vectors.
Currently, the graphene_matrix_transform_point() implementation calls into the matrix/vec3 multiplication, which is wrong; the graphene_matrix_point3d() implementation correctly calls into the matrix/point3 multiplication.
Additionally, the documentation is less than clear as to which API is meant to ignore the W components of both the matrix and the vector, and which API is meant to take into account the W row of the matrix alone.
Test suite changes:

Added a new unit to verify that matrix/point and matrix/point3d transformations are different than matrix/vec3 transformations.","The transformation of 2D and 3D points should take into account the W row of the matrix, unlike transformations of vec3 vectors.
Currently, the graphene_matrix_transform_point() implementation calls into the matrix/vec3 multiplication, which is wrong; the graphene_matrix_point3d() implementation correctly calls into the matrix/point3 multiplication.
Additionally, the documentation is less than clear as to which API is meant to ignore the W components of both the matrix and the vector, and which API is meant to take into account the W row of the matrix alone.
Test suite changes:

Added a new unit to verify that matrix/point and matrix/point3d transformations are different than matrix/vec3 transformations.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,127,2018-10-16T08:38:42Z,2018-12-21T15:29:02Z,2018-12-21T15:29:03Z,CLOSED,False,5,5,3,https://github.com/ystreet,meson: fix HAVE_INIT_ONCE declaration,1,[],https://github.com/ebassi/graphene/pull/127,https://github.com/ystreet,1,https://github.com/ebassi/graphene/pull/127,"meson will set the HAVE_INIT_ONCE value to 0 or 1 when using
conf.set10() so an #if defined() will always succeed.
../src/graphene-box.c:681:1: error: unknown type name 'INIT_ONCE'
../src/graphene-box.c:681:36: error: 'INIT_ONCE_STATIC_INIT' undeclared here (not in a function)
../src/graphene-box.c: In function 'init_static_box':","meson will set the HAVE_INIT_ONCE value to 0 or 1 when using
conf.set10() so an #if defined() will always succeed.
../src/graphene-box.c:681:1: error: unknown type name 'INIT_ONCE'
../src/graphene-box.c:681:36: error: 'INIT_ONCE_STATIC_INIT' undeclared here (not in a function)
../src/graphene-box.c: In function 'init_static_box':",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,127,2018-10-16T08:38:42Z,2018-12-21T15:29:02Z,2018-12-21T15:29:03Z,CLOSED,False,5,5,3,https://github.com/ystreet,meson: fix HAVE_INIT_ONCE declaration,1,[],https://github.com/ebassi/graphene/pull/127,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/127#issuecomment-432375196,"meson will set the HAVE_INIT_ONCE value to 0 or 1 when using
conf.set10() so an #if defined() will always succeed.
../src/graphene-box.c:681:1: error: unknown type name 'INIT_ONCE'
../src/graphene-box.c:681:36: error: 'INIT_ONCE_STATIC_INIT' undeclared here (not in a function)
../src/graphene-box.c: In function 'init_static_box':","Thanks for your contribution!
To be quite honest, I don't really like this style. Either the meson.build should not use set10() and instead rely on the definedness of the symbol; or the preprocessor conditional should not be checking for the symbol being defined (as it it will always be) and turned into:
#if HAVE_INIT_ONCE
...
and:
...
#elif HAVE_INIT_ONCE
...",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,127,2018-10-16T08:38:42Z,2018-12-21T15:29:02Z,2018-12-21T15:29:03Z,CLOSED,False,5,5,3,https://github.com/ystreet,meson: fix HAVE_INIT_ONCE declaration,1,[],https://github.com/ebassi/graphene/pull/127,https://github.com/ebassi,3,https://github.com/ebassi/graphene/pull/127#issuecomment-449417894,"meson will set the HAVE_INIT_ONCE value to 0 or 1 when using
conf.set10() so an #if defined() will always succeed.
../src/graphene-box.c:681:1: error: unknown type name 'INIT_ONCE'
../src/graphene-box.c:681:36: error: 'INIT_ONCE_STATIC_INIT' undeclared here (not in a function)
../src/graphene-box.c: In function 'init_static_box':","I've opened #133 to replace the set10() with a set(), which should fix the issue.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,128,2018-10-16T11:07:37Z,2018-10-23T18:56:13Z,2020-07-13T12:59:07Z,MERGED,True,5,4,1,https://github.com/nirbheek,Fix implicit conversion error when compiling with MSVC,1,[],https://github.com/ebassi/graphene/pull/128,https://github.com/nirbheek,1,https://github.com/ebassi/graphene/pull/128,"error C4244: 'function': conversion from 'int' to 'float', possible loss of data
i can't be float because it is also used as an array subscript
This is the only changed needed to have graphene build with msvc.","error C4244: 'function': conversion from 'int' to 'float', possible loss of data
i can't be float because it is also used as an array subscript
This is the only changed needed to have graphene build with msvc.",True,{'THUMBS_UP': ['https://github.com/ebassi']}
ebassi/graphene,https://github.com/ebassi/graphene,128,2018-10-16T11:07:37Z,2018-10-23T18:56:13Z,2020-07-13T12:59:07Z,MERGED,True,5,4,1,https://github.com/nirbheek,Fix implicit conversion error when compiling with MSVC,1,[],https://github.com/ebassi/graphene/pull/128,https://github.com/nirbheek,2,https://github.com/ebassi/graphene/pull/128#issuecomment-430211097,"error C4244: 'function': conversion from 'int' to 'float', possible loss of data
i can't be float because it is also used as an array subscript
This is the only changed needed to have graphene build with msvc.","I suspect this only shows up with MSVC 19.14.26433, which would explain why the CI didn't trigger it.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,130,2018-12-14T10:06:03Z,2018-12-14T14:16:28Z,2020-07-13T12:59:44Z,MERGED,True,2,2,1,https://github.com/nirbheek,bench: Fix MSVC build error on 32-bit Windows,1,[],https://github.com/ebassi/graphene/pull/130,https://github.com/nirbheek,1,https://github.com/ebassi/graphene/pull/130,"size_t is unsigned long int which is a 32-bit integer on 32-bit Windows. The multiplication in malloc() below then evaluates to a 32-bit integer which the compiler complains about.
This is normally a warning, but since we use -we4244 it's an error.
src/bench/graphene-bench-utils.c(175): error C4244: 'function': conversion from 'gint64' to 'size_t', possible loss of data`
The number of rounds will never exceed INT_MAX, so we can just use an int here.","size_t is unsigned long int which is a 32-bit integer on 32-bit Windows. The multiplication in malloc() below then evaluates to a 32-bit integer which the compiler complains about.
This is normally a warning, but since we use -we4244 it's an error.
src/bench/graphene-bench-utils.c(175): error C4244: 'function': conversion from 'gint64' to 'size_t', possible loss of data`
The number of rounds will never exceed INT_MAX, so we can just use an int here.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,130,2018-12-14T10:06:03Z,2018-12-14T14:16:28Z,2020-07-13T12:59:44Z,MERGED,True,2,2,1,https://github.com/nirbheek,bench: Fix MSVC build error on 32-bit Windows,1,[],https://github.com/ebassi/graphene/pull/130,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/130#issuecomment-447295665,"size_t is unsigned long int which is a 32-bit integer on 32-bit Windows. The multiplication in malloc() below then evaluates to a 32-bit integer which the compiler complains about.
This is normally a warning, but since we use -we4244 it's an error.
src/bench/graphene-bench-utils.c(175): error C4244: 'function': conversion from 'gint64' to 'size_t', possible loss of data`
The number of rounds will never exceed INT_MAX, so we can just use an int here.","It seems this is failing to build with GCC on Linux, and with MINGW on Windows.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,130,2018-12-14T10:06:03Z,2018-12-14T14:16:28Z,2020-07-13T12:59:44Z,MERGED,True,2,2,1,https://github.com/nirbheek,bench: Fix MSVC build error on 32-bit Windows,1,[],https://github.com/ebassi/graphene/pull/130,https://github.com/nirbheek,3,https://github.com/ebassi/graphene/pull/130#issuecomment-447296896,"size_t is unsigned long int which is a 32-bit integer on 32-bit Windows. The multiplication in malloc() below then evaluates to a 32-bit integer which the compiler complains about.
This is normally a warning, but since we use -we4244 it's an error.
src/bench/graphene-bench-utils.c(175): error C4244: 'function': conversion from 'gint64' to 'size_t', possible loss of data`
The number of rounds will never exceed INT_MAX, so we can just use an int here.",Oof. I should've tested on Linux first. Should be fixed now.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,131,2018-12-21T12:29:48Z,2018-12-21T14:39:24Z,2018-12-21T14:40:22Z,MERGED,True,0,2,1,https://github.com/lazka,build: don't hide the stdbool include from g-ir-scanner,1,[],https://github.com/ebassi/graphene/pull/131,https://github.com/lazka,1,https://github.com/ebassi/graphene/pull/131,"g-i recently lost the ability to infer the bool type without a stdbool include.
While this is about to be fixed in g-i (https://gitlab.gnome.org/GNOME/gobject-introspection/merge_requests/116)
I don't see a reason why we should hide this in the first place, so remove the ifdef guard.","g-i recently lost the ability to infer the bool type without a stdbool include.
While this is about to be fixed in g-i (https://gitlab.gnome.org/GNOME/gobject-introspection/merge_requests/116)
I don't see a reason why we should hide this in the first place, so remove the ifdef guard.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,131,2018-12-21T12:29:48Z,2018-12-21T14:39:24Z,2018-12-21T14:40:22Z,MERGED,True,0,2,1,https://github.com/lazka,build: don't hide the stdbool include from g-ir-scanner,1,[],https://github.com/ebassi/graphene/pull/131,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/131#issuecomment-449398815,"g-i recently lost the ability to infer the bool type without a stdbool include.
While this is about to be fixed in g-i (https://gitlab.gnome.org/GNOME/gobject-introspection/merge_requests/116)
I don't see a reason why we should hide this in the first place, so remove the ifdef guard.","The reason why I ignored it was because older g-ir-scanner versions would barf on bool.
I guess this means that graphene needs to depend on a minimum version of gobject-introspection.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,131,2018-12-21T12:29:48Z,2018-12-21T14:39:24Z,2018-12-21T14:40:22Z,MERGED,True,0,2,1,https://github.com/lazka,build: don't hide the stdbool include from g-ir-scanner,1,[],https://github.com/ebassi/graphene/pull/131,https://github.com/lazka,3,https://github.com/ebassi/graphene/pull/131#issuecomment-449404095,"g-i recently lost the ability to infer the bool type without a stdbool include.
While this is about to be fixed in g-i (https://gitlab.gnome.org/GNOME/gobject-introspection/merge_requests/116)
I don't see a reason why we should hide this in the first place, so remove the ifdef guard.","OK, CI uses Debian stretch and I don't see any errors/warnings there. So >= 1.50 should work for example.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,131,2018-12-21T12:29:48Z,2018-12-21T14:39:24Z,2018-12-21T14:40:22Z,MERGED,True,0,2,1,https://github.com/lazka,build: don't hide the stdbool include from g-ir-scanner,1,[],https://github.com/ebassi/graphene/pull/131,https://github.com/ebassi,4,https://github.com/ebassi/graphene/pull/131#issuecomment-449405016,"g-i recently lost the ability to infer the bool type without a stdbool include.
While this is about to be fixed in g-i (https://gitlab.gnome.org/GNOME/gobject-introspection/merge_requests/116)
I don't see a reason why we should hide this in the first place, so remove the ifdef guard.","Okay, let's merge this as is; I can add a requirement on 1.50 (and bump up the requirement for GLib 2.50) if that breaks elsewhere.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,131,2018-12-21T12:29:48Z,2018-12-21T14:39:24Z,2018-12-21T14:40:22Z,MERGED,True,0,2,1,https://github.com/lazka,build: don't hide the stdbool include from g-ir-scanner,1,[],https://github.com/ebassi/graphene/pull/131,https://github.com/lazka,5,https://github.com/ebassi/graphene/pull/131#issuecomment-449405274,"g-i recently lost the ability to infer the bool type without a stdbool include.
While this is about to be fixed in g-i (https://gitlab.gnome.org/GNOME/gobject-introspection/merge_requests/116)
I don't see a reason why we should hide this in the first place, so remove the ifdef guard.",Thanks!,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,132,2018-12-21T14:48:37Z,2018-12-21T15:27:29Z,2018-12-21T15:27:29Z,MERGED,True,26,14,3,https://github.com/ebassi,Ensure pkg-config Requires are correct,3,[],https://github.com/ebassi/graphene/pull/132,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/132,,,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,133,2018-12-21T15:01:07Z,2018-12-21T15:46:40Z,2018-12-21T15:46:40Z,MERGED,True,1,1,1,https://github.com/ebassi,build: Do not use set10() for InitOnce checks,1,[],https://github.com/ebassi/graphene/pull/133,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/133,"We use #ifdef HAVE_INIT_ONCE all over the place, and set10() will
unconditionally define the symbol, which means the check will always
succeed even if InitOnce and friends are not available.","We use #ifdef HAVE_INIT_ONCE all over the place, and set10() will
unconditionally define the symbol, which means the check will always
succeed even if InitOnce and friends are not available.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,135,2019-02-18T21:13:52Z,2019-02-18T21:59:40Z,2019-02-18T21:59:40Z,MERGED,True,36,4,2,https://github.com/benjamin-otte,simd4x4f: Use an intermediate for multiplication,1,[],https://github.com/ebassi/graphene/pull/135,https://github.com/benjamin-otte,1,https://github.com/ebassi/graphene/pull/135,"Otherwise if b == res, the row vectors will be overwritten while they
are still being used.
In particular, this fixes graphene_matrix_multiply (a, b, b) being
broken.
A new test, matrix/mutliply-self has been added.
Fixes #...
Proposed changes:

...

Benchmark results:

Before: ...
After: ...

Test suite changes:

...","Otherwise if b == res, the row vectors will be overwritten while they
are still being used.
In particular, this fixes graphene_matrix_multiply (a, b, b) being
broken.
A new test, matrix/mutliply-self has been added.
Fixes #...
Proposed changes:

...

Benchmark results:

Before: ...
After: ...

Test suite changes:

...",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,136,2019-03-02T00:29:22Z,2019-03-03T14:48:11Z,2019-03-03T14:48:11Z,MERGED,True,27,19,2,https://github.com/benjamin-otte, matrix: Fix boolean logic in graphene_matrix_to_2d(),2,[],https://github.com/ebassi/graphene/pull/136,https://github.com/benjamin-otte,1,https://github.com/ebassi/graphene/pull/136,"This looks like a thinko, where && and || where confused leading to way
too many matrices being accepted as 2D when they shouldn't.
A new test, matrix/is-2d has been added.","This looks like a thinko, where && and || where confused leading to way
too many matrices being accepted as 2D when they shouldn't.
A new test, matrix/is-2d has been added.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,136,2019-03-02T00:29:22Z,2019-03-03T14:48:11Z,2019-03-03T14:48:11Z,MERGED,True,27,19,2,https://github.com/benjamin-otte, matrix: Fix boolean logic in graphene_matrix_to_2d(),2,[],https://github.com/ebassi/graphene/pull/136,https://github.com/benjamin-otte,2,https://github.com/ebassi/graphene/pull/136#issuecomment-468902353,"This looks like a thinko, where && and || where confused leading to way
too many matrices being accepted as 2D when they shouldn't.
A new test, matrix/is-2d has been added.","Updated the commit after finding graphene_matrix_is_2d() to use the same logic as that function, which was correct.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,138,2019-03-05T15:58:27Z,2019-03-05T16:22:06Z,2019-03-05T16:22:06Z,MERGED,True,35,15,2,https://github.com/benjamin-otte,matrix: Fix interpolation of perspective matrices,1,[],https://github.com/ebassi/graphene/pull/138,https://github.com/benjamin-otte,1,https://github.com/ebassi/graphene/pull/138,"The code was extracting the 3rd row as perspective, not the 3rd column.
A new test interpolate-perspective has been added.","The code was extracting the 3rd row as perspective, not the 3rd column.
A new test interpolate-perspective has been added.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,139,2019-03-05T17:15:32Z,2019-05-30T12:32:57Z,2019-05-30T12:32:57Z,MERGED,True,137,2,4,https://github.com/3v1n0,Rect rounding improvements,5,[],https://github.com/ebassi/graphene/pull/139,https://github.com/3v1n0,1,https://github.com/ebassi/graphene/pull/139,"Proposed changes:

Add function for computing the area of a rect
Add function to compute the rounded extents
Fix docstring for round function
Add function to print rects

Test suite changes:

Test for graphene_rect_round
Test for graphene_rect_get_area
Test for graphene_rect_round_extents

Not sure if changing the round function would have been better, but I'd say no, as these two roundings cover different cases (for example, we'd need to round the extents when we want to pass a fractional rect for damaging the area).","Proposed changes:

Add function for computing the area of a rect
Add function to compute the rounded extents
Fix docstring for round function
Add function to print rects

Test suite changes:

Test for graphene_rect_round
Test for graphene_rect_get_area
Test for graphene_rect_round_extents

Not sure if changing the round function would have been better, but I'd say no, as these two roundings cover different cases (for example, we'd need to round the extents when we want to pass a fractional rect for damaging the area).",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,139,2019-03-05T17:15:32Z,2019-05-30T12:32:57Z,2019-05-30T12:32:57Z,MERGED,True,137,2,4,https://github.com/3v1n0,Rect rounding improvements,5,[],https://github.com/ebassi/graphene/pull/139,https://github.com/3v1n0,2,https://github.com/ebassi/graphene/pull/139#issuecomment-469788350,"Proposed changes:

Add function for computing the area of a rect
Add function to compute the rounded extents
Fix docstring for round function
Add function to print rects

Test suite changes:

Test for graphene_rect_round
Test for graphene_rect_get_area
Test for graphene_rect_round_extents

Not sure if changing the round function would have been better, but I'd say no, as these two roundings cover different cases (for example, we'd need to round the extents when we want to pass a fractional rect for damaging the area).","You will need an initial commit to add the 1.10 versioning macros.

Yeah, it was also my guess, but I checked too late.
Fixed though :)",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,139,2019-03-05T17:15:32Z,2019-05-30T12:32:57Z,2019-05-30T12:32:57Z,MERGED,True,137,2,4,https://github.com/3v1n0,Rect rounding improvements,5,[],https://github.com/ebassi/graphene/pull/139,https://github.com/GeorgesStavracas,3,https://github.com/ebassi/graphene/pull/139#issuecomment-472110570,"Proposed changes:

Add function for computing the area of a rect
Add function to compute the rounded extents
Fix docstring for round function
Add function to print rects

Test suite changes:

Test for graphene_rect_round
Test for graphene_rect_get_area
Test for graphene_rect_round_extents

Not sure if changing the round function would have been better, but I'd say no, as these two roundings cover different cases (for example, we'd need to round the extents when we want to pass a fractional rect for damaging the area).","I guess I can drop my very own commits to bump the version, then",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,139,2019-03-05T17:15:32Z,2019-05-30T12:32:57Z,2019-05-30T12:32:57Z,MERGED,True,137,2,4,https://github.com/3v1n0,Rect rounding improvements,5,[],https://github.com/ebassi/graphene/pull/139,https://github.com/ebassi,4,https://github.com/ebassi/graphene/pull/139#issuecomment-497313589,"Proposed changes:

Add function for computing the area of a rect
Add function to compute the rounded extents
Fix docstring for round function
Add function to print rects

Test suite changes:

Test for graphene_rect_round
Test for graphene_rect_get_area
Test for graphene_rect_round_extents

Not sure if changing the round function would have been better, but I'd say no, as these two roundings cover different cases (for example, we'd need to round the extents when we want to pass a fractional rect for damaging the area).","MSYS is apparently borked, so I'm going to ignore it for the time being, and merge this.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,140,2019-03-06T18:19:50Z,2019-03-06T18:54:47Z,2019-03-06T18:54:47Z,CLOSED,False,7,0,1,https://github.com/tintou,Add Vala .vapi file generation,1,[],https://github.com/ebassi/graphene/pull/140,https://github.com/tintou,1,https://github.com/ebassi/graphene/pull/140,,,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,140,2019-03-06T18:19:50Z,2019-03-06T18:54:47Z,2019-03-06T18:54:47Z,CLOSED,False,7,0,1,https://github.com/tintou,Add Vala .vapi file generation,1,[],https://github.com/ebassi/graphene/pull/140,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/140#issuecomment-470230296,,"Sorry, but this pull request is not going to be merged.
First of all, you should write a description for a merge request, summarising why do you think I should merge it in the first place; if you don't do this, I may legitimately come away with the impression that you don't value my time at all. This alone would be enough reason for me to close this MR.
Additionally, the CI breaks becauseâ€”I assume, as I didn't really look at the MRâ€”you did not do either of these two things:

update the CI environment to include Vala
add a configuration option to disable building the Vala API description on platforms that do not have Vala out of the box, like Windows or macOS

PRs with failing CI results are never going to be merged.
Finally, and the main reason this PR won't be merged: we are already shipping an API description in the form of introspection data. I'm not going to add another one that I don't use, I don't plan to use, and I don't want to maintain.
I'm afraid Vala will have to ship the VAPI file for Graphene alongside the rest of the VAPI files it already ships; or projects using Graphene with Vala will have to generate the VAPI from the introspection data themselves.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,141,2019-03-07T00:44:49Z,2019-03-22T11:56:00Z,2019-03-22T11:56:00Z,MERGED,True,94,1,6,https://github.com/GeorgesStavracas,rect: Add scale() method,2,[],https://github.com/ebassi/graphene/pull/141,https://github.com/GeorgesStavracas,1,https://github.com/ebassi/graphene/pull/141,"Scaling is a common operation when dealing with rectangles,
just as rounding.
Provide a scale() method to graphene_rect_t.

Proposed changes:

Inclusion of graphene_rect_scale()

Test suite changes:

Extend the test suite to stretch the new method","Scaling is a common operation when dealing with rectangles,
just as rounding.
Provide a scale() method to graphene_rect_t.

Proposed changes:

Inclusion of graphene_rect_scale()

Test suite changes:

Extend the test suite to stretch the new method",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,141,2019-03-07T00:44:49Z,2019-03-22T11:56:00Z,2019-03-22T11:56:00Z,MERGED,True,94,1,6,https://github.com/GeorgesStavracas,rect: Add scale() method,2,[],https://github.com/ebassi/graphene/pull/141,https://github.com/GeorgesStavracas,2,https://github.com/ebassi/graphene/pull/141#issuecomment-470341063,"Scaling is a common operation when dealing with rectangles,
just as rounding.
Provide a scale() method to graphene_rect_t.

Proposed changes:

Inclusion of graphene_rect_scale()

Test suite changes:

Extend the test suite to stretch the new method",Thanks for the quick review. This PR is now updated with the requested changes.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,142,2019-03-14T15:57:34Z,2019-06-01T00:17:32Z,2019-06-01T00:17:36Z,MERGED,True,3500,3047,38,https://github.com/ebassi,Use ÂµTest for the Graphene test suite,14,[],https://github.com/ebassi/graphene/pull/142,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/142,"GLib's GTest API is not that good, and it adds a dependency for basic
functionality like testing our API on multiple platforms.
The ÂµTest library is smaller than the whole of GLib; it has a nicer API
and output than GTest; and we can use it as a Meson sub-project if it's
not installed in the system, which makes it very convenient to use.","GLib's GTest API is not that good, and it adds a dependency for basic
functionality like testing our API on multiple platforms.
The ÂµTest library is smaller than the whole of GLib; it has a nicer API
and output than GTest; and we can use it as a Meson sub-project if it's
not installed in the system, which makes it very convenient to use.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,143,2019-03-22T12:32:29Z,2019-03-22T13:13:17Z,2019-03-22T13:13:21Z,MERGED,True,133,3,5,https://github.com/ebassi,Add equality operators for the matrix type,3,[],https://github.com/ebassi/graphene/pull/143,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/143,"Proposed changes:

add a graphene_matrix_near() function
use near() to implement graphene_matrix_equal()
add a byte-by-byte comparator for fast checks
document all newly added API

Test suite changes:

add a unit for the newly added API","Proposed changes:

add a graphene_matrix_near() function
use near() to implement graphene_matrix_equal()
add a byte-by-byte comparator for fast checks
document all newly added API

Test suite changes:

add a unit for the newly added API",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,144,2019-03-22T13:52:10Z,2019-03-22T14:31:18Z,2019-03-22T14:31:22Z,MERGED,True,62,0,4,https://github.com/ebassi,Add getters for the translation components of a matrix,2,[],https://github.com/ebassi/graphene/pull/144,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/144,"It's useful to have getters when inspecting a matrix. It's also useful because it hides implementation details, like: ""which row vector contains the translation components"".
Proposed changes:

add graphene_matrix_get_[xyz]_translation()
document the newly added functions","It's useful to have getters when inspecting a matrix. It's also useful because it hides implementation details, like: ""which row vector contains the translation components"".
Proposed changes:

add graphene_matrix_get_[xyz]_translation()
document the newly added functions",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,146,2019-04-15T11:46:46Z,2019-04-15T14:11:54Z,2019-04-15T14:12:00Z,MERGED,True,6,6,2,https://github.com/tschoonj,build: use darwin_versions,1,[],https://github.com/ebassi/graphene/pull/146,https://github.com/tschoonj,1,https://github.com/ebassi/graphene/pull/146,"Fixes: separate issue not opened
Proposed changes:

library() should use darwin_versions to set the dylib versioning on macOS.

Benchmark results:

Before: no benchmarking was performed
After:

Test suite changes:

None","Fixes: separate issue not opened
Proposed changes:

library() should use darwin_versions to set the dylib versioning on macOS.

Benchmark results:

Before: no benchmarking was performed
After:

Test suite changes:

None",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,146,2019-04-15T11:46:46Z,2019-04-15T14:11:54Z,2019-04-15T14:12:00Z,MERGED,True,6,6,2,https://github.com/tschoonj,build: use darwin_versions,1,[],https://github.com/ebassi/graphene/pull/146,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/146#issuecomment-483268101,"Fixes: separate issue not opened
Proposed changes:

library() should use darwin_versions to set the dylib versioning on macOS.

Benchmark results:

Before: no benchmarking was performed
After:

Test suite changes:

None",Thanks!,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,149,2019-05-02T22:15:05Z,2019-05-03T18:22:21Z,2019-05-03T18:22:21Z,MERGED,True,17,3,2,https://github.com/GeorgesStavracas,rect: Add GRAPHENE_RECT_INIT_ZERO,2,[],https://github.com/ebassi/graphene/pull/149,https://github.com/GeorgesStavracas,1,https://github.com/ebassi/graphene/pull/149,"All other similar types have this initializer, and it
is quite handy.
Proposed changes:

Add GRAPHENE_RECT_INIT_ZERO

Benchmark results:
(Does not apply)
Test suite changes:

Add an extra check in rect_init test","All other similar types have this initializer, and it
is quite handy.
Proposed changes:

Add GRAPHENE_RECT_INIT_ZERO

Benchmark results:
(Does not apply)
Test suite changes:

Add an extra check in rect_init test",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,149,2019-05-02T22:15:05Z,2019-05-03T18:22:21Z,2019-05-03T18:22:21Z,MERGED,True,17,3,2,https://github.com/GeorgesStavracas,rect: Add GRAPHENE_RECT_INIT_ZERO,2,[],https://github.com/ebassi/graphene/pull/149,https://github.com/3v1n0,2,https://github.com/ebassi/graphene/pull/149#issuecomment-488852411,"All other similar types have this initializer, and it
is quite handy.
Proposed changes:

Add GRAPHENE_RECT_INIT_ZERO

Benchmark results:
(Does not apply)
Test suite changes:

Add an extra check in rect_init test","Indeed useful.
LGTM :)",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,150,2019-05-17T10:41:29Z,2019-05-20T19:43:49Z,2019-05-20T19:43:49Z,CLOSED,False,25,0,1,https://github.com/alexlarsson,Add a test that roundtrips eulers via a matrix,1,[],https://github.com/ebassi/graphene/pull/150,https://github.com/alexlarsson,1,https://github.com/ebassi/graphene/pull/150,"This is currently failing, it seems like there is some kind of sign
issue in the matrix conversion.
I noted this in gthree, where its breaking the look_at function.","This is currently failing, it seems like there is some kind of sign
issue in the matrix conversion.
I noted this in gthree, where its breaking the look_at function.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,150,2019-05-17T10:41:29Z,2019-05-20T19:43:49Z,2019-05-20T19:43:49Z,CLOSED,False,25,0,1,https://github.com/alexlarsson,Add a test that roundtrips eulers via a matrix,1,[],https://github.com/ebassi/graphene/pull/150,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/150#issuecomment-493416461,"This is currently failing, it seems like there is some kind of sign
issue in the matrix conversion.
I noted this in gthree, where its breaking the look_at function.","Yeah, it's likely connected to the fact that I implemented the quaternion/euler/matrix conversions wrongâ€”see #96. I'll try to do an overhaul of the whole thing.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,151,2019-05-20T16:03:14Z,2019-05-20T19:43:49Z,2019-05-20T19:43:53Z,MERGED,True,716,368,9,https://github.com/ebassi,Reimplement Euler angles,14,[],https://github.com/ebassi/graphene/pull/151,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/151,"Fixes #96
Closes #150
Proposed changes:

reimplement the conversion between graphene_euler_t, graphene_matrix_t, and graphene_quaternion_t
extensively document the conventions used by graphene_euler_t
add more rotation orders to graphene_euler_order_t
fix the equality operator for graphene_quaternion_t

Test suite changes:

cherry pick the roundtrip test from #150
update the unit for graphene_quaternion_t","Fixes #96
Closes #150
Proposed changes:

reimplement the conversion between graphene_euler_t, graphene_matrix_t, and graphene_quaternion_t
extensively document the conventions used by graphene_euler_t
add more rotation orders to graphene_euler_order_t
fix the equality operator for graphene_quaternion_t

Test suite changes:

cherry pick the roundtrip test from #150
update the unit for graphene_quaternion_t",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,152,2019-05-21T09:29:02Z,2019-05-21T10:45:23Z,2019-05-21T10:45:23Z,MERGED,True,76,0,1,https://github.com/ebassi,Add code of conduct,1,[],https://github.com/ebassi/graphene/pull/152,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/152,"Graphene is used in various projects that are hosted on infrastructure
with a code of conduct, and it would be bad for us to not have one as
well.
The Contributor Covenant is probably the best generic option for a CoC
available to us. While Graphene does not have a ""team"", per se, writing
down the actual requirements for contributors is miles better than just
assuming good intentions.","Graphene is used in various projects that are hosted on infrastructure
with a code of conduct, and it would be bad for us to not have one as
well.
The Contributor Covenant is probably the best generic option for a CoC
available to us. While Graphene does not have a ""team"", per se, writing
down the actual requirements for contributors is miles better than just
assuming good intentions.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,154,2019-06-01T00:33:35Z,2019-06-18T15:27:44Z,2019-06-18T15:27:48Z,MERGED,True,72,33,7,https://github.com/ebassi,Remove float equality comparisons,3,[],https://github.com/ebassi/graphene/pull/154,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/154,"Stop comparing floating point values for equality; it's not safe to do.
Fixes #134","Stop comparing floating point values for equality; it's not safe to do.
Fixes #134",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,154,2019-06-01T00:33:35Z,2019-06-18T15:27:44Z,2019-06-18T15:27:48Z,MERGED,True,72,33,7,https://github.com/ebassi,Remove float equality comparisons,3,[],https://github.com/ebassi/graphene/pull/154,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/154#issuecomment-497940387,"Stop comparing floating point values for equality; it's not safe to do.
Fixes #134","Still WIP, but at least we just need to fix Graphene itself and not the test suite, after the switch to ÂµTest, which doesn't have traps like g_assert_cmpfloat().",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,155,2019-06-11T12:27:14Z,2019-06-11T13:27:40Z,2019-06-11T13:27:40Z,MERGED,True,5,1,2,https://github.com/lazka,CI: work around msys2 toolchain upgrade issues on appveyor,2,[],https://github.com/ebassi/graphene/pull/155,https://github.com/lazka,1,https://github.com/ebassi/graphene/pull/155,"error: failed to prepare transaction (could not satisfy dependencies)
:: installing mingw-w64-i686-gcc (9.1.0-1) breaks dependency 'mingw-w64-i686-gcc=7.3.0-2' required by mingw-w64-i686-gcc-ada
:: installing mingw-w64-i686-gcc (9.1.0-1) breaks dependency 'mingw-w64-i686-gcc=7.3.0-2' required by mingw-w64-i686-gcc-objc
:: installing mingw-w64-x86_64-gcc (9.1.0-1) breaks dependency 'mingw-w64-x86_64-gcc=8.2.0-3' required by mingw-w64-x86_64-gcc-ada
:: installing mingw-w64-x86_64-gcc (9.1.0-1) breaks dependency 'mingw-w64-x86_64-gcc=8.2.0-3' required by mingw-w64-x86_64-gcc-objc","error: failed to prepare transaction (could not satisfy dependencies)
:: installing mingw-w64-i686-gcc (9.1.0-1) breaks dependency 'mingw-w64-i686-gcc=7.3.0-2' required by mingw-w64-i686-gcc-ada
:: installing mingw-w64-i686-gcc (9.1.0-1) breaks dependency 'mingw-w64-i686-gcc=7.3.0-2' required by mingw-w64-i686-gcc-objc
:: installing mingw-w64-x86_64-gcc (9.1.0-1) breaks dependency 'mingw-w64-x86_64-gcc=8.2.0-3' required by mingw-w64-x86_64-gcc-ada
:: installing mingw-w64-x86_64-gcc (9.1.0-1) breaks dependency 'mingw-w64-x86_64-gcc=8.2.0-3' required by mingw-w64-x86_64-gcc-objc",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,155,2019-06-11T12:27:14Z,2019-06-11T13:27:40Z,2019-06-11T13:27:40Z,MERGED,True,5,1,2,https://github.com/lazka,CI: work around msys2 toolchain upgrade issues on appveyor,2,[],https://github.com/ebassi/graphene/pull/155,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/155#issuecomment-500822872,"error: failed to prepare transaction (could not satisfy dependencies)
:: installing mingw-w64-i686-gcc (9.1.0-1) breaks dependency 'mingw-w64-i686-gcc=7.3.0-2' required by mingw-w64-i686-gcc-ada
:: installing mingw-w64-i686-gcc (9.1.0-1) breaks dependency 'mingw-w64-i686-gcc=7.3.0-2' required by mingw-w64-i686-gcc-objc
:: installing mingw-w64-x86_64-gcc (9.1.0-1) breaks dependency 'mingw-w64-x86_64-gcc=8.2.0-3' required by mingw-w64-x86_64-gcc-ada
:: installing mingw-w64-x86_64-gcc (9.1.0-1) breaks dependency 'mingw-w64-x86_64-gcc=8.2.0-3' required by mingw-w64-x86_64-gcc-objc","I tried removing the ada and objc packages elsewhere, but AppVeyor constantly timed out. We'll see if it worksâ€¦",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,155,2019-06-11T12:27:14Z,2019-06-11T13:27:40Z,2019-06-11T13:27:40Z,MERGED,True,5,1,2,https://github.com/lazka,CI: work around msys2 toolchain upgrade issues on appveyor,2,[],https://github.com/ebassi/graphene/pull/155,https://github.com/lazka,3,https://github.com/ebassi/graphene/pull/155#issuecomment-500838648,"error: failed to prepare transaction (could not satisfy dependencies)
:: installing mingw-w64-i686-gcc (9.1.0-1) breaks dependency 'mingw-w64-i686-gcc=7.3.0-2' required by mingw-w64-i686-gcc-ada
:: installing mingw-w64-i686-gcc (9.1.0-1) breaks dependency 'mingw-w64-i686-gcc=7.3.0-2' required by mingw-w64-i686-gcc-objc
:: installing mingw-w64-x86_64-gcc (9.1.0-1) breaks dependency 'mingw-w64-x86_64-gcc=8.2.0-3' required by mingw-w64-x86_64-gcc-ada
:: installing mingw-w64-x86_64-gcc (9.1.0-1) breaks dependency 'mingw-w64-x86_64-gcc=8.2.0-3' required by mingw-w64-x86_64-gcc-objc",Looks good :),True,{}
ebassi/graphene,https://github.com/ebassi/graphene,156,2019-06-12T15:37:09Z,2019-06-18T15:28:01Z,2019-06-18T15:28:05Z,MERGED,True,48,33,2,https://github.com/ebassi,Fix ARM NEON support,6,[],https://github.com/ebassi/graphene/pull/156,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/156,"Fixes: #97, #147, #148
Proposed changes:

Properly detect ARM NEON support in the toolchain
Change the implementation for graphene_simd4f_cmp_* on ARM NEON
Remove the compiler warning raised when using the ARM NEON implementation
of graphene_simd4f_t

Test suite changes:

None","Fixes: #97, #147, #148
Proposed changes:

Properly detect ARM NEON support in the toolchain
Change the implementation for graphene_simd4f_cmp_* on ARM NEON
Remove the compiler warning raised when using the ARM NEON implementation
of graphene_simd4f_t

Test suite changes:

None",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,157,2019-06-19T07:26:24Z,2019-06-19T10:01:24Z,2019-06-19T10:01:25Z,MERGED,True,9,1,1,https://github.com/alexlarsson,graphene_quaternion_slerp: Always use the shortest path,1,[],https://github.com/ebassi/graphene/pull/157,https://github.com/alexlarsson,1,https://github.com/ebassi/graphene/pull/157,"As discussed in the ""Invertin Quaternions"" section in:
http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
We need to check if the dot product (i.e. cos(theta/2)) is
negative. If so, that means the rotation is > 180 degrees and
we should invert the rotation so as to take the shortest path.
Without this rotation animations in gthree get really weird when you
pass 360 degrees. I.e. interpolation is slow clockwise until 360
deg, where it switches to a very fast counter-clockwise rotation only
to then continue the slow clockwise rotation.","As discussed in the ""Invertin Quaternions"" section in:
http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
We need to check if the dot product (i.e. cos(theta/2)) is
negative. If so, that means the rotation is > 180 degrees and
we should invert the rotation so as to take the shortest path.
Without this rotation animations in gthree get really weird when you
pass 360 degrees. I.e. interpolation is slow clockwise until 360
deg, where it switches to a very fast counter-clockwise rotation only
to then continue the slow clockwise rotation.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,157,2019-06-19T07:26:24Z,2019-06-19T10:01:24Z,2019-06-19T10:01:25Z,MERGED,True,9,1,1,https://github.com/alexlarsson,graphene_quaternion_slerp: Always use the shortest path,1,[],https://github.com/ebassi/graphene/pull/157,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/157#issuecomment-503494411,"As discussed in the ""Invertin Quaternions"" section in:
http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
We need to check if the dot product (i.e. cos(theta/2)) is
negative. If so, that means the rotation is > 180 degrees and
we should invert the rotation so as to take the shortest path.
Without this rotation animations in gthree get really weird when you
pass 360 degrees. I.e. interpolation is slow clockwise until 360
deg, where it switches to a very fast counter-clockwise rotation only
to then continue the slow clockwise rotation.","Yeah, this makes senseâ€”also in light of 04b3aa3.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,157,2019-06-19T07:26:24Z,2019-06-19T10:01:24Z,2019-06-19T10:01:25Z,MERGED,True,9,1,1,https://github.com/alexlarsson,graphene_quaternion_slerp: Always use the shortest path,1,[],https://github.com/ebassi/graphene/pull/157,https://github.com/ebassi,3,https://github.com/ebassi/graphene/pull/157#issuecomment-503494572,"As discussed in the ""Invertin Quaternions"" section in:
http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
We need to check if the dot product (i.e. cos(theta/2)) is
negative. If so, that means the rotation is > 180 degrees and
we should invert the rotation so as to take the shortest path.
Without this rotation animations in gthree get really weird when you
pass 360 degrees. I.e. interpolation is slow clockwise until 360
deg, where it switches to a very fast counter-clockwise rotation only
to then continue the slow clockwise rotation.",The failure on Windows is unrelated.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,158,2019-06-21T11:17:14Z,2019-06-21T11:19:46Z,2019-06-21T11:19:49Z,MERGED,True,53,6,7,https://github.com/ebassi,Add coverage report,3,[],https://github.com/ebassi/graphene/pull/158,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/158,Use the Coveralls.io service to generate a coverage report when running our CI pipeline on Travis.,Use the Coveralls.io service to generate a coverage report when running our CI pipeline on Travis.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,160,2019-06-24T23:40:06Z,2019-06-24T23:53:31Z,2019-06-24T23:53:33Z,MERGED,True,0,15,1,https://github.com/ebassi,Remove unused function,1,[],https://github.com/ebassi/graphene/pull/160,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/160,"It's tripping -Wunused on Clang (though not on GCC).
Fixes: #159","It's tripping -Wunused on Clang (though not on GCC).
Fixes: #159",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,161,2019-08-07T08:59:17Z,2019-08-07T10:14:49Z,2019-08-07T10:14:52Z,MERGED,True,81,2,5,https://github.com/ebassi,Add lerp operator for vector types,1,[],https://github.com/ebassi/graphene/pull/161,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/161,"We have lerp() for every other vector-like type, including the SIMD
implementation, but we don't have one for the 2, 3, and 4-component
vector type wrappers.
Proposed changes:

Add graphene_vec2_interpolate()
Add graphene_vec3_interpolate()
Add graphene_vec4_interpolate()","We have lerp() for every other vector-like type, including the SIMD
implementation, but we don't have one for the 2, 3, and 4-component
vector type wrappers.
Proposed changes:

Add graphene_vec2_interpolate()
Add graphene_vec3_interpolate()
Add graphene_vec4_interpolate()",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,162,2019-08-07T09:02:20Z,2019-08-07T10:14:32Z,2019-08-07T10:15:02Z,MERGED,True,88,1,3,https://github.com/ebassi,Add quaternion operators,2,[],https://github.com/ebassi/graphene/pull/162,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/162,"The operators coverage for graphene_quaternion_t is a bit low. As the fields in the quaternion structure are private, in order to implement common operations, like adding, multiplying, and scaling, you'd have to convert a quaternion into a vec4, operate on the vec4, and then turn the vec4 back into a quaternion. This is not really efficient, and could be easily solved by providing an actual API.
Proposed changes:

Add graphene_quaternion_add()
Add graphene_quaternion_multiply()
Add graphene_quaternion_scale()","The operators coverage for graphene_quaternion_t is a bit low. As the fields in the quaternion structure are private, in order to implement common operations, like adding, multiplying, and scaling, you'd have to convert a quaternion into a vec4, operate on the vec4, and then turn the vec4 back into a quaternion. This is not really efficient, and could be easily solved by providing an actual API.
Proposed changes:

Add graphene_quaternion_add()
Add graphene_quaternion_multiply()
Add graphene_quaternion_scale()",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,163,2019-08-07T17:11:35Z,2019-08-07T19:35:12Z,2019-08-07T19:35:16Z,MERGED,True,67,0,3,https://github.com/ebassi,Add graphene_plane_transform(),1,[],https://github.com/ebassi/graphene/pull/163,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/163,Transform a plane using the given matrices.,Transform a plane using the given matrices.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,164,2019-08-07T19:34:22Z,2019-08-07T19:47:10Z,2019-08-07T19:47:13Z,MERGED,True,24,16,2,https://github.com/ebassi,Improve the graphene_ray_t documentation,3,[],https://github.com/ebassi/graphene/pull/164,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/164,"Fixes #63
Proposed changes:

Provide a use case for graphene_ray_t
Document properly what graphene_ray_distance_to_point() does
Improve the test description","Fixes #63
Proposed changes:

Provide a use case for graphene_ray_t
Document properly what graphene_ray_distance_to_point() does
Improve the test description",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,166,2019-08-08T10:06:12Z,2019-08-08T13:44:57Z,2019-08-08T13:45:00Z,MERGED,True,121,10,2,https://github.com/ebassi,Fix graphene_box_get_center(),5,[],https://github.com/ebassi/graphene/pull/166,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/166,"Fixes #165
Proposed changes:

Fix various box methods to handle empty and infinite boxes
Fix graphene_box_get_center() to take into account the box.min point
Fix graphene_box_get_bounding_sphere() to use the box center instead of open coding it

Test suite changes:

Add expectations to the graphene_box_get_center() specification that check the behaviour of the function when box.min is not centered in (0, 0, 0)","Fixes #165
Proposed changes:

Fix various box methods to handle empty and infinite boxes
Fix graphene_box_get_center() to take into account the box.min point
Fix graphene_box_get_bounding_sphere() to use the box center instead of open coding it

Test suite changes:

Add expectations to the graphene_box_get_center() specification that check the behaviour of the function when box.min is not centered in (0, 0, 0)",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,167,2019-08-08T16:04:18Z,2019-08-08T16:32:40Z,2019-08-08T16:32:43Z,MERGED,True,191,107,62,https://github.com/ebassi,Reorganise the source repository,10,[],https://github.com/ebassi/graphene/pull/167,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/167,"Proposed changes:

move public headers under include
move tests to the top level directory
generate a simpler pkg-config file for graphene-gobject","Proposed changes:

move public headers under include
move tests to the top level directory
generate a simpler pkg-config file for graphene-gobject",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,169,2019-08-22T15:00:40Z,2019-08-25T08:38:50Z,2019-08-25T08:38:51Z,MERGED,True,5,5,1,https://github.com/alexlarsson,Fix graphene_ray_transform,1,[],https://github.com/ebassi/graphene/pull/169,https://github.com/alexlarsson,1,https://github.com/ebassi/graphene/pull/169,"We can't use graphene_matrix_transform_vec3() to transform the origin
because we need to point to respect transformations (but not the
directions, so we can use vec3 there instead of reconstructing
the direction).
Fixes #...
Proposed changes:

...

Benchmark results:

Before: ...
After: ...

Test suite changes:

...","We can't use graphene_matrix_transform_vec3() to transform the origin
because we need to point to respect transformations (but not the
directions, so we can use vec3 there instead of reconstructing
the direction).
Fixes #...
Proposed changes:

...

Benchmark results:

Before: ...
After: ...

Test suite changes:

...",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,169,2019-08-22T15:00:40Z,2019-08-25T08:38:50Z,2019-08-25T08:38:51Z,MERGED,True,5,5,1,https://github.com/alexlarsson,Fix graphene_ray_transform,1,[],https://github.com/ebassi/graphene/pull/169,https://github.com/alexlarsson,2,https://github.com/ebassi/graphene/pull/169#issuecomment-523945122,"We can't use graphene_matrix_transform_vec3() to transform the origin
because we need to point to respect transformations (but not the
directions, so we can use vec3 there instead of reconstructing
the direction).
Fixes #...
Proposed changes:

...

Benchmark results:

Before: ...
After: ...

Test suite changes:

...","I added support for raycasting to gthree HEAD (see examples/interactive), and without this its totally broken. With this fix it mostl works although sometimes it seems something goes wrong and nothing is selected.
Also, part of the support was adding a bunch of ray-to-$primitive helpers, and these should probably be in graphene: https://github.com/alexlarsson/gthree/blob/master/gthree/gthreemesh.c#L10",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,170,2019-08-25T08:44:04Z,2019-08-26T13:36:58Z,2019-08-26T13:37:01Z,MERGED,True,142,90,3,https://github.com/ebassi,Matrix decompose,2,[],https://github.com/ebassi/graphene/pull/170,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/170,"Proposed changes:

Add graphene_matrix_decompose()","Proposed changes:

Add graphene_matrix_decompose()",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,171,2019-09-04T13:08:50Z,2019-09-08T16:27:24Z,2019-09-08T20:40:39Z,MERGED,True,631,59,9,https://github.com/ebassi,Last minute API additions for Gthree,6,[],https://github.com/ebassi/graphene/pull/171,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/171,"Gthree has some in tree functionality that really belongs to Graphene.
Proposed changes:

add graphene_triangle_init_from_float() initializer; this is useful for buffer objects with lots of triangles stored as vectors of floating point values
add intersection methods for graphene_ray_t; this is used for hit testing objects like spheres, boxes, and triangles
add graphene_triangle_get_uv()","Gthree has some in tree functionality that really belongs to Graphene.
Proposed changes:

add graphene_triangle_init_from_float() initializer; this is useful for buffer objects with lots of triangles stored as vectors of floating point values
add intersection methods for graphene_ray_t; this is used for hit testing objects like spheres, boxes, and triangles
add graphene_triangle_get_uv()",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,171,2019-09-04T13:08:50Z,2019-09-08T16:27:24Z,2019-09-08T20:40:39Z,MERGED,True,631,59,9,https://github.com/ebassi,Last minute API additions for Gthree,6,[],https://github.com/ebassi/graphene/pull/171,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/171#issuecomment-527906260,"Gthree has some in tree functionality that really belongs to Graphene.
Proposed changes:

add graphene_triangle_init_from_float() initializer; this is useful for buffer objects with lots of triangles stored as vectors of floating point values
add intersection methods for graphene_ray_t; this is used for hit testing objects like spheres, boxes, and triangles
add graphene_triangle_get_uv()",Would be nice if @alexlarsson could do a review so I can merge it in time for next week's GNOME 3.34.0 release.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,171,2019-09-04T13:08:50Z,2019-09-08T16:27:24Z,2019-09-08T20:40:39Z,MERGED,True,631,59,9,https://github.com/ebassi,Last minute API additions for Gthree,6,[],https://github.com/ebassi/graphene/pull/171,https://github.com/alexlarsson,3,https://github.com/ebassi/graphene/pull/171#issuecomment-527926542,"Gthree has some in tree functionality that really belongs to Graphene.
Proposed changes:

add graphene_triangle_init_from_float() initializer; this is useful for buffer objects with lots of triangles stored as vectors of floating point values
add intersection methods for graphene_ray_t; this is used for hit testing objects like spheres, boxes, and triangles
add graphene_triangle_get_uv()","So, this looks overall good to me, but there is something weird with the triangle intersection kind.
I ported gthree to use this new API here:
https://github.com/alexlarsson/gthree/tree/use-graphene-intersection
However, with this PR as-is, it gets the tri intersection kind wrong here: https://github.com/alexlarsson/gthree/blob/use-graphene-intersection/gthree/gthreemesh.c#L217 as can be seen in the interactive demo. If i switch SIDE_FRONT/BACK around it works, but otherwise it doesn't.
The fix for this is to switch the two kinds in intersect_triangle like so:

diff --git a/src/graphene-ray.c b/src/graphene-ray.c
index 56bc051..b0bf411 100644
--- a/src/graphene-ray.c
+++ b/src/graphene-ray.c
@@ -661,13 +661,13 @@ graphene_ray_intersect_triangle (const graphene_ray_t      *r,
     }
   else if (DdN > 0)
     {
-      kind = GRAPHENE_RAY_INTERSECTION_KIND_ENTER;
+      kind = GRAPHENE_RAY_INTERSECTION_KIND_LEAVE;
       sign = 1.f;
 
     }
   else
     {
-      kind = GRAPHENE_RAY_INTERSECTION_KIND_LEAVE;
+      kind = GRAPHENE_RAY_INTERSECTION_KIND_ENTER;
       sign = -1.f;
       DdN = -DdN;
     }

This actually matches what three.js does here:
https://github.com/alexlarsson/gthree/blob/use-graphene-intersection/gthree/gthreemesh.c#L217
Where if DdN > 0 and we're backface culling then we have no intersection, which totally smells like a LEAVE kind of intersection to me.
This was actually how I coded the gthree version of the intersector initially, but I had to switch it around to make the code work. Reverting this to what three.js does is nice, but I don't understand what the difference is. Why did I have to revert it to make the previous version in gthree code work???",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,171,2019-09-04T13:08:50Z,2019-09-08T16:27:24Z,2019-09-08T20:40:39Z,MERGED,True,631,59,9,https://github.com/ebassi,Last minute API additions for Gthree,6,[],https://github.com/ebassi/graphene/pull/171,https://github.com/alexlarsson,4,https://github.com/ebassi/graphene/pull/171#issuecomment-527929690,"Gthree has some in tree functionality that really belongs to Graphene.
Proposed changes:

add graphene_triangle_init_from_float() initializer; this is useful for buffer objects with lots of triangles stored as vectors of floating point values
add intersection methods for graphene_ray_t; this is used for hit testing objects like spheres, boxes, and triangles
add graphene_triangle_get_uv()","Ah, i found the difference:
-  kind = ray_intersect_triangle (local_ray, vC, vB, vA, &t);
+  kind = graphene_ray_intersect_triangle (local_ray, triangle, &t);

I.e. the old gthree code passed the vertices in the wrong order, effectively flipping the triangle.
So, the patch about is right and should be applied.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,171,2019-09-04T13:08:50Z,2019-09-08T16:27:24Z,2019-09-08T20:40:39Z,MERGED,True,631,59,9,https://github.com/ebassi,Last minute API additions for Gthree,6,[],https://github.com/ebassi/graphene/pull/171,https://github.com/alexlarsson,5,https://github.com/ebassi/graphene/pull/171#issuecomment-529239611,"Gthree has some in tree functionality that really belongs to Graphene.
Proposed changes:

add graphene_triangle_init_from_float() initializer; this is useful for buffer objects with lots of triangles stored as vectors of floating point values
add intersection methods for graphene_ray_t; this is used for hit testing objects like spheres, boxes, and triangles
add graphene_triangle_get_uv()","So, this looks good. I thought there were some issue with the sign of the v coord initially, but that was just due to some weirdness in how the graphene box primitive sets up the uv coords.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,173,2019-11-12T03:14:15Z,2019-11-13T15:49:21Z,2019-11-13T15:50:07Z,MERGED,True,1,1,1,https://github.com/seungha-yang,meson: Don't error with MSVC C4819 warning,1,[],https://github.com/ebassi/graphene/pull/173,https://github.com/seungha-yang,1,https://github.com/ebassi/graphene/pull/173,"The compiler warning C4819 (encoding related warning) is a trivial
thing on non-English locale system. Instead of error out,
explicitly specify encoding as ""utf-8"".","The compiler warning C4819 (encoding related warning) is a trivial
thing on non-English locale system. Instead of error out,
explicitly specify encoding as ""utf-8"".",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,173,2019-11-12T03:14:15Z,2019-11-13T15:49:21Z,2019-11-13T15:50:07Z,MERGED,True,1,1,1,https://github.com/seungha-yang,meson: Don't error with MSVC C4819 warning,1,[],https://github.com/ebassi/graphene/pull/173,https://github.com/nirbheek,2,https://github.com/ebassi/graphene/pull/173#issuecomment-553453416,"The compiler warning C4819 (encoding related warning) is a trivial
thing on non-English locale system. Instead of error out,
explicitly specify encoding as ""utf-8"".",This was discovered in gstreamer: https://gitlab.freedesktop.org/gstreamer/cerbero/merge_requests/322,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,173,2019-11-12T03:14:15Z,2019-11-13T15:49:21Z,2019-11-13T15:50:07Z,MERGED,True,1,1,1,https://github.com/seungha-yang,meson: Don't error with MSVC C4819 warning,1,[],https://github.com/ebassi/graphene/pull/173,https://github.com/ebassi,3,https://github.com/ebassi/graphene/pull/173#issuecomment-553463166,"The compiler warning C4819 (encoding related warning) is a trivial
thing on non-English locale system. Instead of error out,
explicitly specify encoding as ""utf-8"".","It does make sense to me. Thanks for the merge request, @pudding8757, and thanks to @nirbheek for the reference to the issue on GStreamer.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,174,2019-12-01T12:01:33Z,,2019-12-03T19:41:57Z,OPEN,False,22,16,4,https://github.com/lantw44,Don't use obsolete isinff and isnanf functions,1,[],https://github.com/ebassi/graphene/pull/174,https://github.com/lantw44,1,https://github.com/ebassi/graphene/pull/174,"GNU libc already marks isinff and isnanf functions as obsolete. They
have been replaced by isinf and isnan macros defined by C99. Since we
already requires C99 in this project, it should be nice if we can
switch to standard macros.
Proposed changes:

Drop the use of non-standard and obsolete isinff and isnanf functions.

Benchmark results:

None

Test suite changes:

None","GNU libc already marks isinff and isnanf functions as obsolete. They
have been replaced by isinf and isnan macros defined by C99. Since we
already requires C99 in this project, it should be nice if we can
switch to standard macros.
Proposed changes:

Drop the use of non-standard and obsolete isinff and isnanf functions.

Benchmark results:

None

Test suite changes:

None",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,174,2019-12-01T12:01:33Z,,2019-12-03T19:41:57Z,OPEN,False,22,16,4,https://github.com/lantw44,Don't use obsolete isinff and isnanf functions,1,[],https://github.com/ebassi/graphene/pull/174,https://github.com/lantw44,2,https://github.com/ebassi/graphene/pull/174#issuecomment-560099636,"GNU libc already marks isinff and isnanf functions as obsolete. They
have been replaced by isinf and isnan macros defined by C99. Since we
already requires C99 in this project, it should be nice if we can
switch to standard macros.
Proposed changes:

Drop the use of non-standard and obsolete isinff and isnanf functions.

Benchmark results:

None

Test suite changes:

None",It currently fails with GCC __builtin_isinf when -O1 or higher is used. I haven't found out why it fails. It works with Clang __builtin_isinf and FreeBSD libc. GNU libc just defines isinf as __builtin_isinf.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,174,2019-12-01T12:01:33Z,,2019-12-03T19:41:57Z,OPEN,False,22,16,4,https://github.com/lantw44,Don't use obsolete isinff and isnanf functions,1,[],https://github.com/ebassi/graphene/pull/174,https://github.com/ebassi,3,https://github.com/ebassi/graphene/pull/174#issuecomment-561325167,"GNU libc already marks isinff and isnanf functions as obsolete. They
have been replaced by isinf and isnan macros defined by C99. Since we
already requires C99 in this project, it should be nice if we can
switch to standard macros.
Proposed changes:

Drop the use of non-standard and obsolete isinff and isnanf functions.

Benchmark results:

None

Test suite changes:

None","I initially used isinf() and isnan(), but those ended up breaking when using GCC because it tried to promote floats to doubles, and the results wouldn't match any moreâ€”especially when using GCC vectorisation.
It could very well be a bug in GCC.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,175,2019-12-17T07:26:34Z,2019-12-30T21:08:06Z,2019-12-30T21:08:06Z,MERGED,True,16,8,2,https://github.com/fanc999,Few fixes for Visual Studio builds,3,[],https://github.com/ebassi/graphene/pull/175,https://github.com/fanc999,1,https://github.com/ebassi/graphene/pull/175,"Hi,
This updates the build for Visual Studio builds, as follows:


Support Visual Studio 2013 builds better-re-enable erroring out on C4819 when /utf-8 (a Visual Studio 2015+ feature) is not supported, to avoid mis-compilations, and let people know that it is actually possible to build Graphene as-is with Visual Studio 2013, but at the cost of needing to explicitly disable building and running the tests.


Disable SSE2 builds for all 32-bit x86 Visual Studio builds.  This is because although Visual Studio 2017 and 2019 improved on the __vectorcall calling convention (ABI), that needs to be used for 32-bit x86 builds, which is enough for running Graphene itself with the test programs, but this proved to be not enough to run more involved programs, such as GTK master.  Note that x64 Visual Studio builds continue to support SSE2/SSE4.1 as they did before, Visual Studio 2013 included.


With blessings, thank you!","Hi,
This updates the build for Visual Studio builds, as follows:


Support Visual Studio 2013 builds better-re-enable erroring out on C4819 when /utf-8 (a Visual Studio 2015+ feature) is not supported, to avoid mis-compilations, and let people know that it is actually possible to build Graphene as-is with Visual Studio 2013, but at the cost of needing to explicitly disable building and running the tests.


Disable SSE2 builds for all 32-bit x86 Visual Studio builds.  This is because although Visual Studio 2017 and 2019 improved on the __vectorcall calling convention (ABI), that needs to be used for 32-bit x86 builds, which is enough for running Graphene itself with the test programs, but this proved to be not enough to run more involved programs, such as GTK master.  Note that x64 Visual Studio builds continue to support SSE2/SSE4.1 as they did before, Visual Studio 2013 included.


With blessings, thank you!",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,176,2019-12-21T21:16:32Z,2019-12-21T22:00:06Z,2019-12-21T22:00:10Z,MERGED,True,29,16,1,https://github.com/ebassi,Normalize input rectangles just once,1,[],https://github.com/ebassi/graphene/pull/176,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/176,"If we're calling accessors functions on the same graphene_rect_t
multiple times, we end up normalizing the same rectangle. Let's do this
once at the start, and call the accessors on the normalized rectangle to
avoid tripping the normalization code paths.","If we're calling accessors functions on the same graphene_rect_t
multiple times, we end up normalizing the same rectangle. Let's do this
once at the start, and call the accessors on the normalized rectangle to
avoid tripping the normalization code paths.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,177,2020-01-07T19:57:36Z,2020-01-08T15:43:20Z,2020-01-08T15:43:20Z,MERGED,True,8,1,1,https://github.com/tp-m,meson: pick up gobject from a subproject fallback as well,1,[],https://github.com/ebassi/graphene/pull/177,https://github.com/tp-m,1,https://github.com/ebassi/graphene/pull/177,Makes graphene find gobject in a gst-build on Windows scenario.,Makes graphene find gobject in a gst-build on Windows scenario.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,177,2020-01-07T19:57:36Z,2020-01-08T15:43:20Z,2020-01-08T15:43:20Z,MERGED,True,8,1,1,https://github.com/tp-m,meson: pick up gobject from a subproject fallback as well,1,[],https://github.com/ebassi/graphene/pull/177,https://github.com/tp-m,2,https://github.com/ebassi/graphene/pull/177#issuecomment-571774817,Makes graphene find gobject in a gst-build on Windows scenario.,There's something else I need to investigate as well g-ir-scanner related,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,177,2020-01-07T19:57:36Z,2020-01-08T15:43:20Z,2020-01-08T15:43:20Z,MERGED,True,8,1,1,https://github.com/tp-m,meson: pick up gobject from a subproject fallback as well,1,[],https://github.com/ebassi/graphene/pull/177,https://github.com/tp-m,3,https://github.com/ebassi/graphene/pull/177#issuecomment-571827242,Makes graphene find gobject in a gst-build on Windows scenario.,"There's something else I need to investigate as well g-ir-scanner related

Unrelated, this one should be good to go, I'll do a separate PR for other things.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,177,2020-01-07T19:57:36Z,2020-01-08T15:43:20Z,2020-01-08T15:43:20Z,MERGED,True,8,1,1,https://github.com/tp-m,meson: pick up gobject from a subproject fallback as well,1,[],https://github.com/ebassi/graphene/pull/177,https://github.com/ebassi,4,https://github.com/ebassi/graphene/pull/177#issuecomment-572111628,Makes graphene find gobject in a gst-build on Windows scenario.,"I assume this works in the case where graphene is built as a sub-project of another Meson project that also depends on gobject?
It would be nice to leave a comment in the meson.build file to that effect.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,177,2020-01-07T19:57:36Z,2020-01-08T15:43:20Z,2020-01-08T15:43:20Z,MERGED,True,8,1,1,https://github.com/tp-m,meson: pick up gobject from a subproject fallback as well,1,[],https://github.com/ebassi/graphene/pull/177,https://github.com/tp-m,5,https://github.com/ebassi/graphene/pull/177#issuecomment-572120364,Makes graphene find gobject in a gst-build on Windows scenario.,"I assume this works in the case where graphene is built as a sub-project of another Meson project that also depends on gobject?

Correct. I'm trying to add graphene as subproject to GStreamers's gst-build (it's used in our OpenGL plugin in gst-plugins-base) and make things work on Windows where there's no system install of GObject.

It would be nice to leave a comment in the meson.build file to that effect.

Done. (Plus some gratuitious line wrapping, since it was getting a bit long.)",True,{'THUMBS_UP': ['https://github.com/ebassi']}
ebassi/graphene,https://github.com/ebassi/graphene,178,2020-01-08T00:08:44Z,2021-02-12T12:58:33Z,2021-02-12T12:58:33Z,CLOSED,False,1,1,1,https://github.com/tp-m,meson: don't build introspection if g-ir-scanner is not available,1,[],https://github.com/ebassi/graphene/pull/178,https://github.com/tp-m,1,https://github.com/ebassi/graphene/pull/178,,,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,178,2020-01-08T00:08:44Z,2021-02-12T12:58:33Z,2021-02-12T12:58:33Z,CLOSED,False,1,1,1,https://github.com/tp-m,meson: don't build introspection if g-ir-scanner is not available,1,[],https://github.com/ebassi/graphene/pull/178,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/178#issuecomment-671454199,,@tp-m Any news on this?,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,178,2020-01-08T00:08:44Z,2021-02-12T12:58:33Z,2021-02-12T12:58:33Z,CLOSED,False,1,1,1,https://github.com/tp-m,meson: don't build introspection if g-ir-scanner is not available,1,[],https://github.com/ebassi/graphene/pull/178,https://github.com/tp-m,3,https://github.com/ebassi/graphene/pull/178#issuecomment-671614825,,"@tp-m Any news on this?

I'm not really sure what the outcome of the discussion was.
Should I change it to a feature option, even though Meson doesn't provide a migration path yet?
I kinda assumed this depends on mesonbuild/meson#7444",True,{'THUMBS_UP': ['https://github.com/ebassi']}
ebassi/graphene,https://github.com/ebassi/graphene,178,2020-01-08T00:08:44Z,2021-02-12T12:58:33Z,2021-02-12T12:58:33Z,CLOSED,False,1,1,1,https://github.com/tp-m,meson: don't build introspection if g-ir-scanner is not available,1,[],https://github.com/ebassi/graphene/pull/178,https://github.com/ebassi,4,https://github.com/ebassi/graphene/pull/178#issuecomment-673541142,,"I'm not really sure what the outcome of the discussion was.

I'm okay with migrating to a feature option, but I'd like to wait on the Meson issue.
Additionally, I'd still like for Meson to automatically disable introspection if the tools are not available, instead of having to check myself.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,178,2020-01-08T00:08:44Z,2021-02-12T12:58:33Z,2021-02-12T12:58:33Z,CLOSED,False,1,1,1,https://github.com/tp-m,meson: don't build introspection if g-ir-scanner is not available,1,[],https://github.com/ebassi/graphene/pull/178,https://github.com/xclaesse,5,https://github.com/ebassi/graphene/pull/178#issuecomment-710638535,,@ebassi @tp-m I made a more consistent patch in #200. It switch to feature option with the same logic we have in GStreamer and other GNOME modules including GTK+.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,178,2020-01-08T00:08:44Z,2021-02-12T12:58:33Z,2021-02-12T12:58:33Z,CLOSED,False,1,1,1,https://github.com/tp-m,meson: don't build introspection if g-ir-scanner is not available,1,[],https://github.com/ebassi/graphene/pull/178,https://github.com/ebassi,6,https://github.com/ebassi/graphene/pull/178#issuecomment-778180474,,"The merge request in #200 has been merged, so I think we can close this.
Thanks!",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,179,2020-01-08T00:42:07Z,2020-01-08T15:08:50Z,2020-01-08T15:08:50Z,MERGED,True,11,0,1,https://github.com/tp-m,meson: expose graphene_gobject_dep variable for graphene-gobject,1,[],https://github.com/ebassi/graphene/pull/179,https://github.com/tp-m,1,https://github.com/ebassi/graphene/pull/179,"Expose a separate variable for graphene-gobject for subproject usage
support, so the superproject and sibling subprojects can check for this
directly as part of the dependency() fallback: logic instead of having to
poke at the build_gobject subproject variable. This mirrors the pkg-config
lookup logic where we have a dedicated .pc file for graphene-gobject as well.
If gobject support was disabled the variable will be set to a not-found dep.","Expose a separate variable for graphene-gobject for subproject usage
support, so the superproject and sibling subprojects can check for this
directly as part of the dependency() fallback: logic instead of having to
poke at the build_gobject subproject variable. This mirrors the pkg-config
lookup logic where we have a dedicated .pc file for graphene-gobject as well.
If gobject support was disabled the variable will be set to a not-found dep.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,181,2020-01-13T12:13:11Z,2020-01-13T12:27:23Z,2020-01-13T12:27:27Z,MERGED,True,12,10,5,https://github.com/ebassi,Small clean ups,4,[],https://github.com/ebassi/graphene/pull/181,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/181,"Proposed changes:

Clean up the expectation strings for improved readability
Update the ÂµTest submodule to incorporate the latest fixes from upstream
Fix #180","Proposed changes:

Clean up the expectation strings for improved readability
Update the ÂµTest submodule to incorporate the latest fixes from upstream
Fix #180",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,182,2020-04-02T14:52:28Z,2020-04-02T15:28:17Z,2020-04-02T15:28:17Z,MERGED,True,5,1,1,https://github.com/rossburton,tests: installed tests should use TAP,1,[],https://github.com/ebassi/graphene/pull/182,https://github.com/rossburton,1,https://github.com/ebassi/graphene/pull/182,"The GNOME installed tests system expects the test output to be TAP:
""The key Output (if specified) can only take one value at present, which is TAP. This specifies that the test outputs Test Anything Protocol.""
(https://wiki.gnome.org/Initiatives/GnomeGoals/InstalledTests)
Export MUTEST_OUTPUT=tap so this is the case.
Fixes #...
Proposed changes:

...

Benchmark results:

Before: ...
After: ...

Test suite changes:

...","The GNOME installed tests system expects the test output to be TAP:
""The key Output (if specified) can only take one value at present, which is TAP. This specifies that the test outputs Test Anything Protocol.""
(https://wiki.gnome.org/Initiatives/GnomeGoals/InstalledTests)
Export MUTEST_OUTPUT=tap so this is the case.
Fixes #...
Proposed changes:

...

Benchmark results:

Before: ...
After: ...

Test suite changes:

...",True,{'THUMBS_UP': ['https://github.com/ebassi']}
ebassi/graphene,https://github.com/ebassi/graphene,183,2020-04-03T11:20:25Z,2020-04-03T12:15:26Z,2020-04-03T12:33:31Z,MERGED,True,5,4,1,https://github.com/nirbheek,meson: Fix check for builtype arguments,1,[],https://github.com/ebassi/graphene/pull/183,https://github.com/nirbheek,1,https://github.com/ebassi/graphene/pull/183,"get_option('buildtype') will return 'custom' for most combinations
of -Doptimization and -Ddebug, but those two will always be set
correctly if only -Dbuildtype is set. So we should look at those
options directly.
For the two-way mapping between buildtype and optimization + debug, see this table:
https://mesonbuild.com/Builtin-options.html#build-type-options
Same change as glib: https://gitlab.gnome.org/GNOME/glib/merge_requests/1433","get_option('buildtype') will return 'custom' for most combinations
of -Doptimization and -Ddebug, but those two will always be set
correctly if only -Dbuildtype is set. So we should look at those
options directly.
For the two-way mapping between buildtype and optimization + debug, see this table:
https://mesonbuild.com/Builtin-options.html#build-type-options
Same change as glib: https://gitlab.gnome.org/GNOME/glib/merge_requests/1433",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,183,2020-04-03T11:20:25Z,2020-04-03T12:15:26Z,2020-04-03T12:33:31Z,MERGED,True,5,4,1,https://github.com/nirbheek,meson: Fix check for builtype arguments,1,[],https://github.com/ebassi/graphene/pull/183,https://github.com/nirbheek,2,https://github.com/ebassi/graphene/pull/183#issuecomment-608386486,"get_option('buildtype') will return 'custom' for most combinations
of -Doptimization and -Ddebug, but those two will always be set
correctly if only -Dbuildtype is set. So we should look at those
options directly.
For the two-way mapping between buildtype and optimization + debug, see this table:
https://mesonbuild.com/Builtin-options.html#build-type-options
Same change as glib: https://gitlab.gnome.org/GNOME/glib/merge_requests/1433","Test failure seems to be unrelated?

4/21 graphene / box                          ERROR   0.988502025604248 s",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,183,2020-04-03T11:20:25Z,2020-04-03T12:15:26Z,2020-04-03T12:33:31Z,MERGED,True,5,4,1,https://github.com/nirbheek,meson: Fix check for builtype arguments,1,[],https://github.com/ebassi/graphene/pull/183,https://github.com/ebassi,3,https://github.com/ebassi/graphene/pull/183#issuecomment-608390414,"get_option('buildtype') will return 'custom' for most combinations
of -Doptimization and -Ddebug, but those two will always be set
correctly if only -Dbuildtype is set. So we should look at those
options directly.
For the two-way mapping between buildtype and optimization + debug, see this table:
https://mesonbuild.com/Builtin-options.html#build-type-options
Same change as glib: https://gitlab.gnome.org/GNOME/glib/merge_requests/1433",@nirbheek The transient failure in the graphene_box_t on MSYS2/x86 is known.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,183,2020-04-03T11:20:25Z,2020-04-03T12:15:26Z,2020-04-03T12:33:31Z,MERGED,True,5,4,1,https://github.com/nirbheek,meson: Fix check for builtype arguments,1,[],https://github.com/ebassi/graphene/pull/183,https://github.com/nirbheek,4,https://github.com/ebassi/graphene/pull/183#issuecomment-608400060,"get_option('buildtype') will return 'custom' for most combinations
of -Doptimization and -Ddebug, but those two will always be set
correctly if only -Dbuildtype is set. So we should look at those
options directly.
For the two-way mapping between buildtype and optimization + debug, see this table:
https://mesonbuild.com/Builtin-options.html#build-type-options
Same change as glib: https://gitlab.gnome.org/GNOME/glib/merge_requests/1433",Should I re-push till the test passes?,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,183,2020-04-03T11:20:25Z,2020-04-03T12:15:26Z,2020-04-03T12:33:31Z,MERGED,True,5,4,1,https://github.com/nirbheek,meson: Fix check for builtype arguments,1,[],https://github.com/ebassi/graphene/pull/183,https://github.com/ebassi,5,https://github.com/ebassi/graphene/pull/183#issuecomment-608400548,"get_option('buildtype') will return 'custom' for most combinations
of -Doptimization and -Ddebug, but those two will always be set
correctly if only -Dbuildtype is set. So we should look at those
options directly.
For the two-way mapping between buildtype and optimization + debug, see this table:
https://mesonbuild.com/Builtin-options.html#build-type-options
Same change as glib: https://gitlab.gnome.org/GNOME/glib/merge_requests/1433","Nah, it's just annoying, and I care very little about 32bit platforms.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,186,2020-06-15T16:03:21Z,2020-06-15T16:29:53Z,2020-06-15T16:29:53Z,MERGED,True,30,3,1,https://github.com/alexlarsson,matrix_init_look_at: Handle corner cases better,1,[],https://github.com/ebassi/graphene/pull/186,https://github.com/alexlarsson,1,https://github.com/ebassi/graphene/pull/186,"graphene_matrix_init_look_at() currently breaks badly in the case
where the given point is either the same as the eye, or in ""up"" direction
from the eye.
The exact definition of look_at() kinda breaks down in this situation,
but this is the behaviour three.js uses, and its better than nothing.","graphene_matrix_init_look_at() currently breaks badly in the case
where the given point is either the same as the eye, or in ""up"" direction
from the eye.
The exact definition of look_at() kinda breaks down in this situation,
but this is the behaviour three.js uses, and its better than nothing.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,186,2020-06-15T16:03:21Z,2020-06-15T16:29:53Z,2020-06-15T16:29:53Z,MERGED,True,30,3,1,https://github.com/alexlarsson,matrix_init_look_at: Handle corner cases better,1,[],https://github.com/ebassi/graphene/pull/186,https://github.com/alexlarsson,2,https://github.com/ebassi/graphene/pull/186#issuecomment-644228458,"graphene_matrix_init_look_at() currently breaks badly in the case
where the given point is either the same as the eye, or in ""up"" direction
from the eye.
The exact definition of look_at() kinda breaks down in this situation,
but this is the behaviour three.js uses, and its better than nothing.","FTR, the green plane in examples/clipping in gthree master is fixed by this commit.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,186,2020-06-15T16:03:21Z,2020-06-15T16:29:53Z,2020-06-15T16:29:53Z,MERGED,True,30,3,1,https://github.com/alexlarsson,matrix_init_look_at: Handle corner cases better,1,[],https://github.com/ebassi/graphene/pull/186,https://github.com/ebassi,3,https://github.com/ebassi/graphene/pull/186#issuecomment-644229852,"graphene_matrix_init_look_at() currently breaks badly in the case
where the given point is either the same as the eye, or in ""up"" direction
from the eye.
The exact definition of look_at() kinda breaks down in this situation,
but this is the behaviour three.js uses, and its better than nothing.",Nice; I do wonder if we have tests that have been commented out because of this.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,187,2020-06-18T11:00:35Z,2020-06-18T11:57:49Z,2020-06-18T11:57:52Z,MERGED,True,63,3,2,https://github.com/ebassi,Moar docs,3,[],https://github.com/ebassi/graphene/pull/187,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/187,"Proposed changes:

add more information on the conventions used by graphene_matrix_t
cross-link various functions","Proposed changes:

add more information on the conventions used by graphene_matrix_t
cross-link various functions",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,188,2020-06-18T11:14:21Z,,2020-10-13T23:47:22Z,OPEN,False,32,24,1,https://github.com/ebassi,box: Use isinf() and signbit() when isinff() is not available,1,[],https://github.com/ebassi/graphene/pull/188,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/188,"Instead of using bytewise comparison, use isinf() and hope it works
correctly with single precision floats on the target platform;
additionally, since the negative return value for negative infinities is
a GNU extension, use signbit() to check if the number is a positive or
negative infinity.
Proposed changes:

change the fallback path for the is_empty() and is_infinity() methods of graphene_box_t","Instead of using bytewise comparison, use isinf() and hope it works
correctly with single precision floats on the target platform;
additionally, since the negative return value for negative infinities is
a GNU extension, use signbit() to check if the number is a positive or
negative infinity.
Proposed changes:

change the fallback path for the is_empty() and is_infinity() methods of graphene_box_t",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,189,2020-06-18T12:03:21Z,2020-06-22T09:21:03Z,2020-06-22T09:21:03Z,MERGED,True,5,0,1,https://github.com/vtorri,Windows: use _isnanf macro instead of fallback,2,[],https://github.com/ebassi/graphene/pull/189,https://github.com/vtorri,1,https://github.com/ebassi/graphene/pull/189,,,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,189,2020-06-18T12:03:21Z,2020-06-22T09:21:03Z,2020-06-22T09:21:03Z,MERGED,True,5,0,1,https://github.com/vtorri,Windows: use _isnanf macro instead of fallback,2,[],https://github.com/ebassi/graphene/pull/189,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/189#issuecomment-645989655,,"Sadly, this breaks on MSVC 32bit:
../src/graphene-ray.c(535): error C4013: '_isnanf' undefined; assuming extern returning int",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,189,2020-06-18T12:03:21Z,2020-06-22T09:21:03Z,2020-06-22T09:21:03Z,MERGED,True,5,0,1,https://github.com/vtorri,Windows: use _isnanf macro instead of fallback,2,[],https://github.com/ebassi/graphene/pull/189,https://github.com/vtorri,3,https://github.com/ebassi/graphene/pull/189#issuecomment-645990439,,"accroding to msdn
The _isnan and _isnanf functions are Microsoft-specific. The _isnanf function is only available when compiled for x64.
i'm going to fix this",True,{'THUMBS_UP': ['https://github.com/ebassi']}
ebassi/graphene,https://github.com/ebassi/graphene,189,2020-06-18T12:03:21Z,2020-06-22T09:21:03Z,2020-06-22T09:21:03Z,MERGED,True,5,0,1,https://github.com/vtorri,Windows: use _isnanf macro instead of fallback,2,[],https://github.com/ebassi/graphene/pull/189,https://github.com/vtorri,4,https://github.com/ebassi/graphene/pull/189#issuecomment-645993061,,arg ! i've written 32 bits instead of 64 bits,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,189,2020-06-18T12:03:21Z,2020-06-22T09:21:03Z,2020-06-22T09:21:03Z,MERGED,True,5,0,1,https://github.com/vtorri,Windows: use _isnanf macro instead of fallback,2,[],https://github.com/ebassi/graphene/pull/189,https://github.com/vtorri,5,https://github.com/ebassi/graphene/pull/189#issuecomment-645994851,,@ebassi do i close this PR and create another one (because of my wrong message) ?,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,189,2020-06-18T12:03:21Z,2020-06-22T09:21:03Z,2020-06-22T09:21:03Z,MERGED,True,5,0,1,https://github.com/vtorri,Windows: use _isnanf macro instead of fallback,2,[],https://github.com/ebassi/graphene/pull/189,https://github.com/ebassi,6,https://github.com/ebassi/graphene/pull/189#issuecomment-645995424,,"@ebassi do i close this PR and create another one (because of my wrong message) ?

No. You can edit the commit and then force push to your branch. The merge request will be updated.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,189,2020-06-18T12:03:21Z,2020-06-22T09:21:03Z,2020-06-22T09:21:03Z,MERGED,True,5,0,1,https://github.com/vtorri,Windows: use _isnanf macro instead of fallback,2,[],https://github.com/ebassi/graphene/pull/189,https://github.com/ebassi,7,https://github.com/ebassi/graphene/pull/189#issuecomment-645995721,,"I'd also squash both commits into a single one, so that we don't break the tests when bisecting.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,190,2020-06-18T13:07:17Z,2020-06-18T14:13:04Z,2020-06-18T14:13:08Z,MERGED,True,4,3,1,https://github.com/ebassi,Always convert the passed Euler order to the real one,1,[],https://github.com/ebassi/graphene/pull/190,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/190,"We have a bunch of aliases, so we need to ensure that we're using the
appropriate graphene_euler_order_t value, especially when performing
conversions to and from matrices.","We have a bunch of aliases, so we need to ensure that we're using the
appropriate graphene_euler_order_t value, especially when performing
conversions to and from matrices.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,192,2020-06-22T08:27:31Z,2020-06-22T09:20:35Z,2020-06-22T09:20:35Z,MERGED,True,12,0,1,https://github.com/alexlarsson,matrix: Clarify API docs of graphene_matrix_init_look_at(),1,[],https://github.com/ebassi/graphene/pull/192,https://github.com/alexlarsson,1,https://github.com/ebassi/graphene/pull/192,,,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,192,2020-06-22T08:27:31Z,2020-06-22T09:20:35Z,2020-06-22T09:20:35Z,MERGED,True,12,0,1,https://github.com/alexlarsson,matrix: Clarify API docs of graphene_matrix_init_look_at(),1,[],https://github.com/ebassi/graphene/pull/192,https://github.com/alexlarsson,2,https://github.com/ebassi/graphene/pull/192#issuecomment-647369657,,"http://www.songho.ca/opengl/gl_camera.html has some reference material on this, although the computed matrix there is the inverted final one.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,192,2020-06-22T08:27:31Z,2020-06-22T09:20:35Z,2020-06-22T09:20:35Z,MERGED,True,12,0,1,https://github.com/alexlarsson,matrix: Clarify API docs of graphene_matrix_init_look_at(),1,[],https://github.com/ebassi/graphene/pull/192,https://github.com/alexlarsson,3,https://github.com/ebassi/graphene/pull/192#issuecomment-647389465,,"Unclear why CI failed for a docs change, maybe just retry?",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,192,2020-06-22T08:27:31Z,2020-06-22T09:20:35Z,2020-06-22T09:20:35Z,MERGED,True,12,0,1,https://github.com/alexlarsson,matrix: Clarify API docs of graphene_matrix_init_look_at(),1,[],https://github.com/ebassi/graphene/pull/192,https://github.com/ebassi,4,https://github.com/ebassi/graphene/pull/192#issuecomment-647395156,,"Thanks, looks good.

Unclear why CI failed for a docs change, maybe just retry?

The 32bit MSYS2 build is flaky for unclear reasons. I just tend to ignore it.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,193,2020-06-22T14:34:26Z,2020-06-22T14:50:27Z,2020-06-22T14:50:27Z,MERGED,True,8,4,1,https://github.com/alexlarsson,Euler: Fix matrix orientation in euler matrix (de)composition,1,[],https://github.com/ebassi/graphene/pull/193,https://github.com/alexlarsson,1,https://github.com/ebassi/graphene/pull/193,"The euler_to_matrix and matrix_to_euler code is based on:
https://github.com/matthew-brett/transforms3d/blob/master/transforms3d/euler.py
This is num-py and has the same row-major matrixes like graphene. However
that code is based on column vectors being multiplied with the matrix on
the left:

This module implements intrinsic and extrinsic axes, with standard conventions
for axes i, j, k.  We assume that the matrix should be applied on the
left of the vector, and right-handed coordinate systems.  To get the matrix to
apply on the right of the vector, you need the transpose of the matrix we
supply here, by the matrix transpose rule: $(M . V)^T = V^T M^T$.

To do the transpose we just change the matrix indexing macro (M) to swap
the row/column.","The euler_to_matrix and matrix_to_euler code is based on:
https://github.com/matthew-brett/transforms3d/blob/master/transforms3d/euler.py
This is num-py and has the same row-major matrixes like graphene. However
that code is based on column vectors being multiplied with the matrix on
the left:

This module implements intrinsic and extrinsic axes, with standard conventions
for axes i, j, k.  We assume that the matrix should be applied on the
left of the vector, and right-handed coordinate systems.  To get the matrix to
apply on the right of the vector, you need the transpose of the matrix we
supply here, by the matrix transpose rule: $(M . V)^T = V^T M^T$.

To do the transpose we just change the matrix indexing macro (M) to swap
the row/column.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,194,2020-07-15T10:22:52Z,2020-07-17T12:40:49Z,2020-07-17T12:40:49Z,MERGED,True,372,16,5,https://github.com/fanc999,ARM NEON: Add support for Visual Studio ARM64 builds,3,[],https://github.com/ebassi/graphene/pull/194,https://github.com/fanc999,1,https://github.com/ebassi/graphene/pull/194,"Hi,
This attempts to add support for building Graphene with ARM NEON intrinsics for Visual Studio ARM64 builds, which is introduced with Visual Studio 2017 15.9.x.  This is done in a way like the previous work on the SSE intrinsics for Visual Studio, as there is no extension available that can alleviate us from using a static inline function when calling the ARM NEON intrinsics.
This involves:


Skip the checks for the presence of the ARM EABI macros and the ARM NEON macros, since those macros are done in a GCC-specific way and are not present (but it seems that Visual Studio offer the functionality that are demanded/offered by those macros).  The test code for ARM NEON intrinsics do compile as a result.  Check for _M_ARM64 in graphene-config.h.meson as well when checking to see GRAPHENE_HAS_ARM_NEON is activated.


Add (Re-word) the intrinsics for Visual Studio ARM64 builds in graphene-simd4f.h and graphene-simd4x4.h, so that GCCisms do not get in the way.  This comes at the cost of using static inline functions where needed, as that would be the best we could do, as when we added the SSE intrinsics for Visual Studio builds.  Also add comments for the SSE intrinsics sections so that this distinction between compiler syntax differences is made clearer.


Fix building graphene-ray.c, where we define isnanf() to _isnanf() and activate HAVE_ISNANF on 64-bit Windows.  Change this to check for _M_X64 (the Visual Studio macro defined for x64 builds) instead of _WIN64, since _isnanf() is provided on x64 builds only.


I was able to cross-compile Graphene for Windows 10 ARM with Visual Studio 2019 with ARM NEON intrinsics enabled, and have also built the code with Visual Studio 2019 on a Windows 10 ARM system and run the tests successfully, and the time taken seemed decent enough.
This does not attempt to cover introspection builds, as no official Python binaries exist for ARM64 Windows, so I was not able to build Graphene at this time with introspection support, but GLib/GObject are activated.
With blessings, thank you!","Hi,
This attempts to add support for building Graphene with ARM NEON intrinsics for Visual Studio ARM64 builds, which is introduced with Visual Studio 2017 15.9.x.  This is done in a way like the previous work on the SSE intrinsics for Visual Studio, as there is no extension available that can alleviate us from using a static inline function when calling the ARM NEON intrinsics.
This involves:


Skip the checks for the presence of the ARM EABI macros and the ARM NEON macros, since those macros are done in a GCC-specific way and are not present (but it seems that Visual Studio offer the functionality that are demanded/offered by those macros).  The test code for ARM NEON intrinsics do compile as a result.  Check for _M_ARM64 in graphene-config.h.meson as well when checking to see GRAPHENE_HAS_ARM_NEON is activated.


Add (Re-word) the intrinsics for Visual Studio ARM64 builds in graphene-simd4f.h and graphene-simd4x4.h, so that GCCisms do not get in the way.  This comes at the cost of using static inline functions where needed, as that would be the best we could do, as when we added the SSE intrinsics for Visual Studio builds.  Also add comments for the SSE intrinsics sections so that this distinction between compiler syntax differences is made clearer.


Fix building graphene-ray.c, where we define isnanf() to _isnanf() and activate HAVE_ISNANF on 64-bit Windows.  Change this to check for _M_X64 (the Visual Studio macro defined for x64 builds) instead of _WIN64, since _isnanf() is provided on x64 builds only.


I was able to cross-compile Graphene for Windows 10 ARM with Visual Studio 2019 with ARM NEON intrinsics enabled, and have also built the code with Visual Studio 2019 on a Windows 10 ARM system and run the tests successfully, and the time taken seemed decent enough.
This does not attempt to cover introspection builds, as no official Python binaries exist for ARM64 Windows, so I was not able to build Graphene at this time with introspection support, but GLib/GObject are activated.
With blessings, thank you!",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,194,2020-07-15T10:22:52Z,2020-07-17T12:40:49Z,2020-07-17T12:40:49Z,MERGED,True,372,16,5,https://github.com/fanc999,ARM NEON: Add support for Visual Studio ARM64 builds,3,[],https://github.com/ebassi/graphene/pull/194,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/194#issuecomment-660084897,"Hi,
This attempts to add support for building Graphene with ARM NEON intrinsics for Visual Studio ARM64 builds, which is introduced with Visual Studio 2017 15.9.x.  This is done in a way like the previous work on the SSE intrinsics for Visual Studio, as there is no extension available that can alleviate us from using a static inline function when calling the ARM NEON intrinsics.
This involves:


Skip the checks for the presence of the ARM EABI macros and the ARM NEON macros, since those macros are done in a GCC-specific way and are not present (but it seems that Visual Studio offer the functionality that are demanded/offered by those macros).  The test code for ARM NEON intrinsics do compile as a result.  Check for _M_ARM64 in graphene-config.h.meson as well when checking to see GRAPHENE_HAS_ARM_NEON is activated.


Add (Re-word) the intrinsics for Visual Studio ARM64 builds in graphene-simd4f.h and graphene-simd4x4.h, so that GCCisms do not get in the way.  This comes at the cost of using static inline functions where needed, as that would be the best we could do, as when we added the SSE intrinsics for Visual Studio builds.  Also add comments for the SSE intrinsics sections so that this distinction between compiler syntax differences is made clearer.


Fix building graphene-ray.c, where we define isnanf() to _isnanf() and activate HAVE_ISNANF on 64-bit Windows.  Change this to check for _M_X64 (the Visual Studio macro defined for x64 builds) instead of _WIN64, since _isnanf() is provided on x64 builds only.


I was able to cross-compile Graphene for Windows 10 ARM with Visual Studio 2019 with ARM NEON intrinsics enabled, and have also built the code with Visual Studio 2019 on a Windows 10 ARM system and run the tests successfully, and the time taken seemed decent enough.
This does not attempt to cover introspection builds, as no official Python binaries exist for ARM64 Windows, so I was not able to build Graphene at this time with introspection support, but GLib/GObject are activated.
With blessings, thank you!",Thanks! This looks fantastic.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,195,2020-07-24T15:05:34Z,2020-07-24T15:59:31Z,2020-07-24T17:20:28Z,MERGED,True,27,0,1,https://github.com/ebassi,Add CI using GitHub actions,7,[],https://github.com/ebassi/graphene/pull/195,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/195,Start with a CI pipeline using GitHub actions on a Ubuntu base.,Start with a CI pipeline using GitHub actions on a Ubuntu base.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,196,2020-07-24T15:34:41Z,2020-07-24T15:59:03Z,2020-07-24T15:59:07Z,MERGED,True,5,5,4,https://github.com/ebassi,"Drop deprecated ""python3"" module",2,[],https://github.com/ebassi/graphene/pull/196,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/196,"We depend on a new enough version of Meson, so we can drop the old ""python3"" module, and use the appropriate ""python"" module API instead.","We depend on a new enough version of Meson, so we can drop the old ""python3"" module, and use the appropriate ""python"" module API instead.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,197,2020-08-13T13:53:05Z,2020-08-13T15:31:37Z,2020-08-13T17:11:10Z,MERGED,True,63,5,4,https://github.com/ebassi,Ci actions,4,[],https://github.com/ebassi/graphene/pull/197,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/197,Improvements to the GitHub actions pipeline,Improvements to the GitHub actions pipeline,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,197,2020-08-13T13:53:05Z,2020-08-13T15:31:37Z,2020-08-13T17:11:10Z,MERGED,True,63,5,4,https://github.com/ebassi,Ci actions,4,[],https://github.com/ebassi/graphene/pull/197,https://github.com/nirbheek,2,https://github.com/ebassi/graphene/pull/197#issuecomment-673495053,Improvements to the GitHub actions pipeline,"Seems like a good time to switch from ninja to meson compile / meson test, etc, and also test --backend vs on Windows :)",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,197,2020-08-13T13:53:05Z,2020-08-13T15:31:37Z,2020-08-13T17:11:10Z,MERGED,True,63,5,4,https://github.com/ebassi,Ci actions,4,[],https://github.com/ebassi/graphene/pull/197,https://github.com/ebassi,3,https://github.com/ebassi/graphene/pull/197#issuecomment-673533257,Improvements to the GitHub actions pipeline,"Seems like a good time to switch from ninja to meson compile / meson test, etc, and also test --backend vs on Windows :)

I've switched most of the calls to that, except the API docs build, because apparently it doesn't work on 0.54.3.
I'll probably test out the VS backend as well, but I wanted to have a working baseline.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,197,2020-08-13T13:53:05Z,2020-08-13T15:31:37Z,2020-08-13T17:11:10Z,MERGED,True,63,5,4,https://github.com/ebassi,Ci actions,4,[],https://github.com/ebassi/graphene/pull/197,https://github.com/nirbheek,4,https://github.com/ebassi/graphene/pull/197#issuecomment-673537111,Improvements to the GitHub actions pipeline,"I noticed that the gobject API is not built on Windows because there's no wrap file for glib (+ libffi + zlib + proxy-libintl). I also had to pass -Dintrospection=false because it's not a feature option, but that's a separate issue.
Everything built fine once I did that.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,197,2020-08-13T13:53:05Z,2020-08-13T15:31:37Z,2020-08-13T17:11:10Z,MERGED,True,63,5,4,https://github.com/ebassi,Ci actions,4,[],https://github.com/ebassi/graphene/pull/197,https://github.com/ebassi,5,https://github.com/ebassi/graphene/pull/197#issuecomment-673539674,Improvements to the GitHub actions pipeline,"I noticed that the gobject API is not built on Windows because there's no wrap file for glib (+ libffi + zlib + proxy-libintl)

Yes, that's the current state on AppVeyor as well; I might end up adding subprojects, but I don't want to build the whole planet.

I also had to pass -Dintrospection=false because it's not a feature option, but that's a separate issue.

That's PR #178.",True,{'THUMBS_UP': ['https://github.com/nirbheek']}
ebassi/graphene,https://github.com/ebassi/graphene,197,2020-08-13T13:53:05Z,2020-08-13T15:31:37Z,2020-08-13T17:11:10Z,MERGED,True,63,5,4,https://github.com/ebassi,Ci actions,4,[],https://github.com/ebassi/graphene/pull/197,https://github.com/nirbheek,6,https://github.com/ebassi/graphene/pull/197#issuecomment-673578184,Improvements to the GitHub actions pipeline,"I might end up adding subprojects, but I don't want to build the whole planet.

You'll need mesonbuild/meson#7587 to be able to run just the graphene tests. By default meson test runs tests defined in all subprojects.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,198,2020-08-13T17:31:45Z,2022-02-14T17:02:37Z,2022-02-14T17:02:40Z,CLOSED,False,0,4,2,https://github.com/nirbheek,Test meson fix for PYTHONIOENCODING,1,[],https://github.com/ebassi/graphene/pull/198,https://github.com/nirbheek,1,https://github.com/ebassi/graphene/pull/198,Testing: mesonbuild/meson#7589,Testing: mesonbuild/meson#7589,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,198,2020-08-13T17:31:45Z,2022-02-14T17:02:37Z,2022-02-14T17:02:40Z,CLOSED,False,0,4,2,https://github.com/nirbheek,Test meson fix for PYTHONIOENCODING,1,[],https://github.com/ebassi/graphene/pull/198,https://github.com/nirbheek,2,https://github.com/ebassi/graphene/pull/198#issuecomment-673611996,Testing: mesonbuild/meson#7589,"@ebassi seems to work fine without that meson PR, actually ðŸ¤”",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,199,2020-09-01T02:53:53Z,,2020-09-08T00:20:37Z,OPEN,False,8,8,1,https://github.com/matthiasclasen,Fix handling of projective transforms,2,[],https://github.com/ebassi/graphene/pull/199,https://github.com/matthiasclasen,1,https://github.com/ebassi/graphene/pull/199,"When transforming points with projective matrices,
we must divide the resulting vector by w, in order
to get the normalized result.
This commit fixes graphene_matrix_transform_point,
graphene_matrix_transform_point3d and
graphene_matrix_transform_bounds. I suspect that
some of the remaining transform functions need
similar fixes, but they are not used in GTK, so
I couldn't verify that.
Before:

After:

Notice how the bounding box for the projectively transformed button is much too small before, and just right after.","When transforming points with projective matrices,
we must divide the resulting vector by w, in order
to get the normalized result.
This commit fixes graphene_matrix_transform_point,
graphene_matrix_transform_point3d and
graphene_matrix_transform_bounds. I suspect that
some of the remaining transform functions need
similar fixes, but they are not used in GTK, so
I couldn't verify that.
Before:

After:

Notice how the bounding box for the projectively transformed button is much too small before, and just right after.",True,{'THUMBS_UP': ['https://github.com/bmwalters']}
ebassi/graphene,https://github.com/ebassi/graphene,199,2020-09-01T02:53:53Z,,2020-09-08T00:20:37Z,OPEN,False,8,8,1,https://github.com/matthiasclasen,Fix handling of projective transforms,2,[],https://github.com/ebassi/graphene/pull/199,https://github.com/matthiasclasen,2,https://github.com/ebassi/graphene/pull/199#issuecomment-684837685,"When transforming points with projective matrices,
we must divide the resulting vector by w, in order
to get the normalized result.
This commit fixes graphene_matrix_transform_point,
graphene_matrix_transform_point3d and
graphene_matrix_transform_bounds. I suspect that
some of the remaining transform functions need
similar fixes, but they are not used in GTK, so
I couldn't verify that.
Before:

After:

Notice how the bounding box for the projectively transformed button is much too small before, and just right after.",Here is a gtk-side fix for now: https://gitlab.gnome.org/GNOME/gtk/-/merge_requests/2514,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,199,2020-09-01T02:53:53Z,,2020-09-08T00:20:37Z,OPEN,False,8,8,1,https://github.com/matthiasclasen,Fix handling of projective transforms,2,[],https://github.com/ebassi/graphene/pull/199,https://github.com/alexlarsson,3,https://github.com/ebassi/graphene/pull/199#issuecomment-686302330,"When transforming points with projective matrices,
we must divide the resulting vector by w, in order
to get the normalized result.
This commit fixes graphene_matrix_transform_point,
graphene_matrix_transform_point3d and
graphene_matrix_transform_bounds. I suspect that
some of the remaining transform functions need
similar fixes, but they are not used in GTK, so
I couldn't verify that.
Before:

After:

Notice how the bounding box for the projectively transformed button is much too small before, and just right after.","Given things like https://gitlab.gnome.org/GNOME/gtk/-/commit/30ab8b3ecac15e22436f6c38c1149e54f42f0d50 it seems existing code relies on the current behaviour. So, is it safe to change this?",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,200,2020-10-16T21:05:19Z,2021-02-09T20:58:39Z,2021-02-10T15:31:24Z,MERGED,True,11,4,3,https://github.com/xclaesse,meson: Change introspection option to yielding feature,1,[],https://github.com/ebassi/graphene/pull/200,https://github.com/xclaesse,1,https://github.com/ebassi/graphene/pull/200,"This copies the same logic as in GTK+. A yielding feature option has the
advantage that if introspection is disabled in GTK and graphene is built
as subproject it will inherit the value from GTK main project.","This copies the same logic as in GTK+. A yielding feature option has the
advantage that if introspection is disabled in GTK and graphene is built
as subproject it will inherit the value from GTK main project.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,200,2020-10-16T21:05:19Z,2021-02-09T20:58:39Z,2021-02-10T15:31:24Z,MERGED,True,11,4,3,https://github.com/xclaesse,meson: Change introspection option to yielding feature,1,[],https://github.com/ebassi/graphene/pull/200,https://github.com/xclaesse,2,https://github.com/ebassi/graphene/pull/200#issuecomment-710635080,"This copies the same logic as in GTK+. A yielding feature option has the
advantage that if introspection is disabled in GTK and graphene is built
as subproject it will inherit the value from GTK main project.","The same logic got merged into gtk, pango, cairo, gstreamer, probably others.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,200,2020-10-16T21:05:19Z,2021-02-09T20:58:39Z,2021-02-10T15:31:24Z,MERGED,True,11,4,3,https://github.com/xclaesse,meson: Change introspection option to yielding feature,1,[],https://github.com/ebassi/graphene/pull/200,https://github.com/xclaesse,3,https://github.com/ebassi/graphene/pull/200#issuecomment-710995889,"This copies the same logic as in GTK+. A yielding feature option has the
advantage that if introspection is disabled in GTK and graphene is built
as subproject it will inherit the value from GTK main project.",@ebassi CI failure seems unrelated.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,200,2020-10-16T21:05:19Z,2021-02-09T20:58:39Z,2021-02-10T15:31:24Z,MERGED,True,11,4,3,https://github.com/xclaesse,meson: Change introspection option to yielding feature,1,[],https://github.com/ebassi/graphene/pull/200,https://github.com/matthiasclasen,4,https://github.com/ebassi/graphene/pull/200#issuecomment-753571095,"This copies the same logic as in GTK+. A yielding feature option has the
advantage that if introspection is disabled in GTK and graphene is built
as subproject it will inherit the value from GTK main project.",This would be nice to have for the GTK macos ci that I'm trying to set up,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,202,2020-12-10T07:19:32Z,2020-12-10T15:58:57Z,2020-12-10T15:59:03Z,MERGED,True,37,1,2,https://github.com/vanvugt,Fix graphene_box_intersection for non-intersecting boxes.,2,[],https://github.com/ebassi/graphene/pull/202,https://github.com/vanvugt,1,https://github.com/ebassi/graphene/pull/202,"Fixes #201
The old logic did essentially:
  (min.x >= max.x && min.y >= max.y && min.z >= max.z)

which for a pair of non-intersecting boxes that differ in only one or two
dimensions will return false when we need it to return true (meaning there
is no intersection). What we really need is:
  (min.x > max.x || min.y > max.y || min.z > max.z)

which can be rewritten as:
  !(min.x <= max.x && min.y <= max.y && min.z <= max.z)","Fixes #201
The old logic did essentially:
  (min.x >= max.x && min.y >= max.y && min.z >= max.z)

which for a pair of non-intersecting boxes that differ in only one or two
dimensions will return false when we need it to return true (meaning there
is no intersection). What we really need is:
  (min.x > max.x || min.y > max.y || min.z > max.z)

which can be rewritten as:
  !(min.x <= max.x && min.y <= max.y && min.z <= max.z)",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,202,2020-12-10T07:19:32Z,2020-12-10T15:58:57Z,2020-12-10T15:59:03Z,MERGED,True,37,1,2,https://github.com/vanvugt,Fix graphene_box_intersection for non-intersecting boxes.,2,[],https://github.com/ebassi/graphene/pull/202,https://github.com/vanvugt,2,https://github.com/ebassi/graphene/pull/202#issuecomment-742395224,"Fixes #201
The old logic did essentially:
  (min.x >= max.x && min.y >= max.y && min.z >= max.z)

which for a pair of non-intersecting boxes that differ in only one or two
dimensions will return false when we need it to return true (meaning there
is no intersection). What we really need is:
  (min.x > max.x || min.y > max.y || min.z > max.z)

which can be rewritten as:
  !(min.x <= max.x && min.y <= max.y && min.z <= max.z)",The CI failure does not appear to be related to the pull request.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,202,2020-12-10T07:19:32Z,2020-12-10T15:58:57Z,2020-12-10T15:59:03Z,MERGED,True,37,1,2,https://github.com/vanvugt,Fix graphene_box_intersection for non-intersecting boxes.,2,[],https://github.com/ebassi/graphene/pull/202,https://github.com/ebassi,3,https://github.com/ebassi/graphene/pull/202#issuecomment-742611782,"Fixes #201
The old logic did essentially:
  (min.x >= max.x && min.y >= max.y && min.z >= max.z)

which for a pair of non-intersecting boxes that differ in only one or two
dimensions will return false when we need it to return true (meaning there
is no intersection). What we really need is:
  (min.x > max.x || min.y > max.y || min.z > max.z)

which can be rewritten as:
  !(min.x <= max.x && min.y <= max.y && min.z <= max.z)",Thanks!,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,203,2020-12-10T16:05:50Z,2020-12-10T16:19:54Z,2020-12-10T16:19:57Z,MERGED,True,3,234,8,https://github.com/ebassi,Drop external CI services,3,[],https://github.com/ebassi/graphene/pull/203,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/203,"Drop Travis and AppVeyor, now that we have corresponding functionality natively in GitHub.","Drop Travis and AppVeyor, now that we have corresponding functionality natively in GitHub.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,206,2020-12-21T15:43:23Z,2020-12-22T12:30:43Z,2020-12-22T12:30:52Z,MERGED,True,2,2,1,https://github.com/xry111,meson: only enable SSE2 on x86_64,1,[],https://github.com/ebassi/graphene/pull/206,https://github.com/xry111,1,https://github.com/ebassi/graphene/pull/206,"Now SSE2 is enabled for 32-bit x86 by default (with recent GCC).  It's
causing issues such as https://gitlab.gnome.org/GNOME/gtk/-/issues/3497.","Now SSE2 is enabled for 32-bit x86 by default (with recent GCC).  It's
causing issues such as https://gitlab.gnome.org/GNOME/gtk/-/issues/3497.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,206,2020-12-21T15:43:23Z,2020-12-22T12:30:43Z,2020-12-22T12:30:52Z,MERGED,True,2,2,1,https://github.com/xry111,meson: only enable SSE2 on x86_64,1,[],https://github.com/ebassi/graphene/pull/206,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/206#issuecomment-749042651,"Now SSE2 is enabled for 32-bit x86 by default (with recent GCC).  It's
causing issues such as https://gitlab.gnome.org/GNOME/gtk/-/issues/3497.","That'sâ€¦ A lot of changes, and not really what I'd like to merge.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,206,2020-12-21T15:43:23Z,2020-12-22T12:30:43Z,2020-12-22T12:30:52Z,MERGED,True,2,2,1,https://github.com/xry111,meson: only enable SSE2 on x86_64,1,[],https://github.com/ebassi/graphene/pull/206,https://github.com/ebassi,3,https://github.com/ebassi/graphene/pull/206#issuecomment-749517441,"Now SSE2 is enabled for 32-bit x86 by default (with recent GCC).  It's
causing issues such as https://gitlab.gnome.org/GNOME/gtk/-/issues/3497.",Thanks for the fixes!,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,208,2021-02-01T19:57:05Z,2021-02-09T20:57:32Z,2021-02-09T20:57:35Z,MERGED,True,8,5,6,https://github.com/ebassi,Use the appropriate notation for alignment attributes,3,[],https://github.com/ebassi/graphene/pull/208,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/208,Instead of relying on GCC accepting the same notation as MSVC.,Instead of relying on GCC accepting the same notation as MSVC.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,212,2021-02-12T11:43:52Z,2021-02-12T12:57:50Z,2021-02-12T12:57:51Z,MERGED,True,135,24,3,https://github.com/smcv,graphene-config: Hide SIMD implementation from GObject-Introspection,2,[],https://github.com/ebassi/graphene/pull/212,https://github.com/smcv,1,https://github.com/ebassi/graphene/pull/212,"Exposing the various #mesondefine'd constants results in the GIR XML
unnecessarily varying between architectures.
Conversely, GObject-Introspection's rather simplistic cpp parser
thinks GRAPHENE_SIMD_S is always defined to ""sse"", even on
architectures where it should not be.
Introspected code is not going to be able to use SIMD anyway, so this
doesn't seem to have any value.
Resolves: #211

Not tested yet, but hopefully fixes #211.
Proposed changes:

Wrap more of graphene-config.h in #ifndef __GI_SCANNER__

Benchmark results:

not benchmarked

Test suite changes:

Add a smoke-test for GObject-Introspection using PyGI","Exposing the various #mesondefine'd constants results in the GIR XML
unnecessarily varying between architectures.
Conversely, GObject-Introspection's rather simplistic cpp parser
thinks GRAPHENE_SIMD_S is always defined to ""sse"", even on
architectures where it should not be.
Introspected code is not going to be able to use SIMD anyway, so this
doesn't seem to have any value.
Resolves: #211

Not tested yet, but hopefully fixes #211.
Proposed changes:

Wrap more of graphene-config.h in #ifndef __GI_SCANNER__

Benchmark results:

not benchmarked

Test suite changes:

Add a smoke-test for GObject-Introspection using PyGI",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,212,2021-02-12T11:43:52Z,2021-02-12T12:57:50Z,2021-02-12T12:57:51Z,MERGED,True,135,24,3,https://github.com/smcv,graphene-config: Hide SIMD implementation from GObject-Introspection,2,[],https://github.com/ebassi/graphene/pull/212,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/212#issuecomment-778180111,"Exposing the various #mesondefine'd constants results in the GIR XML
unnecessarily varying between architectures.
Conversely, GObject-Introspection's rather simplistic cpp parser
thinks GRAPHENE_SIMD_S is always defined to ""sse"", even on
architectures where it should not be.
Introspected code is not going to be able to use SIMD anyway, so this
doesn't seem to have any value.
Resolves: #211

Not tested yet, but hopefully fixes #211.
Proposed changes:

Wrap more of graphene-config.h in #ifndef __GI_SCANNER__

Benchmark results:

not benchmarked

Test suite changes:

Add a smoke-test for GObject-Introspection using PyGI","Looks good; thanks for adding the introspection test, it's much appreciated.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,213,2021-02-12T12:31:21Z,2021-02-12T12:52:58Z,2021-02-12T12:53:02Z,MERGED,True,5,5,2,https://github.com/smcv,CI: Show detailed build logs,1,[],https://github.com/ebassi/graphene/pull/213,https://github.com/smcv,1,https://github.com/ebassi/graphene/pull/213,"If a test fails on CI but not locally, it's useful to know what happened.","If a test fails on CI but not locally, it's useful to know what happened.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,213,2021-02-12T12:31:21Z,2021-02-12T12:52:58Z,2021-02-12T12:53:02Z,MERGED,True,5,5,2,https://github.com/smcv,CI: Show detailed build logs,1,[],https://github.com/ebassi/graphene/pull/213,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/213#issuecomment-778178042,"If a test fails on CI but not locally, it's useful to know what happened.",Thanks!,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,217,2021-03-23T07:29:19Z,2021-03-23T19:25:05Z,2021-03-23T19:25:05Z,MERGED,True,92,1,2,https://github.com/jadahl,ray: Nudge ray direction of axis when intersecting,1,[],https://github.com/ebassi/graphene/pull/217,https://github.com/jadahl,1,https://github.com/ebassi/graphene/pull/217,"The formula used to calculate the inverse of the direction vector
doesn't handle the direction vector aligning with an axis. Depending on
the SIMD (or not SIMD) implementation used, a axis aligned vector would
either remain the same, or e.g. end up with NaN components messing up
any future calculations.
Fixing the math to handle this is non-trivial, so for now work around
this by nudging the direction vector slightly off axis so that it has a
better hand of hitting the right box even when the direction is axis
aligned.
Closes: #214
Fixes #...
Proposed changes:

...

Benchmark results:

Before: ...
After: ...

Test suite changes:

...","The formula used to calculate the inverse of the direction vector
doesn't handle the direction vector aligning with an axis. Depending on
the SIMD (or not SIMD) implementation used, a axis aligned vector would
either remain the same, or e.g. end up with NaN components messing up
any future calculations.
Fixing the math to handle this is non-trivial, so for now work around
this by nudging the direction vector slightly off axis so that it has a
better hand of hitting the right box even when the direction is axis
aligned.
Closes: #214
Fixes #...
Proposed changes:

...

Benchmark results:

Before: ...
After: ...

Test suite changes:

...",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,218,2021-04-01T21:55:17Z,2021-04-03T19:31:24Z,2021-04-03T19:31:24Z,CLOSED,False,1,1,1,https://github.com/doraskayo,graphene-config: Fix GCC version check,1,[],https://github.com/ebassi/graphene/pull/218,https://github.com/doraskayo,1,https://github.com/ebassi/graphene/pull/218,I expect the CI build to fail as it does for me locally. Creating as draft.,I expect the CI build to fail as it does for me locally. Creating as draft.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,218,2021-04-01T21:55:17Z,2021-04-03T19:31:24Z,2021-04-03T19:31:24Z,CLOSED,False,1,1,1,https://github.com/doraskayo,graphene-config: Fix GCC version check,1,[],https://github.com/ebassi/graphene/pull/218,https://github.com/doraskayo,2,https://github.com/ebassi/graphene/pull/218#issuecomment-812914764,I expect the CI build to fail as it does for me locally. Creating as draft.,I guess this will be covered by #219. Closing.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,219,2021-04-01T22:16:00Z,2021-06-06T18:57:03Z,2021-06-06T18:57:03Z,CLOSED,False,30,9,2,https://github.com/ebassi,Fixes for the GCC vector code,3,[],https://github.com/ebassi/graphene/pull/219,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/219,It seems it regressed even with the test suite running.,It seems it regressed even with the test suite running.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,219,2021-04-01T22:16:00Z,2021-06-06T18:57:03Z,2021-06-06T18:57:03Z,CLOSED,False,30,9,2,https://github.com/ebassi,Fixes for the GCC vector code,3,[],https://github.com/ebassi/graphene/pull/219,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/219#issuecomment-855445253,It seems it regressed even with the test suite running.,Merged as part of #220.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,220,2021-04-02T11:53:23Z,2021-06-06T18:21:14Z,2021-06-06T18:21:14Z,CLOSED,False,133,48,6,https://github.com/doraskayo,simd4f: Make reciprocal operations 0-safe,6,[],https://github.com/ebassi/graphene/pull/220,https://github.com/doraskayo,1,https://github.com/ebassi/graphene/pull/220,"Description
From the main commit messages: (performance measurements omitted)
    simd4f: Make reciprocal operations 0-safe
    
    Introduce a well-defined behavior for the reciprocal calculation of
    positive and negative 0. These would now result in positive and
    negative infinity, respectively.
    
    This behavior follows the definition of the IEEE 754 standard.
    
    In the SSE implementation, _mm_rcp_ps() already returned positive or
    negative infinity when used on a positive or negative 0. However, since
    it is then multiplied by 0, we end up with NaN. NaN is then used in the
    next calculations, which finally result in it being returned.
    
    To avoid ending up with NaN, we use a mask created by _mm_cmpeq_ps()
    and a constant, and along with _mm_andnot_ps() we replace infinity with
    0 in the multiplication. After the following subtraction, we end up
    with 2 multiplied by the positive or negative infinity, which finally
    returns the expected result.
    
    The GCC vectorization and scalar implementations are adjusted to return
    infinity when calculating the reciprocal of 0, with copysign() used to
    set the expected sign of the result.
    
    The ARM NEON implementation doesn't require adjusting as it is already
    0-safe.
    
    This comes at a cost of ~11.9% for the SSE implementation, while the
    performance of the GCC vectorization and scalar implementations
    largely remains the same.

    ray: Remove nudging workaround
    
    Since the reciprocals of positive and negative 0 are now well-defined,
    this workaround should no longer be needed.

Performance
Tests
ray-speed: 50,000,000 ray intersection tests with a box, each using a unique ray.
simd-speed: 100,000,000 vector reciprocal calculations, each using a unique vector.
Results
The following are measurements made for the entire PR. For measurements made for each individual commit, see the commit message.
SSE
  BEFORE
    1/2 graphene / ray-speed  OK             1.27s
    2/2 graphene / simd-speed OK             0.42s
  AFTER
    1/2 graphene / ray-speed  OK             1.12s
    2/2 graphene / simd-speed OK             0.47s

GCC VECTORIZATION
  BEFORE
    1/2 graphene / ray-speed  OK             1.32s
    2/2 graphene / simd-speed OK             1.12s
  AFTER
    1/2 graphene / ray-speed  OK             1.27s
    2/2 graphene / simd-speed OK             1.12s

SCALAR
  BEFORE
    1/2 graphene / ray-speed  OK             2.02s
    2/2 graphene / simd-speed OK             1.62s
  AFTER
    1/2 graphene / ray-speed  OK             1.87s
    2/2 graphene / simd-speed OK             1.32s

Status
Ready. The following items were done:

 Add unit tests.
 Measure performance and optimize where possible.
 Test the SSE implementation and adjust where necessary.
 Test the GCC vectorization implementation and adjust where necessary.
 Test the scalar implementation and adjust where necessary.
 Test the ARM NEON implementation and adjust where necessary.

Dependencies
The following PRs are included in this PR until merged:

#219 for the GCC vectorization adjustments","Description
From the main commit messages: (performance measurements omitted)
    simd4f: Make reciprocal operations 0-safe
    
    Introduce a well-defined behavior for the reciprocal calculation of
    positive and negative 0. These would now result in positive and
    negative infinity, respectively.
    
    This behavior follows the definition of the IEEE 754 standard.
    
    In the SSE implementation, _mm_rcp_ps() already returned positive or
    negative infinity when used on a positive or negative 0. However, since
    it is then multiplied by 0, we end up with NaN. NaN is then used in the
    next calculations, which finally result in it being returned.
    
    To avoid ending up with NaN, we use a mask created by _mm_cmpeq_ps()
    and a constant, and along with _mm_andnot_ps() we replace infinity with
    0 in the multiplication. After the following subtraction, we end up
    with 2 multiplied by the positive or negative infinity, which finally
    returns the expected result.
    
    The GCC vectorization and scalar implementations are adjusted to return
    infinity when calculating the reciprocal of 0, with copysign() used to
    set the expected sign of the result.
    
    The ARM NEON implementation doesn't require adjusting as it is already
    0-safe.
    
    This comes at a cost of ~11.9% for the SSE implementation, while the
    performance of the GCC vectorization and scalar implementations
    largely remains the same.

    ray: Remove nudging workaround
    
    Since the reciprocals of positive and negative 0 are now well-defined,
    this workaround should no longer be needed.

Performance
Tests
ray-speed: 50,000,000 ray intersection tests with a box, each using a unique ray.
simd-speed: 100,000,000 vector reciprocal calculations, each using a unique vector.
Results
The following are measurements made for the entire PR. For measurements made for each individual commit, see the commit message.
SSE
  BEFORE
    1/2 graphene / ray-speed  OK             1.27s
    2/2 graphene / simd-speed OK             0.42s
  AFTER
    1/2 graphene / ray-speed  OK             1.12s
    2/2 graphene / simd-speed OK             0.47s

GCC VECTORIZATION
  BEFORE
    1/2 graphene / ray-speed  OK             1.32s
    2/2 graphene / simd-speed OK             1.12s
  AFTER
    1/2 graphene / ray-speed  OK             1.27s
    2/2 graphene / simd-speed OK             1.12s

SCALAR
  BEFORE
    1/2 graphene / ray-speed  OK             2.02s
    2/2 graphene / simd-speed OK             1.62s
  AFTER
    1/2 graphene / ray-speed  OK             1.87s
    2/2 graphene / simd-speed OK             1.32s

Status
Ready. The following items were done:

 Add unit tests.
 Measure performance and optimize where possible.
 Test the SSE implementation and adjust where necessary.
 Test the GCC vectorization implementation and adjust where necessary.
 Test the scalar implementation and adjust where necessary.
 Test the ARM NEON implementation and adjust where necessary.

Dependencies
The following PRs are included in this PR until merged:

#219 for the GCC vectorization adjustments",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,220,2021-04-02T11:53:23Z,2021-06-06T18:21:14Z,2021-06-06T18:21:14Z,CLOSED,False,133,48,6,https://github.com/doraskayo,simd4f: Make reciprocal operations 0-safe,6,[],https://github.com/ebassi/graphene/pull/220,https://github.com/doraskayo,2,https://github.com/ebassi/graphene/pull/220#issuecomment-812501399,"Description
From the main commit messages: (performance measurements omitted)
    simd4f: Make reciprocal operations 0-safe
    
    Introduce a well-defined behavior for the reciprocal calculation of
    positive and negative 0. These would now result in positive and
    negative infinity, respectively.
    
    This behavior follows the definition of the IEEE 754 standard.
    
    In the SSE implementation, _mm_rcp_ps() already returned positive or
    negative infinity when used on a positive or negative 0. However, since
    it is then multiplied by 0, we end up with NaN. NaN is then used in the
    next calculations, which finally result in it being returned.
    
    To avoid ending up with NaN, we use a mask created by _mm_cmpeq_ps()
    and a constant, and along with _mm_andnot_ps() we replace infinity with
    0 in the multiplication. After the following subtraction, we end up
    with 2 multiplied by the positive or negative infinity, which finally
    returns the expected result.
    
    The GCC vectorization and scalar implementations are adjusted to return
    infinity when calculating the reciprocal of 0, with copysign() used to
    set the expected sign of the result.
    
    The ARM NEON implementation doesn't require adjusting as it is already
    0-safe.
    
    This comes at a cost of ~11.9% for the SSE implementation, while the
    performance of the GCC vectorization and scalar implementations
    largely remains the same.

    ray: Remove nudging workaround
    
    Since the reciprocals of positive and negative 0 are now well-defined,
    this workaround should no longer be needed.

Performance
Tests
ray-speed: 50,000,000 ray intersection tests with a box, each using a unique ray.
simd-speed: 100,000,000 vector reciprocal calculations, each using a unique vector.
Results
The following are measurements made for the entire PR. For measurements made for each individual commit, see the commit message.
SSE
  BEFORE
    1/2 graphene / ray-speed  OK             1.27s
    2/2 graphene / simd-speed OK             0.42s
  AFTER
    1/2 graphene / ray-speed  OK             1.12s
    2/2 graphene / simd-speed OK             0.47s

GCC VECTORIZATION
  BEFORE
    1/2 graphene / ray-speed  OK             1.32s
    2/2 graphene / simd-speed OK             1.12s
  AFTER
    1/2 graphene / ray-speed  OK             1.27s
    2/2 graphene / simd-speed OK             1.12s

SCALAR
  BEFORE
    1/2 graphene / ray-speed  OK             2.02s
    2/2 graphene / simd-speed OK             1.62s
  AFTER
    1/2 graphene / ray-speed  OK             1.87s
    2/2 graphene / simd-speed OK             1.32s

Status
Ready. The following items were done:

 Add unit tests.
 Measure performance and optimize where possible.
 Test the SSE implementation and adjust where necessary.
 Test the GCC vectorization implementation and adjust where necessary.
 Test the scalar implementation and adjust where necessary.
 Test the ARM NEON implementation and adjust where necessary.

Dependencies
The following PRs are included in this PR until merged:

#219 for the GCC vectorization adjustments","CI seems to have issues setting up the environment due to apt-get failing to download python3-lxml:

Err:16 http://security.ubuntu.com/ubuntu focal-updates/main amd64 python3-lxml amd64 4.5.0-1ubuntu0.2
404  Not Found [IP: 52.154.174.208 80]
E: Failed to fetch http://security.ubuntu.com/ubuntu/pool/main/l/lxml/python3-lxml_4.5.0-1ubuntu0.2_amd64.deb  404  Not Found [IP: 52.154.174.208 80]
Fetched 4249 kB in 0s (12.3 MB/s)
E: Unable to fetch some archives, maybe run apt-get update or try with --fix-missing?
Error: Process completed with exit code 100.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,220,2021-04-02T11:53:23Z,2021-06-06T18:21:14Z,2021-06-06T18:21:14Z,CLOSED,False,133,48,6,https://github.com/doraskayo,simd4f: Make reciprocal operations 0-safe,6,[],https://github.com/ebassi/graphene/pull/220,https://github.com/doraskayo,3,https://github.com/ebassi/graphene/pull/220#issuecomment-812712177,"Description
From the main commit messages: (performance measurements omitted)
    simd4f: Make reciprocal operations 0-safe
    
    Introduce a well-defined behavior for the reciprocal calculation of
    positive and negative 0. These would now result in positive and
    negative infinity, respectively.
    
    This behavior follows the definition of the IEEE 754 standard.
    
    In the SSE implementation, _mm_rcp_ps() already returned positive or
    negative infinity when used on a positive or negative 0. However, since
    it is then multiplied by 0, we end up with NaN. NaN is then used in the
    next calculations, which finally result in it being returned.
    
    To avoid ending up with NaN, we use a mask created by _mm_cmpeq_ps()
    and a constant, and along with _mm_andnot_ps() we replace infinity with
    0 in the multiplication. After the following subtraction, we end up
    with 2 multiplied by the positive or negative infinity, which finally
    returns the expected result.
    
    The GCC vectorization and scalar implementations are adjusted to return
    infinity when calculating the reciprocal of 0, with copysign() used to
    set the expected sign of the result.
    
    The ARM NEON implementation doesn't require adjusting as it is already
    0-safe.
    
    This comes at a cost of ~11.9% for the SSE implementation, while the
    performance of the GCC vectorization and scalar implementations
    largely remains the same.

    ray: Remove nudging workaround
    
    Since the reciprocals of positive and negative 0 are now well-defined,
    this workaround should no longer be needed.

Performance
Tests
ray-speed: 50,000,000 ray intersection tests with a box, each using a unique ray.
simd-speed: 100,000,000 vector reciprocal calculations, each using a unique vector.
Results
The following are measurements made for the entire PR. For measurements made for each individual commit, see the commit message.
SSE
  BEFORE
    1/2 graphene / ray-speed  OK             1.27s
    2/2 graphene / simd-speed OK             0.42s
  AFTER
    1/2 graphene / ray-speed  OK             1.12s
    2/2 graphene / simd-speed OK             0.47s

GCC VECTORIZATION
  BEFORE
    1/2 graphene / ray-speed  OK             1.32s
    2/2 graphene / simd-speed OK             1.12s
  AFTER
    1/2 graphene / ray-speed  OK             1.27s
    2/2 graphene / simd-speed OK             1.12s

SCALAR
  BEFORE
    1/2 graphene / ray-speed  OK             2.02s
    2/2 graphene / simd-speed OK             1.62s
  AFTER
    1/2 graphene / ray-speed  OK             1.87s
    2/2 graphene / simd-speed OK             1.32s

Status
Ready. The following items were done:

 Add unit tests.
 Measure performance and optimize where possible.
 Test the SSE implementation and adjust where necessary.
 Test the GCC vectorization implementation and adjust where necessary.
 Test the scalar implementation and adjust where necessary.
 Test the ARM NEON implementation and adjust where necessary.

Dependencies
The following PRs are included in this PR until merged:

#219 for the GCC vectorization adjustments","Unfortunately I don't own an ARM device, so I can't test the existing NEON implementation and check whether it needs to be adjusted as well. Looking at the pseudo-code in ARM's documentation and our existing NEON implementation of graphene_simd4f_reciprocal, I think it may already behave as expected without modification.
@ebassi, or someone else, I'd appreciate it if you could test this on an ARM device and confirm. I've added unit tests for the expected behavior under tests/simd.c for ease of testing.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,220,2021-04-02T11:53:23Z,2021-06-06T18:21:14Z,2021-06-06T18:21:14Z,CLOSED,False,133,48,6,https://github.com/doraskayo,simd4f: Make reciprocal operations 0-safe,6,[],https://github.com/ebassi/graphene/pull/220,https://github.com/doraskayo,4,https://github.com/ebassi/graphene/pull/220#issuecomment-812866432,"Description
From the main commit messages: (performance measurements omitted)
    simd4f: Make reciprocal operations 0-safe
    
    Introduce a well-defined behavior for the reciprocal calculation of
    positive and negative 0. These would now result in positive and
    negative infinity, respectively.
    
    This behavior follows the definition of the IEEE 754 standard.
    
    In the SSE implementation, _mm_rcp_ps() already returned positive or
    negative infinity when used on a positive or negative 0. However, since
    it is then multiplied by 0, we end up with NaN. NaN is then used in the
    next calculations, which finally result in it being returned.
    
    To avoid ending up with NaN, we use a mask created by _mm_cmpeq_ps()
    and a constant, and along with _mm_andnot_ps() we replace infinity with
    0 in the multiplication. After the following subtraction, we end up
    with 2 multiplied by the positive or negative infinity, which finally
    returns the expected result.
    
    The GCC vectorization and scalar implementations are adjusted to return
    infinity when calculating the reciprocal of 0, with copysign() used to
    set the expected sign of the result.
    
    The ARM NEON implementation doesn't require adjusting as it is already
    0-safe.
    
    This comes at a cost of ~11.9% for the SSE implementation, while the
    performance of the GCC vectorization and scalar implementations
    largely remains the same.

    ray: Remove nudging workaround
    
    Since the reciprocals of positive and negative 0 are now well-defined,
    this workaround should no longer be needed.

Performance
Tests
ray-speed: 50,000,000 ray intersection tests with a box, each using a unique ray.
simd-speed: 100,000,000 vector reciprocal calculations, each using a unique vector.
Results
The following are measurements made for the entire PR. For measurements made for each individual commit, see the commit message.
SSE
  BEFORE
    1/2 graphene / ray-speed  OK             1.27s
    2/2 graphene / simd-speed OK             0.42s
  AFTER
    1/2 graphene / ray-speed  OK             1.12s
    2/2 graphene / simd-speed OK             0.47s

GCC VECTORIZATION
  BEFORE
    1/2 graphene / ray-speed  OK             1.32s
    2/2 graphene / simd-speed OK             1.12s
  AFTER
    1/2 graphene / ray-speed  OK             1.27s
    2/2 graphene / simd-speed OK             1.12s

SCALAR
  BEFORE
    1/2 graphene / ray-speed  OK             2.02s
    2/2 graphene / simd-speed OK             1.62s
  AFTER
    1/2 graphene / ray-speed  OK             1.87s
    2/2 graphene / simd-speed OK             1.32s

Status
Ready. The following items were done:

 Add unit tests.
 Measure performance and optimize where possible.
 Test the SSE implementation and adjust where necessary.
 Test the GCC vectorization implementation and adjust where necessary.
 Test the scalar implementation and adjust where necessary.
 Test the ARM NEON implementation and adjust where necessary.

Dependencies
The following PRs are included in this PR until merged:

#219 for the GCC vectorization adjustments","I've used a QEMU user emulated environment to test the NEON implementation, and the implementation of graphene_simd4f_reciprocal does seem to already be 0-safe without modification.
However, it's better to confirm this on a bare-metal environment without a translation/emulation layer involved.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,220,2021-04-02T11:53:23Z,2021-06-06T18:21:14Z,2021-06-06T18:21:14Z,CLOSED,False,133,48,6,https://github.com/doraskayo,simd4f: Make reciprocal operations 0-safe,6,[],https://github.com/ebassi/graphene/pull/220,https://github.com/doraskayo,5,https://github.com/ebassi/graphene/pull/220#issuecomment-812873103,"Description
From the main commit messages: (performance measurements omitted)
    simd4f: Make reciprocal operations 0-safe
    
    Introduce a well-defined behavior for the reciprocal calculation of
    positive and negative 0. These would now result in positive and
    negative infinity, respectively.
    
    This behavior follows the definition of the IEEE 754 standard.
    
    In the SSE implementation, _mm_rcp_ps() already returned positive or
    negative infinity when used on a positive or negative 0. However, since
    it is then multiplied by 0, we end up with NaN. NaN is then used in the
    next calculations, which finally result in it being returned.
    
    To avoid ending up with NaN, we use a mask created by _mm_cmpeq_ps()
    and a constant, and along with _mm_andnot_ps() we replace infinity with
    0 in the multiplication. After the following subtraction, we end up
    with 2 multiplied by the positive or negative infinity, which finally
    returns the expected result.
    
    The GCC vectorization and scalar implementations are adjusted to return
    infinity when calculating the reciprocal of 0, with copysign() used to
    set the expected sign of the result.
    
    The ARM NEON implementation doesn't require adjusting as it is already
    0-safe.
    
    This comes at a cost of ~11.9% for the SSE implementation, while the
    performance of the GCC vectorization and scalar implementations
    largely remains the same.

    ray: Remove nudging workaround
    
    Since the reciprocals of positive and negative 0 are now well-defined,
    this workaround should no longer be needed.

Performance
Tests
ray-speed: 50,000,000 ray intersection tests with a box, each using a unique ray.
simd-speed: 100,000,000 vector reciprocal calculations, each using a unique vector.
Results
The following are measurements made for the entire PR. For measurements made for each individual commit, see the commit message.
SSE
  BEFORE
    1/2 graphene / ray-speed  OK             1.27s
    2/2 graphene / simd-speed OK             0.42s
  AFTER
    1/2 graphene / ray-speed  OK             1.12s
    2/2 graphene / simd-speed OK             0.47s

GCC VECTORIZATION
  BEFORE
    1/2 graphene / ray-speed  OK             1.32s
    2/2 graphene / simd-speed OK             1.12s
  AFTER
    1/2 graphene / ray-speed  OK             1.27s
    2/2 graphene / simd-speed OK             1.12s

SCALAR
  BEFORE
    1/2 graphene / ray-speed  OK             2.02s
    2/2 graphene / simd-speed OK             1.62s
  AFTER
    1/2 graphene / ray-speed  OK             1.87s
    2/2 graphene / simd-speed OK             1.32s

Status
Ready. The following items were done:

 Add unit tests.
 Measure performance and optimize where possible.
 Test the SSE implementation and adjust where necessary.
 Test the GCC vectorization implementation and adjust where necessary.
 Test the scalar implementation and adjust where necessary.
 Test the ARM NEON implementation and adjust where necessary.

Dependencies
The following PRs are included in this PR until merged:

#219 for the GCC vectorization adjustments","I enabled NEON for AArch64 on Linux in #221, and included it in this PR for testing purposes. I want to avoid a situation where someone would test this branch on AArch64 hardware and confirm that the NEON implementation doesn't require adjustments without actually running the NEON code-path.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,220,2021-04-02T11:53:23Z,2021-06-06T18:21:14Z,2021-06-06T18:21:14Z,CLOSED,False,133,48,6,https://github.com/doraskayo,simd4f: Make reciprocal operations 0-safe,6,[],https://github.com/ebassi/graphene/pull/220,https://github.com/doraskayo,6,https://github.com/ebassi/graphene/pull/220#issuecomment-820222783,"Description
From the main commit messages: (performance measurements omitted)
    simd4f: Make reciprocal operations 0-safe
    
    Introduce a well-defined behavior for the reciprocal calculation of
    positive and negative 0. These would now result in positive and
    negative infinity, respectively.
    
    This behavior follows the definition of the IEEE 754 standard.
    
    In the SSE implementation, _mm_rcp_ps() already returned positive or
    negative infinity when used on a positive or negative 0. However, since
    it is then multiplied by 0, we end up with NaN. NaN is then used in the
    next calculations, which finally result in it being returned.
    
    To avoid ending up with NaN, we use a mask created by _mm_cmpeq_ps()
    and a constant, and along with _mm_andnot_ps() we replace infinity with
    0 in the multiplication. After the following subtraction, we end up
    with 2 multiplied by the positive or negative infinity, which finally
    returns the expected result.
    
    The GCC vectorization and scalar implementations are adjusted to return
    infinity when calculating the reciprocal of 0, with copysign() used to
    set the expected sign of the result.
    
    The ARM NEON implementation doesn't require adjusting as it is already
    0-safe.
    
    This comes at a cost of ~11.9% for the SSE implementation, while the
    performance of the GCC vectorization and scalar implementations
    largely remains the same.

    ray: Remove nudging workaround
    
    Since the reciprocals of positive and negative 0 are now well-defined,
    this workaround should no longer be needed.

Performance
Tests
ray-speed: 50,000,000 ray intersection tests with a box, each using a unique ray.
simd-speed: 100,000,000 vector reciprocal calculations, each using a unique vector.
Results
The following are measurements made for the entire PR. For measurements made for each individual commit, see the commit message.
SSE
  BEFORE
    1/2 graphene / ray-speed  OK             1.27s
    2/2 graphene / simd-speed OK             0.42s
  AFTER
    1/2 graphene / ray-speed  OK             1.12s
    2/2 graphene / simd-speed OK             0.47s

GCC VECTORIZATION
  BEFORE
    1/2 graphene / ray-speed  OK             1.32s
    2/2 graphene / simd-speed OK             1.12s
  AFTER
    1/2 graphene / ray-speed  OK             1.27s
    2/2 graphene / simd-speed OK             1.12s

SCALAR
  BEFORE
    1/2 graphene / ray-speed  OK             2.02s
    2/2 graphene / simd-speed OK             1.62s
  AFTER
    1/2 graphene / ray-speed  OK             1.87s
    2/2 graphene / simd-speed OK             1.32s

Status
Ready. The following items were done:

 Add unit tests.
 Measure performance and optimize where possible.
 Test the SSE implementation and adjust where necessary.
 Test the GCC vectorization implementation and adjust where necessary.
 Test the scalar implementation and adjust where necessary.
 Test the ARM NEON implementation and adjust where necessary.

Dependencies
The following PRs are included in this PR until merged:

#219 for the GCC vectorization adjustments","I ended up installing Linux on an old armv7l phone with NEON support. As expected, the NEON implementation is already 0-safe and requires no additional modifications.
So it seems everything works ðŸ˜€",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,220,2021-04-02T11:53:23Z,2021-06-06T18:21:14Z,2021-06-06T18:21:14Z,CLOSED,False,133,48,6,https://github.com/doraskayo,simd4f: Make reciprocal operations 0-safe,6,[],https://github.com/ebassi/graphene/pull/220,https://github.com/doraskayo,7,https://github.com/ebassi/graphene/pull/220#issuecomment-820231477,"Description
From the main commit messages: (performance measurements omitted)
    simd4f: Make reciprocal operations 0-safe
    
    Introduce a well-defined behavior for the reciprocal calculation of
    positive and negative 0. These would now result in positive and
    negative infinity, respectively.
    
    This behavior follows the definition of the IEEE 754 standard.
    
    In the SSE implementation, _mm_rcp_ps() already returned positive or
    negative infinity when used on a positive or negative 0. However, since
    it is then multiplied by 0, we end up with NaN. NaN is then used in the
    next calculations, which finally result in it being returned.
    
    To avoid ending up with NaN, we use a mask created by _mm_cmpeq_ps()
    and a constant, and along with _mm_andnot_ps() we replace infinity with
    0 in the multiplication. After the following subtraction, we end up
    with 2 multiplied by the positive or negative infinity, which finally
    returns the expected result.
    
    The GCC vectorization and scalar implementations are adjusted to return
    infinity when calculating the reciprocal of 0, with copysign() used to
    set the expected sign of the result.
    
    The ARM NEON implementation doesn't require adjusting as it is already
    0-safe.
    
    This comes at a cost of ~11.9% for the SSE implementation, while the
    performance of the GCC vectorization and scalar implementations
    largely remains the same.

    ray: Remove nudging workaround
    
    Since the reciprocals of positive and negative 0 are now well-defined,
    this workaround should no longer be needed.

Performance
Tests
ray-speed: 50,000,000 ray intersection tests with a box, each using a unique ray.
simd-speed: 100,000,000 vector reciprocal calculations, each using a unique vector.
Results
The following are measurements made for the entire PR. For measurements made for each individual commit, see the commit message.
SSE
  BEFORE
    1/2 graphene / ray-speed  OK             1.27s
    2/2 graphene / simd-speed OK             0.42s
  AFTER
    1/2 graphene / ray-speed  OK             1.12s
    2/2 graphene / simd-speed OK             0.47s

GCC VECTORIZATION
  BEFORE
    1/2 graphene / ray-speed  OK             1.32s
    2/2 graphene / simd-speed OK             1.12s
  AFTER
    1/2 graphene / ray-speed  OK             1.27s
    2/2 graphene / simd-speed OK             1.12s

SCALAR
  BEFORE
    1/2 graphene / ray-speed  OK             2.02s
    2/2 graphene / simd-speed OK             1.62s
  AFTER
    1/2 graphene / ray-speed  OK             1.87s
    2/2 graphene / simd-speed OK             1.32s

Status
Ready. The following items were done:

 Add unit tests.
 Measure performance and optimize where possible.
 Test the SSE implementation and adjust where necessary.
 Test the GCC vectorization implementation and adjust where necessary.
 Test the scalar implementation and adjust where necessary.
 Test the ARM NEON implementation and adjust where necessary.

Dependencies
The following PRs are included in this PR until merged:

#219 for the GCC vectorization adjustments","I removed the dependency on #221 as it was only added to ease the testing of the ARM NEON implementation. Now that it was fully tested, it's no longer needed.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,220,2021-04-02T11:53:23Z,2021-06-06T18:21:14Z,2021-06-06T18:21:14Z,CLOSED,False,133,48,6,https://github.com/doraskayo,simd4f: Make reciprocal operations 0-safe,6,[],https://github.com/ebassi/graphene/pull/220,https://github.com/doraskayo,8,https://github.com/ebassi/graphene/pull/220#issuecomment-821817838,"Description
From the main commit messages: (performance measurements omitted)
    simd4f: Make reciprocal operations 0-safe
    
    Introduce a well-defined behavior for the reciprocal calculation of
    positive and negative 0. These would now result in positive and
    negative infinity, respectively.
    
    This behavior follows the definition of the IEEE 754 standard.
    
    In the SSE implementation, _mm_rcp_ps() already returned positive or
    negative infinity when used on a positive or negative 0. However, since
    it is then multiplied by 0, we end up with NaN. NaN is then used in the
    next calculations, which finally result in it being returned.
    
    To avoid ending up with NaN, we use a mask created by _mm_cmpeq_ps()
    and a constant, and along with _mm_andnot_ps() we replace infinity with
    0 in the multiplication. After the following subtraction, we end up
    with 2 multiplied by the positive or negative infinity, which finally
    returns the expected result.
    
    The GCC vectorization and scalar implementations are adjusted to return
    infinity when calculating the reciprocal of 0, with copysign() used to
    set the expected sign of the result.
    
    The ARM NEON implementation doesn't require adjusting as it is already
    0-safe.
    
    This comes at a cost of ~11.9% for the SSE implementation, while the
    performance of the GCC vectorization and scalar implementations
    largely remains the same.

    ray: Remove nudging workaround
    
    Since the reciprocals of positive and negative 0 are now well-defined,
    this workaround should no longer be needed.

Performance
Tests
ray-speed: 50,000,000 ray intersection tests with a box, each using a unique ray.
simd-speed: 100,000,000 vector reciprocal calculations, each using a unique vector.
Results
The following are measurements made for the entire PR. For measurements made for each individual commit, see the commit message.
SSE
  BEFORE
    1/2 graphene / ray-speed  OK             1.27s
    2/2 graphene / simd-speed OK             0.42s
  AFTER
    1/2 graphene / ray-speed  OK             1.12s
    2/2 graphene / simd-speed OK             0.47s

GCC VECTORIZATION
  BEFORE
    1/2 graphene / ray-speed  OK             1.32s
    2/2 graphene / simd-speed OK             1.12s
  AFTER
    1/2 graphene / ray-speed  OK             1.27s
    2/2 graphene / simd-speed OK             1.12s

SCALAR
  BEFORE
    1/2 graphene / ray-speed  OK             2.02s
    2/2 graphene / simd-speed OK             1.62s
  AFTER
    1/2 graphene / ray-speed  OK             1.87s
    2/2 graphene / simd-speed OK             1.32s

Status
Ready. The following items were done:

 Add unit tests.
 Measure performance and optimize where possible.
 Test the SSE implementation and adjust where necessary.
 Test the GCC vectorization implementation and adjust where necessary.
 Test the scalar implementation and adjust where necessary.
 Test the ARM NEON implementation and adjust where necessary.

Dependencies
The following PRs are included in this PR until merged:

#219 for the GCC vectorization adjustments","I made a bunch of before/after performance measurements per commit (see commit messages) and for the entire PR (see PR description).
I think this is ready now. @ebassi, I'd appreciate your review and thoughts.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,220,2021-04-02T11:53:23Z,2021-06-06T18:21:14Z,2021-06-06T18:21:14Z,CLOSED,False,133,48,6,https://github.com/doraskayo,simd4f: Make reciprocal operations 0-safe,6,[],https://github.com/ebassi/graphene/pull/220,https://github.com/ebassi,9,https://github.com/ebassi/graphene/pull/220#issuecomment-855440356,"Description
From the main commit messages: (performance measurements omitted)
    simd4f: Make reciprocal operations 0-safe
    
    Introduce a well-defined behavior for the reciprocal calculation of
    positive and negative 0. These would now result in positive and
    negative infinity, respectively.
    
    This behavior follows the definition of the IEEE 754 standard.
    
    In the SSE implementation, _mm_rcp_ps() already returned positive or
    negative infinity when used on a positive or negative 0. However, since
    it is then multiplied by 0, we end up with NaN. NaN is then used in the
    next calculations, which finally result in it being returned.
    
    To avoid ending up with NaN, we use a mask created by _mm_cmpeq_ps()
    and a constant, and along with _mm_andnot_ps() we replace infinity with
    0 in the multiplication. After the following subtraction, we end up
    with 2 multiplied by the positive or negative infinity, which finally
    returns the expected result.
    
    The GCC vectorization and scalar implementations are adjusted to return
    infinity when calculating the reciprocal of 0, with copysign() used to
    set the expected sign of the result.
    
    The ARM NEON implementation doesn't require adjusting as it is already
    0-safe.
    
    This comes at a cost of ~11.9% for the SSE implementation, while the
    performance of the GCC vectorization and scalar implementations
    largely remains the same.

    ray: Remove nudging workaround
    
    Since the reciprocals of positive and negative 0 are now well-defined,
    this workaround should no longer be needed.

Performance
Tests
ray-speed: 50,000,000 ray intersection tests with a box, each using a unique ray.
simd-speed: 100,000,000 vector reciprocal calculations, each using a unique vector.
Results
The following are measurements made for the entire PR. For measurements made for each individual commit, see the commit message.
SSE
  BEFORE
    1/2 graphene / ray-speed  OK             1.27s
    2/2 graphene / simd-speed OK             0.42s
  AFTER
    1/2 graphene / ray-speed  OK             1.12s
    2/2 graphene / simd-speed OK             0.47s

GCC VECTORIZATION
  BEFORE
    1/2 graphene / ray-speed  OK             1.32s
    2/2 graphene / simd-speed OK             1.12s
  AFTER
    1/2 graphene / ray-speed  OK             1.27s
    2/2 graphene / simd-speed OK             1.12s

SCALAR
  BEFORE
    1/2 graphene / ray-speed  OK             2.02s
    2/2 graphene / simd-speed OK             1.62s
  AFTER
    1/2 graphene / ray-speed  OK             1.87s
    2/2 graphene / simd-speed OK             1.32s

Status
Ready. The following items were done:

 Add unit tests.
 Measure performance and optimize where possible.
 Test the SSE implementation and adjust where necessary.
 Test the GCC vectorization implementation and adjust where necessary.
 Test the scalar implementation and adjust where necessary.
 Test the ARM NEON implementation and adjust where necessary.

Dependencies
The following PRs are included in this PR until merged:

#219 for the GCC vectorization adjustments","GitHub was having a fit every time I tried to run the CI, so I had to merge it manually.
Thanks for the changes!",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,221,2021-04-03T13:49:58Z,2021-06-06T19:02:14Z,2021-06-06T19:02:14Z,MERGED,True,10,7,2,https://github.com/doraskayo,Enable NEON for AArch64 on Linux,2,[],https://github.com/ebassi/graphene/pull/221,https://github.com/doraskayo,1,https://github.com/ebassi/graphene/pull/221,"I actually don't have the hardware to test this, but in my QEMU user emulated environment it seems to allow AArch64 to use the NEON code-paths.
NEON for AArch64 has been supposedly enabled on Windows builds since 29f9eb0, but remained disabled on Linux builds.","I actually don't have the hardware to test this, but in my QEMU user emulated environment it seems to allow AArch64 to use the NEON code-paths.
NEON for AArch64 has been supposedly enabled on Windows builds since 29f9eb0, but remained disabled on Linux builds.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,221,2021-04-03T13:49:58Z,2021-06-06T19:02:14Z,2021-06-06T19:02:14Z,MERGED,True,10,7,2,https://github.com/doraskayo,Enable NEON for AArch64 on Linux,2,[],https://github.com/ebassi/graphene/pull/221,https://github.com/linkmauve,2,https://github.com/ebassi/graphene/pull/221#issuecomment-812871613,"I actually don't have the hardware to test this, but in my QEMU user emulated environment it seems to allow AArch64 to use the NEON code-paths.
NEON for AArch64 has been supposedly enabled on Windows builds since 29f9eb0, but remained disabled on Linux builds.","This does enable NEON vector operations on my phone while in AArch64 mode, I never noticed those were missing before, thanks!",True,{'HEART': ['https://github.com/doraskayo']}
ebassi/graphene,https://github.com/ebassi/graphene,224,2021-04-11T19:05:09Z,2021-06-06T18:23:07Z,2021-06-06T19:21:39Z,CLOSED,False,106,1,2,https://github.com/sbstnk,ray: Fix ray/box intersection on systems without isnanf,2,[],https://github.com/ebassi/graphene/pull/224,https://github.com/sbstnk,1,https://github.com/ebassi/graphene/pull/224,"Fixes #223
Proposed changes:

Fix the typo in the non-HAVE_ISNANF code path to match the behavior of the HAVE_ISNANF code path.","Fixes #223
Proposed changes:

Fix the typo in the non-HAVE_ISNANF code path to match the behavior of the HAVE_ISNANF code path.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,224,2021-04-11T19:05:09Z,2021-06-06T18:23:07Z,2021-06-06T19:21:39Z,CLOSED,False,106,1,2,https://github.com/sbstnk,ray: Fix ray/box intersection on systems without isnanf,2,[],https://github.com/ebassi/graphene/pull/224,https://github.com/Gottox,2,https://github.com/ebassi/graphene/pull/224#issuecomment-817357450,"Fixes #223
Proposed changes:

Fix the typo in the non-HAVE_ISNANF code path to match the behavior of the HAVE_ISNANF code path.",It would be awesome to add a testcase for this issue.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,224,2021-04-11T19:05:09Z,2021-06-06T18:23:07Z,2021-06-06T19:21:39Z,CLOSED,False,106,1,2,https://github.com/sbstnk,ray: Fix ray/box intersection on systems without isnanf,2,[],https://github.com/ebassi/graphene/pull/224,https://github.com/ebassi,3,https://github.com/ebassi/graphene/pull/224#issuecomment-817357734,"Fixes #223
Proposed changes:

Fix the typo in the non-HAVE_ISNANF code path to match the behavior of the HAVE_ISNANF code path.","Indeed, it would be awesome to have a test case. :-)",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,224,2021-04-11T19:05:09Z,2021-06-06T18:23:07Z,2021-06-06T19:21:39Z,CLOSED,False,106,1,2,https://github.com/sbstnk,ray: Fix ray/box intersection on systems without isnanf,2,[],https://github.com/ebassi/graphene/pull/224,https://github.com/ericonr,4,https://github.com/ebassi/graphene/pull/224#issuecomment-817357852,"Fixes #223
Proposed changes:

Fix the typo in the non-HAVE_ISNANF code path to match the behavior of the HAVE_ISNANF code path.","I think merging this as a simple patch is reasonable, but I would recommend going with #225 later. I can rebase it.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,224,2021-04-11T19:05:09Z,2021-06-06T18:23:07Z,2021-06-06T19:21:39Z,CLOSED,False,106,1,2,https://github.com/sbstnk,ray: Fix ray/box intersection on systems without isnanf,2,[],https://github.com/ebassi/graphene/pull/224,https://github.com/sbstnk,5,https://github.com/ebassi/graphene/pull/224#issuecomment-817358977,"Fixes #223
Proposed changes:

Fix the typo in the non-HAVE_ISNANF code path to match the behavior of the HAVE_ISNANF code path.","I wasn't sure about adding a test case, because due to the nature of the bug that would just be some random numbers for which it happens to fail instead of a real class of issues. But I can add the example from the bug report as a test. Can't think of a good name for such a test though.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,224,2021-04-11T19:05:09Z,2021-06-06T18:23:07Z,2021-06-06T19:21:39Z,CLOSED,False,106,1,2,https://github.com/sbstnk,ray: Fix ray/box intersection on systems without isnanf,2,[],https://github.com/ebassi/graphene/pull/224,https://github.com/sbstnk,6,https://github.com/ebassi/graphene/pull/224#issuecomment-817364012,"Fixes #223
Proposed changes:

Fix the typo in the non-HAVE_ISNANF code path to match the behavior of the HAVE_ISNANF code path.",I was thinking of turning the code I used to find these random numbers into a test that does picking for ~1000 random coordinates like it would be done in clutter/mutter. Not sure how useful such non-deterministic tests would be though.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,224,2021-04-11T19:05:09Z,2021-06-06T18:23:07Z,2021-06-06T19:21:39Z,CLOSED,False,106,1,2,https://github.com/sbstnk,ray: Fix ray/box intersection on systems without isnanf,2,[],https://github.com/ebassi/graphene/pull/224,https://github.com/sbstnk,7,https://github.com/ebassi/graphene/pull/224#issuecomment-817377300,"Fixes #223
Proposed changes:

Fix the typo in the non-HAVE_ISNANF code path to match the behavior of the HAVE_ISNANF code path.","I couldn't find a way to make a useful test with random positions, so I went with some hardcoded ones.
This includes code based on Mutter/Clutter which was written by @GeorgesStavracas. Since Mutter is GPL and graphene is MIT, are you okay with using that code under MIT @GeorgesStavracas?",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,224,2021-04-11T19:05:09Z,2021-06-06T18:23:07Z,2021-06-06T19:21:39Z,CLOSED,False,106,1,2,https://github.com/sbstnk,ray: Fix ray/box intersection on systems without isnanf,2,[],https://github.com/ebassi/graphene/pull/224,https://github.com/GeorgesStavracas,8,https://github.com/ebassi/graphene/pull/224#issuecomment-817380458,"Fixes #223
Proposed changes:

Fix the typo in the non-HAVE_ISNANF code path to match the behavior of the HAVE_ISNANF code path.",I'm fine with it ðŸ™‚,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,224,2021-04-11T19:05:09Z,2021-06-06T18:23:07Z,2021-06-06T19:21:39Z,CLOSED,False,106,1,2,https://github.com/sbstnk,ray: Fix ray/box intersection on systems without isnanf,2,[],https://github.com/ebassi/graphene/pull/224,https://github.com/ebassi,9,https://github.com/ebassi/graphene/pull/224#issuecomment-855440598,"Fixes #223
Proposed changes:

Fix the typo in the non-HAVE_ISNANF code path to match the behavior of the HAVE_ISNANF code path.",I think both #225 and #220 have fixed most of these issues.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,224,2021-04-11T19:05:09Z,2021-06-06T18:23:07Z,2021-06-06T19:21:39Z,CLOSED,False,106,1,2,https://github.com/sbstnk,ray: Fix ray/box intersection on systems without isnanf,2,[],https://github.com/ebassi/graphene/pull/224,https://github.com/sbstnk,10,https://github.com/ebassi/graphene/pull/224#issuecomment-855447013,"Fixes #223
Proposed changes:

Fix the typo in the non-HAVE_ISNANF code path to match the behavior of the HAVE_ISNANF code path.",Would it make sense to open a separate PR with just the test since a test was specifically requested here and the merged fix did not have one?,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,224,2021-04-11T19:05:09Z,2021-06-06T18:23:07Z,2021-06-06T19:21:39Z,CLOSED,False,106,1,2,https://github.com/sbstnk,ray: Fix ray/box intersection on systems without isnanf,2,[],https://github.com/ebassi/graphene/pull/224,https://github.com/ebassi,11,https://github.com/ebassi/graphene/pull/224#issuecomment-855448953,"Fixes #223
Proposed changes:

Fix the typo in the non-HAVE_ISNANF code path to match the behavior of the HAVE_ISNANF code path.","Yes, sure.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,225,2021-04-11T19:14:12Z,2021-06-06T18:14:35Z,2021-06-06T18:14:35Z,MERGED,True,12,23,2,https://github.com/ericonr,ray: simplify nan checking by creating a macro.,1,[],https://github.com/ebassi/graphene/pull/225,https://github.com/ericonr,1,https://github.com/ebassi/graphene/pull/225,"Avoids the #ifdef forest and code duplication resulting from it.
There was mismatch in the two code paths, see [1] and [2], and this
commit avoids repeating the same mistake.
[1] #223
[2] https://gitlab.gnome.org/GNOME/gnome-shell/-/issues/3976
Fixes #223","Avoids the #ifdef forest and code duplication resulting from it.
There was mismatch in the two code paths, see [1] and [2], and this
commit avoids repeating the same mistake.
[1] #223
[2] https://gitlab.gnome.org/GNOME/gnome-shell/-/issues/3976
Fixes #223",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,225,2021-04-11T19:14:12Z,2021-06-06T18:14:35Z,2021-06-06T18:14:35Z,MERGED,True,12,23,2,https://github.com/ericonr,ray: simplify nan checking by creating a macro.,1,[],https://github.com/ebassi/graphene/pull/225,https://github.com/Gottox,2,https://github.com/ebassi/graphene/pull/225#issuecomment-817358227,"Avoids the #ifdef forest and code duplication resulting from it.
There was mismatch in the two code paths, see [1] and [2], and this
commit avoids repeating the same mistake.
[1] #223
[2] https://gitlab.gnome.org/GNOME/gnome-shell/-/issues/3976
Fixes #223",Be aware of this comment: #174 (comment),True,{}
ebassi/graphene,https://github.com/ebassi/graphene,225,2021-04-11T19:14:12Z,2021-06-06T18:14:35Z,2021-06-06T18:14:35Z,MERGED,True,12,23,2,https://github.com/ericonr,ray: simplify nan checking by creating a macro.,1,[],https://github.com/ebassi/graphene/pull/225,https://github.com/ericonr,3,https://github.com/ebassi/graphene/pull/225#issuecomment-817358342,"Avoids the #ifdef forest and code duplication resulting from it.
There was mismatch in the two code paths, see [1] and [2], and this
commit avoids repeating the same mistake.
[1] #223
[2] https://gitlab.gnome.org/GNOME/gnome-shell/-/issues/3976
Fixes #223","@Gottox I am still using isnanf when available, just avoiding the code duplication resulting from how it was originally implemented.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,225,2021-04-11T19:14:12Z,2021-06-06T18:14:35Z,2021-06-06T18:14:35Z,MERGED,True,12,23,2,https://github.com/ericonr,ray: simplify nan checking by creating a macro.,1,[],https://github.com/ebassi/graphene/pull/225,https://github.com/ericonr,4,https://github.com/ebassi/graphene/pull/225#issuecomment-842667125,"Avoids the #ifdef forest and code duplication resulting from it.
There was mismatch in the two code paths, see [1] and [2], and this
commit avoids repeating the same mistake.
[1] #223
[2] https://gitlab.gnome.org/GNOME/gnome-shell/-/issues/3976
Fixes #223",Ping?,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,226,2021-04-11T19:53:16Z,2021-06-06T17:24:57Z,2021-06-06T17:25:06Z,MERGED,True,38,0,1,https://github.com/Gottox,Add a Github action to test on Alpine,1,[],https://github.com/ebassi/graphene/pull/226,https://github.com/Gottox,1,https://github.com/ebassi/graphene/pull/226,"Proposed changes:

Add a Github action to test on Alpine

Benchmark results:

Before: not relevant
After: not relevant

Test suite changes:

This PR introduces a new github action to build and test graphene on a musl-libc based distribution.","Proposed changes:

Add a Github action to test on Alpine

Benchmark results:

Before: not relevant
After: not relevant

Test suite changes:

This PR introduces a new github action to build and test graphene on a musl-libc based distribution.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,226,2021-04-11T19:53:16Z,2021-06-06T17:24:57Z,2021-06-06T17:25:06Z,MERGED,True,38,0,1,https://github.com/Gottox,Add a Github action to test on Alpine,1,[],https://github.com/ebassi/graphene/pull/226,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/226#issuecomment-855432875,"Proposed changes:

Add a Github action to test on Alpine

Benchmark results:

Before: not relevant
After: not relevant

Test suite changes:

This PR introduces a new github action to build and test graphene on a musl-libc based distribution.","Thanks, much appreciated!",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,229,2021-06-05T04:59:25Z,2021-09-05T17:27:04Z,2021-09-05T17:27:04Z,MERGED,True,10,2,2,https://github.com/fanc999,build: Fix ARM64 (aarch64) builds on Visual Studio 2017,3,[],https://github.com/ebassi/graphene/pull/229,https://github.com/fanc999,1,https://github.com/ebassi/graphene/pull/229,"Hi,
From the commit message:
On Visual Studio 2017, it is unfortunate that it does not allow us to include arm_neon.h directly for ARM64 builds, so we must include arm64_neon.h instead.
Interestingly, Visual Studio 2019 can include arm_neon.h directly for ARM64 builds, which will in turn include arm64_neon.h
Fix the Visual Studio 2017 ARM64 build by:


Updating the check program to include arm64_neon.h when building with Visual Studio 2017 for ARM64.


Use macros in graphene-config.h.meson so that we include the right header depending on the compiler being used when building for ARM64.


With blessings, thank you!","Hi,
From the commit message:
On Visual Studio 2017, it is unfortunate that it does not allow us to include arm_neon.h directly for ARM64 builds, so we must include arm64_neon.h instead.
Interestingly, Visual Studio 2019 can include arm_neon.h directly for ARM64 builds, which will in turn include arm64_neon.h
Fix the Visual Studio 2017 ARM64 build by:


Updating the check program to include arm64_neon.h when building with Visual Studio 2017 for ARM64.


Use macros in graphene-config.h.meson so that we include the right header depending on the compiler being used when building for ARM64.


With blessings, thank you!",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,230,2021-06-06T17:09:41Z,2021-06-06T18:56:35Z,2021-06-06T18:56:35Z,MERGED,True,2,0,1,https://github.com/mdevlamynck,Fix installation of the introspection.py file for installed-tests,1,[],https://github.com/ebassi/graphene/pull/230,https://github.com/mdevlamynck,1,https://github.com/ebassi/graphene/pull/230,Fixes installed-test. The instrospection.py file was not installed which made the corresponding test fail to run.,Fixes installed-test. The instrospection.py file was not installed which made the corresponding test fail to run.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,231,2021-06-06T19:20:20Z,2021-06-06T23:01:43Z,2021-06-06T23:01:56Z,MERGED,True,41,6,6,https://github.com/ebassi,Update the Meson version,4,[],https://github.com/ebassi/graphene/pull/231,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/231,We want to use some of the newer features in Meson.,We want to use some of the newer features in Meson.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,232,2021-06-06T22:44:35Z,2021-06-06T23:41:19Z,2021-06-06T23:41:19Z,MERGED,True,105,0,1,https://github.com/sbstnk,Add test for ray/box intersection based picking,1,[],https://github.com/ebassi/graphene/pull/232,https://github.com/sbstnk,1,https://github.com/ebassi/graphene/pull/232,This test was split out from #224 which was fixed differently but without a test.,This test was split out from #224 which was fixed differently but without a test.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,233,2021-06-09T14:04:04Z,2021-07-16T12:46:55Z,2021-11-26T19:06:03Z,MERGED,True,1,1,1,https://github.com/q66,meson: fix gcc vector 64-bit check,1,[],https://github.com/ebassi/graphene/pull/233,https://github.com/q66,1,https://github.com/ebassi/graphene/pull/233,"the previous behavior only ever enabled gcc vectors on x86_64
this results in a massive performance improvement in gnome 40 on ppc64le","the previous behavior only ever enabled gcc vectors on x86_64
this results in a massive performance improvement in gnome 40 on ppc64le",True,"{'HOORAY': ['https://github.com/classilla', 'https://github.com/sharkcz', 'https://github.com/MPC7500', 'https://github.com/thesamesam']}"
ebassi/graphene,https://github.com/ebassi/graphene,233,2021-06-09T14:04:04Z,2021-07-16T12:46:55Z,2021-11-26T19:06:03Z,MERGED,True,1,1,1,https://github.com/q66,meson: fix gcc vector 64-bit check,1,[],https://github.com/ebassi/graphene/pull/233,https://github.com/q66,2,https://github.com/ebassi/graphene/pull/233#issuecomment-858172366,"the previous behavior only ever enabled gcc vectors on x86_64
this results in a massive performance improvement in gnome 40 on ppc64le","btw, I also noticed that similarly, the check will not pick up clang (even though it should probably also work)
this is because all clang versions report __GNUC__ as 4 and __GNUC_MINOR__ as 2, so the test thinks it's gcc 4.2; perhaps adding __clang__ explicitly would also be good, though I haven't tested this configuration and it'd need modifying in more places than just this meson.build, so it's out of scope for this PR",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,233,2021-06-09T14:04:04Z,2021-07-16T12:46:55Z,2021-11-26T19:06:03Z,MERGED,True,1,1,1,https://github.com/q66,meson: fix gcc vector 64-bit check,1,[],https://github.com/ebassi/graphene/pull/233,https://github.com/ebassi,3,https://github.com/ebassi/graphene/pull/233#issuecomment-859513106,"the previous behavior only ever enabled gcc vectors on x86_64
this results in a massive performance improvement in gnome 40 on ppc64le","Yes, I'd leave the Clang support for another pull request, especially if it comes with some numbers as to whether Clang/LLVM support for vector types is on par with GCC's.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,233,2021-06-09T14:04:04Z,2021-07-16T12:46:55Z,2021-11-26T19:06:03Z,MERGED,True,1,1,1,https://github.com/q66,meson: fix gcc vector 64-bit check,1,[],https://github.com/ebassi/graphene/pull/233,https://github.com/sharkcz,4,https://github.com/ebassi/graphene/pull/233#issuecomment-859520789,"the previous behavior only ever enabled gcc vectors on x86_64
this results in a massive performance improvement in gnome 40 on ppc64le","I believe we want the GCC vector stuff for every possible arch (ppc64, s390x, mips64, ...), so hard-coding a list is not a good solution.
64 bit PowerPC defines __powerpc64__, I have tested this patch on s390x that defines __s390x__, and there will be more ...",True,{'THUMBS_UP': ['https://github.com/classilla']}
ebassi/graphene,https://github.com/ebassi/graphene,233,2021-06-09T14:04:04Z,2021-07-16T12:46:55Z,2021-11-26T19:06:03Z,MERGED,True,1,1,1,https://github.com/q66,meson: fix gcc vector 64-bit check,1,[],https://github.com/ebassi/graphene/pull/233,https://github.com/ebassi,5,https://github.com/ebassi/graphene/pull/233#issuecomment-859522607,"the previous behavior only ever enabled gcc vectors on x86_64
this results in a massive performance improvement in gnome 40 on ppc64le","I believe we want the GCC vector stuff for every possible arch (ppc64, s390x, mips64, ...)

I believe that as well, in theory, except that GCC has had bugs in the past, and I don't have access to any of those architectures, so I can't put them under CI.
I'm tentatively ðŸ‘ on this pull request, but I'd like actual confirmation that somebody is actually testing this stuff, and can follow up with fixes in case something breaks.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,233,2021-06-09T14:04:04Z,2021-07-16T12:46:55Z,2021-11-26T19:06:03Z,MERGED,True,1,1,1,https://github.com/q66,meson: fix gcc vector 64-bit check,1,[],https://github.com/ebassi/graphene/pull/233,https://github.com/sharkcz,6,https://github.com/ebassi/graphene/pull/233#issuecomment-859529546,"the previous behavior only ever enabled gcc vectors on x86_64
this results in a massive performance improvement in gnome 40 on ppc64le","If you can use Travis for CI, then it has ppc64le and s390x (and aarch64 too) available. I can (and likely will) add graphene to our private Fedora multi-arch CI or can provide to our public shared machines, if needed.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,233,2021-06-09T14:04:04Z,2021-07-16T12:46:55Z,2021-11-26T19:06:03Z,MERGED,True,1,1,1,https://github.com/q66,meson: fix gcc vector 64-bit check,1,[],https://github.com/ebassi/graphene/pull/233,https://github.com/q66,7,https://github.com/ebassi/graphene/pull/233#issuecomment-859540788,"the previous behavior only ever enabled gcc vectors on x86_64
this results in a massive performance improvement in gnome 40 on ppc64le","what's the actual reason gcc vectors can't work on 32-bit architectures, by the way? (though a lot of 32-bit CPUs don't have any kind of SIMD)
if things can work on those that do have SIMD, i don't see a reason to always disable it (if some are found to be broken, distributions/users can explicitly disable it via meson options, and a special case could be added later)",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,233,2021-06-09T14:04:04Z,2021-07-16T12:46:55Z,2021-11-26T19:06:03Z,MERGED,True,1,1,1,https://github.com/q66,meson: fix gcc vector 64-bit check,1,[],https://github.com/ebassi/graphene/pull/233,https://github.com/q66,8,https://github.com/ebassi/graphene/pull/233#issuecomment-859544740,"the previous behavior only ever enabled gcc vectors on x86_64
this results in a massive performance improvement in gnome 40 on ppc64le","anyway, as far as testing goes: in our distro we have support for all ppc architectures (i.e. ppc64le, ppc64, ppc, ppcle) and i daily drive gnome on ppc64le with musl (since that's my primary workstation setup; i occasionally test the others on a variety of hardware as well), so testing is being done...",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,233,2021-06-09T14:04:04Z,2021-07-16T12:46:55Z,2021-11-26T19:06:03Z,MERGED,True,1,1,1,https://github.com/q66,meson: fix gcc vector 64-bit check,1,[],https://github.com/ebassi/graphene/pull/233,https://github.com/classilla,9,https://github.com/ebassi/graphene/pull/233#issuecomment-867276513,"the previous behavior only ever enabled gcc vectors on x86_64
this results in a massive performance improvement in gnome 40 on ppc64le","More testing. I sat down and built F34's 1.10.6 with Daniel's patch and swapped it in, and holy smokes what a difference on this Talos II. GNOME is actually usable again (I'm typing this comment on it). Animations are just about back to F33-levels of performance.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,233,2021-06-09T14:04:04Z,2021-07-16T12:46:55Z,2021-11-26T19:06:03Z,MERGED,True,1,1,1,https://github.com/q66,meson: fix gcc vector 64-bit check,1,[],https://github.com/ebassi/graphene/pull/233,https://github.com/classilla,10,https://github.com/ebassi/graphene/pull/233#issuecomment-867277824,"the previous behavior only ever enabled gcc vectors on x86_64
this results in a massive performance improvement in gnome 40 on ppc64le","Here's my F34 build, if others want to try and confirm (ppc64le). It should drop right into /lib64. I threw in an -O3 -mcpu=power9 so don't run it on a POWER8.
libgraphene-1.0.so.0.1000.6.gz",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,233,2021-06-09T14:04:04Z,2021-07-16T12:46:55Z,2021-11-26T19:06:03Z,MERGED,True,1,1,1,https://github.com/q66,meson: fix gcc vector 64-bit check,1,[],https://github.com/ebassi/graphene/pull/233,https://github.com/gyakovlev,11,https://github.com/ebassi/graphene/pull/233#issuecomment-868180825,"the previous behavior only ever enabled gcc vectors on x86_64
this results in a massive performance improvement in gnome 40 on ppc64le","another report from ppc64le user, it improved experience a lot.
1.10.6
Checking if ""GCC vector intrinsics"" compiles: YES
 1/22 mutest / general            OK              0.25s
 2/22 mutest / hooks              OK              0.25s
 3/22 mutest / types              OK              0.24s
 4/22 graphene / box              OK              0.23s   65 subtests passed
 5/22 graphene / euler            OK              0.23s   10 subtests passed
 6/22 graphene / frustum          OK              0.22s   21 subtests passed
 7/22 graphene / matrix           OK              0.22s   70 subtests passed
 8/22 graphene / plane            OK              0.21s   13 subtests passed
 9/22 graphene / point            OK              0.20s   24 subtests passed
10/22 graphene / point3d          OK              0.19s   36 subtests passed
11/22 graphene / quad             OK              0.19s   12 subtests passed
12/22 graphene / quaternion       OK              0.18s   24 subtests passed
13/22 graphene / ray              OK              0.17s   21 subtests passed
14/22 graphene / rect             OK              0.17s   65 subtests passed
15/22 graphene / simd             OK              0.16s   25 subtests passed
16/22 graphene / size             OK              0.16s   17 subtests passed
17/22 graphene / sphere           OK              0.15s   17 subtests passed
18/22 graphene / triangle         OK              0.14s   56 subtests passed
19/22 graphene / vec2             OK              0.14s   37 subtests passed
20/22 graphene / vec3             OK              0.13s   51 subtests passed
21/22 graphene / vec4             OK              0.13s   63 subtests passed
22/22 graphene / introspection.py OK              0.14s   1 subtests passed


Ok:                 22  
Expected Fail:      0   
Fail:               0   
Unexpected Pass:    0   
Skipped:            0   
Timeout:            0",True,{'THUMBS_UP': ['https://github.com/classilla']}
ebassi/graphene,https://github.com/ebassi/graphene,233,2021-06-09T14:04:04Z,2021-07-16T12:46:55Z,2021-11-26T19:06:03Z,MERGED,True,1,1,1,https://github.com/q66,meson: fix gcc vector 64-bit check,1,[],https://github.com/ebassi/graphene/pull/233,https://github.com/ebassi,12,https://github.com/ebassi/graphene/pull/233#issuecomment-881421562,"the previous behavior only ever enabled gcc vectors on x86_64
this results in a massive performance improvement in gnome 40 on ppc64le",Thanks for testing!,True,{'HOORAY': ['https://github.com/classilla']}
ebassi/graphene,https://github.com/ebassi/graphene,233,2021-06-09T14:04:04Z,2021-07-16T12:46:55Z,2021-11-26T19:06:03Z,MERGED,True,1,1,1,https://github.com/q66,meson: fix gcc vector 64-bit check,1,[],https://github.com/ebassi/graphene/pull/233,https://github.com/runlevel5,13,https://github.com/ebassi/graphene/pull/233#issuecomment-969887917,"the previous behavior only ever enabled gcc vectors on x86_64
this results in a massive performance improvement in gnome 40 on ppc64le",@ebassi I would like to ask if you could do another release so that upstream projects could pick up this improvement. Many thanks in advance,True,{'THUMBS_UP': ['https://github.com/classilla']}
ebassi/graphene,https://github.com/ebassi/graphene,233,2021-06-09T14:04:04Z,2021-07-16T12:46:55Z,2021-11-26T19:06:03Z,MERGED,True,1,1,1,https://github.com/q66,meson: fix gcc vector 64-bit check,1,[],https://github.com/ebassi/graphene/pull/233,https://github.com/classilla,14,https://github.com/ebassi/graphene/pull/233#issuecomment-979687134,"the previous behavior only ever enabled gcc vectors on x86_64
this results in a massive performance improvement in gnome 40 on ppc64le","It looks like Fedora has this patch, but it's not in the build. I'm not sure the problem is on this end because pulling and rebuilding it fixed it. I've attached another -O3 -mcpu=power9 build here for those who want it; it's a drop in replacement. Not for POWER8.
libgraphene-1.0.so.0.1000.6.gz",True,{'THUMBS_UP': ['https://github.com/runlevel5']}
ebassi/graphene,https://github.com/ebassi/graphene,233,2021-06-09T14:04:04Z,2021-07-16T12:46:55Z,2021-11-26T19:06:03Z,MERGED,True,1,1,1,https://github.com/q66,meson: fix gcc vector 64-bit check,1,[],https://github.com/ebassi/graphene/pull/233,https://github.com/classilla,15,https://github.com/ebassi/graphene/pull/233#issuecomment-979696514,"the previous behavior only ever enabled gcc vectors on x86_64
this results in a massive performance improvement in gnome 40 on ppc64le",(that's for F35),True,{}
ebassi/graphene,https://github.com/ebassi/graphene,233,2021-06-09T14:04:04Z,2021-07-16T12:46:55Z,2021-11-26T19:06:03Z,MERGED,True,1,1,1,https://github.com/q66,meson: fix gcc vector 64-bit check,1,[],https://github.com/ebassi/graphene/pull/233,https://github.com/sharkcz,16,https://github.com/ebassi/graphene/pull/233#issuecomment-979753869,"the previous behavior only ever enabled gcc vectors on x86_64
this results in a massive performance improvement in gnome 40 on ppc64le","strange, since graphene-1.10.6-2.fc35 the patches are in the build and applied
...
Program g-ir-scanner found: YES (/usr/bin/g-ir-scanner)
Checking if ""SSE intrinsics"" compiles: NO 
Checking if ""GCC vector intrinsics"" compiles: YES 
Checking if ""ARM NEON intrinsics"" compiles: NO 
Configuring graphene-config.h using configuration
...

in https://kojipkgs.fedoraproject.org//packages/graphene/1.10.6/2.fc35/data/logs/ppc64le/build.log",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,233,2021-06-09T14:04:04Z,2021-07-16T12:46:55Z,2021-11-26T19:06:03Z,MERGED,True,1,1,1,https://github.com/q66,meson: fix gcc vector 64-bit check,1,[],https://github.com/ebassi/graphene/pull/233,https://github.com/classilla,17,https://github.com/ebassi/graphene/pull/233#issuecomment-980278924,"the previous behavior only ever enabled gcc vectors on x86_64
this results in a massive performance improvement in gnome 40 on ppc64le",I agree I can see the patch in there (I built from the same package) but compare yourself: there's a definite performance difference between the two libraries. I don't think my -O3 -mcpu=power9 yields that much improvement.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,233,2021-06-09T14:04:04Z,2021-07-16T12:46:55Z,2021-11-26T19:06:03Z,MERGED,True,1,1,1,https://github.com/q66,meson: fix gcc vector 64-bit check,1,[],https://github.com/ebassi/graphene/pull/233,https://github.com/sharkcz,18,https://github.com/ebassi/graphene/pull/233#issuecomment-980288369,"the previous behavior only ever enabled gcc vectors on x86_64
this results in a massive performance improvement in gnome 40 on ppc64le",I believe it will be the flags :-) I will check with the toolchain guys.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,233,2021-06-09T14:04:04Z,2021-07-16T12:46:55Z,2021-11-26T19:06:03Z,MERGED,True,1,1,1,https://github.com/q66,meson: fix gcc vector 64-bit check,1,[],https://github.com/ebassi/graphene/pull/233,https://github.com/q66,19,https://github.com/ebassi/graphene/pull/233#issuecomment-980311746,"the previous behavior only ever enabled gcc vectors on x86_64
this results in a massive performance improvement in gnome 40 on ppc64le","fwiw, Void compiles with -O2 and power8 default and performance is fine",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,236,2021-09-05T13:48:13Z,2021-09-05T17:26:40Z,2021-09-05T17:26:45Z,MERGED,True,12,6,1,https://github.com/q66,Fix various broken macros when using GCC extension vectors,1,[],https://github.com/ebassi/graphene/pull/236,https://github.com/q66,1,https://github.com/ebassi/graphene/pull/236,"Commit 8e5c251 introduced some pragmas, however those unintentionally change the types of the macros, as the diagnostic pop pragma becomes the last statement and the type of the expression becomes void.","Commit 8e5c251 introduced some pragmas, however those unintentionally change the types of the macros, as the diagnostic pop pragma becomes the last statement and the type of the expression becomes void.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,236,2021-09-05T13:48:13Z,2021-09-05T17:26:40Z,2021-09-05T17:26:45Z,MERGED,True,12,6,1,https://github.com/q66,Fix various broken macros when using GCC extension vectors,1,[],https://github.com/ebassi/graphene/pull/236,https://github.com/ebassi,2,https://github.com/ebassi/graphene/pull/236#issuecomment-913194508,"Commit 8e5c251 introduced some pragmas, however those unintentionally change the types of the macros, as the diagnostic pop pragma becomes the last statement and the type of the expression becomes void.",Thanks!,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,238,2021-10-07T10:53:09Z,2021-10-07T10:58:36Z,2021-10-07T10:58:39Z,MERGED,True,32,0,1,https://github.com/ebassi,tests: Check points outside a rect boundaries,1,[],https://github.com/ebassi/graphene/pull/238,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/238,"Verify that the contains_point() tests are satisfied on all directions.
Test suite changes:

the test for graphene_rect_contains_point() now checks a point outside of the rectangle on all directions","Verify that the contains_point() tests are satisfied on all directions.
Test suite changes:

the test for graphene_rect_contains_point() now checks a point outside of the rectangle on all directions",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,239,2021-10-07T10:55:17Z,2021-10-07T11:01:35Z,2021-10-07T11:01:38Z,MERGED,True,1,1,1,https://github.com/ebassi,docs: Update link to the matrix deconstruction gem,1,[],https://github.com/ebassi/graphene/pull/239,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/239,"The URL now redirects to a random ACM location. Let's use the last
snapshot on the Interner Wayback Machine.
Fixes: #235","The URL now redirects to a random ACM location. Let's use the last
snapshot on the Interner Wayback Machine.
Fixes: #235",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,240,2021-10-30T22:21:23Z,2022-01-25T01:35:26Z,2022-01-25T01:35:26Z,MERGED,True,1,1,1,https://github.com/ml-,docs: Fix link to main page,1,[],https://github.com/ebassi/graphene/pull/240,https://github.com/ml-,1,https://github.com/ebassi/graphene/pull/240,,,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,241,2021-12-15T05:30:31Z,2022-01-25T01:35:07Z,2022-01-25T01:35:07Z,MERGED,True,55,38,8,https://github.com/q66,Implement vector intrinsics for Clang,1,[],https://github.com/ebassi/graphene/pull/241,https://github.com/q66,1,https://github.com/ebassi/graphene/pull/241,This implements vector intrinsics support to be used with Clang on platforms without SSE/NEON.,This implements vector intrinsics support to be used with Clang on platforms without SSE/NEON.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,241,2021-12-15T05:30:31Z,2022-01-25T01:35:07Z,2022-01-25T01:35:07Z,MERGED,True,55,38,8,https://github.com/q66,Implement vector intrinsics for Clang,1,[],https://github.com/ebassi/graphene/pull/241,https://github.com/q66,2,https://github.com/ebassi/graphene/pull/241#issuecomment-994307941,This implements vector intrinsics support to be used with Clang on platforms without SSE/NEON.,Do you think this might be worth combining under one set of macros? Doing so would have some advantages (a build made on GCC would be able to use intrinsics on Clang and the other way around),True,{}
ebassi/graphene,https://github.com/ebassi/graphene,241,2021-12-15T05:30:31Z,2022-01-25T01:35:07Z,2022-01-25T01:35:07Z,MERGED,True,55,38,8,https://github.com/q66,Implement vector intrinsics for Clang,1,[],https://github.com/ebassi/graphene/pull/241,https://github.com/q66,3,https://github.com/ebassi/graphene/pull/241#issuecomment-995275647,This implements vector intrinsics support to be used with Clang on platforms without SSE/NEON.,Now combined for a common implementation. This should ensure that you can use different compilers and still have both use the intrinsics when using the library.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,241,2021-12-15T05:30:31Z,2022-01-25T01:35:07Z,2022-01-25T01:35:07Z,MERGED,True,55,38,8,https://github.com/q66,Implement vector intrinsics for Clang,1,[],https://github.com/ebassi/graphene/pull/241,https://github.com/ebassi,4,https://github.com/ebassi/graphene/pull/241#issuecomment-995294326,This implements vector intrinsics support to be used with Clang on platforms without SSE/NEON.,"Thanks for looking into this; I'm in general okay with it, but the CI needs to pass first.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,241,2021-12-15T05:30:31Z,2022-01-25T01:35:07Z,2022-01-25T01:35:07Z,MERGED,True,55,38,8,https://github.com/q66,Implement vector intrinsics for Clang,1,[],https://github.com/ebassi/graphene/pull/241,https://github.com/q66,5,https://github.com/ebassi/graphene/pull/241#issuecomment-995298788,This implements vector intrinsics support to be used with Clang on platforms without SSE/NEON.,"I also wonder, what was the original reason they were disabled on 32-bit for GCC? Is this something that would also concern us on Clang? (I have no way to test any 32-bit targets right now)",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,241,2021-12-15T05:30:31Z,2022-01-25T01:35:07Z,2022-01-25T01:35:07Z,MERGED,True,55,38,8,https://github.com/q66,Implement vector intrinsics for Clang,1,[],https://github.com/ebassi/graphene/pull/241,https://github.com/ebassi,6,https://github.com/ebassi/graphene/pull/241#issuecomment-995300272,This implements vector intrinsics support to be used with Clang on platforms without SSE/NEON.,"Mainly, two reasons: compiler bugs with older versions of GCC, and basically no hardware to test outside of CI. To be fair, 32 bit architectures are essentially dead, and they aren't coming back, so I don't really care about them.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,241,2021-12-15T05:30:31Z,2022-01-25T01:35:07Z,2022-01-25T01:35:07Z,MERGED,True,55,38,8,https://github.com/q66,Implement vector intrinsics for Clang,1,[],https://github.com/ebassi/graphene/pull/241,https://github.com/q66,7,https://github.com/ebassi/graphene/pull/241#issuecomment-995300363,This implements vector intrinsics support to be used with Clang on platforms without SSE/NEON.,"It is probably best to disable them universally anyway, since this would mean Clang-compiled builds enabling intrinsics could not be used on GCC",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,241,2021-12-15T05:30:31Z,2022-01-25T01:35:07Z,2022-01-25T01:35:07Z,MERGED,True,55,38,8,https://github.com/q66,Implement vector intrinsics for Clang,1,[],https://github.com/ebassi/graphene/pull/241,https://github.com/q66,8,https://github.com/ebassi/graphene/pull/241#issuecomment-995302270,This implements vector intrinsics support to be used with Clang on platforms without SSE/NEON.,"Alright, this should work I think.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,241,2021-12-15T05:30:31Z,2022-01-25T01:35:07Z,2022-01-25T01:35:07Z,MERGED,True,55,38,8,https://github.com/q66,Implement vector intrinsics for Clang,1,[],https://github.com/ebassi/graphene/pull/241,https://github.com/q66,9,https://github.com/ebassi/graphene/pull/241#issuecomment-995303637,This implements vector intrinsics support to be used with Clang on platforms without SSE/NEON.,Now no symbols are being dropped,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,242,2022-01-06T13:33:02Z,2022-01-06T14:47:20Z,2022-01-06T19:37:41Z,MERGED,True,7,1,1,https://github.com/elmarco,build-sys: do not cc.run() on cross-compiling,1,[],https://github.com/ebassi/graphene/pull/242,https://github.com/elmarco,1,https://github.com/ebassi/graphene/pull/242,"Enable IEEE 754 with clang & gcc without running test. We may want to
add an extra option if necessary.","Enable IEEE 754 with clang & gcc without running test. We may want to
add an extra option if necessary.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,242,2022-01-06T13:33:02Z,2022-01-06T14:47:20Z,2022-01-06T19:37:41Z,MERGED,True,7,1,1,https://github.com/elmarco,build-sys: do not cc.run() on cross-compiling,1,[],https://github.com/ebassi/graphene/pull/242,https://github.com/elmarco,2,https://github.com/ebassi/graphene/pull/242#issuecomment-1006600884,"Enable IEEE 754 with clang & gcc without running test. We may want to
add an extra option if necessary.","fwiw this prevents cross-building gtk on fedora 35 atm,
https://gitlab.gnome.org/malureau/gtk/-/jobs/1714142
(fedora rawhide has mingw-graphene 1.10.6 without this issue)",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,242,2022-01-06T13:33:02Z,2022-01-06T14:47:20Z,2022-01-06T19:37:41Z,MERGED,True,7,1,1,https://github.com/elmarco,build-sys: do not cc.run() on cross-compiling,1,[],https://github.com/ebassi/graphene/pull/242,https://github.com/ebassi,3,https://github.com/ebassi/graphene/pull/242#issuecomment-1006629961,"Enable IEEE 754 with clang & gcc without running test. We may want to
add an extra option if necessary.","BTW, @elmarco: would you be willing to add a CI job for mingw cross-compilation?",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,242,2022-01-06T13:33:02Z,2022-01-06T14:47:20Z,2022-01-06T19:37:41Z,MERGED,True,7,1,1,https://github.com/elmarco,build-sys: do not cc.run() on cross-compiling,1,[],https://github.com/ebassi/graphene/pull/242,https://github.com/elmarco,4,https://github.com/ebassi/graphene/pull/242#issuecomment-1006631261,"Enable IEEE 754 with clang & gcc without running test. We may want to
add an extra option if necessary.","Yeah, I was thinking the same. But I am less familiar with github CI. Let me check.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,242,2022-01-06T13:33:02Z,2022-01-06T14:47:20Z,2022-01-06T19:37:41Z,MERGED,True,7,1,1,https://github.com/elmarco,build-sys: do not cc.run() on cross-compiling,1,[],https://github.com/ebassi/graphene/pull/242,https://github.com/ebassi,5,https://github.com/ebassi/graphene/pull/242#issuecomment-1006648150,"Enable IEEE 754 with clang & gcc without running test. We may want to
add an extra option if necessary.","But I am less familiar with github CI. Let me check.

Thanks, and no worries; I can also have a look.
Let's get this in, in any case.",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,243,2022-01-06T14:57:45Z,2022-01-25T01:31:42Z,2022-01-25T01:31:42Z,MERGED,True,2,2,1,https://github.com/ebassi,Do not use volatile GType storage,1,[],https://github.com/ebassi/graphene/pull/243,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/243,The volatile modifier got dropped from GLib.,The volatile modifier got dropped from GLib.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,245,2022-01-25T01:31:31Z,2022-01-25T01:31:52Z,2022-01-25T01:31:52Z,CLOSED,False,2,2,1,https://github.com/ebassi,Drop the use of volatile in GType functions,1,[],https://github.com/ebassi/graphene/pull/245,https://github.com/ebassi,1,https://github.com/ebassi/graphene/pull/245,GLib deprecated the volatile modifier for GOnce API.,GLib deprecated the volatile modifier for GOnce API.,True,{}
ebassi/graphene,https://github.com/ebassi/graphene,248,2022-04-07T19:02:24Z,,2022-04-07T19:02:24Z,OPEN,False,3,1,1,https://github.com/nekopsykose,meson: don't install introspection file with installed_tests=false,1,[],https://github.com/ebassi/graphene/pull/248,https://github.com/nekopsykose,1,https://github.com/ebassi/graphene/pull/248,Fixes #247,Fixes #247,True,{'THUMBS_UP': ['https://github.com/awilfox']}
ebassi/graphene,https://github.com/ebassi/graphene,251,2022-05-11T03:43:37Z,,2022-05-11T03:43:59Z,OPEN,False,25,15,4,https://github.com/fanc999,Fix and improve building with clang-cl,4,[],https://github.com/ebassi/graphene/pull/251,https://github.com/fanc999,1,https://github.com/ebassi/graphene/pull/251,"Hi,
This attempts to fix building with clang-cl (the clang compiler that attempts to be MSVC compatible), by:

Fixing graphene-macros.h by checking for the existance of __GNUC__ before trying to check its value, since clang-cl defines _MSC_VER but not __GNUC__, unlike clang on *NIX.
Improve detection of compiler flags used for clang-cl, which follows more the ones used on GCC than Visual Studio, and filter out those that aren't supported.  Also, force -msse4.1 since that is required for bulding the SSE 4.1 code on clang-cl.
Disable the deprecation warnings that result form the Visual Studio headers, which clang-cl utilizes.
For the SSE/ARM NEON SIMD implementations, make clang-cl follow the GCC codepath, since __extension__ is supported there as well.

With blessings, thank you!","Hi,
This attempts to fix building with clang-cl (the clang compiler that attempts to be MSVC compatible), by:

Fixing graphene-macros.h by checking for the existance of __GNUC__ before trying to check its value, since clang-cl defines _MSC_VER but not __GNUC__, unlike clang on *NIX.
Improve detection of compiler flags used for clang-cl, which follows more the ones used on GCC than Visual Studio, and filter out those that aren't supported.  Also, force -msse4.1 since that is required for bulding the SSE 4.1 code on clang-cl.
Disable the deprecation warnings that result form the Visual Studio headers, which clang-cl utilizes.
For the SSE/ARM NEON SIMD implementations, make clang-cl follow the GCC codepath, since __extension__ is supported there as well.

With blessings, thank you!",True,{}
ebassi/graphene,https://github.com/ebassi/graphene,252,2022-05-11T04:24:37Z,,2022-05-11T04:25:32Z,OPEN,False,256,485,3,https://github.com/fanc999,Attempt to consolidate SSE and ARM NEON SIMD code for GCC/clang and Visual Studio,9,[],https://github.com/ebassi/graphene/pull/252,https://github.com/fanc999,1,https://github.com/ebassi/graphene/pull/252,"Hi,
This attempts to clean up the code a bit in graphene-simd4f.h and graphene-simd4x4f.h by trying to reduce the code duplication for SSE and ARM NEON SIMD implementation due to syntactical differences in Visual Studio and GCC/clang in regards to inlining, via:

Defining macros that deals with the inlining method (__extension__ and direct intrinsic call) supported by GCC/clang and Visual Studio, for calls that could be done as one-liners.
In a similar fashion, define initializing graphene_simd4f_t  arrays from the 4 floats that we pass in, especially as we required C99 support for a while and the supported Visual Studio compilers have the needed support for this.
Remove unneeded repetitions in the code.
Prefix the MSVC-specific implementations with graphene_msvc_ instead of just _ to make things clearer to people[1].

[1]: Sadly, I was not able to do the cleanup for the SIMD code that are done in a function-like manner.  I couldn't get the preprocessor happy in one shot for Visual Studio and clang, ugh :|, so I had to leave that alone, since preprocessors don't allow a working #define inside a macro and doesn't like splitting lines when set apart by #if/#ifdef's.  So this is the best I could do for now. For instance:
(unrelated parts omitted for brevity, trying to remember things on top of my head, so there might be some mistakes below)
(graphene-macros.h)
#if defined (__GNUC__) || defined (__clang__)
...
#define GRAPHENE_FUNCCALL_2ARG_MACRO(ftype,fname,v0,v1) \
  (__extension({

#define GRAPHENE_FUNCCALL_2ARG_BEGIN(rtype,ftype,fname,t0,v0,t1,v1)
#define GRAPHENE_FUNCCALL_BODY(expr) expr;
#define GRAPHENE_FUNCCALL_RETURN(rtype,rvalue) (rtype) rvalue;
#define GRAPHENE_FUNCCALL_END \
  }))
#elif defined (_MSC_VER)
...
#define GRAPHENE_FUNCCALL_2ARG_MACRO(ftype,fname,v0,v1) \
  graphene_msvc_##ftype##_##fname## (v0, v1)

#define GRAPHENE_FUNCCALL_2ARG_BEGIN(rtype,ftype,fname,t0,v0,t1,v1) \
static inline rtype \
graphene_msvc_##ftype##_##fname## (t0 v0, t1 v1) \
{

#define GRAPHENE_FUNCCALL_BODY(expr) expr;
#define GRAPHENE_FUNCCALL_RETURN(rtype,rvalue) return rvalue;

#define GRAPHENE_FUNCCALL_END \
}
#else
...

(graphene-simd4f.h)
...
#  define graphene_simd4f_get(s,i) \
  GRAPHENE_FUNCCALL_2ARG_MACRO (simd4f, get,s ,i) \ /* for this line, it's either with the trailing backslash for GCC/clang or without it for MSVC :(, otherwise other lines here all work */
  GRAPHENE_FUNCCALL_2ARG_BEGIN (float, simd4f, get, graphene_simd4f_t, int, s, i) \
  GRAPHENE_FUNCCALL_BODY (graphene_simd4f_union_t __u = { (s) }) \
  GRAPHENE_FUNCCALL_RETURN (float, __u.f[(i)]) \
  GRAPHENE_FUNCCALL_END
...

I understand that this PR might well conflict with the changes in #251, so if one of this or #251 goes through, I will fix things up as needed as soon as possible.
With blessings, thank you!","Hi,
This attempts to clean up the code a bit in graphene-simd4f.h and graphene-simd4x4f.h by trying to reduce the code duplication for SSE and ARM NEON SIMD implementation due to syntactical differences in Visual Studio and GCC/clang in regards to inlining, via:

Defining macros that deals with the inlining method (__extension__ and direct intrinsic call) supported by GCC/clang and Visual Studio, for calls that could be done as one-liners.
In a similar fashion, define initializing graphene_simd4f_t  arrays from the 4 floats that we pass in, especially as we required C99 support for a while and the supported Visual Studio compilers have the needed support for this.
Remove unneeded repetitions in the code.
Prefix the MSVC-specific implementations with graphene_msvc_ instead of just _ to make things clearer to people[1].

[1]: Sadly, I was not able to do the cleanup for the SIMD code that are done in a function-like manner.  I couldn't get the preprocessor happy in one shot for Visual Studio and clang, ugh :|, so I had to leave that alone, since preprocessors don't allow a working #define inside a macro and doesn't like splitting lines when set apart by #if/#ifdef's.  So this is the best I could do for now. For instance:
(unrelated parts omitted for brevity, trying to remember things on top of my head, so there might be some mistakes below)
(graphene-macros.h)
#if defined (__GNUC__) || defined (__clang__)
...
#define GRAPHENE_FUNCCALL_2ARG_MACRO(ftype,fname,v0,v1) \
  (__extension({

#define GRAPHENE_FUNCCALL_2ARG_BEGIN(rtype,ftype,fname,t0,v0,t1,v1)
#define GRAPHENE_FUNCCALL_BODY(expr) expr;
#define GRAPHENE_FUNCCALL_RETURN(rtype,rvalue) (rtype) rvalue;
#define GRAPHENE_FUNCCALL_END \
  }))
#elif defined (_MSC_VER)
...
#define GRAPHENE_FUNCCALL_2ARG_MACRO(ftype,fname,v0,v1) \
  graphene_msvc_##ftype##_##fname## (v0, v1)

#define GRAPHENE_FUNCCALL_2ARG_BEGIN(rtype,ftype,fname,t0,v0,t1,v1) \
static inline rtype \
graphene_msvc_##ftype##_##fname## (t0 v0, t1 v1) \
{

#define GRAPHENE_FUNCCALL_BODY(expr) expr;
#define GRAPHENE_FUNCCALL_RETURN(rtype,rvalue) return rvalue;

#define GRAPHENE_FUNCCALL_END \
}
#else
...

(graphene-simd4f.h)
...
#  define graphene_simd4f_get(s,i) \
  GRAPHENE_FUNCCALL_2ARG_MACRO (simd4f, get,s ,i) \ /* for this line, it's either with the trailing backslash for GCC/clang or without it for MSVC :(, otherwise other lines here all work */
  GRAPHENE_FUNCCALL_2ARG_BEGIN (float, simd4f, get, graphene_simd4f_t, int, s, i) \
  GRAPHENE_FUNCCALL_BODY (graphene_simd4f_union_t __u = { (s) }) \
  GRAPHENE_FUNCCALL_RETURN (float, __u.f[(i)]) \
  GRAPHENE_FUNCCALL_END
...

I understand that this PR might well conflict with the changes in #251, so if one of this or #251 goes through, I will fix things up as needed as soon as possible.
With blessings, thank you!",True,{}
